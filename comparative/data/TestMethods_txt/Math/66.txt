/** */@Test public void testTransformDouble()throws Exception {double expected=1.0;Double input=Double.valueOf(expected);DefaultTransformer t=new DefaultTransformer();Assert.assertEquals(expected,t.transform(input),1.0e-4);}
/** */@Test public void testTransformNull()throws Exception {DefaultTransformer t=new DefaultTransformer();try {t.transform(null);Assert.fail("Expecting NullArgumentException");}catch(NullArgumentException e){}}
/** */@Test public void testTransformInteger()throws Exception {double expected=1.0;Integer input=Integer.valueOf(1);DefaultTransformer t=new DefaultTransformer();Assert.assertEquals(expected,t.transform(input),1.0e-4);}
/** */@Test public void testTransformBigDecimal()throws Exception {double expected=1.0;BigDecimal input=new BigDecimal("1.0");DefaultTransformer t=new DefaultTransformer();Assert.assertEquals(expected,t.transform(input),1.0e-4);}
/** */@Test public void testTransformString()throws Exception {double expected=1.0;String input="1.0";DefaultTransformer t=new DefaultTransformer();Assert.assertEquals(expected,t.transform(input),1.0e-4);}
/** */@Test public void testTransformObject(){Boolean input=Boolean.TRUE;DefaultTransformer t=new DefaultTransformer();try {t.transform(input);Assert.fail("Expecting MathException");}catch(MathException e){}}
@Test public void testSerial(){Assert.assertEquals(new DefaultTransformer(),TestUtils.serializeAndRecover(new DefaultTransformer()));}
/** * Make sure Double.NaN is returned iff n = 0*/@Test public void testNaN(){StandardDeviation std=new StandardDeviation();Assert.assertTrue(Double.isNaN(std.getResult()));std.increment(1d);Assert.assertEquals(0d,std.getResult(),0);}
/** * Test population version of variance*/@Test public void testPopulation(){double[]values={-1.0d,3.1d,4.0d,-2.1d,22d,11.7d,3d,14d};double sigma=populationStandardDeviation(values);SecondMoment m=new SecondMoment();m.evaluate(values);StandardDeviation s1=new StandardDeviation();s1.setBiasCorrected(false);Assert.assertEquals(sigma,s1.evaluate(values),1E-14);s1.incrementAll(values);Assert.assertEquals(sigma,s1.getResult(),1E-14);s1=new StandardDeviation(false,m);Assert.assertEquals(sigma,s1.getResult(),1E-14);s1=new StandardDeviation(false);Assert.assertEquals(sigma,s1.evaluate(values),1E-14);s1.incrementAll(values);Assert.assertEquals(sigma,s1.getResult(),1E-14);}
/** * Verifies that increment()and incrementAll work properly.*/@Test public void testIncrementation()throws Exception {StorelessUnivariateStatistic statistic=(StorelessUnivariateStatistic)getUnivariateStatistic();for (int i=0;i < testArray.length;i++){statistic.increment(testArray[i]);}Assert.assertEquals(expectedValue(),statistic.getResult(),getTolerance());Assert.assertEquals(testArray.length,statistic.getN());statistic.clear();statistic.incrementAll(testArray);Assert.assertEquals(expectedValue(),statistic.getResult(),getTolerance());Assert.assertEquals(testArray.length,statistic.getN());statistic.clear();checkClearValue(statistic);Assert.assertEquals(0,statistic.getN());}
@Test public void testSerialization()throws Exception {StorelessUnivariateStatistic statistic=(StorelessUnivariateStatistic)getUnivariateStatistic();TestUtils.checkSerializedEquality(statistic);statistic.clear();for (int i=0;i < testArray.length;i++){statistic.increment(testArray[i]);if (i % 5 == 0)statistic=(StorelessUnivariateStatistic)TestUtils.serializeAndRecover(statistic);}TestUtils.checkSerializedEquality(statistic);Assert.assertEquals(expectedValue(),statistic.getResult(),getTolerance());statistic.clear();checkClearValue(statistic);}
@Test public void testEqualsAndHashCode(){StorelessUnivariateStatistic statistic=(StorelessUnivariateStatistic)getUnivariateStatistic();StorelessUnivariateStatistic statistic2=null;Assert.assertTrue("non-null,compared to null",!statistic.equals(statistic2));Assert.assertTrue("reflexive,non-null",statistic.equals(statistic));int emptyHash=statistic.hashCode();statistic2=(StorelessUnivariateStatistic)getUnivariateStatistic();Assert.assertTrue("empty stats should be equal",statistic.equals(statistic2));Assert.assertEquals("empty stats should have the same hashcode",emptyHash,statistic2.hashCode());statistic.increment(1d);Assert.assertTrue("reflexive,non-empty",statistic.equals(statistic));Assert.assertTrue("non-empty,compared to empty",!statistic.equals(statistic2));Assert.assertTrue("non-empty,compared to empty",!statistic2.equals(statistic));Assert.assertTrue("non-empty stat should have different hashcode from empty stat",statistic.hashCode()!= emptyHash);statistic2.increment(1d);Assert.assertTrue("stats with same data should be equal",statistic.equals(statistic2));Assert.assertEquals("stats with same data should have the same hashcode",statistic.hashCode(),statistic2.hashCode());statistic.increment(Double.POSITIVE_INFINITY);Assert.assertTrue("stats with different n's should not be equal",!statistic2.equals(statistic));Assert.assertTrue("stats with different n's should have different hashcodes",statistic.hashCode()!= statistic2.hashCode());statistic2.increment(Double.POSITIVE_INFINITY);Assert.assertTrue("stats with same data should be equal",statistic.equals(statistic2));Assert.assertEquals("stats with same data should have the same hashcode",statistic.hashCode(),statistic2.hashCode());statistic.clear();statistic2.clear();Assert.assertTrue("cleared stats should be equal",statistic.equals(statistic2));Assert.assertEquals("cleared stats should have thashcode of empty stat",emptyHash,statistic2.hashCode());Assert.assertEquals("cleared stats should have thashcode of empty stat",emptyHash,statistic.hashCode());}
@Test public void testMomentSmallSamples(){UnivariateStatistic stat=getUnivariateStatistic();if (stat instanceof SecondMoment){SecondMoment moment=(SecondMoment)getUnivariateStatistic();Assert.assertTrue(Double.isNaN(moment.getResult()));moment.increment(1d);Assert.assertEquals(0d,moment.getResult(),0);}}
/** * Make sure that evaluate(double[])and inrementAll(double[]),getResult()give same results.*/@Test public void testConsistency(){StorelessUnivariateStatistic stat=(StorelessUnivariateStatistic)getUnivariateStatistic();stat.incrementAll(testArray);Assert.assertEquals(stat.getResult(),stat.evaluate(testArray),getTolerance());for (int i=0;i < smallSamples.length;i++){stat.clear();for (int j=0;j < smallSamples[i].length;j++){stat.increment(smallSamples[i][j]);}TestUtils.assertEquals(stat.getResult(),stat.evaluate(smallSamples[i]),getTolerance());}}
/** * Verifies that copied statistics remain equal to originals when incremented the same way.*/@Test public void testCopyConsistency(){StorelessUnivariateStatistic master=(StorelessUnivariateStatistic)getUnivariateStatistic();StorelessUnivariateStatistic replica=null;long index=FastMath.round((FastMath.random())* testArray.length);master.incrementAll(testArray,0,(int)index);replica=master.copy();Assert.assertTrue(replica.equals(master));Assert.assertTrue(master.equals(replica));master.incrementAll(testArray,(int)index,(int)(testArray.length - index));replica.incrementAll(testArray,(int)index,(int)(testArray.length - index));Assert.assertTrue(replica.equals(master));Assert.assertTrue(master.equals(replica));}
@Test public void testSerial(){StorelessUnivariateStatistic s=(StorelessUnivariateStatistic)getUnivariateStatistic();Assert.assertEquals(s,TestUtils.serializeAndRecover(s));}
@Test public void testEvaluation()throws Exception {Assert.assertEquals(expectedValue(),getUnivariateStatistic().evaluate(testArray),getTolerance());}
@Test public void testEvaluateArraySegment(){final UnivariateStatistic stat=getUnivariateStatistic();final double[]arrayZero=new double[5];System.arraycopy(testArray,0,arrayZero,0,5);Assert.assertEquals(stat.evaluate(arrayZero),stat.evaluate(testArray,0,5),0);final double[]arrayOne=new double[5];System.arraycopy(testArray,5,arrayOne,0,5);Assert.assertEquals(stat.evaluate(arrayOne),stat.evaluate(testArray,5,5),0);final double[]arrayEnd=new double[5];System.arraycopy(testArray,testArray.length - 5,arrayEnd,0,5);Assert.assertEquals(stat.evaluate(arrayEnd),stat.evaluate(testArray,testArray.length - 5,5),0);}
@Test public void testEvaluateArraySegmentWeighted(){UnivariateStatistic statistic=getUnivariateStatistic();if (!(statistic instanceof WeightedEvaluation)){return;}final WeightedEvaluation stat=(WeightedEvaluation)getUnivariateStatistic();final double[]arrayZero=new double[5];final double[]weightZero=new double[5];System.arraycopy(testArray,0,arrayZero,0,5);System.arraycopy(testWeightsArray,0,weightZero,0,5);Assert.assertEquals(stat.evaluate(arrayZero,weightZero),stat.evaluate(testArray,testWeightsArray,0,5),0);final double[]arrayOne=new double[5];final double[]weightOne=new double[5];System.arraycopy(testArray,5,arrayOne,0,5);System.arraycopy(testWeightsArray,5,weightOne,0,5);Assert.assertEquals(stat.evaluate(arrayOne,weightOne),stat.evaluate(testArray,testWeightsArray,5,5),0);final double[]arrayEnd=new double[5];final double[]weightEnd=new double[5];System.arraycopy(testArray,testArray.length - 5,arrayEnd,0,5);System.arraycopy(testWeightsArray,testArray.length - 5,weightEnd,0,5);Assert.assertEquals(stat.evaluate(arrayEnd,weightEnd),stat.evaluate(testArray,testWeightsArray,testArray.length - 5,5),0);}
@Test public void testCopy()throws Exception {UnivariateStatistic original=getUnivariateStatistic();UnivariateStatistic copy=original.copy();Assert.assertEquals(expectedValue(),copy.evaluate(testArray),getTolerance());}
/** * Tests consistency of weighted statistic computation. For statistics that support weighted evaluation,this test case compares the result of direct computation on an array with repeated values with a weighted computation on the corresponding (shorter)array with each value appearing only once but with a weight value equal to its multiplicity in the repeating array.*/@Test public void testWeightedConsistency()throws Exception {UnivariateStatistic statistic=getUnivariateStatistic();if (!(statistic instanceof WeightedEvaluation)){return;}final int len=10;final double mu=0;final double sigma=5;double[]values=new double[len];double[]weights=new double[len];RandomData randomData=new RandomDataImpl();int[]intWeights=new int[len];for (int i=0;i < len;i++){intWeights[i]=randomData.nextInt(1,5);weights[i]=intWeights[i];}List<Double> valuesList=new ArrayList<Double>();for (int i=0;i < len;i++){double value=randomData.nextGaussian(mu,sigma);values[i]=value;for (int j=0;j < intWeights[i];j++){valuesList.add(new Double(value));}}int sumWeights=valuesList.size();double[]repeatedValues=new double[sumWeights];for (int i=0;i < sumWeights;i++){repeatedValues[i]=valuesList.get(i);}WeightedEvaluation weightedStatistic=(WeightedEvaluation)statistic;TestUtils.assertRelativelyEquals(statistic.evaluate(repeatedValues),weightedStatistic.evaluate(values,weights,0,values.length),10E-14);Assert.assertEquals(weightedStatistic.evaluate(values,weights,0,values.length),weightedStatistic.evaluate(values,weights),Double.MIN_VALUE);}
@Test(expected=DimensionMismatchException.class)public void testDimensionCheck(){TestProblem1 pb=new TestProblem1();new EulerIntegrator(0.01).integrate(pb,0.0,new double[pb.getDimension()+ 10],1.0,new double[pb.getDimension()+ 10]);Assert.fail("an exception should have been thrown");}
@Test public void testDecreasingSteps(){TestProblemAbstract[]problems=TestProblemFactory.getProblems();for (int k=0;k < problems.length;++k){double previousValueError=Double.NaN;double previousTimeError=Double.NaN;for (int i=4;i < 8;++i){TestProblemAbstract pb=problems[k].copy();double step=(pb.getFinalTime()- pb.getInitialTime())* FastMath.pow(2.0,-i);FirstOrderIntegrator integ=new EulerIntegrator(step);TestProblemHandler handler=new TestProblemHandler(pb,integ);integ.addStepHandler(handler);EventHandler[]functions=pb.getEventsHandlers();for (int l=0;l < functions.length;++l){integ.addEventHandler(functions[l],Double.POSITIVE_INFINITY,1.0e-6 * step,1000);}double stopTime=integ.integrate(pb,pb.getInitialTime(),pb.getInitialState(),pb.getFinalTime(),new double[pb.getDimension()]);if (functions.length == 0){Assert.assertEquals(pb.getFinalTime(),stopTime,1.0e-10);}double valueError=handler.getMaximalValueError();if (i > 4){Assert.assertTrue(valueError < FastMath.abs(previousValueError));}previousValueError=valueError;double timeError=handler.getMaximalTimeError();if (i > 4){Assert.assertTrue(timeError <= FastMath.abs(previousTimeError));}previousTimeError=timeError;}}}
@Test public void testSmallStep(){TestProblem1 pb=new TestProblem1();double step=(pb.getFinalTime()- pb.getInitialTime())* 0.001;FirstOrderIntegrator integ=new EulerIntegrator(step);TestProblemHandler handler=new TestProblemHandler(pb,integ);integ.addStepHandler(handler);integ.integrate(pb,pb.getInitialTime(),pb.getInitialState(),pb.getFinalTime(),new double[pb.getDimension()]);Assert.assertTrue(handler.getLastError()< 2.0e-4);Assert.assertTrue(handler.getMaximalValueError()< 1.0e-3);Assert.assertEquals(0,handler.getMaximalTimeError(),1.0e-12);Assert.assertEquals("Euler",integ.getName());}
@Test public void testBigStep(){TestProblem1 pb=new TestProblem1();double step=(pb.getFinalTime()- pb.getInitialTime())* 0.2;FirstOrderIntegrator integ=new EulerIntegrator(step);TestProblemHandler handler=new TestProblemHandler(pb,integ);integ.addStepHandler(handler);integ.integrate(pb,pb.getInitialTime(),pb.getInitialState(),pb.getFinalTime(),new double[pb.getDimension()]);Assert.assertTrue(handler.getLastError()> 0.01);Assert.assertTrue(handler.getMaximalValueError()> 0.2);Assert.assertEquals(0,handler.getMaximalTimeError(),1.0e-12);}
@Test public void testBackward(){TestProblem5 pb=new TestProblem5();double step=FastMath.abs(pb.getFinalTime()- pb.getInitialTime())* 0.001;FirstOrderIntegrator integ=new EulerIntegrator(step);TestProblemHandler handler=new TestProblemHandler(pb,integ);integ.addStepHandler(handler);integ.integrate(pb,pb.getInitialTime(),pb.getInitialState(),pb.getFinalTime(),new double[pb.getDimension()]);Assert.assertTrue(handler.getLastError()< 0.45);Assert.assertTrue(handler.getMaximalValueError()< 0.45);Assert.assertEquals(0,handler.getMaximalTimeError(),1.0e-12);Assert.assertEquals("Euler",integ.getName());}
@Test public void testStepSize(){final double step=1.23456;FirstOrderIntegrator integ=new EulerIntegrator(step);integ.addStepHandler(new StepHandler(){public void handleStep(StepInterpolator interpolator,boolean isLast){if (!isLast){Assert.assertEquals(step,interpolator.getCurrentTime()- interpolator.getPreviousTime(),1.0e-12);}}public void init(double t0,double[]y0,double t){}});integ.integrate(new FirstOrderDifferentialEquations(){public void computeDerivatives(double t,double[]y,double[]dot){dot[0]=1.0;}public int getDimension(){return 1;}},0.0,new double[]{0.0},5.0,new double[1]);}
/** * Test of transformer for the ad hoc data taken from Mathematica.*/@Test public void testAdHocData(){FastFourierTransformer transformer=new FastFourierTransformer();Complex result[];double tolerance=1E-12;double x[]={1.3,2.4,1.7,4.1,2.9,1.7,5.1,2.7};Complex y[]={new Complex(21.9,0.0),new Complex(-2.09497474683058,1.91507575950825),new Complex(-2.6,2.7),new Complex(-1.10502525316942,-4.88492424049175),new Complex(0.1,0.0),new Complex(-1.10502525316942,4.88492424049175),new Complex(-2.6,-2.7),new Complex(-2.09497474683058,-1.91507575950825)};result=transformer.transform(x);for (int i=0;i < result.length;i++){Assert.assertEquals(y[i].getReal(),result[i].getReal(),tolerance);Assert.assertEquals(y[i].getImaginary(),result[i].getImaginary(),tolerance);}result=transformer.inversetransform(y);for (int i=0;i < result.length;i++){Assert.assertEquals(x[i],result[i].getReal(),tolerance);Assert.assertEquals(0.0,result[i].getImaginary(),tolerance);}double x2[]={10.4,21.6,40.8,13.6,23.2,32.8,13.6,19.2};FastFourierTransformer.scaleArray(x2,1.0 / FastMath.sqrt(x2.length));Complex y2[]=y;result=transformer.transform2(y2);for (int i=0;i < result.length;i++){Assert.assertEquals(x2[i],result[i].getReal(),tolerance);Assert.assertEquals(0.0,result[i].getImaginary(),tolerance);}result=transformer.inversetransform2(x2);for (int i=0;i < result.length;i++){Assert.assertEquals(y2[i].getReal(),result[i].getReal(),tolerance);Assert.assertEquals(y2[i].getImaginary(),result[i].getImaginary(),tolerance);}}
@Test public void test2DData(){FastFourierTransformer transformer=new FastFourierTransformer();double tolerance=1E-12;Complex[][]input=new Complex[][]{new Complex[]{new Complex(1,0),new Complex(2,0)},new Complex[]{new Complex(3,1),new Complex(4,2)}};Complex[][]goodOutput=new Complex[][]{new Complex[]{new Complex(5,1.5),new Complex(-1,-.5)},new Complex[]{new Complex(-2,-1.5),new Complex(0,.5)}};Complex[][]output=(Complex[][])transformer.mdfft(input,true);Complex[][]output2=(Complex[][])transformer.mdfft(output,false);Assert.assertEquals(input.length,output.length);Assert.assertEquals(input.length,output2.length);Assert.assertEquals(input[0].length,output[0].length);Assert.assertEquals(input[0].length,output2[0].length);Assert.assertEquals(input[1].length,output[1].length);Assert.assertEquals(input[1].length,output2[1].length);for (int i=0;i < input.length;i++){for (int j=0;j < input[0].length;j++){Assert.assertEquals(input[i][j].getImaginary(),output2[i][j].getImaginary(),tolerance);Assert.assertEquals(input[i][j].getReal(),output2[i][j].getReal(),tolerance);Assert.assertEquals(goodOutput[i][j].getImaginary(),output[i][j].getImaginary(),tolerance);Assert.assertEquals(goodOutput[i][j].getReal(),output[i][j].getReal(),tolerance);}}}
/** * Test of transformer for the sine function.*/@Test public void testSinFunction(){UnivariateFunction f=new SinFunction();FastFourierTransformer transformer=new FastFourierTransformer();Complex result[];int N=1 << 8;double min,max,tolerance=1E-12;min=0.0;max=2.0 * FastMath.PI;result=transformer.transform(f,min,max,N);Assert.assertEquals(0.0,result[1].getReal(),tolerance);Assert.assertEquals(-(N >> 1),result[1].getImaginary(),tolerance);Assert.assertEquals(0.0,result[N - 1].getReal(),tolerance);Assert.assertEquals(N >> 1,result[N - 1].getImaginary(),tolerance);for (int i=0;i < N - 1;i+=(i == 0 ? 2 : 1)){Assert.assertEquals(0.0,result[i].getReal(),tolerance);Assert.assertEquals(0.0,result[i].getImaginary(),tolerance);}min=-FastMath.PI;max=FastMath.PI;result=transformer.inversetransform(f,min,max,N);Assert.assertEquals(0.0,result[1].getReal(),tolerance);Assert.assertEquals(-0.5,result[1].getImaginary(),tolerance);Assert.assertEquals(0.0,result[N - 1].getReal(),tolerance);Assert.assertEquals(0.5,result[N - 1].getImaginary(),tolerance);for (int i=0;i < N - 1;i+=(i == 0 ? 2 : 1)){Assert.assertEquals(0.0,result[i].getReal(),tolerance);Assert.assertEquals(0.0,result[i].getImaginary(),tolerance);}}
/** * Test of parameters for the transformer.*/@Test public void testParameters()throws Exception {UnivariateFunction f=new SinFunction();FastFourierTransformer transformer=new FastFourierTransformer();try {transformer.transform(f,1,-1,64);Assert.fail("Expecting IllegalArgumentException - bad interval");}catch(IllegalArgumentException ex){}try {transformer.transform(f,-1,1,0);Assert.fail("Expecting IllegalArgumentException - bad samples number");}catch(IllegalArgumentException ex){}try {transformer.transform(f,-1,1,100);Assert.fail("Expecting IllegalArgumentException - bad samples number");}catch(IllegalArgumentException ex){}}
@Test public void dimension2(){KMeansPlusPlusClusterer<EuclideanIntegerPoint> transformer=new KMeansPlusPlusClusterer<EuclideanIntegerPoint>(new Random(1746432956321l));EuclideanIntegerPoint[]points=new EuclideanIntegerPoint[]{new EuclideanIntegerPoint(new int[]{-15,3}),new EuclideanIntegerPoint(new int[]{-15,4}),new EuclideanIntegerPoint(new int[]{-15,5}),new EuclideanIntegerPoint(new int[]{-14,3}),new EuclideanIntegerPoint(new int[]{-14,5}),new EuclideanIntegerPoint(new int[]{-13,3}),new EuclideanIntegerPoint(new int[]{-13,4}),new EuclideanIntegerPoint(new int[]{-13,5}),new EuclideanIntegerPoint(new int[]{-1,0}),new EuclideanIntegerPoint(new int[]{-1,-1}),new EuclideanIntegerPoint(new int[]{0,-1}),new EuclideanIntegerPoint(new int[]{1,-1}),new EuclideanIntegerPoint(new int[]{1,-2}),new EuclideanIntegerPoint(new int[]{13,3}),new EuclideanIntegerPoint(new int[]{13,4}),new EuclideanIntegerPoint(new int[]{14,4}),new EuclideanIntegerPoint(new int[]{14,7}),new EuclideanIntegerPoint(new int[]{16,5}),new EuclideanIntegerPoint(new int[]{16,6}),new EuclideanIntegerPoint(new int[]{17,4}),new EuclideanIntegerPoint(new int[]{17,7})};List<Cluster<EuclideanIntegerPoint>> clusters=transformer.cluster(Arrays.asList(points),3,5,10);Assert.assertEquals(3,clusters.size());boolean cluster1Found=false;boolean cluster2Found=false;boolean cluster3Found=false;for(Cluster<EuclideanIntegerPoint> cluster : clusters){int[]center=cluster.getCenter().getPoint();if (center[0]< 0){cluster1Found=true;Assert.assertEquals(8,cluster.getPoints().size());Assert.assertEquals(-14,center[0]);Assert.assertEquals(4,center[1]);}else     if (center[1]< 0){cluster2Found=true;Assert.assertEquals(5,cluster.getPoints().size());Assert.assertEquals(0,center[0]);Assert.assertEquals(-1,center[1]);}else {cluster3Found=true;Assert.assertEquals(8,cluster.getPoints().size());Assert.assertEquals(15,center[0]);Assert.assertEquals(5,center[1]);}}Assert.assertTrue(cluster1Found);Assert.assertTrue(cluster2Found);Assert.assertTrue(cluster3Found);}
/** * JIRA: MATH-305 Two points,one cluster,one iteration*/@Test public void testPerformClusterAnalysisDegenerate(){KMeansPlusPlusClusterer<EuclideanIntegerPoint> transformer=new KMeansPlusPlusClusterer<EuclideanIntegerPoint>(new Random(1746432956321l));EuclideanIntegerPoint[]points=new EuclideanIntegerPoint[]{new EuclideanIntegerPoint(new int[]{1959,325100}),new EuclideanIntegerPoint(new int[]{1960,373200})};List<Cluster<EuclideanIntegerPoint>> clusters=transformer.cluster(Arrays.asList(points),1,1);Assert.assertEquals(1,clusters.size());Assert.assertEquals(2,(clusters.get(0).getPoints().size()));EuclideanIntegerPoint pt1=new EuclideanIntegerPoint(new int[]{1959,325100});EuclideanIntegerPoint pt2=new EuclideanIntegerPoint(new int[]{1960,373200});Assert.assertTrue(clusters.get(0).getPoints().contains(pt1));Assert.assertTrue(clusters.get(0).getPoints().contains(pt2));}
@Test public void testCertainSpace(){KMeansPlusPlusClusterer.EmptyClusterStrategy[]strategies={KMeansPlusPlusClusterer.EmptyClusterStrategy.LARGEST_VARIANCE,KMeansPlusPlusClusterer.EmptyClusterStrategy.LARGEST_POINTS_NUMBER,KMeansPlusPlusClusterer.EmptyClusterStrategy.FARTHEST_POINT};for(KMeansPlusPlusClusterer.EmptyClusterStrategy strategy : strategies){KMeansPlusPlusClusterer<EuclideanIntegerPoint> transformer=new KMeansPlusPlusClusterer<EuclideanIntegerPoint>(new Random(1746432956321l),strategy);int numberOfVariables=27;int position1=1;int position2=position1 + numberOfVariables;int position3=position2 + numberOfVariables;int position4=position3 + numberOfVariables;int multiplier=1000000;EuclideanIntegerPoint[]breakingPoints=new EuclideanIntegerPoint[numberOfVariables];for (int i=0;i < numberOfVariables;i++){int points[]={position1,position2,position3,position4};for (int j=0;j < points.length;j++){points[j]=points[j]* multiplier;}EuclideanIntegerPoint euclideanIntegerPoint=new EuclideanIntegerPoint(points);breakingPoints[i]=euclideanIntegerPoint;position1=position1 + numberOfVariables;position2=position2 + numberOfVariables;position3=position3 + numberOfVariables;position4=position4 + numberOfVariables;}for (int n=2;n < 27;++n){List<Cluster<EuclideanIntegerPoint>> clusters=transformer.cluster(Arrays.asList(breakingPoints),n,100);Assert.assertEquals(n,clusters.size());int sum=0;for(Cluster<EuclideanIntegerPoint> cluster : clusters){sum+=cluster.getPoints().size();}Assert.assertEquals(numberOfVariables,sum);}}}
/** * Test points that are very close together. See issue MATH-546.*/@Test public void testSmallDistances(){int[]repeatedArray={0};int[]uniqueArray={1};CloseIntegerPoint repeatedPoint=new CloseIntegerPoint(new EuclideanIntegerPoint(repeatedArray));CloseIntegerPoint uniquePoint=new CloseIntegerPoint(new EuclideanIntegerPoint(uniqueArray));Collection<CloseIntegerPoint> points=new ArrayList<CloseIntegerPoint>();final int NUM_REPEATED_POINTS=10 * 1000;for (int i=0;i < NUM_REPEATED_POINTS;++i){points.add(repeatedPoint);}points.add(uniquePoint);final long RANDOM_SEED=0;final int NUM_CLUSTERS=2;final int NUM_ITERATIONS=0;KMeansPlusPlusClusterer<CloseIntegerPoint> clusterer=new KMeansPlusPlusClusterer<CloseIntegerPoint>(new Random(RANDOM_SEED));List<Cluster<CloseIntegerPoint>> clusters=clusterer.cluster(points,NUM_CLUSTERS,NUM_ITERATIONS);boolean uniquePointIsCenter=false;for(Cluster<CloseIntegerPoint> cluster : clusters){if (cluster.getCenter().equals(uniquePoint)){uniquePointIsCenter=true;}}Assert.assertTrue(uniquePointIsCenter);}
/** * 2 variables cannot be clustered into 3 clusters. See issue MATH-436.*/@Test(expected=NumberIsTooSmallException.class)public void testPerformClusterAnalysisToManyClusters(){KMeansPlusPlusClusterer<EuclideanIntegerPoint> transformer=new KMeansPlusPlusClusterer<EuclideanIntegerPoint>(new Random(1746432956321l));EuclideanIntegerPoint[]points=new EuclideanIntegerPoint[]{new EuclideanIntegerPoint(new int[]{1959,325100}),new EuclideanIntegerPoint(new int[]{1960,373200})};transformer.cluster(Arrays.asList(points),3,1);}
@Test public void derivativesConsistency(){TestProblem3 pb=new TestProblem3();AdamsBashforthIntegrator integ=new AdamsBashforthIntegrator(4,0.0,1.0,1.0e-10,1.0e-10);StepInterpolatorTestUtils.checkDerivativesConsistency(integ,pb,5e-9);}
@Test public void serialization()throws IOException,ClassNotFoundException {TestProblem1 pb=new TestProblem1();AdamsBashforthIntegrator integ=new AdamsBashforthIntegrator(4,0.0,1.0,1.0e-10,1.0e-10);integ.addStepHandler(new ContinuousOutputModel());integ.integrate(pb,pb.getInitialTime(),pb.getInitialState(),pb.getFinalTime(),new double[pb.getDimension()]);ByteArrayOutputStream bos=new ByteArrayOutputStream();ObjectOutputStream oos=new ObjectOutputStream(bos);for(StepHandler handler : integ.getStepHandlers()){oos.writeObject(handler);}Assert.assertTrue(bos.size()> 25500);Assert.assertTrue(bos.size()< 26500);ByteArrayInputStream bis=new ByteArrayInputStream(bos.toByteArray());ObjectInputStream ois=new ObjectInputStream(bis);ContinuousOutputModel cm=(ContinuousOutputModel)ois.readObject();Random random=new Random(347588535632l);double maxError=0.0;for (int i=0;i < 1000;++i){double r=random.nextDouble();double time=r * pb.getInitialTime()+ (1.0 - r)* pb.getFinalTime();cm.setInterpolatedTime(time);double[]interpolatedY=cm.getInterpolatedState();double[]theoreticalY=pb.computeTheoreticalState(time);double dx=interpolatedY[0]- theoreticalY[0];double dy=interpolatedY[1]- theoreticalY[1];double error=dx * dx + dy * dy;if (error > maxError){maxError=error;}}Assert.assertTrue(maxError < 1.0e-6);}
/** * Verify that if there are no failures,mass is concentrated on sampleSize */@Test public void testDegenerateNoFailures()throws Exception {setDistribution(new HypergeometricDistribution(5,5,3));setCumulativeTestPoints(new int[]{-1,0,1,3,10});setCumulativeTestValues(new double[]{0d,0d,0d,1d,1d});setDensityTestPoints(new int[]{-1,0,1,3,10});setDensityTestValues(new double[]{0d,0d,0d,1d,0d});setInverseCumulativeTestPoints(new double[]{0.1d,0.5d});setInverseCumulativeTestValues(new int[]{2,2});verifyDensities();verifyCumulativeProbabilities();verifyInverseCumulativeProbabilities();}
/** * Verify that if there are no successes,mass is concentrated on 0 */@Test public void testDegenerateNoSuccesses()throws Exception {setDistribution(new HypergeometricDistribution(5,0,3));setCumulativeTestPoints(new int[]{-1,0,1,3,10});setCumulativeTestValues(new double[]{0d,1d,1d,1d,1d});setDensityTestPoints(new int[]{-1,0,1,3,10});setDensityTestValues(new double[]{0d,1d,0d,0d,0d});setInverseCumulativeTestPoints(new double[]{0.1d,0.5d});setInverseCumulativeTestValues(new int[]{-1,-1});verifyDensities();verifyCumulativeProbabilities();verifyInverseCumulativeProbabilities();}
/** * Verify that if sampleSize = populationSize,mass is concentrated on numberOfSuccesses */@Test public void testDegenerateFullSample()throws Exception {setDistribution(new HypergeometricDistribution(5,3,5));setCumulativeTestPoints(new int[]{-1,0,1,3,10});setCumulativeTestValues(new double[]{0d,0d,0d,1d,1d});setDensityTestPoints(new int[]{-1,0,1,3,10});setDensityTestValues(new double[]{0d,0d,0d,1d,0d});setInverseCumulativeTestPoints(new double[]{0.1d,0.5d});setInverseCumulativeTestValues(new int[]{2,2});verifyDensities();verifyCumulativeProbabilities();verifyInverseCumulativeProbabilities();}
@Test public void testPreconditions(){try {new HypergeometricDistribution(0,3,5);Assert.fail("negative population size. NotStrictlyPositiveException expected");}catch(NotStrictlyPositiveException ex){}try {new HypergeometricDistribution(5,-1,5);Assert.fail("negative number of successes. NotPositiveException expected");}catch(NotPositiveException ex){}try {new HypergeometricDistribution(5,3,-1);Assert.fail("negative sample size. NotPositiveException expected");}catch(NotPositiveException ex){}try {new HypergeometricDistribution(5,6,5);Assert.fail("numberOfSuccesses > populationSize. NumberIsTooLargeException expected");}catch(NumberIsTooLargeException ex){}try {new HypergeometricDistribution(5,3,6);Assert.fail("sampleSize > populationSize. NumberIsTooLargeException expected");}catch(NumberIsTooLargeException ex){}}
@Test public void testAccessors(){HypergeometricDistribution dist=new HypergeometricDistribution(5,3,4);Assert.assertEquals(5,dist.getPopulationSize());Assert.assertEquals(3,dist.getNumberOfSuccesses());Assert.assertEquals(4,dist.getSampleSize());}
@Test public void testLargeValues(){int populationSize=3456;int sampleSize=789;int numberOfSucceses=101;double[][]data={{0.0,2.75646034603961e-12,2.75646034603961e-12,1.0},{1.0,8.55705370142386e-11,8.83269973602783e-11,0.999999999997244},{2.0,1.31288129219665e-9,1.40120828955693e-9,0.999999999911673},{3.0,1.32724172984193e-8,1.46736255879763e-8,0.999999998598792},{4.0,9.94501711734089e-8,1.14123796761385e-7,0.999999985326375},{5.0,5.89080768883643e-7,7.03204565645028e-7,0.999999885876203},{20.0,0.0760051397707708,0.27349758476299,0.802507555007781},{21.0,0.087144222047629,0.360641806810619,0.72650241523701},{22.0,0.0940378846881819,0.454679691498801,0.639358193189381},{23.0,0.0956897500614809,0.550369441560282,0.545320308501199},{24.0,0.0919766921922999,0.642346133752582,0.449630558439718},{25.0,0.083641637261095,0.725987771013677,0.357653866247418},{96.0,5.93849188852098e-57,1.0,6.01900244560712e-57},{97.0,7.96593036832547e-59,1.0,8.05105570861321e-59},{98.0,8.44582921934367e-61,1.0,8.5125340287733e-61},{99.0,6.63604297068222e-63,1.0,6.670480942963e-63},{100.0,3.43501099007557e-65,1.0,3.4437972280786e-65},{101.0,8.78623800302957e-68,1.0,8.78623800302957e-68}};testHypergeometricDistributionProbabilities(populationSize,sampleSize,numberOfSucceses,data);}
@Test public void testMoreLargeValues(){int populationSize=26896;int sampleSize=895;int numberOfSucceses=55;double[][]data={{0.0,0.155168304750504,0.155168304750504,1.0},{1.0,0.29437545000746,0.449543754757964,0.844831695249496},{2.0,0.273841321577003,0.723385076334967,0.550456245242036},{3.0,0.166488572570786,0.889873648905753,0.276614923665033},{4.0,0.0743969744713231,0.964270623377076,0.110126351094247},{5.0,0.0260542785784855,0.990324901955562,0.0357293766229237},{20.0,3.57101101678792e-16,1.0,3.78252101622096e-16},{21.0,2.00551638598312e-17,1.0,2.11509999433041e-17},{22.0,1.04317070180562e-18,1.0,1.09583608347287e-18},{23.0,5.03153504903308e-20,1.0,5.266538166725e-20},{24.0,2.2525984149695e-21,1.0,2.35003117691919e-21},{25.0,9.3677424515947e-23,1.0,9.74327619496943e-23},{50.0,9.83633962945521e-69,1.0,9.8677629437617e-69},{51.0,3.13448949497553e-71,1.0,3.14233143064882e-71},{52.0,7.82755221928122e-74,1.0,7.84193567329055e-74},{53.0,1.43662126065532e-76,1.0,1.43834540093295e-76},{54.0,1.72312692517348e-79,1.0,1.7241402776278e-79},{55.0,1.01335245432581e-82,1.0,1.01335245432581e-82}};testHypergeometricDistributionProbabilities(populationSize,sampleSize,numberOfSucceses,data);}
@Test public void testMoments(){final double tol=1e-9;HypergeometricDistribution dist;dist=new HypergeometricDistribution(1500,40,100);Assert.assertEquals(dist.getNumericalMean(),40d * 100d / 1500d,tol);Assert.assertEquals(dist.getNumericalVariance(),(100d * 40d * (1500d - 100d)* (1500d - 40d))/ ((1500d * 1500d * 1499d)),tol);dist=new HypergeometricDistribution(3000,55,200);Assert.assertEquals(dist.getNumericalMean(),55d * 200d / 3000d,tol);Assert.assertEquals(dist.getNumericalVariance(),(200d * 55d * (3000d - 200d)* (3000d - 55d))/ ((3000d * 3000d * 2999d)),tol);}
/** * Verifies that probability density calculations match expected values using default test instance data*/@Test public void testDensities()throws Exception {verifyDensities();}
/** * Verifies that cumulative probability density calculations match expected values using default test instance data*/@Test public void testCumulativeProbabilities()throws Exception {verifyCumulativeProbabilities();}
/** * Verifies that floating point arguments are correctly handled by cumulativeProbablility(-,-)JIRA: MATH-184*/@Test public void testFloatingPointArguments()throws Exception {for (int i=0;i < cumulativeTestPoints.length;i++){double arg=cumulativeTestPoints[i];Assert.assertEquals("Incorrect cumulative probability value returned for " + cumulativeTestPoints[i],cumulativeTestValues[i],distribution.cumulativeProbability(arg),tolerance);if (i < cumulativeTestPoints.length - 1){double arg2=cumulativeTestPoints[i + 1];Assert.assertEquals("Inconsistent probability for discrete range " + "[" + arg + ","+ arg2+ " ]",distribution.cumulativeProbability(cumulativeTestPoints[i],cumulativeTestPoints[i + 1]),distribution.cumulativeProbability(arg,arg2),tolerance);arg=arg - FastMath.random();arg2=arg2 + FastMath.random();Assert.assertEquals("Inconsistent probability for discrete range " + "[" + arg + ","+ arg2+ " ]",distribution.cumulativeProbability(cumulativeTestPoints[i],cumulativeTestPoints[i + 1]),distribution.cumulativeProbability(arg,arg2),tolerance);}}int one=1;int ten=10;int two=2;double oned=one;double twod=two;double tend=ten;Assert.assertEquals(distribution.cumulativeProbability(one,two),distribution.cumulativeProbability(oned,twod),tolerance);Assert.assertEquals(distribution.cumulativeProbability(one,two),distribution.cumulativeProbability(oned - tolerance,twod + 0.9),tolerance);Assert.assertEquals(distribution.cumulativeProbability(two,ten),distribution.cumulativeProbability(twod,tend),tolerance);Assert.assertEquals(distribution.cumulativeProbability(two,ten),distribution.cumulativeProbability(twod - tolerance,tend + 0.9),tolerance);}
/** * Verifies that inverse cumulative probability density calculations match expected values using default test instance data*/@Test public void testInverseCumulativeProbabilities()throws Exception {verifyInverseCumulativeProbabilities();}
/** * Verifies that illegal arguments are correctly handled*/@Test public void testIllegalArguments()throws Exception {try {distribution.cumulativeProbability(1,0);Assert.fail("Expecting MathIllegalArgumentException for bad cumulativeProbability interval");}catch(MathIllegalArgumentException ex){}try {distribution.inverseCumulativeProbability(-1);Assert.fail("Expecting MathIllegalArgumentException for p = -1");}catch(MathIllegalArgumentException ex){}try {distribution.inverseCumulativeProbability(2);Assert.fail("Expecting MathIllegalArgumentException for p = 2");}catch(MathIllegalArgumentException ex){}}
/** * Test sampling*/@Test public void testSampling()throws Exception {int[]densityPoints=makeDensityTestPoints();double[]densityValues=makeDensityTestValues();int sampleSize=1000;int length=TestUtils.eliminateZeroMassPoints(densityPoints,densityValues);AbstractIntegerDistribution distribution=(AbstractIntegerDistribution)makeDistribution();double[]expectedCounts=new double[length];long[]observedCounts=new long[length];for (int i=0;i < length;i++){expectedCounts[i]=sampleSize * densityValues[i];}distribution.reseedRandomGenerator(1000);int[]sample=distribution.sample(sampleSize);for (int i=0;i < sampleSize;i++){for (int j=0;j < length;j++){if (sample[i]== densityPoints[j]){observedCounts[j]++;}}}TestUtils.assertChiSquareAccept(densityPoints,expectedCounts,observedCounts,.001);}
@Test public void testCumulativeProbabilitiesSingleIntegerArguments()throws Exception {int lower=1;for (int i=1;i < 7;i++){Assert.assertEquals(p * i,diceDistribution.cumulativeProbability(lower),Double.MIN_VALUE);lower++;}Assert.assertEquals(0,diceDistribution.cumulativeProbability(-1),Double.MIN_VALUE);Assert.assertEquals(1,diceDistribution.cumulativeProbability(7),Double.MIN_VALUE);}
@Test public void testCumulativeProbabilitiesSingleDoubleArguments()throws Exception {int lower=1;double arg=0;for (int i=1;i < 7;i++){arg=lower;Assert.assertEquals(p * i,diceDistribution.cumulativeProbability(arg),Double.MIN_VALUE);arg=lower + Math.random();Assert.assertEquals(p * i,diceDistribution.cumulativeProbability(arg),Double.MIN_VALUE);lower++;}}
@Test public void testCumulativeProbabilitiesRangeIntegerArguments()throws Exception {int lower=1;int upper=6;for (int i=0;i < 2;i++){Assert.assertEquals(1 - p * 2 * i,diceDistribution.cumulativeProbability(lower,upper),1E-12);lower++;upper--;}for (int i=1;i < 7;i++){Assert.assertEquals(p,diceDistribution.cumulativeProbability(i,i),1E-12);}}
@Test public void testCumulativeProbabilitiesRangeDoubleArguments()throws Exception {int lower=1;int upper=6;double dlower=lower;double dupper=upper;for (int i=0;i < 2;i++){Assert.assertEquals(1 - p * 2 * i,diceDistribution.cumulativeProbability(dlower,dupper),1E-12);dlower-=Math.random();dupper+=Math.random();Assert.assertEquals(1 - p * 2 * i,diceDistribution.cumulativeProbability(dlower,dupper),1E-12);lower++;upper--;dlower=lower;dupper=upper;}for (int i=1;i < 7;i++){lower=i;Assert.assertEquals(p,diceDistribution.cumulativeProbability(lower,lower),1E-12);Assert.assertEquals(p,diceDistribution.cumulativeProbability(lower,lower + Math.random()),1E-12);Assert.assertEquals(p,diceDistribution.cumulativeProbability(lower - Math.random(),lower),1E-12);Assert.assertEquals(p,diceDistribution.cumulativeProbability(lower - Math.random(),lower + Math.random()),1E-12);}}
/** * Test preconditions.*/@Test public void testPreconditions(){double[]xval=new double[]{3,4,5,6.5};double[]yval=new double[]{-4,-3,-1,2.5};double[][]zval=new double[xval.length][yval.length];@SuppressWarnings("unused")BivariateRealFunction bcf=new BicubicSplineInterpolatingFunction(xval,yval,zval,zval,zval,zval);double[]wxval=new double[]{3,2,5,6.5};try {bcf=new BicubicSplineInterpolatingFunction(wxval,yval,zval,zval,zval,zval);Assert.fail("an exception should have been thrown");}catch(MathIllegalArgumentException e){}double[]wyval=new double[]{-4,-1,-1,2.5};try {bcf=new BicubicSplineInterpolatingFunction(xval,wyval,zval,zval,zval,zval);Assert.fail("an exception should have been thrown");}catch(MathIllegalArgumentException e){}double[][]wzval=new double[xval.length][yval.length - 1];try {bcf=new BicubicSplineInterpolatingFunction(xval,yval,wzval,zval,zval,zval);Assert.fail("an exception should have been thrown");}catch(DimensionMismatchException e){}try {bcf=new BicubicSplineInterpolatingFunction(xval,yval,zval,wzval,zval,zval);Assert.fail("an exception should have been thrown");}catch(DimensionMismatchException e){}try {bcf=new BicubicSplineInterpolatingFunction(xval,yval,zval,zval,wzval,zval);Assert.fail("an exception should have been thrown");}catch(DimensionMismatchException e){}try {bcf=new BicubicSplineInterpolatingFunction(xval,yval,zval,zval,zval,wzval);Assert.fail("an exception should have been thrown");}catch(DimensionMismatchException e){}wzval=new double[xval.length - 1][yval.length];try {bcf=new BicubicSplineInterpolatingFunction(xval,yval,wzval,zval,zval,zval);Assert.fail("an exception should have been thrown");}catch(DimensionMismatchException e){}try {bcf=new BicubicSplineInterpolatingFunction(xval,yval,zval,wzval,zval,zval);Assert.fail("an exception should have been thrown");}catch(DimensionMismatchException e){}try {bcf=new BicubicSplineInterpolatingFunction(xval,yval,zval,zval,wzval,zval);Assert.fail("an exception should have been thrown");}catch(DimensionMismatchException e){}try {bcf=new BicubicSplineInterpolatingFunction(xval,yval,zval,zval,zval,wzval);Assert.fail("an exception should have been thrown");}catch(DimensionMismatchException e){}}
/** * Test for a plane. <p> z = 2 x - 3 y + 5*/@Test public void testPlane(){double[]xval=new double[]{3,4,5,6.5};double[]yval=new double[]{-4,-3,-1,2,2.5};BivariateRealFunction f=new BivariateRealFunction(){public double value(double x,double y){return 2 * x - 3 * y + 5;}};double[][]zval=new double[xval.length][yval.length];for (int i=0;i < xval.length;i++){for (int j=0;j < yval.length;j++){zval[i][j]=f.value(xval[i],yval[j]);}}double[][]dZdX=new double[xval.length][yval.length];for (int i=0;i < xval.length;i++){for (int j=0;j < yval.length;j++){dZdX[i][j]=2;}}double[][]dZdY=new double[xval.length][yval.length];for (int i=0;i < xval.length;i++){for (int j=0;j < yval.length;j++){dZdY[i][j]=-3;}}double[][]dZdXdY=new double[xval.length][yval.length];for (int i=0;i < xval.length;i++){for (int j=0;j < yval.length;j++){dZdXdY[i][j]=0;}}BivariateRealFunction bcf=new BicubicSplineInterpolatingFunction(xval,yval,zval,dZdX,dZdY,dZdXdY);double x,y;double expected,result;x=4;y=-3;expected=f.value(x,y);result=bcf.value(x,y);Assert.assertEquals("On sample point",expected,result,1e-15);x=4.5;y=-1.5;expected=f.value(x,y);result=bcf.value(x,y);Assert.assertEquals("Half-way between sample points (middle of the patch)",expected,result,0.3);x=3.5;y=-3.5;expected=f.value(x,y);result=bcf.value(x,y);Assert.assertEquals("Half-way between sample points (border of the patch)",expected,result,0.3);}
/** * Test for a paraboloid. <p> z = 2 x<sup>2</sup> - 3 y<sup>2</sup> + 4 x y - 5*/@Test public void testParaboloid(){double[]xval=new double[]{3,4,5,6.5};double[]yval=new double[]{-4,-3,-1,2,2.5};BivariateRealFunction f=new BivariateRealFunction(){public double value(double x,double y){return 2 * x * x - 3 * y * y + 4 * x * y - 5;}};double[][]zval=new double[xval.length][yval.length];for (int i=0;i < xval.length;i++){for (int j=0;j < yval.length;j++){zval[i][j]=f.value(xval[i],yval[j]);}}double[][]dZdX=new double[xval.length][yval.length];BivariateRealFunction dfdX=new BivariateRealFunction(){public double value(double x,double y){return 4 * (x + y);}};for (int i=0;i < xval.length;i++){for (int j=0;j < yval.length;j++){dZdX[i][j]=dfdX.value(xval[i],yval[j]);}}double[][]dZdY=new double[xval.length][yval.length];BivariateRealFunction dfdY=new BivariateRealFunction(){public double value(double x,double y){return 4 * x - 6 * y;}};for (int i=0;i < xval.length;i++){for (int j=0;j < yval.length;j++){dZdY[i][j]=dfdY.value(xval[i],yval[j]);}}double[][]dZdXdY=new double[xval.length][yval.length];for (int i=0;i < xval.length;i++){for (int j=0;j < yval.length;j++){dZdXdY[i][j]=4;}}BivariateRealFunction bcf=new BicubicSplineInterpolatingFunction(xval,yval,zval,dZdX,dZdY,dZdXdY);double x,y;double expected,result;x=4;y=-3;expected=f.value(x,y);result=bcf.value(x,y);Assert.assertEquals("On sample point",expected,result,1e-15);x=4.5;y=-1.5;expected=f.value(x,y);result=bcf.value(x,y);Assert.assertEquals("Half-way between sample points (middle of the patch)",expected,result,2);x=3.5;y=-3.5;expected=f.value(x,y);result=bcf.value(x,y);Assert.assertEquals("Half-way between sample points (border of the patch)",expected,result,2);}
/** * Test for partial derivatives of  {@link BicubicSplineFunction}. <p> f(x,y)= &Sigma;<sub>i</sub>&Sigma;<sub>j</sub> (i+1)(j+2)x<sup>i</sup> y<sup>j</sup>*/@Test public void testSplinePartialDerivatives(){final int N=4;final double[]coeff=new double[16];for (int i=0;i < N;i++){for (int j=0;j < N;j++){coeff[i + N * j]=(i + 1)* (j + 2);}}final BicubicSplineFunction f=new BicubicSplineFunction(coeff);BivariateRealFunction derivative;final double x=0.435;final double y=0.776;final double tol=1e-13;derivative=new BivariateRealFunction(){public double value(double x,double y){final double x2=x * x;final double y2=y * y;final double y3=y2 * y;final double yFactor=2 + 3 * y + 4 * y2 + 5 * y3;return yFactor * (2 + 6 * x + 12 * x2);}};Assert.assertEquals("dFdX",derivative.value(x,y),f.partialDerivativeX().value(x,y),tol);derivative=new BivariateRealFunction(){public double value(double x,double y){final double x2=x * x;final double x3=x2 * x;final double y2=y * y;final double xFactor=1 + 2 * x + 3 * x2 + 4 * x3;return xFactor * (3 + 8 * y + 15 * y2);}};Assert.assertEquals("dFdY",derivative.value(x,y),f.partialDerivativeY().value(x,y),tol);derivative=new BivariateRealFunction(){public double value(double x,double y){final double y2=y * y;final double y3=y2 * y;final double yFactor=2 + 3 * y + 4 * y2 + 5 * y3;return yFactor * (6 + 24 * x);}};Assert.assertEquals("d2FdX2",derivative.value(x,y),f.partialDerivativeXX().value(x,y),tol);derivative=new BivariateRealFunction(){public double value(double x,double y){final double x2=x * x;final double x3=x2 * x;final double xFactor=1 + 2 * x + 3 * x2 + 4 * x3;return xFactor * (8 + 30 * y);}};Assert.assertEquals("d2FdY2",derivative.value(x,y),f.partialDerivativeYY().value(x,y),tol);derivative=new BivariateRealFunction(){public double value(double x,double y){final double x2=x * x;final double y2=y * y;final double yFactor=3 + 8 * y + 15 * y2;return yFactor * (2 + 6 * x + 12 * x2);}};Assert.assertEquals("d2FdXdY",derivative.value(x,y),f.partialDerivativeXY().value(x,y),tol);}
/** * Test that the partial derivatives computed from a {@link BicubicSplineInterpolatingFunction}match the input data.<p> f(x,y)= 5 - 3 x + 2 y - x y + 2 x<sup>2</sup> - 3 y<sup>2</sup> + 4 x<sup>2</sup> y - x y<sup>2</sup> - 3 x<sup>3</sup> + y<sup>3</sup>*/@Test public void testMatchingPartialDerivatives(){final int sz=21;double[]val=new double[sz];final double delta=1d / (sz - 1);for (int i=0;i < sz;i++){val[i]=i * delta;}BivariateRealFunction f=new BivariateRealFunction(){public double value(double x,double y){final double x2=x * x;final double x3=x2 * x;final double y2=y * y;final double y3=y2 * y;return 5 - 3 * x + 2 * y - x * y + 2 * x2 - 3 * y2 + 4 * x2 * y - x * y2 - 3 * x3 + y3;}};double[][]fval=new double[sz][sz];for (int i=0;i < sz;i++){for (int j=0;j < sz;j++){fval[i][j]=f.value(val[i],val[j]);}}double[][]dFdX=new double[sz][sz];BivariateRealFunction dfdX=new BivariateRealFunction(){public double value(double x,double y){final double x2=x * x;final double y2=y * y;return -3 - y + 4 * x + 8 * x * y - y2 - 9 * x2;}};for (int i=0;i < sz;i++){for (int j=0;j < sz;j++){dFdX[i][j]=dfdX.value(val[i],val[j]);}}double[][]dFdY=new double[sz][sz];BivariateRealFunction dfdY=new BivariateRealFunction(){public double value(double x,double y){final double x2=x * x;final double y2=y * y;return 2 - x - 6 * y + 4 * x2 - 2 * x * y + 3 * y2;}};for (int i=0;i < sz;i++){for (int j=0;j < sz;j++){dFdY[i][j]=dfdY.value(val[i],val[j]);}}double[][]d2FdXdY=new double[sz][sz];BivariateRealFunction d2fdXdY=new BivariateRealFunction(){public double value(double x,double y){return -1 + 8 * x - 2 * y;}};for (int i=0;i < sz;i++){for (int j=0;j < sz;j++){d2FdXdY[i][j]=d2fdXdY.value(val[i],val[j]);}}BicubicSplineInterpolatingFunction bcf=new BicubicSplineInterpolatingFunction(val,val,fval,dFdX,dFdY,d2FdXdY);double x,y;double expected,result;final double tol=1e-12;for (int i=0;i < sz;i++){x=val[i];for (int j=0;j < sz;j++){y=val[j];expected=dfdX.value(x,y);result=bcf.partialDerivativeX(x,y);Assert.assertEquals(x + " " + y+ " dFdX",expected,result,tol);expected=dfdY.value(x,y);result=bcf.partialDerivativeY(x,y);Assert.assertEquals(x + " " + y+ " dFdY",expected,result,tol);expected=d2fdXdY.value(x,y);result=bcf.partialDerivativeXY(x,y);Assert.assertEquals(x + " " + y+ " d2FdXdY",expected,result,tol);}}}
@Test public void derivativesConsistency(){TestProblem3 pb=new TestProblem3(0.1);double minStep=0;double maxStep=pb.getFinalTime()- pb.getInitialTime();double scalAbsoluteTolerance=1.0e-8;double scalRelativeTolerance=scalAbsoluteTolerance;DormandPrince853Integrator integ=new DormandPrince853Integrator(minStep,maxStep,scalAbsoluteTolerance,scalRelativeTolerance);StepInterpolatorTestUtils.checkDerivativesConsistency(integ,pb,1.0e-10);}
@Test public void serialization()throws IOException,ClassNotFoundException {TestProblem3 pb=new TestProblem3(0.9);double minStep=0;double maxStep=pb.getFinalTime()- pb.getInitialTime();double scalAbsoluteTolerance=1.0e-8;double scalRelativeTolerance=scalAbsoluteTolerance;DormandPrince853Integrator integ=new DormandPrince853Integrator(minStep,maxStep,scalAbsoluteTolerance,scalRelativeTolerance);integ.addStepHandler(new ContinuousOutputModel());integ.integrate(pb,pb.getInitialTime(),pb.getInitialState(),pb.getFinalTime(),new double[pb.getDimension()]);ByteArrayOutputStream bos=new ByteArrayOutputStream();ObjectOutputStream oos=new ObjectOutputStream(bos);for(StepHandler handler : integ.getStepHandlers()){oos.writeObject(handler);}Assert.assertTrue(bos.size()> 90000);Assert.assertTrue(bos.size()< 100000);ByteArrayInputStream bis=new ByteArrayInputStream(bos.toByteArray());ObjectInputStream ois=new ObjectInputStream(bis);ContinuousOutputModel cm=(ContinuousOutputModel)ois.readObject();Random random=new Random(347588535632l);double maxError=0.0;for (int i=0;i < 1000;++i){double r=random.nextDouble();double time=r * pb.getInitialTime()+ (1.0 - r)* pb.getFinalTime();cm.setInterpolatedTime(time);double[]interpolatedY=cm.getInterpolatedState();double[]theoreticalY=pb.computeTheoreticalState(time);double dx=interpolatedY[0]- theoreticalY[0];double dy=interpolatedY[1]- theoreticalY[1];double error=dx * dx + dy * dy;if (error > maxError){maxError=error;}}Assert.assertTrue(maxError < 2.4e-10);}
@Test public void checklone(){TestProblem3 pb=new TestProblem3(0.9);double minStep=0;double maxStep=pb.getFinalTime()- pb.getInitialTime();double scalAbsoluteTolerance=1.0e-8;double scalRelativeTolerance=scalAbsoluteTolerance;DormandPrince853Integrator integ=new DormandPrince853Integrator(minStep,maxStep,scalAbsoluteTolerance,scalRelativeTolerance);integ.addStepHandler(new StepHandler(){public void handleStep(StepInterpolator interpolator,boolean isLast){StepInterpolator cloned=interpolator.copy();double tA=cloned.getPreviousTime();double tB=cloned.getCurrentTime();double halfStep=FastMath.abs(tB - tA)/ 2;Assert.assertEquals(interpolator.getPreviousTime(),tA,1.0e-12);Assert.assertEquals(interpolator.getCurrentTime(),tB,1.0e-12);for (int i=0;i < 10;++i){double t=(i * tB + (9 - i)* tA)/ 9;interpolator.setInterpolatedTime(t);Assert.assertTrue(FastMath.abs(cloned.getInterpolatedTime()- t)> (halfStep / 10));cloned.setInterpolatedTime(t);Assert.assertEquals(t,cloned.getInterpolatedTime(),1.0e-12);double[]referenceState=interpolator.getInterpolatedState();double[]cloneState=cloned.getInterpolatedState();for (int j=0;j < referenceState.length;++j){Assert.assertEquals(referenceState[j],cloneState[j],1.0e-12);}}}public void init(double t0,double[]y0,double t){}});integ.integrate(pb,pb.getInitialTime(),pb.getInitialState(),pb.getFinalTime(),new double[pb.getDimension()]);}
@Test public void testConstructor()throws Exception {assertFraction(0,1,new BigFraction(0,1));assertFraction(0,1,new BigFraction(0l,2l));assertFraction(0,1,new BigFraction(0,-1));assertFraction(1,2,new BigFraction(1,2));assertFraction(1,2,new BigFraction(2,4));assertFraction(-1,2,new BigFraction(-1,2));assertFraction(-1,2,new BigFraction(1,-2));assertFraction(-1,2,new BigFraction(-2,4));assertFraction(-1,2,new BigFraction(2,-4));assertFraction(11,1,new BigFraction(11));assertFraction(11,1,new BigFraction(11l));assertFraction(11,1,new BigFraction(new BigInteger("11")));assertFraction(0,1,new BigFraction(0.00000000000001,1.0e-5,100));assertFraction(2,5,new BigFraction(0.40000000000001,1.0e-5,100));assertFraction(15,1,new BigFraction(15.0000000000001,1.0e-5,100));Assert.assertEquals(0.00000000000001,new BigFraction(0.00000000000001).doubleValue(),0.0);Assert.assertEquals(0.40000000000001,new BigFraction(0.40000000000001).doubleValue(),0.0);Assert.assertEquals(15.0000000000001,new BigFraction(15.0000000000001).doubleValue(),0.0);assertFraction(3602879701896487l,9007199254740992l,new BigFraction(0.40000000000001));assertFraction(1055531162664967l,70368744177664l,new BigFraction(15.0000000000001));try {new BigFraction(null,BigInteger.ONE);Assert.fail("Expecting NullArgumentException");}catch(NullArgumentException npe){}try {new BigFraction(BigInteger.ONE,null);Assert.fail("Expecting NullArgumentException");}catch(NullArgumentException npe){}try {new BigFraction(BigInteger.ONE,BigInteger.ZERO);Assert.fail("Expecting ZeroException");}catch(ZeroException npe){}try {new BigFraction(2.0 * Integer.MAX_VALUE,1.0e-5,100000);Assert.fail("Expecting FractionConversionException");}catch(FractionConversionException fce){}}
@Test(expected=ConvergenceException.class)public void testGoldenRatio(){new BigFraction((1 + FastMath.sqrt(5))/ 2,1.0e-12,25);}
@Test public void testDoubleConstructor()throws ConvergenceException {assertFraction(1,2,new BigFraction((double)1 / (double)2,1.0e-5,100));assertFraction(1,3,new BigFraction((double)1 / (double)3,1.0e-5,100));assertFraction(2,3,new BigFraction((double)2 / (double)3,1.0e-5,100));assertFraction(1,4,new BigFraction((double)1 / (double)4,1.0e-5,100));assertFraction(3,4,new BigFraction((double)3 / (double)4,1.0e-5,100));assertFraction(1,5,new BigFraction((double)1 / (double)5,1.0e-5,100));assertFraction(2,5,new BigFraction((double)2 / (double)5,1.0e-5,100));assertFraction(3,5,new BigFraction((double)3 / (double)5,1.0e-5,100));assertFraction(4,5,new BigFraction((double)4 / (double)5,1.0e-5,100));assertFraction(1,6,new BigFraction((double)1 / (double)6,1.0e-5,100));assertFraction(5,6,new BigFraction((double)5 / (double)6,1.0e-5,100));assertFraction(1,7,new BigFraction((double)1 / (double)7,1.0e-5,100));assertFraction(2,7,new BigFraction((double)2 / (double)7,1.0e-5,100));assertFraction(3,7,new BigFraction((double)3 / (double)7,1.0e-5,100));assertFraction(4,7,new BigFraction((double)4 / (double)7,1.0e-5,100));assertFraction(5,7,new BigFraction((double)5 / (double)7,1.0e-5,100));assertFraction(6,7,new BigFraction((double)6 / (double)7,1.0e-5,100));assertFraction(1,8,new BigFraction((double)1 / (double)8,1.0e-5,100));assertFraction(3,8,new BigFraction((double)3 / (double)8,1.0e-5,100));assertFraction(5,8,new BigFraction((double)5 / (double)8,1.0e-5,100));assertFraction(7,8,new BigFraction((double)7 / (double)8,1.0e-5,100));assertFraction(1,9,new BigFraction((double)1 / (double)9,1.0e-5,100));assertFraction(2,9,new BigFraction((double)2 / (double)9,1.0e-5,100));assertFraction(4,9,new BigFraction((double)4 / (double)9,1.0e-5,100));assertFraction(5,9,new BigFraction((double)5 / (double)9,1.0e-5,100));assertFraction(7,9,new BigFraction((double)7 / (double)9,1.0e-5,100));assertFraction(8,9,new BigFraction((double)8 / (double)9,1.0e-5,100));assertFraction(1,10,new BigFraction((double)1 / (double)10,1.0e-5,100));assertFraction(3,10,new BigFraction((double)3 / (double)10,1.0e-5,100));assertFraction(7,10,new BigFraction((double)7 / (double)10,1.0e-5,100));assertFraction(9,10,new BigFraction((double)9 / (double)10,1.0e-5,100));assertFraction(1,11,new BigFraction((double)1 / (double)11,1.0e-5,100));assertFraction(2,11,new BigFraction((double)2 / (double)11,1.0e-5,100));assertFraction(3,11,new BigFraction((double)3 / (double)11,1.0e-5,100));assertFraction(4,11,new BigFraction((double)4 / (double)11,1.0e-5,100));assertFraction(5,11,new BigFraction((double)5 / (double)11,1.0e-5,100));assertFraction(6,11,new BigFraction((double)6 / (double)11,1.0e-5,100));assertFraction(7,11,new BigFraction((double)7 / (double)11,1.0e-5,100));assertFraction(8,11,new BigFraction((double)8 / (double)11,1.0e-5,100));assertFraction(9,11,new BigFraction((double)9 / (double)11,1.0e-5,100));assertFraction(10,11,new BigFraction((double)10 / (double)11,1.0e-5,100));}
@Test public void testDigitLimitConstructor()throws ConvergenceException {assertFraction(2,5,new BigFraction(0.4,9));assertFraction(2,5,new BigFraction(0.4,99));assertFraction(2,5,new BigFraction(0.4,999));assertFraction(3,5,new BigFraction(0.6152,9));assertFraction(8,13,new BigFraction(0.6152,99));assertFraction(510,829,new BigFraction(0.6152,999));assertFraction(769,1250,new BigFraction(0.6152,9999));}
@Test public void testEpsilonLimitConstructor()throws ConvergenceException {assertFraction(2,5,new BigFraction(0.4,1.0e-5,100));assertFraction(3,5,new BigFraction(0.6152,0.02,100));assertFraction(8,13,new BigFraction(0.6152,1.0e-3,100));assertFraction(251,408,new BigFraction(0.6152,1.0e-4,100));assertFraction(251,408,new BigFraction(0.6152,1.0e-5,100));assertFraction(510,829,new BigFraction(0.6152,1.0e-6,100));assertFraction(769,1250,new BigFraction(0.6152,1.0e-7,100));}
@Test public void testCompareTo(){BigFraction first=new BigFraction(1,2);BigFraction second=new BigFraction(1,3);BigFraction third=new BigFraction(1,2);Assert.assertEquals(0,first.compareTo(first));Assert.assertEquals(0,first.compareTo(third));Assert.assertEquals(1,first.compareTo(second));Assert.assertEquals(-1,second.compareTo(first));BigFraction pi1=new BigFraction(1068966896,340262731);BigFraction pi2=new BigFraction(411557987,131002976);Assert.assertEquals(-1,pi1.compareTo(pi2));Assert.assertEquals(1,pi2.compareTo(pi1));Assert.assertEquals(0.0,pi1.doubleValue()- pi2.doubleValue(),1.0e-20);}
@Test public void testDoubleValue(){BigFraction first=new BigFraction(1,2);BigFraction second=new BigFraction(1,3);Assert.assertEquals(0.5,first.doubleValue(),0.0);Assert.assertEquals(1.0 / 3.0,second.doubleValue(),0.0);}
@Test public void testFloatValue(){BigFraction first=new BigFraction(1,2);BigFraction second=new BigFraction(1,3);Assert.assertEquals(0.5f,first.floatValue(),0.0f);Assert.assertEquals((float)(1.0 / 3.0),second.floatValue(),0.0f);}
@Test public void testIntValue(){BigFraction first=new BigFraction(1,2);BigFraction second=new BigFraction(3,2);Assert.assertEquals(0,first.intValue());Assert.assertEquals(1,second.intValue());}
@Test public void testLongValue(){BigFraction first=new BigFraction(1,2);BigFraction second=new BigFraction(3,2);Assert.assertEquals(0L,first.longValue());Assert.assertEquals(1L,second.longValue());}
@Test public void testConstructorDouble(){assertFraction(1,2,new BigFraction(0.5));assertFraction(6004799503160661l,18014398509481984l,new BigFraction(1.0 / 3.0));assertFraction(6124895493223875l,36028797018963968l,new BigFraction(17.0 / 100.0));assertFraction(1784551352345559l,562949953421312l,new BigFraction(317.0 / 100.0));assertFraction(-1,2,new BigFraction(-0.5));assertFraction(-6004799503160661l,18014398509481984l,new BigFraction(-1.0 / 3.0));assertFraction(-6124895493223875l,36028797018963968l,new BigFraction(17.0 / -100.0));assertFraction(-1784551352345559l,562949953421312l,new BigFraction(-317.0 / 100.0));for(double v : new double[]{Double.NaN,Double.NEGATIVE_INFINITY,Double.POSITIVE_INFINITY}){try {new BigFraction(v);Assert.fail("Expecting IllegalArgumentException");}catch(IllegalArgumentException iae){}}Assert.assertEquals(1l,new BigFraction(Double.MAX_VALUE).getDenominatorAsLong());Assert.assertEquals(1l,new BigFraction(Double.longBitsToDouble(0x0010000000000000L)).getNumeratorAsLong());Assert.assertEquals(1l,new BigFraction(Double.MIN_VALUE).getNumeratorAsLong());}
@Test public void testAbs(){BigFraction a=new BigFraction(10,21);BigFraction b=new BigFraction(-10,21);BigFraction c=new BigFraction(10,-21);assertFraction(10,21,a.abs());assertFraction(10,21,b.abs());assertFraction(10,21,c.abs());}
@Test public void testReciprocal(){BigFraction f=null;f=new BigFraction(50,75);f=f.reciprocal();Assert.assertEquals(3,f.getNumeratorAsInt());Assert.assertEquals(2,f.getDenominatorAsInt());f=new BigFraction(4,3);f=f.reciprocal();Assert.assertEquals(3,f.getNumeratorAsInt());Assert.assertEquals(4,f.getDenominatorAsInt());f=new BigFraction(-15,47);f=f.reciprocal();Assert.assertEquals(-47,f.getNumeratorAsInt());Assert.assertEquals(15,f.getDenominatorAsInt());f=new BigFraction(0,3);try {f=f.reciprocal();Assert.fail("expecting ZeroException");}catch(ZeroException ex){}f=new BigFraction(Integer.MAX_VALUE,1);f=f.reciprocal();Assert.assertEquals(1,f.getNumeratorAsInt());Assert.assertEquals(Integer.MAX_VALUE,f.getDenominatorAsInt());}
@Test public void testNegate(){BigFraction f=null;f=new BigFraction(50,75);f=f.negate();Assert.assertEquals(-2,f.getNumeratorAsInt());Assert.assertEquals(3,f.getDenominatorAsInt());f=new BigFraction(-50,75);f=f.negate();Assert.assertEquals(2,f.getNumeratorAsInt());Assert.assertEquals(3,f.getDenominatorAsInt());f=new BigFraction(Integer.MAX_VALUE - 1,Integer.MAX_VALUE);f=f.negate();Assert.assertEquals(Integer.MIN_VALUE + 2,f.getNumeratorAsInt());Assert.assertEquals(Integer.MAX_VALUE,f.getDenominatorAsInt());}
@Test public void testAdd(){BigFraction a=new BigFraction(1,2);BigFraction b=new BigFraction(2,3);assertFraction(1,1,a.add(a));assertFraction(7,6,a.add(b));assertFraction(7,6,b.add(a));assertFraction(4,3,b.add(b));BigFraction f1=new BigFraction(Integer.MAX_VALUE - 1,1);BigFraction f2=BigFraction.ONE;BigFraction f=f1.add(f2);Assert.assertEquals(Integer.MAX_VALUE,f.getNumeratorAsInt());Assert.assertEquals(1,f.getDenominatorAsInt());f1=new BigFraction(-1,13 * 13 * 2* 2);f2=new BigFraction(-2,13 * 17 * 2);f=f1.add(f2);Assert.assertEquals(13 * 13 * 17* 2* 2,f.getDenominatorAsInt());Assert.assertEquals(-17 - 2 * 13 * 2,f.getNumeratorAsInt());try {f.add((BigFraction)null);Assert.fail("expecting NullArgumentException");}catch(NullArgumentException ex){}f1=new BigFraction(1,32768 * 3);f2=new BigFraction(1,59049);f=f1.add(f2);Assert.assertEquals(52451,f.getNumeratorAsInt());Assert.assertEquals(1934917632,f.getDenominatorAsInt());f1=new BigFraction(Integer.MIN_VALUE,3);f2=new BigFraction(1,3);f=f1.add(f2);Assert.assertEquals(Integer.MIN_VALUE + 1,f.getNumeratorAsInt());Assert.assertEquals(3,f.getDenominatorAsInt());f1=new BigFraction(Integer.MAX_VALUE - 1,1);f=f1.add(BigInteger.ONE);Assert.assertEquals(Integer.MAX_VALUE,f.getNumeratorAsInt());Assert.assertEquals(1,f.getDenominatorAsInt());f=f.add(BigInteger.ZERO);Assert.assertEquals(Integer.MAX_VALUE,f.getNumeratorAsInt());Assert.assertEquals(1,f.getDenominatorAsInt());f1=new BigFraction(Integer.MAX_VALUE - 1,1);f=f1.add(1);Assert.assertEquals(Integer.MAX_VALUE,f.getNumeratorAsInt());Assert.assertEquals(1,f.getDenominatorAsInt());f=f.add(0);Assert.assertEquals(Integer.MAX_VALUE,f.getNumeratorAsInt());Assert.assertEquals(1,f.getDenominatorAsInt());f1=new BigFraction(Integer.MAX_VALUE - 1,1);f=f1.add(1l);Assert.assertEquals(Integer.MAX_VALUE,f.getNumeratorAsInt());Assert.assertEquals(1,f.getDenominatorAsInt());f=f.add(0l);Assert.assertEquals(Integer.MAX_VALUE,f.getNumeratorAsInt());Assert.assertEquals(1,f.getDenominatorAsInt());}
@Test public void testDivide(){BigFraction a=new BigFraction(1,2);BigFraction b=new BigFraction(2,3);assertFraction(1,1,a.divide(a));assertFraction(3,4,a.divide(b));assertFraction(4,3,b.divide(a));assertFraction(1,1,b.divide(b));BigFraction f1=new BigFraction(3,5);BigFraction f2=BigFraction.ZERO;try {f1.divide(f2);Assert.fail("expecting ArithmeticException");}catch(ZeroException ex){}f1=new BigFraction(0,5);f2=new BigFraction(2,7);BigFraction f=f1.divide(f2);Assert.assertSame(BigFraction.ZERO,f);f1=new BigFraction(2,7);f2=BigFraction.ONE;f=f1.divide(f2);Assert.assertEquals(2,f.getNumeratorAsInt());Assert.assertEquals(7,f.getDenominatorAsInt());f1=new BigFraction(1,Integer.MAX_VALUE);f=f1.divide(f1);Assert.assertEquals(1,f.getNumeratorAsInt());Assert.assertEquals(1,f.getDenominatorAsInt());f1=new BigFraction(Integer.MIN_VALUE,Integer.MAX_VALUE);f2=new BigFraction(1,Integer.MAX_VALUE);f=f1.divide(f2);Assert.assertEquals(Integer.MIN_VALUE,f.getNumeratorAsInt());Assert.assertEquals(1,f.getDenominatorAsInt());try {f.divide((BigFraction)null);Assert.fail("expecting NullArgumentException");}catch(NullArgumentException ex){}f1=new BigFraction(Integer.MIN_VALUE,Integer.MAX_VALUE);f=f1.divide(BigInteger.valueOf(Integer.MIN_VALUE));Assert.assertEquals(Integer.MAX_VALUE,f.getDenominatorAsInt());Assert.assertEquals(1,f.getNumeratorAsInt());f1=new BigFraction(Integer.MIN_VALUE,Integer.MAX_VALUE);f=f1.divide(Integer.MIN_VALUE);Assert.assertEquals(Integer.MAX_VALUE,f.getDenominatorAsInt());Assert.assertEquals(1,f.getNumeratorAsInt());f1=new BigFraction(Integer.MIN_VALUE,Integer.MAX_VALUE);f=f1.divide((long)Integer.MIN_VALUE);Assert.assertEquals(Integer.MAX_VALUE,f.getDenominatorAsInt());Assert.assertEquals(1,f.getNumeratorAsInt());}
@Test public void testMultiply(){BigFraction a=new BigFraction(1,2);BigFraction b=new BigFraction(2,3);assertFraction(1,4,a.multiply(a));assertFraction(1,3,a.multiply(b));assertFraction(1,3,b.multiply(a));assertFraction(4,9,b.multiply(b));BigFraction f1=new BigFraction(Integer.MAX_VALUE,1);BigFraction f2=new BigFraction(Integer.MIN_VALUE,Integer.MAX_VALUE);BigFraction f=f1.multiply(f2);Assert.assertEquals(Integer.MIN_VALUE,f.getNumeratorAsInt());Assert.assertEquals(1,f.getDenominatorAsInt());f=f2.multiply(Integer.MAX_VALUE);Assert.assertEquals(Integer.MIN_VALUE,f.getNumeratorAsInt());Assert.assertEquals(1,f.getDenominatorAsInt());f=f2.multiply((long)Integer.MAX_VALUE);Assert.assertEquals(Integer.MIN_VALUE,f.getNumeratorAsInt());Assert.assertEquals(1,f.getDenominatorAsInt());try {f.multiply((BigFraction)null);Assert.fail("expecting NullArgumentException");}catch(NullArgumentException ex){}}
@Test public void testSubtract(){BigFraction a=new BigFraction(1,2);BigFraction b=new BigFraction(2,3);assertFraction(0,1,a.subtract(a));assertFraction(-1,6,a.subtract(b));assertFraction(1,6,b.subtract(a));assertFraction(0,1,b.subtract(b));BigFraction f=new BigFraction(1,1);try {f.subtract((BigFraction)null);Assert.fail("expecting NullArgumentException");}catch(NullArgumentException ex){}BigFraction f1=new BigFraction(1,32768 * 3);BigFraction f2=new BigFraction(1,59049);f=f1.subtract(f2);Assert.assertEquals(-13085,f.getNumeratorAsInt());Assert.assertEquals(1934917632,f.getDenominatorAsInt());f1=new BigFraction(Integer.MIN_VALUE,3);f2=new BigFraction(1,3).negate();f=f1.subtract(f2);Assert.assertEquals(Integer.MIN_VALUE + 1,f.getNumeratorAsInt());Assert.assertEquals(3,f.getDenominatorAsInt());f1=new BigFraction(Integer.MAX_VALUE,1);f2=BigFraction.ONE;f=f1.subtract(f2);Assert.assertEquals(Integer.MAX_VALUE - 1,f.getNumeratorAsInt());Assert.assertEquals(1,f.getDenominatorAsInt());}
@Test public void testBigDecimalValue(){Assert.assertEquals(new BigDecimal(0.5),new BigFraction(1,2).bigDecimalValue());Assert.assertEquals(new BigDecimal("0.0003"),new BigFraction(3,10000).bigDecimalValue());Assert.assertEquals(new BigDecimal("0"),new BigFraction(1,3).bigDecimalValue(BigDecimal.ROUND_DOWN));Assert.assertEquals(new BigDecimal("0.333"),new BigFraction(1,3).bigDecimalValue(3,BigDecimal.ROUND_DOWN));}
@Test public void testEqualsAndHashCode(){BigFraction zero=new BigFraction(0,1);BigFraction nullFraction=null;Assert.assertTrue(zero.equals(zero));Assert.assertFalse(zero.equals(nullFraction));Assert.assertFalse(zero.equals(Double.valueOf(0)));BigFraction zero2=new BigFraction(0,2);Assert.assertTrue(zero.equals(zero2));Assert.assertEquals(zero.hashCode(),zero2.hashCode());BigFraction one=new BigFraction(1,1);Assert.assertFalse((one.equals(zero)|| zero.equals(one)));Assert.assertTrue(one.equals(BigFraction.ONE));}
@Test public void testGetReducedFraction(){BigFraction threeFourths=new BigFraction(3,4);Assert.assertTrue(threeFourths.equals(BigFraction.getReducedFraction(6,8)));Assert.assertTrue(BigFraction.ZERO.equals(BigFraction.getReducedFraction(0,-1)));try {BigFraction.getReducedFraction(1,0);Assert.fail("expecting ZeroException");}catch(ZeroException ex){}Assert.assertEquals(BigFraction.getReducedFraction(2,Integer.MIN_VALUE).getNumeratorAsInt(),-1);Assert.assertEquals(BigFraction.getReducedFraction(1,-1).getNumeratorAsInt(),-1);}
@Test public void testPercentage(){Assert.assertEquals(50.0,new BigFraction(1,2).percentageValue(),1.0e-15);}
@Test public void testPow(){Assert.assertEquals(new BigFraction(8192,1594323),new BigFraction(2,3).pow(13));Assert.assertEquals(new BigFraction(8192,1594323),new BigFraction(2,3).pow(13l));Assert.assertEquals(new BigFraction(8192,1594323),new BigFraction(2,3).pow(BigInteger.valueOf(13l)));Assert.assertEquals(BigFraction.ONE,new BigFraction(2,3).pow(0));Assert.assertEquals(BigFraction.ONE,new BigFraction(2,3).pow(0l));Assert.assertEquals(BigFraction.ONE,new BigFraction(2,3).pow(BigInteger.valueOf(0l)));Assert.assertEquals(new BigFraction(1594323,8192),new BigFraction(2,3).pow(-13));Assert.assertEquals(new BigFraction(1594323,8192),new BigFraction(2,3).pow(-13l));Assert.assertEquals(new BigFraction(1594323,8192),new BigFraction(2,3).pow(BigInteger.valueOf(-13l)));}
@Test public void testMath340(){BigFraction fractionA=new BigFraction(0.00131);BigFraction fractionB=new BigFraction(.37).reciprocal();BigFraction errorResult=fractionA.multiply(fractionB);BigFraction correctResult=new BigFraction(fractionA.getNumerator().multiply(fractionB.getNumerator()),fractionA.getDenominator().multiply(fractionB.getDenominator()));Assert.assertEquals(correctResult,errorResult);}
@Test public void testSerial()throws FractionConversionException {BigFraction[]fractions={new BigFraction(3,4),BigFraction.ONE,BigFraction.ZERO,new BigFraction(17),new BigFraction(FastMath.PI,1000),new BigFraction(-5,2)};for(BigFraction fraction : fractions){Assert.assertEquals(fraction,TestUtils.serializeAndRecover(fraction));}}
@Test public void testSetterInjection()throws Exception {MultivariateSummaryStatistics u=createMultivariateSummaryStatistics(2,true);u.setMeanImpl(new StorelessUnivariateStatistic[]{new sumMean(),new sumMean()});u.addValue(new double[]{1,2});u.addValue(new double[]{3,4});Assert.assertEquals(4,u.getMean()[0],1E-14);Assert.assertEquals(6,u.getMean()[1],1E-14);u.clear();u.addValue(new double[]{1,2});u.addValue(new double[]{3,4});Assert.assertEquals(4,u.getMean()[0],1E-14);Assert.assertEquals(6,u.getMean()[1],1E-14);u.clear();u.setMeanImpl(new StorelessUnivariateStatistic[]{new Mean(),new Mean()});u.addValue(new double[]{1,2});u.addValue(new double[]{3,4});Assert.assertEquals(2,u.getMean()[0],1E-14);Assert.assertEquals(3,u.getMean()[1],1E-14);Assert.assertEquals(2,u.getDimension());}
@Test public void testSetterIllegalState()throws Exception {MultivariateSummaryStatistics u=createMultivariateSummaryStatistics(2,true);u.addValue(new double[]{1,2});u.addValue(new double[]{3,4});try {u.setMeanImpl(new StorelessUnivariateStatistic[]{new sumMean(),new sumMean()});Assert.fail("Expecting IllegalStateException");}catch(IllegalStateException ex){}}
@Test public void testToString(){MultivariateSummaryStatistics stats=createMultivariateSummaryStatistics(2,true);stats.addValue(new double[]{1,3});stats.addValue(new double[]{2,2});stats.addValue(new double[]{3,1});Locale d=Locale.getDefault();Locale.setDefault(Locale.US);final String suffix=System.getProperty("line.separator");Assert.assertEquals("MultivariateSummaryStatistics:" + suffix + "n: 3"+ suffix+ "min: 1.0,1.0"+ suffix+ "max: 3.0,3.0"+ suffix+ "mean: 2.0,2.0"+ suffix+ "geometric mean: 1.817...,1.817..."+ suffix+ "sum of squares: 14.0,14.0"+ suffix+ "sum of logarithms: 1.791...,1.791..."+ suffix+ "standard deviation: 1.0,1.0"+ suffix+ "covariance: Array2DRowRealMatrix{{1.0,-1.0},{-1.0,1.0}}"+ suffix,stats.toString().replaceAll("([0-9]+\\.[0-9][0-9][0-9])[0-9]+","$1..."));Locale.setDefault(d);}
@Test public void testShuffledStatistics(){MultivariateSummaryStatistics reference=createMultivariateSummaryStatistics(2,true);MultivariateSummaryStatistics shuffled=createMultivariateSummaryStatistics(2,true);StorelessUnivariateStatistic[]tmp=shuffled.getGeoMeanImpl();shuffled.setGeoMeanImpl(shuffled.getMeanImpl());shuffled.setMeanImpl(shuffled.getMaxImpl());shuffled.setMaxImpl(shuffled.getMinImpl());shuffled.setMinImpl(shuffled.getSumImpl());shuffled.setSumImpl(shuffled.getSumsqImpl());shuffled.setSumsqImpl(shuffled.getSumLogImpl());shuffled.setSumLogImpl(tmp);for (int i=100;i > 0;--i){reference.addValue(new double[]{i,i});shuffled.addValue(new double[]{i,i});}TestUtils.assertEquals(reference.getMean(),shuffled.getGeometricMean(),1.0e-10);TestUtils.assertEquals(reference.getMax(),shuffled.getMean(),1.0e-10);TestUtils.assertEquals(reference.getMin(),shuffled.getMax(),1.0e-10);TestUtils.assertEquals(reference.getSum(),shuffled.getMin(),1.0e-10);TestUtils.assertEquals(reference.getSumSq(),shuffled.getSum(),1.0e-10);TestUtils.assertEquals(reference.getSumLog(),shuffled.getSumSq(),1.0e-10);TestUtils.assertEquals(reference.getGeometricMean(),shuffled.getSumLog(),1.0e-10);}
@Test public void testDimension(){try {createMultivariateSummaryStatistics(2,true).addValue(new double[3]);Assert.fail("Expecting DimensionMismatchException");}catch(DimensionMismatchException dme){}}
/** * test stats */@Test public void testStats(){MultivariateSummaryStatistics u=createMultivariateSummaryStatistics(2,true);Assert.assertEquals(0,u.getN());u.addValue(new double[]{1,2});u.addValue(new double[]{2,3});u.addValue(new double[]{2,3});u.addValue(new double[]{3,4});Assert.assertEquals(4,u.getN());Assert.assertEquals(8,u.getSum()[0],1.0e-10);Assert.assertEquals(12,u.getSum()[1],1.0e-10);Assert.assertEquals(18,u.getSumSq()[0],1.0e-10);Assert.assertEquals(38,u.getSumSq()[1],1.0e-10);Assert.assertEquals(1,u.getMin()[0],1.0e-10);Assert.assertEquals(2,u.getMin()[1],1.0e-10);Assert.assertEquals(3,u.getMax()[0],1.0e-10);Assert.assertEquals(4,u.getMax()[1],1.0e-10);Assert.assertEquals(2.4849066497880003102,u.getSumLog()[0],1.0e-10);Assert.assertEquals(4.276666119016055311,u.getSumLog()[1],1.0e-10);Assert.assertEquals(1.8612097182041991979,u.getGeometricMean()[0],1.0e-10);Assert.assertEquals(2.9129506302439405217,u.getGeometricMean()[1],1.0e-10);Assert.assertEquals(2,u.getMean()[0],1.0e-10);Assert.assertEquals(3,u.getMean()[1],1.0e-10);Assert.assertEquals(FastMath.sqrt(2.0 / 3.0),u.getStandardDeviation()[0],1.0e-10);Assert.assertEquals(FastMath.sqrt(2.0 / 3.0),u.getStandardDeviation()[1],1.0e-10);Assert.assertEquals(2.0 / 3.0,u.getCovariance().getEntry(0,0),1.0e-10);Assert.assertEquals(2.0 / 3.0,u.getCovariance().getEntry(0,1),1.0e-10);Assert.assertEquals(2.0 / 3.0,u.getCovariance().getEntry(1,0),1.0e-10);Assert.assertEquals(2.0 / 3.0,u.getCovariance().getEntry(1,1),1.0e-10);u.clear();Assert.assertEquals(0,u.getN());}
@Test public void testN0andN1Conditions()throws Exception {MultivariateSummaryStatistics u=createMultivariateSummaryStatistics(1,true);Assert.assertTrue(Double.isNaN(u.getMean()[0]));Assert.assertTrue(Double.isNaN(u.getStandardDeviation()[0]));u.addValue(new double[]{1});Assert.assertEquals(1.0,u.getMean()[0],1.0e-10);Assert.assertEquals(1.0,u.getGeometricMean()[0],1.0e-10);Assert.assertEquals(0.0,u.getStandardDeviation()[0],1.0e-10);u.addValue(new double[]{2});Assert.assertTrue(u.getStandardDeviation()[0]> 0);}
@Test public void testNaNContracts(){MultivariateSummaryStatistics u=createMultivariateSummaryStatistics(1,true);Assert.assertTrue(Double.isNaN(u.getMean()[0]));Assert.assertTrue(Double.isNaN(u.getMin()[0]));Assert.assertTrue(Double.isNaN(u.getStandardDeviation()[0]));Assert.assertTrue(Double.isNaN(u.getGeometricMean()[0]));u.addValue(new double[]{1.0});Assert.assertFalse(Double.isNaN(u.getMean()[0]));Assert.assertFalse(Double.isNaN(u.getMin()[0]));Assert.assertFalse(Double.isNaN(u.getStandardDeviation()[0]));Assert.assertFalse(Double.isNaN(u.getGeometricMean()[0]));}
@Test public void testSerialization(){MultivariateSummaryStatistics u=createMultivariateSummaryStatistics(2,true);TestUtils.checkSerializedEquality(u);MultivariateSummaryStatistics s=(MultivariateSummaryStatistics)TestUtils.serializeAndRecover(u);Assert.assertEquals(u,s);u.addValue(new double[]{2d,1d});u.addValue(new double[]{1d,1d});u.addValue(new double[]{3d,1d});u.addValue(new double[]{4d,1d});u.addValue(new double[]{5d,1d});TestUtils.checkSerializedEquality(u);s=(MultivariateSummaryStatistics)TestUtils.serializeAndRecover(u);Assert.assertEquals(u,s);}
@Test public void testEqualsAndHashCode(){MultivariateSummaryStatistics u=createMultivariateSummaryStatistics(2,true);MultivariateSummaryStatistics t=null;int emptyHash=u.hashCode();Assert.assertTrue(u.equals(u));Assert.assertFalse(u.equals(t));Assert.assertFalse(u.equals(Double.valueOf(0)));t=createMultivariateSummaryStatistics(2,true);Assert.assertTrue(t.equals(u));Assert.assertTrue(u.equals(t));Assert.assertEquals(emptyHash,t.hashCode());u.addValue(new double[]{2d,1d});u.addValue(new double[]{1d,1d});u.addValue(new double[]{3d,1d});u.addValue(new double[]{4d,1d});u.addValue(new double[]{5d,1d});Assert.assertFalse(t.equals(u));Assert.assertFalse(u.equals(t));Assert.assertTrue(u.hashCode()!= t.hashCode());t.addValue(new double[]{2d,1d});t.addValue(new double[]{1d,1d});t.addValue(new double[]{3d,1d});t.addValue(new double[]{4d,1d});t.addValue(new double[]{5d,1d});Assert.assertTrue(t.equals(u));Assert.assertTrue(u.equals(t));Assert.assertEquals(u.hashCode(),t.hashCode());u.clear();t.clear();Assert.assertTrue(t.equals(u));Assert.assertTrue(u.equals(t));Assert.assertEquals(emptyHash,t.hashCode());Assert.assertEquals(emptyHash,u.hashCode());}
@Test public void testFirstChebyshevPolynomials(){checkPolynomial(PolynomialsUtils.createChebyshevPolynomial(3),"-3 x + 4 x^3");checkPolynomial(PolynomialsUtils.createChebyshevPolynomial(2),"-1 + 2 x^2");checkPolynomial(PolynomialsUtils.createChebyshevPolynomial(1),"x");checkPolynomial(PolynomialsUtils.createChebyshevPolynomial(0),"1");checkPolynomial(PolynomialsUtils.createChebyshevPolynomial(7),"-7 x + 56 x^3 - 112 x^5 + 64 x^7");checkPolynomial(PolynomialsUtils.createChebyshevPolynomial(6),"-1 + 18 x^2 - 48 x^4 + 32 x^6");checkPolynomial(PolynomialsUtils.createChebyshevPolynomial(5),"5 x - 20 x^3 + 16 x^5");checkPolynomial(PolynomialsUtils.createChebyshevPolynomial(4),"1 - 8 x^2 + 8 x^4");}
@Test public void testChebyshevBounds(){for (int k=0;k < 12;++k){PolynomialFunction Tk=PolynomialsUtils.createChebyshevPolynomial(k);for (double x=-1;x <= 1;x+=0.02){Assert.assertTrue(k + " " + Tk.value(x),FastMath.abs(Tk.value(x))< (1 + 1e-12));}}}
@Test public void testChebyshevDifferentials(){for (int k=0;k < 12;++k){PolynomialFunction Tk0=PolynomialsUtils.createChebyshevPolynomial(k);PolynomialFunction Tk1=Tk0.polynomialDerivative();PolynomialFunction Tk2=Tk1.polynomialDerivative();PolynomialFunction g0=new PolynomialFunction(new double[]{k * k});PolynomialFunction g1=new PolynomialFunction(new double[]{0,-1});PolynomialFunction g2=new PolynomialFunction(new double[]{1,0,-1});PolynomialFunction Tk0g0=Tk0.multiply(g0);PolynomialFunction Tk1g1=Tk1.multiply(g1);PolynomialFunction Tk2g2=Tk2.multiply(g2);checkNullPolynomial(Tk0g0.add(Tk1g1.add(Tk2g2)));}}
@Test public void testChebyshevOrthogonality(){UnivariateFunction weight=new UnivariateFunction(){public double value(double x){return 1 / FastMath.sqrt(1 - x * x);}};for (int i=0;i < 10;++i){PolynomialFunction pi=PolynomialsUtils.createChebyshevPolynomial(i);for (int j=0;j <= i;++j){PolynomialFunction pj=PolynomialsUtils.createChebyshevPolynomial(j);checkOrthogonality(pi,pj,weight,-0.9999,0.9999,1.5,0.03);}}}
@Test public void testFirstHermitePolynomials(){checkPolynomial(PolynomialsUtils.createHermitePolynomial(3),"-12 x + 8 x^3");checkPolynomial(PolynomialsUtils.createHermitePolynomial(2),"-2 + 4 x^2");checkPolynomial(PolynomialsUtils.createHermitePolynomial(1),"2 x");checkPolynomial(PolynomialsUtils.createHermitePolynomial(0),"1");checkPolynomial(PolynomialsUtils.createHermitePolynomial(7),"-1680 x + 3360 x^3 - 1344 x^5 + 128 x^7");checkPolynomial(PolynomialsUtils.createHermitePolynomial(6),"-120 + 720 x^2 - 480 x^4 + 64 x^6");checkPolynomial(PolynomialsUtils.createHermitePolynomial(5),"120 x - 160 x^3 + 32 x^5");checkPolynomial(PolynomialsUtils.createHermitePolynomial(4),"12 - 48 x^2 + 16 x^4");}
@Test public void testHermiteDifferentials(){for (int k=0;k < 12;++k){PolynomialFunction Hk0=PolynomialsUtils.createHermitePolynomial(k);PolynomialFunction Hk1=Hk0.polynomialDerivative();PolynomialFunction Hk2=Hk1.polynomialDerivative();PolynomialFunction g0=new PolynomialFunction(new double[]{2 * k});PolynomialFunction g1=new PolynomialFunction(new double[]{0,-2});PolynomialFunction g2=new PolynomialFunction(new double[]{1});PolynomialFunction Hk0g0=Hk0.multiply(g0);PolynomialFunction Hk1g1=Hk1.multiply(g1);PolynomialFunction Hk2g2=Hk2.multiply(g2);checkNullPolynomial(Hk0g0.add(Hk1g1.add(Hk2g2)));}}
@Test public void testHermiteOrthogonality(){UnivariateFunction weight=new UnivariateFunction(){public double value(double x){return FastMath.exp(-x * x);}};for (int i=0;i < 10;++i){PolynomialFunction pi=PolynomialsUtils.createHermitePolynomial(i);for (int j=0;j <= i;++j){PolynomialFunction pj=PolynomialsUtils.createHermitePolynomial(j);checkOrthogonality(pi,pj,weight,-50,50,1.5,1.0e-8);}}}
@Test public void testFirstLaguerrePolynomials(){checkPolynomial(PolynomialsUtils.createLaguerrePolynomial(3),6l,"6 - 18 x + 9 x^2 - x^3");checkPolynomial(PolynomialsUtils.createLaguerrePolynomial(2),2l,"2 - 4 x + x^2");checkPolynomial(PolynomialsUtils.createLaguerrePolynomial(1),1l,"1 - x");checkPolynomial(PolynomialsUtils.createLaguerrePolynomial(0),1l,"1");checkPolynomial(PolynomialsUtils.createLaguerrePolynomial(7),5040l,"5040 - 35280 x + 52920 x^2 - 29400 x^3" + " + 7350 x^4 - 882 x^5 + 49 x^6 - x^7");checkPolynomial(PolynomialsUtils.createLaguerrePolynomial(6),720l,"720 - 4320 x + 5400 x^2 - 2400 x^3 + 450 x^4" + " - 36 x^5 + x^6");checkPolynomial(PolynomialsUtils.createLaguerrePolynomial(5),120l,"120 - 600 x + 600 x^2 - 200 x^3 + 25 x^4 - x^5");checkPolynomial(PolynomialsUtils.createLaguerrePolynomial(4),24l,"24 - 96 x + 72 x^2 - 16 x^3 + x^4");}
@Test public void testLaguerreDifferentials(){for (int k=0;k < 12;++k){PolynomialFunction Lk0=PolynomialsUtils.createLaguerrePolynomial(k);PolynomialFunction Lk1=Lk0.polynomialDerivative();PolynomialFunction Lk2=Lk1.polynomialDerivative();PolynomialFunction g0=new PolynomialFunction(new double[]{k});PolynomialFunction g1=new PolynomialFunction(new double[]{1,-1});PolynomialFunction g2=new PolynomialFunction(new double[]{0,1});PolynomialFunction Lk0g0=Lk0.multiply(g0);PolynomialFunction Lk1g1=Lk1.multiply(g1);PolynomialFunction Lk2g2=Lk2.multiply(g2);checkNullPolynomial(Lk0g0.add(Lk1g1.add(Lk2g2)));}}
@Test public void testLaguerreOrthogonality(){UnivariateFunction weight=new UnivariateFunction(){public double value(double x){return FastMath.exp(-x);}};for (int i=0;i < 10;++i){PolynomialFunction pi=PolynomialsUtils.createLaguerrePolynomial(i);for (int j=0;j <= i;++j){PolynomialFunction pj=PolynomialsUtils.createLaguerrePolynomial(j);checkOrthogonality(pi,pj,weight,0.0,100.0,0.99999,1.0e-13);}}}
@Test public void testFirstLegendrePolynomials(){checkPolynomial(PolynomialsUtils.createLegendrePolynomial(3),2l,"-3 x + 5 x^3");checkPolynomial(PolynomialsUtils.createLegendrePolynomial(2),2l,"-1 + 3 x^2");checkPolynomial(PolynomialsUtils.createLegendrePolynomial(1),1l,"x");checkPolynomial(PolynomialsUtils.createLegendrePolynomial(0),1l,"1");checkPolynomial(PolynomialsUtils.createLegendrePolynomial(7),16l,"-35 x + 315 x^3 - 693 x^5 + 429 x^7");checkPolynomial(PolynomialsUtils.createLegendrePolynomial(6),16l,"-5 + 105 x^2 - 315 x^4 + 231 x^6");checkPolynomial(PolynomialsUtils.createLegendrePolynomial(5),8l,"15 x - 70 x^3 + 63 x^5");checkPolynomial(PolynomialsUtils.createLegendrePolynomial(4),8l,"3 - 30 x^2 + 35 x^4");}
@Test public void testLegendreDifferentials(){for (int k=0;k < 12;++k){PolynomialFunction Pk0=PolynomialsUtils.createLegendrePolynomial(k);PolynomialFunction Pk1=Pk0.polynomialDerivative();PolynomialFunction Pk2=Pk1.polynomialDerivative();PolynomialFunction g0=new PolynomialFunction(new double[]{k * (k + 1)});PolynomialFunction g1=new PolynomialFunction(new double[]{0,-2});PolynomialFunction g2=new PolynomialFunction(new double[]{1,0,-1});PolynomialFunction Pk0g0=Pk0.multiply(g0);PolynomialFunction Pk1g1=Pk1.multiply(g1);PolynomialFunction Pk2g2=Pk2.multiply(g2);checkNullPolynomial(Pk0g0.add(Pk1g1.add(Pk2g2)));}}
@Test public void testLegendreOrthogonality(){UnivariateFunction weight=new UnivariateFunction(){public double value(double x){return 1;}};for (int i=0;i < 10;++i){PolynomialFunction pi=PolynomialsUtils.createLegendrePolynomial(i);for (int j=0;j <= i;++j){PolynomialFunction pj=PolynomialsUtils.createLegendrePolynomial(j);checkOrthogonality(pi,pj,weight,-1,1,0.1,1.0e-13);}}}
@Test public void testHighDegreeLegendre(){PolynomialsUtils.createLegendrePolynomial(40);double[]l40=PolynomialsUtils.createLegendrePolynomial(40).getCoefficients();double denominator=274877906944d;double[]numerators=new double[]{+34461632205d,-28258538408100d,+3847870979902950d,-207785032914759300d,+5929294332103310025d,-103301483474866556880d,+1197358103913226000200d,-9763073770369381232400d,+58171647881784229843050d,-260061484647976556945400d,+888315281771246239250340d,-2345767627188139419665400d,+4819022625419112503443050d,-7710436200670580005508880d,+9566652323054238154983240d,-9104813935044723209570256d,+6516550296251767619752905d,-3391858621221953912598660d,+1211378079007840683070950d,-265365894974690562152100d,+26876802183334044115405d};for (int i=0;i < l40.length;++i){if (i % 2 == 0){double ci=numerators[i / 2]/ denominator;Assert.assertEquals(ci,l40[i],FastMath.abs(ci)* 1e-15);}else {Assert.assertEquals(0,l40[i],0);}}}
@Test public void testJacobiLegendre(){for (int i=0;i < 10;++i){PolynomialFunction legendre=PolynomialsUtils.createLegendrePolynomial(i);PolynomialFunction jacobi=PolynomialsUtils.createJacobiPolynomial(i,0,0);checkNullPolynomial(legendre.subtract(jacobi));}}
@Test public void testJacobiEvaluationAt1(){for (int v=0;v < 10;++v){for (int w=0;w < 10;++w){for (int i=0;i < 10;++i){PolynomialFunction jacobi=PolynomialsUtils.createJacobiPolynomial(i,v,w);double binomial=ArithmeticUtils.binomialCoefficient(v + i,i);Assert.assertTrue(Precision.equals(binomial,jacobi.value(1.0),1));}}}}
@Test public void testJacobiOrthogonality(){for (int v=0;v < 5;++v){for (int w=v;w < 5;++w){final int vv=v;final int ww=w;UnivariateFunction weight=new UnivariateFunction(){public double value(double x){return FastMath.pow(1 - x,vv)* FastMath.pow(1 + x,ww);}};for (int i=0;i < 10;++i){PolynomialFunction pi=PolynomialsUtils.createJacobiPolynomial(i,v,w);for (int j=0;j <= i;++j){PolynomialFunction pj=PolynomialsUtils.createJacobiPolynomial(j,v,w);checkOrthogonality(pi,pj,weight,-1,1,0.1,1.0e-12);}}}}}
@Test public void testShift(){PolynomialFunction f1x=new PolynomialFunction(new double[]{1,1,2});PolynomialFunction f1x1=new PolynomialFunction(PolynomialsUtils.shift(f1x.getCoefficients(),1));checkPolynomial(f1x1,"4 + 5 x + 2 x^2");PolynomialFunction f1xM1=new PolynomialFunction(PolynomialsUtils.shift(f1x.getCoefficients(),-1));checkPolynomial(f1xM1,"2 - 3 x + 2 x^2");PolynomialFunction f1x3=new PolynomialFunction(PolynomialsUtils.shift(f1x.getCoefficients(),3));checkPolynomial(f1x3,"22 + 13 x + 2 x^2");PolynomialFunction f2x=new PolynomialFunction(new double[]{2,0,3,8,0,121});PolynomialFunction f2x1=new PolynomialFunction(PolynomialsUtils.shift(f2x.getCoefficients(),1));checkPolynomial(f2x1,"134 + 635 x + 1237 x^2 + 1218 x^3 + 605 x^4 + 121 x^5");PolynomialFunction f2x3=new PolynomialFunction(PolynomialsUtils.shift(f2x.getCoefficients(),3));checkPolynomial(f2x3,"29648 + 49239 x + 32745 x^2 + 10898 x^3 + 1815 x^4 + 121 x^5");}
/** * Verifies that increment()and incrementAll work properly.*/@Test public void testIncrementation()throws Exception {StorelessUnivariateStatistic statistic=(StorelessUnivariateStatistic)getUnivariateStatistic();for (int i=0;i < testArray.length;i++){statistic.increment(testArray[i]);}Assert.assertEquals(expectedValue(),statistic.getResult(),getTolerance());Assert.assertEquals(testArray.length,statistic.getN());statistic.clear();statistic.incrementAll(testArray);Assert.assertEquals(expectedValue(),statistic.getResult(),getTolerance());Assert.assertEquals(testArray.length,statistic.getN());statistic.clear();checkClearValue(statistic);Assert.assertEquals(0,statistic.getN());}
@Test public void testSerialization()throws Exception {StorelessUnivariateStatistic statistic=(StorelessUnivariateStatistic)getUnivariateStatistic();TestUtils.checkSerializedEquality(statistic);statistic.clear();for (int i=0;i < testArray.length;i++){statistic.increment(testArray[i]);if (i % 5 == 0)statistic=(StorelessUnivariateStatistic)TestUtils.serializeAndRecover(statistic);}TestUtils.checkSerializedEquality(statistic);Assert.assertEquals(expectedValue(),statistic.getResult(),getTolerance());statistic.clear();checkClearValue(statistic);}
@Test public void testEqualsAndHashCode(){StorelessUnivariateStatistic statistic=(StorelessUnivariateStatistic)getUnivariateStatistic();StorelessUnivariateStatistic statistic2=null;Assert.assertTrue("non-null,compared to null",!statistic.equals(statistic2));Assert.assertTrue("reflexive,non-null",statistic.equals(statistic));int emptyHash=statistic.hashCode();statistic2=(StorelessUnivariateStatistic)getUnivariateStatistic();Assert.assertTrue("empty stats should be equal",statistic.equals(statistic2));Assert.assertEquals("empty stats should have the same hashcode",emptyHash,statistic2.hashCode());statistic.increment(1d);Assert.assertTrue("reflexive,non-empty",statistic.equals(statistic));Assert.assertTrue("non-empty,compared to empty",!statistic.equals(statistic2));Assert.assertTrue("non-empty,compared to empty",!statistic2.equals(statistic));Assert.assertTrue("non-empty stat should have different hashcode from empty stat",statistic.hashCode()!= emptyHash);statistic2.increment(1d);Assert.assertTrue("stats with same data should be equal",statistic.equals(statistic2));Assert.assertEquals("stats with same data should have the same hashcode",statistic.hashCode(),statistic2.hashCode());statistic.increment(Double.POSITIVE_INFINITY);Assert.assertTrue("stats with different n's should not be equal",!statistic2.equals(statistic));Assert.assertTrue("stats with different n's should have different hashcodes",statistic.hashCode()!= statistic2.hashCode());statistic2.increment(Double.POSITIVE_INFINITY);Assert.assertTrue("stats with same data should be equal",statistic.equals(statistic2));Assert.assertEquals("stats with same data should have the same hashcode",statistic.hashCode(),statistic2.hashCode());statistic.clear();statistic2.clear();Assert.assertTrue("cleared stats should be equal",statistic.equals(statistic2));Assert.assertEquals("cleared stats should have thashcode of empty stat",emptyHash,statistic2.hashCode());Assert.assertEquals("cleared stats should have thashcode of empty stat",emptyHash,statistic.hashCode());}
@Test public void testMomentSmallSamples(){UnivariateStatistic stat=getUnivariateStatistic();if (stat instanceof SecondMoment){SecondMoment moment=(SecondMoment)getUnivariateStatistic();Assert.assertTrue(Double.isNaN(moment.getResult()));moment.increment(1d);Assert.assertEquals(0d,moment.getResult(),0);}}
/** * Make sure that evaluate(double[])and inrementAll(double[]),getResult()give same results.*/@Test public void testConsistency(){StorelessUnivariateStatistic stat=(StorelessUnivariateStatistic)getUnivariateStatistic();stat.incrementAll(testArray);Assert.assertEquals(stat.getResult(),stat.evaluate(testArray),getTolerance());for (int i=0;i < smallSamples.length;i++){stat.clear();for (int j=0;j < smallSamples[i].length;j++){stat.increment(smallSamples[i][j]);}TestUtils.assertEquals(stat.getResult(),stat.evaluate(smallSamples[i]),getTolerance());}}
/** * Verifies that copied statistics remain equal to originals when incremented the same way.*/@Test public void testCopyConsistency(){StorelessUnivariateStatistic master=(StorelessUnivariateStatistic)getUnivariateStatistic();StorelessUnivariateStatistic replica=null;long index=FastMath.round((FastMath.random())* testArray.length);master.incrementAll(testArray,0,(int)index);replica=master.copy();Assert.assertTrue(replica.equals(master));Assert.assertTrue(master.equals(replica));master.incrementAll(testArray,(int)index,(int)(testArray.length - index));replica.incrementAll(testArray,(int)index,(int)(testArray.length - index));Assert.assertTrue(replica.equals(master));Assert.assertTrue(master.equals(replica));}
@Test public void testSerial(){StorelessUnivariateStatistic s=(StorelessUnivariateStatistic)getUnivariateStatistic();Assert.assertEquals(s,TestUtils.serializeAndRecover(s));}
@Test public void testEvaluation()throws Exception {Assert.assertEquals(expectedValue(),getUnivariateStatistic().evaluate(testArray),getTolerance());}
@Test public void testEvaluateArraySegment(){final UnivariateStatistic stat=getUnivariateStatistic();final double[]arrayZero=new double[5];System.arraycopy(testArray,0,arrayZero,0,5);Assert.assertEquals(stat.evaluate(arrayZero),stat.evaluate(testArray,0,5),0);final double[]arrayOne=new double[5];System.arraycopy(testArray,5,arrayOne,0,5);Assert.assertEquals(stat.evaluate(arrayOne),stat.evaluate(testArray,5,5),0);final double[]arrayEnd=new double[5];System.arraycopy(testArray,testArray.length - 5,arrayEnd,0,5);Assert.assertEquals(stat.evaluate(arrayEnd),stat.evaluate(testArray,testArray.length - 5,5),0);}
@Test public void testEvaluateArraySegmentWeighted(){UnivariateStatistic statistic=getUnivariateStatistic();if (!(statistic instanceof WeightedEvaluation)){return;}final WeightedEvaluation stat=(WeightedEvaluation)getUnivariateStatistic();final double[]arrayZero=new double[5];final double[]weightZero=new double[5];System.arraycopy(testArray,0,arrayZero,0,5);System.arraycopy(testWeightsArray,0,weightZero,0,5);Assert.assertEquals(stat.evaluate(arrayZero,weightZero),stat.evaluate(testArray,testWeightsArray,0,5),0);final double[]arrayOne=new double[5];final double[]weightOne=new double[5];System.arraycopy(testArray,5,arrayOne,0,5);System.arraycopy(testWeightsArray,5,weightOne,0,5);Assert.assertEquals(stat.evaluate(arrayOne,weightOne),stat.evaluate(testArray,testWeightsArray,5,5),0);final double[]arrayEnd=new double[5];final double[]weightEnd=new double[5];System.arraycopy(testArray,testArray.length - 5,arrayEnd,0,5);System.arraycopy(testWeightsArray,testArray.length - 5,weightEnd,0,5);Assert.assertEquals(stat.evaluate(arrayEnd,weightEnd),stat.evaluate(testArray,testWeightsArray,testArray.length - 5,5),0);}
@Test public void testCopy()throws Exception {UnivariateStatistic original=getUnivariateStatistic();UnivariateStatistic copy=original.copy();Assert.assertEquals(expectedValue(),copy.evaluate(testArray),getTolerance());}
/** * Tests consistency of weighted statistic computation. For statistics that support weighted evaluation,this test case compares the result of direct computation on an array with repeated values with a weighted computation on the corresponding (shorter)array with each value appearing only once but with a weight value equal to its multiplicity in the repeating array.*/@Test public void testWeightedConsistency()throws Exception {UnivariateStatistic statistic=getUnivariateStatistic();if (!(statistic instanceof WeightedEvaluation)){return;}final int len=10;final double mu=0;final double sigma=5;double[]values=new double[len];double[]weights=new double[len];RandomData randomData=new RandomDataImpl();int[]intWeights=new int[len];for (int i=0;i < len;i++){intWeights[i]=randomData.nextInt(1,5);weights[i]=intWeights[i];}List<Double> valuesList=new ArrayList<Double>();for (int i=0;i < len;i++){double value=randomData.nextGaussian(mu,sigma);values[i]=value;for (int j=0;j < intWeights[i];j++){valuesList.add(new Double(value));}}int sumWeights=valuesList.size();double[]repeatedValues=new double[sumWeights];for (int i=0;i < sumWeights;i++){repeatedValues[i]=valuesList.get(i);}WeightedEvaluation weightedStatistic=(WeightedEvaluation)statistic;TestUtils.assertRelativelyEquals(statistic.evaluate(repeatedValues),weightedStatistic.evaluate(values,weights,0,values.length),10E-14);Assert.assertEquals(weightedStatistic.evaluate(values,weights,0,values.length),weightedStatistic.evaluate(values,weights),Double.MIN_VALUE);}
@Test public void testSpecialValues(){SumOfSquares sumSq=new SumOfSquares();Assert.assertEquals(0,sumSq.getResult(),0);sumSq.increment(2d);Assert.assertEquals(4d,sumSq.getResult(),0);sumSq.increment(Double.POSITIVE_INFINITY);Assert.assertEquals(Double.POSITIVE_INFINITY,sumSq.getResult(),0);sumSq.increment(Double.NEGATIVE_INFINITY);Assert.assertEquals(Double.POSITIVE_INFINITY,sumSq.getResult(),0);sumSq.increment(Double.NaN);Assert.assertTrue(Double.isNaN(sumSq.getResult()));sumSq.increment(1);Assert.assertTrue(Double.isNaN(sumSq.getResult()));}
/** * Verifies that increment()and incrementAll work properly.*/@Test public void testIncrementation()throws Exception {StorelessUnivariateStatistic statistic=(StorelessUnivariateStatistic)getUnivariateStatistic();for (int i=0;i < testArray.length;i++){statistic.increment(testArray[i]);}Assert.assertEquals(expectedValue(),statistic.getResult(),getTolerance());Assert.assertEquals(testArray.length,statistic.getN());statistic.clear();statistic.incrementAll(testArray);Assert.assertEquals(expectedValue(),statistic.getResult(),getTolerance());Assert.assertEquals(testArray.length,statistic.getN());statistic.clear();checkClearValue(statistic);Assert.assertEquals(0,statistic.getN());}
@Test public void testSerialization()throws Exception {StorelessUnivariateStatistic statistic=(StorelessUnivariateStatistic)getUnivariateStatistic();TestUtils.checkSerializedEquality(statistic);statistic.clear();for (int i=0;i < testArray.length;i++){statistic.increment(testArray[i]);if (i % 5 == 0)statistic=(StorelessUnivariateStatistic)TestUtils.serializeAndRecover(statistic);}TestUtils.checkSerializedEquality(statistic);Assert.assertEquals(expectedValue(),statistic.getResult(),getTolerance());statistic.clear();checkClearValue(statistic);}
@Test public void testEqualsAndHashCode(){StorelessUnivariateStatistic statistic=(StorelessUnivariateStatistic)getUnivariateStatistic();StorelessUnivariateStatistic statistic2=null;Assert.assertTrue("non-null,compared to null",!statistic.equals(statistic2));Assert.assertTrue("reflexive,non-null",statistic.equals(statistic));int emptyHash=statistic.hashCode();statistic2=(StorelessUnivariateStatistic)getUnivariateStatistic();Assert.assertTrue("empty stats should be equal",statistic.equals(statistic2));Assert.assertEquals("empty stats should have the same hashcode",emptyHash,statistic2.hashCode());statistic.increment(1d);Assert.assertTrue("reflexive,non-empty",statistic.equals(statistic));Assert.assertTrue("non-empty,compared to empty",!statistic.equals(statistic2));Assert.assertTrue("non-empty,compared to empty",!statistic2.equals(statistic));Assert.assertTrue("non-empty stat should have different hashcode from empty stat",statistic.hashCode()!= emptyHash);statistic2.increment(1d);Assert.assertTrue("stats with same data should be equal",statistic.equals(statistic2));Assert.assertEquals("stats with same data should have the same hashcode",statistic.hashCode(),statistic2.hashCode());statistic.increment(Double.POSITIVE_INFINITY);Assert.assertTrue("stats with different n's should not be equal",!statistic2.equals(statistic));Assert.assertTrue("stats with different n's should have different hashcodes",statistic.hashCode()!= statistic2.hashCode());statistic2.increment(Double.POSITIVE_INFINITY);Assert.assertTrue("stats with same data should be equal",statistic.equals(statistic2));Assert.assertEquals("stats with same data should have the same hashcode",statistic.hashCode(),statistic2.hashCode());statistic.clear();statistic2.clear();Assert.assertTrue("cleared stats should be equal",statistic.equals(statistic2));Assert.assertEquals("cleared stats should have thashcode of empty stat",emptyHash,statistic2.hashCode());Assert.assertEquals("cleared stats should have thashcode of empty stat",emptyHash,statistic.hashCode());}
@Test public void testMomentSmallSamples(){UnivariateStatistic stat=getUnivariateStatistic();if (stat instanceof SecondMoment){SecondMoment moment=(SecondMoment)getUnivariateStatistic();Assert.assertTrue(Double.isNaN(moment.getResult()));moment.increment(1d);Assert.assertEquals(0d,moment.getResult(),0);}}
/** * Make sure that evaluate(double[])and inrementAll(double[]),getResult()give same results.*/@Test public void testConsistency(){StorelessUnivariateStatistic stat=(StorelessUnivariateStatistic)getUnivariateStatistic();stat.incrementAll(testArray);Assert.assertEquals(stat.getResult(),stat.evaluate(testArray),getTolerance());for (int i=0;i < smallSamples.length;i++){stat.clear();for (int j=0;j < smallSamples[i].length;j++){stat.increment(smallSamples[i][j]);}TestUtils.assertEquals(stat.getResult(),stat.evaluate(smallSamples[i]),getTolerance());}}
/** * Verifies that copied statistics remain equal to originals when incremented the same way.*/@Test public void testCopyConsistency(){StorelessUnivariateStatistic master=(StorelessUnivariateStatistic)getUnivariateStatistic();StorelessUnivariateStatistic replica=null;long index=FastMath.round((FastMath.random())* testArray.length);master.incrementAll(testArray,0,(int)index);replica=master.copy();Assert.assertTrue(replica.equals(master));Assert.assertTrue(master.equals(replica));master.incrementAll(testArray,(int)index,(int)(testArray.length - index));replica.incrementAll(testArray,(int)index,(int)(testArray.length - index));Assert.assertTrue(replica.equals(master));Assert.assertTrue(master.equals(replica));}
@Test public void testSerial(){StorelessUnivariateStatistic s=(StorelessUnivariateStatistic)getUnivariateStatistic();Assert.assertEquals(s,TestUtils.serializeAndRecover(s));}
@Test public void testEvaluation()throws Exception {Assert.assertEquals(expectedValue(),getUnivariateStatistic().evaluate(testArray),getTolerance());}
@Test public void testEvaluateArraySegment(){final UnivariateStatistic stat=getUnivariateStatistic();final double[]arrayZero=new double[5];System.arraycopy(testArray,0,arrayZero,0,5);Assert.assertEquals(stat.evaluate(arrayZero),stat.evaluate(testArray,0,5),0);final double[]arrayOne=new double[5];System.arraycopy(testArray,5,arrayOne,0,5);Assert.assertEquals(stat.evaluate(arrayOne),stat.evaluate(testArray,5,5),0);final double[]arrayEnd=new double[5];System.arraycopy(testArray,testArray.length - 5,arrayEnd,0,5);Assert.assertEquals(stat.evaluate(arrayEnd),stat.evaluate(testArray,testArray.length - 5,5),0);}
@Test public void testEvaluateArraySegmentWeighted(){UnivariateStatistic statistic=getUnivariateStatistic();if (!(statistic instanceof WeightedEvaluation)){return;}final WeightedEvaluation stat=(WeightedEvaluation)getUnivariateStatistic();final double[]arrayZero=new double[5];final double[]weightZero=new double[5];System.arraycopy(testArray,0,arrayZero,0,5);System.arraycopy(testWeightsArray,0,weightZero,0,5);Assert.assertEquals(stat.evaluate(arrayZero,weightZero),stat.evaluate(testArray,testWeightsArray,0,5),0);final double[]arrayOne=new double[5];final double[]weightOne=new double[5];System.arraycopy(testArray,5,arrayOne,0,5);System.arraycopy(testWeightsArray,5,weightOne,0,5);Assert.assertEquals(stat.evaluate(arrayOne,weightOne),stat.evaluate(testArray,testWeightsArray,5,5),0);final double[]arrayEnd=new double[5];final double[]weightEnd=new double[5];System.arraycopy(testArray,testArray.length - 5,arrayEnd,0,5);System.arraycopy(testWeightsArray,testArray.length - 5,weightEnd,0,5);Assert.assertEquals(stat.evaluate(arrayEnd,weightEnd),stat.evaluate(testArray,testWeightsArray,testArray.length - 5,5),0);}
@Test public void testCopy()throws Exception {UnivariateStatistic original=getUnivariateStatistic();UnivariateStatistic copy=original.copy();Assert.assertEquals(expectedValue(),copy.evaluate(testArray),getTolerance());}
/** * Tests consistency of weighted statistic computation. For statistics that support weighted evaluation,this test case compares the result of direct computation on an array with repeated values with a weighted computation on the corresponding (shorter)array with each value appearing only once but with a weight value equal to its multiplicity in the repeating array.*/@Test public void testWeightedConsistency()throws Exception {UnivariateStatistic statistic=getUnivariateStatistic();if (!(statistic instanceof WeightedEvaluation)){return;}final int len=10;final double mu=0;final double sigma=5;double[]values=new double[len];double[]weights=new double[len];RandomData randomData=new RandomDataImpl();int[]intWeights=new int[len];for (int i=0;i < len;i++){intWeights[i]=randomData.nextInt(1,5);weights[i]=intWeights[i];}List<Double> valuesList=new ArrayList<Double>();for (int i=0;i < len;i++){double value=randomData.nextGaussian(mu,sigma);values[i]=value;for (int j=0;j < intWeights[i];j++){valuesList.add(new Double(value));}}int sumWeights=valuesList.size();double[]repeatedValues=new double[sumWeights];for (int i=0;i < sumWeights;i++){repeatedValues[i]=valuesList.get(i);}WeightedEvaluation weightedStatistic=(WeightedEvaluation)statistic;TestUtils.assertRelativelyEquals(statistic.evaluate(repeatedValues),weightedStatistic.evaluate(values,weights,0,values.length),10E-14);Assert.assertEquals(weightedStatistic.evaluate(values,weights,0,values.length),weightedStatistic.evaluate(values,weights),Double.MIN_VALUE);}
@Test public void testMannWhitneyUSimple()throws Exception {final double x[]={19,22,16,29,24};final double y[]={20,11,17,12};Assert.assertEquals(17,testStatistic.mannWhitneyU(x,y),1e-10);Assert.assertEquals(0.08641,testStatistic.mannWhitneyUTest(x,y),1e-5);}
@Test public void testMannWhitneyUInputValidation()throws Exception {try {testStatistic.mannWhitneyUTest(new double[]{},new double[]{1.0});Assert.fail("x does not contain samples (exact),IllegalArgumentException expected");}catch(IllegalArgumentException ex){}try {testStatistic.mannWhitneyUTest(new double[]{1.0},new double[]{});Assert.fail("y does not contain samples (exact),IllegalArgumentException expected");}catch(IllegalArgumentException ex){}try {testStatistic.mannWhitneyUTest(null,null);Assert.fail("x and y is null (exact),IllegalArgumentException expected");}catch(IllegalArgumentException ex){}try {testStatistic.mannWhitneyUTest(null,null);Assert.fail("x and y is null (asymptotic),IllegalArgumentException expected");}catch(IllegalArgumentException ex){}try {testStatistic.mannWhitneyUTest(null,new double[]{1.0});Assert.fail("x is null (exact),IllegalArgumentException expected");}catch(IllegalArgumentException ex){}try {testStatistic.mannWhitneyUTest(new double[]{1.0},null);Assert.fail("y is null (exact),IllegalArgumentException expected");}catch(IllegalArgumentException ex){}}
@Test public void testCreateRealMatrix(){Assert.assertEquals(new BlockRealMatrix(testData),MatrixUtils.createRealMatrix(testData));try {MatrixUtils.createRealMatrix(new double[][]{{1},{1,2}});Assert.fail("Expecting MathIllegalArgumentException");}catch(MathIllegalArgumentException ex){}try {MatrixUtils.createRealMatrix(new double[][]{{},{}});Assert.fail("Expecting MathIllegalArgumentException");}catch(MathIllegalArgumentException ex){}try {MatrixUtils.createRealMatrix(null);Assert.fail("Expecting NullArgumentException");}catch(NullArgumentException ex){}}
@Test public void testcreateFieldMatrix(){Assert.assertEquals(new Array2DRowFieldMatrix<Fraction>(asFraction(testData)),MatrixUtils.createFieldMatrix(asFraction(testData)));Assert.assertEquals(new Array2DRowFieldMatrix<Fraction>(FractionField.getInstance(),fractionColMatrix),MatrixUtils.createFieldMatrix(fractionColMatrix));try {MatrixUtils.createFieldMatrix(asFraction(new double[][]{{1},{1,2}}));Assert.fail("Expecting MathIllegalArgumentException");}catch(MathIllegalArgumentException ex){}try {MatrixUtils.createFieldMatrix(asFraction(new double[][]{{},{}}));Assert.fail("Expecting MathIllegalArgumentException");}catch(MathIllegalArgumentException ex){}try {MatrixUtils.createFieldMatrix((Fraction[][])null);Assert.fail("Expecting NullArgumentException");}catch(NullArgumentException ex){}}
@Test public void testCreateRowRealMatrix(){Assert.assertEquals(MatrixUtils.createRowRealMatrix(row),new BlockRealMatrix(rowMatrix));try {MatrixUtils.createRowRealMatrix(new double[]{});Assert.fail("Expecting NotStrictlyPositiveException");}catch(NotStrictlyPositiveException ex){}try {MatrixUtils.createRowRealMatrix(null);Assert.fail("Expecting NullArgumentException");}catch(NullArgumentException ex){}}
@Test public void testCreateRowFieldMatrix(){Assert.assertEquals(MatrixUtils.createRowFieldMatrix(asFraction(row)),new Array2DRowFieldMatrix<Fraction>(asFraction(rowMatrix)));Assert.assertEquals(MatrixUtils.createRowFieldMatrix(fractionRow),new Array2DRowFieldMatrix<Fraction>(fractionRowMatrix));try {MatrixUtils.createRowFieldMatrix(new Fraction[]{});Assert.fail("Expecting MathIllegalArgumentException");}catch(MathIllegalArgumentException ex){}try {MatrixUtils.createRowFieldMatrix((Fraction[])null);Assert.fail("Expecting NullArgumentException");}catch(NullArgumentException ex){}}
@Test public void testCreateColumnRealMatrix(){Assert.assertEquals(MatrixUtils.createColumnRealMatrix(col),new BlockRealMatrix(colMatrix));try {MatrixUtils.createColumnRealMatrix(new double[]{});Assert.fail("Expecting MathIllegalArgumentException");}catch(MathIllegalArgumentException ex){}try {MatrixUtils.createColumnRealMatrix(null);Assert.fail("Expecting NullArgumentException");}catch(NullArgumentException ex){}}
@Test public void testCreateColumnFieldMatrix(){Assert.assertEquals(MatrixUtils.createColumnFieldMatrix(asFraction(col)),new Array2DRowFieldMatrix<Fraction>(asFraction(colMatrix)));Assert.assertEquals(MatrixUtils.createColumnFieldMatrix(fractionCol),new Array2DRowFieldMatrix<Fraction>(fractionColMatrix));try {MatrixUtils.createColumnFieldMatrix(new Fraction[]{});Assert.fail("Expecting MathIllegalArgumentException");}catch(MathIllegalArgumentException ex){}try {MatrixUtils.createColumnFieldMatrix((Fraction[])null);Assert.fail("Expecting NullArgumentException");}catch(NullArgumentException ex){}}
@Test public void testCreateIdentityMatrix(){checkIdentityMatrix(MatrixUtils.createRealIdentityMatrix(3));checkIdentityMatrix(MatrixUtils.createRealIdentityMatrix(2));checkIdentityMatrix(MatrixUtils.createRealIdentityMatrix(1));try {MatrixUtils.createRealIdentityMatrix(0);Assert.fail("Expecting MathIllegalArgumentException");}catch(MathIllegalArgumentException ex){}}
@Test public void testcreateFieldIdentityMatrix(){checkIdentityFieldMatrix(MatrixUtils.createFieldIdentityMatrix(FractionField.getInstance(),3));checkIdentityFieldMatrix(MatrixUtils.createFieldIdentityMatrix(FractionField.getInstance(),2));checkIdentityFieldMatrix(MatrixUtils.createFieldIdentityMatrix(FractionField.getInstance(),1));try {MatrixUtils.createRealIdentityMatrix(0);Assert.fail("Expecting MathIllegalArgumentException");}catch(MathIllegalArgumentException ex){}}
@Test public void testBigFractionConverter(){BigFraction[][]bfData={{new BigFraction(1),new BigFraction(2),new BigFraction(3)},{new BigFraction(2),new BigFraction(5),new BigFraction(3)},{new BigFraction(1),new BigFraction(0),new BigFraction(8)}};FieldMatrix<BigFraction> m=new Array2DRowFieldMatrix<BigFraction>(bfData,false);RealMatrix converted=MatrixUtils.bigFractionMatrixToRealMatrix(m);RealMatrix reference=new Array2DRowRealMatrix(testData,false);Assert.assertEquals(0.0,converted.subtract(reference).getNorm(),0.0);}
@Test public void testFractionConverter(){Fraction[][]fData={{new Fraction(1),new Fraction(2),new Fraction(3)},{new Fraction(2),new Fraction(5),new Fraction(3)},{new Fraction(1),new Fraction(0),new Fraction(8)}};FieldMatrix<Fraction> m=new Array2DRowFieldMatrix<Fraction>(fData,false);RealMatrix converted=MatrixUtils.fractionMatrixToRealMatrix(m);RealMatrix reference=new Array2DRowRealMatrix(testData,false);Assert.assertEquals(0.0,converted.subtract(reference).getNorm(),0.0);}
@Test public void testSolveLowerTriangularSystem(){RealMatrix rm=new Array2DRowRealMatrix(new double[][]{{2,0,0,0},{1,1,0,0},{3,3,3,0},{3,3,3,4}},false);RealVector b=new ArrayRealVector(new double[]{2,3,4,8},false);MatrixUtils.solveLowerTriangularSystem(rm,b);TestUtils.assertEquals(new double[]{1,2,-1.66666666666667,1.0},b.toArray(),1.0e-12);}
@Test public void testSolveUpperTriangularSystem(){RealMatrix rm=new Array2DRowRealMatrix(new double[][]{{1,2,3},{0,1,1},{0,0,2}},false);RealVector b=new ArrayRealVector(new double[]{8,4,2},false);MatrixUtils.solveUpperTriangularSystem(rm,b);TestUtils.assertEquals(new double[]{-1,3,1},b.toArray(),1.0e-12);}
@Test public void testGoldenRatio()throws Exception {ContinuedFraction cf=new ContinuedFraction(){@Override public double getA(int n,double x){return 1.0;}@Override public double getB(int n,double x){return 1.0;}};double gr=cf.evaluate(0.0,10e-9);Assert.assertEquals(1.61803399,gr,10e-9);}
@Test public void testWilcoxonSignedRankSimple()throws Exception {final double x[]={1.83,0.50,1.62,2.48,1.68,1.88,1.55,3.06,1.30};final double y[]={0.878,0.647,0.598,2.05,1.06,1.29,1.06,3.14,1.29};Assert.assertEquals(40,testStatistic.wilcoxonSignedRank(x,y),1e-10);Assert.assertEquals(0.03906,testStatistic.wilcoxonSignedRankTest(x,y,true),1e-5);Assert.assertEquals(40,testStatistic.wilcoxonSignedRank(x,y),1e-10);Assert.assertEquals(0.0329693812,testStatistic.wilcoxonSignedRankTest(x,y,false),1e-10);}
@Test public void testWilcoxonSignedRankInputValidation()throws Exception {final double[]x1=new double[30];final double[]x2=new double[31];final double[]y1=new double[30];final double[]y2=new double[31];for (int i=0;i < 30;++i){x1[i]=x2[i]=y1[i]=y2[i]=i;}try {testStatistic.wilcoxonSignedRankTest(x2,y2,true);Assert.fail("More than 30 samples and exact chosen,IllegalArgumentException expected");}catch(IllegalArgumentException ex){}try {testStatistic.wilcoxonSignedRankTest(new double[]{},new double[]{1.0},true);Assert.fail("x does not contain samples (exact),IllegalArgumentException expected");}catch(IllegalArgumentException ex){}try {testStatistic.wilcoxonSignedRankTest(new double[]{},new double[]{1.0},false);Assert.fail("x does not contain samples (asymptotic),IllegalArgumentException expected");}catch(IllegalArgumentException ex){}try {testStatistic.wilcoxonSignedRankTest(new double[]{1.0},new double[]{},true);Assert.fail("y does not contain samples (exact),IllegalArgumentException expected");}catch(IllegalArgumentException ex){}try {testStatistic.wilcoxonSignedRankTest(new double[]{1.0},new double[]{},false);Assert.fail("y does not contain samples (asymptotic),IllegalArgumentException expected");}catch(IllegalArgumentException ex){}try {testStatistic.wilcoxonSignedRankTest(new double[]{1.0,2.0},new double[]{3.0},true);Assert.fail("x and y not same size (exact),IllegalArgumentException expected");}catch(IllegalArgumentException ex){}try {testStatistic.wilcoxonSignedRankTest(new double[]{1.0,2.0},new double[]{3.0},false);Assert.fail("x and y not same size (asymptotic),IllegalArgumentException expected");}catch(IllegalArgumentException ex){}try {testStatistic.wilcoxonSignedRankTest(null,null,true);Assert.fail("x and y is null (exact),IllegalArgumentException expected");}catch(IllegalArgumentException ex){}try {testStatistic.wilcoxonSignedRankTest(null,null,false);Assert.fail("x and y is null (asymptotic),IllegalArgumentException expected");}catch(IllegalArgumentException ex){}try {testStatistic.wilcoxonSignedRankTest(null,new double[]{1.0},true);Assert.fail("x is null (exact),IllegalArgumentException expected");}catch(IllegalArgumentException ex){}try {testStatistic.wilcoxonSignedRankTest(null,new double[]{1.0},false);Assert.fail("x is null (asymptotic),IllegalArgumentException expected");}catch(IllegalArgumentException ex){}try {testStatistic.wilcoxonSignedRankTest(new double[]{1.0},null,true);Assert.fail("y is null (exact),IllegalArgumentException expected");}catch(IllegalArgumentException ex){}try {testStatistic.wilcoxonSignedRankTest(new double[]{1.0},null,false);Assert.fail("y is null (asymptotic),IllegalArgumentException expected");}catch(IllegalArgumentException ex){}}
@Test public void derivativesConsistency(){TestProblem3 pb=new TestProblem3();double step=(pb.getFinalTime()- pb.getInitialTime())* 0.001;ClassicalRungeKuttaIntegrator integ=new ClassicalRungeKuttaIntegrator(step);StepInterpolatorTestUtils.checkDerivativesConsistency(integ,pb,1.0e-10);}
@Test public void serialization()throws IOException,ClassNotFoundException {TestProblem3 pb=new TestProblem3(0.9);double step=(pb.getFinalTime()- pb.getInitialTime())* 0.0003;ClassicalRungeKuttaIntegrator integ=new ClassicalRungeKuttaIntegrator(step);integ.addStepHandler(new ContinuousOutputModel());integ.integrate(pb,pb.getInitialTime(),pb.getInitialState(),pb.getFinalTime(),new double[pb.getDimension()]);ByteArrayOutputStream bos=new ByteArrayOutputStream();ObjectOutputStream oos=new ObjectOutputStream(bos);for(StepHandler handler : integ.getStepHandlers()){oos.writeObject(handler);}Assert.assertTrue(bos.size()> 880000);Assert.assertTrue(bos.size()< 900000);ByteArrayInputStream bis=new ByteArrayInputStream(bos.toByteArray());ObjectInputStream ois=new ObjectInputStream(bis);ContinuousOutputModel cm=(ContinuousOutputModel)ois.readObject();Random random=new Random(347588535632l);double maxError=0.0;for (int i=0;i < 1000;++i){double r=random.nextDouble();double time=r * pb.getInitialTime()+ (1.0 - r)* pb.getFinalTime();cm.setInterpolatedTime(time);double[]interpolatedY=cm.getInterpolatedState();double[]theoreticalY=pb.computeTheoreticalState(time);double dx=interpolatedY[0]- theoreticalY[0];double dy=interpolatedY[1]- theoreticalY[1];double error=dx * dx + dy * dy;if (error > maxError){maxError=error;}}Assert.assertTrue(maxError > 0.005);}
/** * Test of solver for the sine function.*/@Test public void testSinFunction(){UnivariateFunction f=new SinFunction();UnivariateRealSolver solver=new MullerSolver();double min,max,expected,result,tolerance;min=3.0;max=4.0;expected=FastMath.PI;tolerance=FastMath.max(solver.getAbsoluteAccuracy(),FastMath.abs(expected * solver.getRelativeAccuracy()));result=solver.solve(100,f,min,max);Assert.assertEquals(expected,result,tolerance);min=-1.0;max=1.5;expected=0.0;tolerance=FastMath.max(solver.getAbsoluteAccuracy(),FastMath.abs(expected * solver.getRelativeAccuracy()));result=solver.solve(100,f,min,max);Assert.assertEquals(expected,result,tolerance);}
/** * Test of solver for the quintic function.*/@Test public void testQuinticFunction(){UnivariateFunction f=new QuinticFunction();UnivariateRealSolver solver=new MullerSolver();double min,max,expected,result,tolerance;min=-0.4;max=0.2;expected=0.0;tolerance=FastMath.max(solver.getAbsoluteAccuracy(),FastMath.abs(expected * solver.getRelativeAccuracy()));result=solver.solve(100,f,min,max);Assert.assertEquals(expected,result,tolerance);min=0.75;max=1.5;expected=1.0;tolerance=FastMath.max(solver.getAbsoluteAccuracy(),FastMath.abs(expected * solver.getRelativeAccuracy()));result=solver.solve(100,f,min,max);Assert.assertEquals(expected,result,tolerance);min=-0.9;max=-0.2;expected=-0.5;tolerance=FastMath.max(solver.getAbsoluteAccuracy(),FastMath.abs(expected * solver.getRelativeAccuracy()));result=solver.solve(100,f,min,max);Assert.assertEquals(expected,result,tolerance);}
/** * Test of solver for the exponential function. <p> It takes 10 to 15 iterations for the last two tests to converge. In fact,if not for the bisection alternative,the solver would exceed the default maximal iteration of 100.*/@Test public void testExpm1Function(){UnivariateFunction f=new Expm1Function();UnivariateRealSolver solver=new MullerSolver();double min,max,expected,result,tolerance;min=-1.0;max=2.0;expected=0.0;tolerance=FastMath.max(solver.getAbsoluteAccuracy(),FastMath.abs(expected * solver.getRelativeAccuracy()));result=solver.solve(100,f,min,max);Assert.assertEquals(expected,result,tolerance);min=-20.0;max=10.0;expected=0.0;tolerance=FastMath.max(solver.getAbsoluteAccuracy(),FastMath.abs(expected * solver.getRelativeAccuracy()));result=solver.solve(100,f,min,max);Assert.assertEquals(expected,result,tolerance);min=-50.0;max=100.0;expected=0.0;tolerance=FastMath.max(solver.getAbsoluteAccuracy(),FastMath.abs(expected * solver.getRelativeAccuracy()));result=solver.solve(100,f,min,max);Assert.assertEquals(expected,result,tolerance);}
/** * Test of parameters for the solver.*/@Test public void testParameters()throws Exception {UnivariateFunction f=new SinFunction();UnivariateRealSolver solver=new MullerSolver();try {double root=solver.solve(100,f,1,-1);System.out.println("root=" + root);Assert.fail("Expecting NumberIsTooLargeException - bad interval");}catch(NumberIsTooLargeException ex){}try {solver.solve(100,f,2,3);Assert.fail("Expecting NoBracketingException - no bracketing");}catch(NoBracketingException ex){}}
@Test public void testPreconditions(){MultidimensionalCounter c;try {c=new MultidimensionalCounter(0,1);Assert.fail("NotStrictlyPositiveException expected");}catch(NotStrictlyPositiveException e){}try {c=new MultidimensionalCounter(2,0);Assert.fail("NotStrictlyPositiveException expected");}catch(NotStrictlyPositiveException e){}try {c=new MultidimensionalCounter(-1,1);Assert.fail("NotStrictlyPositiveException expected");}catch(NotStrictlyPositiveException e){}c=new MultidimensionalCounter(2,3);try {c.getCount(1,1,1);Assert.fail("DimensionMismatchException expected");}catch(DimensionMismatchException e){}try {c.getCount(3,1);Assert.fail("OutOfRangeException expected");}catch(OutOfRangeException e){}try {c.getCount(0,-1);Assert.fail("OutOfRangeException expected");}catch(OutOfRangeException e){}try {c.getCounts(-1);Assert.fail("OutOfRangeException expected");}catch(OutOfRangeException e){}try {c.getCounts(6);Assert.fail("OutOfRangeException expected");}catch(OutOfRangeException e){}}
@Test public void testIteratorPreconditions(){MultidimensionalCounter.Iterator iter=(new MultidimensionalCounter(2,3)).iterator();try {iter.getCount(-1);Assert.fail("IndexOutOfBoundsException expected");}catch(IndexOutOfBoundsException e){}try {iter.getCount(2);Assert.fail("IndexOutOfBoundsException expected");}catch(IndexOutOfBoundsException e){}}
@Test public void testMulti2UniConversion(){final MultidimensionalCounter c=new MultidimensionalCounter(2,4,5);Assert.assertEquals(c.getCount(1,2,3),33);}
@Test public void testAccessors(){final int[]originalSize=new int[]{2,6,5};final MultidimensionalCounter c=new MultidimensionalCounter(originalSize);final int nDim=c.getDimension();Assert.assertEquals(nDim,originalSize.length);final int[]size=c.getSizes();for (int i=0;i < nDim;i++){Assert.assertEquals(originalSize[i],size[i]);}}
@Test public void testIterationConsistency(){final MultidimensionalCounter c=new MultidimensionalCounter(2,3,4);final int[][]expected=new int[][]{{0,0,0},{0,0,1},{0,0,2},{0,0,3},{0,1,0},{0,1,1},{0,1,2},{0,1,3},{0,2,0},{0,2,1},{0,2,2},{0,2,3},{1,0,0},{1,0,1},{1,0,2},{1,0,3},{1,1,0},{1,1,1},{1,1,2},{1,1,3},{1,2,0},{1,2,1},{1,2,2},{1,2,3}};final int totalSize=c.getSize();final int nDim=c.getDimension();final MultidimensionalCounter.Iterator iter=c.iterator();for (int i=0;i < totalSize;i++){if (!iter.hasNext()){Assert.fail("Too short");}final int uniDimIndex=iter.next();Assert.assertEquals("Wrong iteration at " + i,i,uniDimIndex);for (int dimIndex=0;dimIndex < nDim;dimIndex++){Assert.assertEquals("Wrong multidimensional index for [" + i + "]["+ dimIndex+ "]",expected[i][dimIndex],iter.getCount(dimIndex));}Assert.assertEquals("Wrong unidimensional index for [" + i + "]",c.getCount(expected[i]),uniDimIndex);final int[]indices=c.getCounts(uniDimIndex);for (int dimIndex=0;dimIndex < nDim;dimIndex++){Assert.assertEquals("Wrong multidimensional index for [" + i + "]["+ dimIndex+ "]",expected[i][dimIndex],indices[dimIndex]);}}if (iter.hasNext()){Assert.fail("Too long");}}
/** * tests the value of a constant polynomial. <p>value of this is 2.5 everywhere.</p>*/@Test public void testConstants(){double[]c={2.5};PolynomialFunction f=new PolynomialFunction(c);Assert.assertEquals(f.value(0),c[0],tolerance);Assert.assertEquals(f.value(-1),c[0],tolerance);Assert.assertEquals(f.value(-123.5),c[0],tolerance);Assert.assertEquals(f.value(3),c[0],tolerance);Assert.assertEquals(f.value(456.89),c[0],tolerance);Assert.assertEquals(f.degree(),0);Assert.assertEquals(f.derivative().value(0),0,tolerance);Assert.assertEquals(f.polynomialDerivative().derivative().value(0),0,tolerance);}
/** * tests the value of a linear polynomial. <p>This will test the function f(x)= 3*x - 1.5</p> <p>This will have the values <tt>f(0)= -1.5,f(-1)= -4.5,f(-2.5)= -9,f(0.5)= 0,f(1.5)= 3</tt> and <tt>f(3)= 7.5</tt> </p>*/@Test public void testLinear(){double[]c={-1.5,3};PolynomialFunction f=new PolynomialFunction(c);Assert.assertEquals(f.value(0),c[0],tolerance);Assert.assertEquals(-4.5,f.value(-1),tolerance);Assert.assertEquals(-9,f.value(-2.5),tolerance);Assert.assertEquals(0,f.value(0.5),tolerance);Assert.assertEquals(3,f.value(1.5),tolerance);Assert.assertEquals(7.5,f.value(3),tolerance);Assert.assertEquals(f.degree(),1);Assert.assertEquals(f.polynomialDerivative().derivative().value(0),0,tolerance);}
/** * Tests a second order polynomial. <p> This will test the function f(x)= 2x^2 - 3x -2 = (2x+1)(x-2)</p>*/@Test public void testQuadratic(){double[]c={-2,-3,2};PolynomialFunction f=new PolynomialFunction(c);Assert.assertEquals(f.value(0),c[0],tolerance);Assert.assertEquals(0,f.value(-0.5),tolerance);Assert.assertEquals(0,f.value(2),tolerance);Assert.assertEquals(-2,f.value(1.5),tolerance);Assert.assertEquals(7,f.value(-1.5),tolerance);Assert.assertEquals(265.5312,f.value(12.34),tolerance);}
/** * This will test the quintic function f(x)= x^2(x-5)(x+3)(x-1)= x^5 - 3x^4 -13x^3 + 15x^2</p>*/@Test public void testQuintic(){double[]c={0,0,15,-13,-3,1};PolynomialFunction f=new PolynomialFunction(c);Assert.assertEquals(f.value(0),c[0],tolerance);Assert.assertEquals(0,f.value(5),tolerance);Assert.assertEquals(0,f.value(1),tolerance);Assert.assertEquals(0,f.value(-3),tolerance);Assert.assertEquals(54.84375,f.value(-1.5),tolerance);Assert.assertEquals(-8.06637,f.value(1.3),tolerance);Assert.assertEquals(f.degree(),5);}
/** * tests the firstDerivative function by comparison <p>This will test the functions <tt>f(x)= x^3 - 2x^2 + 6x + 3,g(x)= 3x^2 - 4x + 6</tt> and <tt>h(x)= 6x - 4</tt>*/@Test public void testfirstDerivativeComparison(){double[]f_coeff={3,6,-2,1};double[]g_coeff={6,-4,3};double[]h_coeff={-4,6};PolynomialFunction f=new PolynomialFunction(f_coeff);PolynomialFunction g=new PolynomialFunction(g_coeff);PolynomialFunction h=new PolynomialFunction(h_coeff);Assert.assertEquals(f.derivative().value(0),g.value(0),tolerance);Assert.assertEquals(f.derivative().value(1),g.value(1),tolerance);Assert.assertEquals(f.derivative().value(100),g.value(100),tolerance);Assert.assertEquals(f.derivative().value(4.1),g.value(4.1),tolerance);Assert.assertEquals(f.derivative().value(-3.25),g.value(-3.25),tolerance);Assert.assertEquals(g.derivative().value(FastMath.PI),h.value(FastMath.PI),tolerance);Assert.assertEquals(g.derivative().value(FastMath.E),h.value(FastMath.E),tolerance);}
@Test public void testString(){PolynomialFunction p=new PolynomialFunction(new double[]{-5,3,1});checkPolynomial(p,"-5 + 3 x + x^2");checkPolynomial(new PolynomialFunction(new double[]{0,-2,3}),"-2 x + 3 x^2");checkPolynomial(new PolynomialFunction(new double[]{1,-2,3}),"1 - 2 x + 3 x^2");checkPolynomial(new PolynomialFunction(new double[]{0,2,3}),"2 x + 3 x^2");checkPolynomial(new PolynomialFunction(new double[]{1,2,3}),"1 + 2 x + 3 x^2");checkPolynomial(new PolynomialFunction(new double[]{1,0,3}),"1 + 3 x^2");checkPolynomial(new PolynomialFunction(new double[]{0}),"0");}
@Test public void testAddition(){PolynomialFunction p1=new PolynomialFunction(new double[]{-2,1});PolynomialFunction p2=new PolynomialFunction(new double[]{2,-1,0});checkNullPolynomial(p1.add(p2));p2=p1.add(p1);checkPolynomial(p2,"-4 + 2 x");p1=new PolynomialFunction(new double[]{1,-4,2});p2=new PolynomialFunction(new double[]{-1,3,-2});p1=p1.add(p2);Assert.assertEquals(1,p1.degree());checkPolynomial(p1,"-x");}
@Test public void testSubtraction(){PolynomialFunction p1=new PolynomialFunction(new double[]{-2,1});checkNullPolynomial(p1.subtract(p1));PolynomialFunction p2=new PolynomialFunction(new double[]{-2,6});p2=p2.subtract(p1);checkPolynomial(p2,"5 x");p1=new PolynomialFunction(new double[]{1,-4,2});p2=new PolynomialFunction(new double[]{-1,3,2});p1=p1.subtract(p2);Assert.assertEquals(1,p1.degree());checkPolynomial(p1,"2 - 7 x");}
@Test public void testMultiplication(){PolynomialFunction p1=new PolynomialFunction(new double[]{-3,2});PolynomialFunction p2=new PolynomialFunction(new double[]{3,2,1});checkPolynomial(p1.multiply(p2),"-9 + x^2 + 2 x^3");p1=new PolynomialFunction(new double[]{0,1});p2=p1;for (int i=2;i < 10;++i){p2=p2.multiply(p1);checkPolynomial(p2,"x^" + i);}}
@Test public void testSerial(){PolynomialFunction p2=new PolynomialFunction(new double[]{3,2,1});Assert.assertEquals(p2,TestUtils.serializeAndRecover(p2));}
/** * tests the firstDerivative function by comparison <p>This will test the functions <tt>f(x)= x^3 - 2x^2 + 6x + 3,g(x)= 3x^2 - 4x + 6</tt> and <tt>h(x)= 6x - 4</tt>*/@Test public void testMath341(){double[]f_coeff={3,6,-2,1};double[]g_coeff={6,-4,3};double[]h_coeff={-4,6};PolynomialFunction f=new PolynomialFunction(f_coeff);PolynomialFunction g=new PolynomialFunction(g_coeff);PolynomialFunction h=new PolynomialFunction(h_coeff);Assert.assertEquals(f.derivative().value(0),g.value(0),tolerance);Assert.assertEquals(f.derivative().value(1),g.value(1),tolerance);Assert.assertEquals(f.derivative().value(100),g.value(100),tolerance);Assert.assertEquals(f.derivative().value(4.1),g.value(4.1),tolerance);Assert.assertEquals(f.derivative().value(-3.25),g.value(-3.25),tolerance);Assert.assertEquals(g.derivative().value(FastMath.PI),h.value(FastMath.PI),tolerance);Assert.assertEquals(g.derivative().value(FastMath.E),h.value(FastMath.E),tolerance);}
@Test public void testSetterInjection()throws Exception {MultivariateSummaryStatistics u=createMultivariateSummaryStatistics(2,true);u.setMeanImpl(new StorelessUnivariateStatistic[]{new sumMean(),new sumMean()});u.addValue(new double[]{1,2});u.addValue(new double[]{3,4});Assert.assertEquals(4,u.getMean()[0],1E-14);Assert.assertEquals(6,u.getMean()[1],1E-14);u.clear();u.addValue(new double[]{1,2});u.addValue(new double[]{3,4});Assert.assertEquals(4,u.getMean()[0],1E-14);Assert.assertEquals(6,u.getMean()[1],1E-14);u.clear();u.setMeanImpl(new StorelessUnivariateStatistic[]{new Mean(),new Mean()});u.addValue(new double[]{1,2});u.addValue(new double[]{3,4});Assert.assertEquals(2,u.getMean()[0],1E-14);Assert.assertEquals(3,u.getMean()[1],1E-14);Assert.assertEquals(2,u.getDimension());}
@Test public void testSetterIllegalState()throws Exception {MultivariateSummaryStatistics u=createMultivariateSummaryStatistics(2,true);u.addValue(new double[]{1,2});u.addValue(new double[]{3,4});try {u.setMeanImpl(new StorelessUnivariateStatistic[]{new sumMean(),new sumMean()});Assert.fail("Expecting IllegalStateException");}catch(IllegalStateException ex){}}
@Test public void testToString(){MultivariateSummaryStatistics stats=createMultivariateSummaryStatistics(2,true);stats.addValue(new double[]{1,3});stats.addValue(new double[]{2,2});stats.addValue(new double[]{3,1});Locale d=Locale.getDefault();Locale.setDefault(Locale.US);final String suffix=System.getProperty("line.separator");Assert.assertEquals("MultivariateSummaryStatistics:" + suffix + "n: 3"+ suffix+ "min: 1.0,1.0"+ suffix+ "max: 3.0,3.0"+ suffix+ "mean: 2.0,2.0"+ suffix+ "geometric mean: 1.817...,1.817..."+ suffix+ "sum of squares: 14.0,14.0"+ suffix+ "sum of logarithms: 1.791...,1.791..."+ suffix+ "standard deviation: 1.0,1.0"+ suffix+ "covariance: Array2DRowRealMatrix{{1.0,-1.0},{-1.0,1.0}}"+ suffix,stats.toString().replaceAll("([0-9]+\\.[0-9][0-9][0-9])[0-9]+","$1..."));Locale.setDefault(d);}
@Test public void testShuffledStatistics(){MultivariateSummaryStatistics reference=createMultivariateSummaryStatistics(2,true);MultivariateSummaryStatistics shuffled=createMultivariateSummaryStatistics(2,true);StorelessUnivariateStatistic[]tmp=shuffled.getGeoMeanImpl();shuffled.setGeoMeanImpl(shuffled.getMeanImpl());shuffled.setMeanImpl(shuffled.getMaxImpl());shuffled.setMaxImpl(shuffled.getMinImpl());shuffled.setMinImpl(shuffled.getSumImpl());shuffled.setSumImpl(shuffled.getSumsqImpl());shuffled.setSumsqImpl(shuffled.getSumLogImpl());shuffled.setSumLogImpl(tmp);for (int i=100;i > 0;--i){reference.addValue(new double[]{i,i});shuffled.addValue(new double[]{i,i});}TestUtils.assertEquals(reference.getMean(),shuffled.getGeometricMean(),1.0e-10);TestUtils.assertEquals(reference.getMax(),shuffled.getMean(),1.0e-10);TestUtils.assertEquals(reference.getMin(),shuffled.getMax(),1.0e-10);TestUtils.assertEquals(reference.getSum(),shuffled.getMin(),1.0e-10);TestUtils.assertEquals(reference.getSumSq(),shuffled.getSum(),1.0e-10);TestUtils.assertEquals(reference.getSumLog(),shuffled.getSumSq(),1.0e-10);TestUtils.assertEquals(reference.getGeometricMean(),shuffled.getSumLog(),1.0e-10);}
@Test public void testDimension(){try {createMultivariateSummaryStatistics(2,true).addValue(new double[3]);Assert.fail("Expecting DimensionMismatchException");}catch(DimensionMismatchException dme){}}
/** * test stats */@Test public void testStats(){MultivariateSummaryStatistics u=createMultivariateSummaryStatistics(2,true);Assert.assertEquals(0,u.getN());u.addValue(new double[]{1,2});u.addValue(new double[]{2,3});u.addValue(new double[]{2,3});u.addValue(new double[]{3,4});Assert.assertEquals(4,u.getN());Assert.assertEquals(8,u.getSum()[0],1.0e-10);Assert.assertEquals(12,u.getSum()[1],1.0e-10);Assert.assertEquals(18,u.getSumSq()[0],1.0e-10);Assert.assertEquals(38,u.getSumSq()[1],1.0e-10);Assert.assertEquals(1,u.getMin()[0],1.0e-10);Assert.assertEquals(2,u.getMin()[1],1.0e-10);Assert.assertEquals(3,u.getMax()[0],1.0e-10);Assert.assertEquals(4,u.getMax()[1],1.0e-10);Assert.assertEquals(2.4849066497880003102,u.getSumLog()[0],1.0e-10);Assert.assertEquals(4.276666119016055311,u.getSumLog()[1],1.0e-10);Assert.assertEquals(1.8612097182041991979,u.getGeometricMean()[0],1.0e-10);Assert.assertEquals(2.9129506302439405217,u.getGeometricMean()[1],1.0e-10);Assert.assertEquals(2,u.getMean()[0],1.0e-10);Assert.assertEquals(3,u.getMean()[1],1.0e-10);Assert.assertEquals(FastMath.sqrt(2.0 / 3.0),u.getStandardDeviation()[0],1.0e-10);Assert.assertEquals(FastMath.sqrt(2.0 / 3.0),u.getStandardDeviation()[1],1.0e-10);Assert.assertEquals(2.0 / 3.0,u.getCovariance().getEntry(0,0),1.0e-10);Assert.assertEquals(2.0 / 3.0,u.getCovariance().getEntry(0,1),1.0e-10);Assert.assertEquals(2.0 / 3.0,u.getCovariance().getEntry(1,0),1.0e-10);Assert.assertEquals(2.0 / 3.0,u.getCovariance().getEntry(1,1),1.0e-10);u.clear();Assert.assertEquals(0,u.getN());}
@Test public void testN0andN1Conditions()throws Exception {MultivariateSummaryStatistics u=createMultivariateSummaryStatistics(1,true);Assert.assertTrue(Double.isNaN(u.getMean()[0]));Assert.assertTrue(Double.isNaN(u.getStandardDeviation()[0]));u.addValue(new double[]{1});Assert.assertEquals(1.0,u.getMean()[0],1.0e-10);Assert.assertEquals(1.0,u.getGeometricMean()[0],1.0e-10);Assert.assertEquals(0.0,u.getStandardDeviation()[0],1.0e-10);u.addValue(new double[]{2});Assert.assertTrue(u.getStandardDeviation()[0]> 0);}
@Test public void testNaNContracts(){MultivariateSummaryStatistics u=createMultivariateSummaryStatistics(1,true);Assert.assertTrue(Double.isNaN(u.getMean()[0]));Assert.assertTrue(Double.isNaN(u.getMin()[0]));Assert.assertTrue(Double.isNaN(u.getStandardDeviation()[0]));Assert.assertTrue(Double.isNaN(u.getGeometricMean()[0]));u.addValue(new double[]{1.0});Assert.assertFalse(Double.isNaN(u.getMean()[0]));Assert.assertFalse(Double.isNaN(u.getMin()[0]));Assert.assertFalse(Double.isNaN(u.getStandardDeviation()[0]));Assert.assertFalse(Double.isNaN(u.getGeometricMean()[0]));}
@Test public void testSerialization(){MultivariateSummaryStatistics u=createMultivariateSummaryStatistics(2,true);TestUtils.checkSerializedEquality(u);MultivariateSummaryStatistics s=(MultivariateSummaryStatistics)TestUtils.serializeAndRecover(u);Assert.assertEquals(u,s);u.addValue(new double[]{2d,1d});u.addValue(new double[]{1d,1d});u.addValue(new double[]{3d,1d});u.addValue(new double[]{4d,1d});u.addValue(new double[]{5d,1d});TestUtils.checkSerializedEquality(u);s=(MultivariateSummaryStatistics)TestUtils.serializeAndRecover(u);Assert.assertEquals(u,s);}
@Test public void testEqualsAndHashCode(){MultivariateSummaryStatistics u=createMultivariateSummaryStatistics(2,true);MultivariateSummaryStatistics t=null;int emptyHash=u.hashCode();Assert.assertTrue(u.equals(u));Assert.assertFalse(u.equals(t));Assert.assertFalse(u.equals(Double.valueOf(0)));t=createMultivariateSummaryStatistics(2,true);Assert.assertTrue(t.equals(u));Assert.assertTrue(u.equals(t));Assert.assertEquals(emptyHash,t.hashCode());u.addValue(new double[]{2d,1d});u.addValue(new double[]{1d,1d});u.addValue(new double[]{3d,1d});u.addValue(new double[]{4d,1d});u.addValue(new double[]{5d,1d});Assert.assertFalse(t.equals(u));Assert.assertFalse(u.equals(t));Assert.assertTrue(u.hashCode()!= t.hashCode());t.addValue(new double[]{2d,1d});t.addValue(new double[]{1d,1d});t.addValue(new double[]{3d,1d});t.addValue(new double[]{4d,1d});t.addValue(new double[]{5d,1d});Assert.assertTrue(t.equals(u));Assert.assertTrue(u.equals(t));Assert.assertEquals(u.hashCode(),t.hashCode());u.clear();t.clear();Assert.assertTrue(t.equals(u));Assert.assertTrue(u.equals(t));Assert.assertEquals(emptyHash,t.hashCode());Assert.assertEquals(emptyHash,u.hashCode());}
@Test public void testParameterAccessors(){GammaDistribution distribution=(GammaDistribution)getDistribution();Assert.assertEquals(4d,distribution.getAlpha(),0);Assert.assertEquals(2d,distribution.getBeta(),0);}
@Test public void testPreconditions(){try {new GammaDistribution(0,1);Assert.fail("Expecting NotStrictlyPositiveException for alpha = 0");}catch(NotStrictlyPositiveException ex){}try {new GammaDistribution(1,0);Assert.fail("Expecting NotStrictlyPositiveException for alpha = 0");}catch(NotStrictlyPositiveException ex){}}
@Test public void testProbabilities()throws Exception {testProbability(-1.000,4.0,2.0,.0000);testProbability(15.501,4.0,2.0,.9499);testProbability(0.504,4.0,1.0,.0018);testProbability(10.011,1.0,2.0,.9933);testProbability(5.000,2.0,2.0,.7127);}
@Test public void testValues()throws Exception {testValue(15.501,4.0,2.0,.9499);testValue(0.504,4.0,1.0,.0018);testValue(10.011,1.0,2.0,.9933);testValue(5.000,2.0,2.0,.7127);}
@Test public void testDensity(){double[]x=new double[]{-0.1,1e-6,0.5,1,2,5};checkDensity(1,1,x,new double[]{0.000000000000,0.999999000001,0.606530659713,0.367879441171,0.135335283237,0.006737946999});checkDensity(2,1,x,new double[]{0.000000000000,0.000000999999,0.303265329856,0.367879441171,0.270670566473,0.033689734995});checkDensity(4,1,x,new double[]{0.000000000e+00,1.666665000e-19,1.263605541e-02,6.131324020e-02,1.804470443e-01,1.403738958e-01});checkDensity(4,10,x,new double[]{0.000000000e+00,1.666650000e-15,1.403738958e+00,7.566654960e-02,2.748204830e-05,4.018228850e-17});checkDensity(0.1,10,x,new double[]{0.000000000e+00,3.323953832e+04,1.663849010e-03,6.007786726e-06,1.461647647e-10,5.996008322e-24});checkDensity(0.1,20,x,new double[]{0.000000000e+00,3.562489883e+04,1.201557345e-05,2.923295295e-10,3.228910843e-19,1.239484589e-45});checkDensity(0.1,4,x,new double[]{0.000000000e+00,3.032938388e+04,3.049322494e-02,2.211502311e-03,2.170613371e-05,5.846590589e-11});checkDensity(0.1,1,x,new double[]{0.000000000e+00,2.640334143e+04,1.189704437e-01,3.866916944e-02,7.623306235e-03,1.663849010e-04});}
@Test public void testInverseCumulativeProbabilityExtremes()throws Exception {setInverseCumulativeTestPoints(new double[]{0,1});setInverseCumulativeTestValues(new double[]{0,Double.POSITIVE_INFINITY});verifyInverseCumulativeProbabilities();}
@Test public void testMoments(){final double tol=1e-9;GammaDistribution dist;dist=new GammaDistribution(1,2);Assert.assertEquals(dist.getNumericalMean(),2,tol);Assert.assertEquals(dist.getNumericalVariance(),4,tol);dist=new GammaDistribution(1.1,4.2);Assert.assertEquals(dist.getNumericalMean(),1.1d * 4.2d,tol);Assert.assertEquals(dist.getNumericalVariance(),1.1d * 4.2d * 4.2d,tol);}
/** * Verifies that cumulative probability density calculations match expected values using default test instance data*/@Test public void testCumulativeProbabilities()throws Exception {verifyCumulativeProbabilities();}
/** * Verifies that inverse cumulative probability density calculations match expected values using default test instance data*/@Test public void testInverseCumulativeProbabilities()throws Exception {verifyInverseCumulativeProbabilities();}
/** * Verifies that density calculations return expected values for default test instance data*/@Test public void testDensities()throws Exception {verifyDensities();}
/** * Verifies that probability computations are consistent*/@Test public void testConsistency()throws Exception {for (int i=1;i < cumulativeTestPoints.length;i++){TestUtils.assertEquals(0d,distribution.cumulativeProbability(cumulativeTestPoints[i],cumulativeTestPoints[i]),tolerance);double upper=FastMath.max(cumulativeTestPoints[i],cumulativeTestPoints[i - 1]);double lower=FastMath.min(cumulativeTestPoints[i],cumulativeTestPoints[i - 1]);double diff=distribution.cumulativeProbability(upper)- distribution.cumulativeProbability(lower);double direct=distribution.cumulativeProbability(lower,upper);TestUtils.assertEquals("Inconsistent cumulative probabilities for (" + lower + ","+ upper+ ")",diff,direct,tolerance);}}
/** * Verifies that illegal arguments are correctly handled*/@Test public void testIllegalArguments()throws Exception {try {distribution.cumulativeProbability(1,0);Assert.fail("Expecting MathIllegalArgumentException for bad cumulativeProbability interval");}catch(MathIllegalArgumentException ex){}try {distribution.inverseCumulativeProbability(-1);Assert.fail("Expecting MathIllegalArgumentException for p = -1");}catch(MathIllegalArgumentException ex){}try {distribution.inverseCumulativeProbability(2);Assert.fail("Expecting MathIllegalArgumentException for p = 2");}catch(MathIllegalArgumentException ex){}}
/** * Test sampling*/@Test public void testSampling()throws Exception {AbstractContinuousDistribution dist=(AbstractContinuousDistribution)makeDistribution();final int sampleSize=1000;dist.reseedRandomGenerator(1000);double[]sample=dist.sample(sampleSize);double[]quartiles=TestUtils.getDistributionQuartiles(dist);double[]expected={250,250,250,250};long[]counts=new long[4];for (int i=0;i < sampleSize;i++){TestUtils.updateCounts(sample[i],counts,quartiles);}TestUtils.assertChiSquareAccept(expected,counts,0.001);}
/** * test stats */@Test public void testStats(){SummaryStatistics u=createSummaryStatistics();Assert.assertEquals("total count",0,u.getN(),tolerance);u.addValue(one);u.addValue(twoF);u.addValue(twoL);u.addValue(three);Assert.assertEquals("N",n,u.getN(),tolerance);Assert.assertEquals("sum",sum,u.getSum(),tolerance);Assert.assertEquals("sumsq",sumSq,u.getSumsq(),tolerance);Assert.assertEquals("var",var,u.getVariance(),tolerance);Assert.assertEquals("population var",popVar,u.getPopulationVariance(),tolerance);Assert.assertEquals("std",std,u.getStandardDeviation(),tolerance);Assert.assertEquals("mean",mean,u.getMean(),tolerance);Assert.assertEquals("min",min,u.getMin(),tolerance);Assert.assertEquals("max",max,u.getMax(),tolerance);u.clear();Assert.assertEquals("total count",0,u.getN(),tolerance);}
@Test public void testN0andN1Conditions()throws Exception {SummaryStatistics u=createSummaryStatistics();Assert.assertTrue("Mean of n = 0 set should be NaN",Double.isNaN(u.getMean()));Assert.assertTrue("Standard Deviation of n = 0 set should be NaN",Double.isNaN(u.getStandardDeviation()));Assert.assertTrue("Variance of n = 0 set should be NaN",Double.isNaN(u.getVariance()));u.addValue(one);Assert.assertTrue("mean should be one (n = 1)",u.getMean()== one);Assert.assertTrue("geometric should be one (n = 1)instead it is " + u.getGeometricMean(),u.getGeometricMean()== one);Assert.assertTrue("Std should be zero (n = 1)",u.getStandardDeviation()== 0.0);Assert.assertTrue("variance should be zero (n = 1)",u.getVariance()== 0.0);u.addValue(twoF);Assert.assertTrue("Std should not be zero (n = 2)",u.getStandardDeviation()!= 0.0);Assert.assertTrue("variance should not be zero (n = 2)",u.getVariance()!= 0.0);}
@Test public void testProductAndGeometricMean()throws Exception {SummaryStatistics u=createSummaryStatistics();u.addValue(1.0);u.addValue(2.0);u.addValue(3.0);u.addValue(4.0);Assert.assertEquals("Geometric mean not expected",2.213364,u.getGeometricMean(),0.00001);}
@Test public void testNaNContracts(){SummaryStatistics u=createSummaryStatistics();Assert.assertTrue("mean not NaN",Double.isNaN(u.getMean()));Assert.assertTrue("min not NaN",Double.isNaN(u.getMin()));Assert.assertTrue("std dev not NaN",Double.isNaN(u.getStandardDeviation()));Assert.assertTrue("var not NaN",Double.isNaN(u.getVariance()));Assert.assertTrue("geom mean not NaN",Double.isNaN(u.getGeometricMean()));u.addValue(1.0);Assert.assertEquals("mean not expected",1.0,u.getMean(),Double.MIN_VALUE);Assert.assertEquals("variance not expected",0.0,u.getVariance(),Double.MIN_VALUE);Assert.assertEquals("geometric mean not expected",1.0,u.getGeometricMean(),Double.MIN_VALUE);u.addValue(-1.0);Assert.assertTrue("geom mean not NaN",Double.isNaN(u.getGeometricMean()));u.addValue(0.0);Assert.assertTrue("geom mean not NaN",Double.isNaN(u.getGeometricMean()));}
@Test public void testGetSummary(){SummaryStatistics u=createSummaryStatistics();StatisticalSummary summary=u.getSummary();verifySummary(u,summary);u.addValue(1d);summary=u.getSummary();verifySummary(u,summary);u.addValue(2d);summary=u.getSummary();verifySummary(u,summary);u.addValue(2d);summary=u.getSummary();verifySummary(u,summary);}
@Test public void testSerialization(){SummaryStatistics u=createSummaryStatistics();TestUtils.checkSerializedEquality(u);SummaryStatistics s=(SummaryStatistics)TestUtils.serializeAndRecover(u);StatisticalSummary summary=s.getSummary();verifySummary(u,summary);u.addValue(2d);u.addValue(1d);u.addValue(3d);u.addValue(4d);u.addValue(5d);TestUtils.checkSerializedEquality(u);s=(SummaryStatistics)TestUtils.serializeAndRecover(u);summary=s.getSummary();verifySummary(u,summary);}
@Test public void testEqualsAndHashCode(){SummaryStatistics u=createSummaryStatistics();SummaryStatistics t=null;int emptyHash=u.hashCode();Assert.assertTrue("reflexive",u.equals(u));Assert.assertFalse("non-null compared to null",u.equals(t));Assert.assertFalse("wrong type",u.equals(Double.valueOf(0)));t=createSummaryStatistics();Assert.assertTrue("empty instances should be equal",t.equals(u));Assert.assertTrue("empty instances should be equal",u.equals(t));Assert.assertEquals("empty hash code",emptyHash,t.hashCode());u.addValue(2d);u.addValue(1d);u.addValue(3d);u.addValue(4d);Assert.assertFalse("different n's should make instances not equal",t.equals(u));Assert.assertFalse("different n's should make instances not equal",u.equals(t));Assert.assertTrue("different n's should make hashcodes different",u.hashCode()!= t.hashCode());t.addValue(2d);t.addValue(1d);t.addValue(3d);t.addValue(4d);Assert.assertTrue("summaries based on same data should be equal",t.equals(u));Assert.assertTrue("summaries based on same data should be equal",u.equals(t));Assert.assertEquals("summaries based on same data should have same hashcodes",u.hashCode(),t.hashCode());u.clear();t.clear();Assert.assertTrue("empty instances should be equal",t.equals(u));Assert.assertTrue("empty instances should be equal",u.equals(t));Assert.assertEquals("empty hash code",emptyHash,t.hashCode());Assert.assertEquals("empty hash code",emptyHash,u.hashCode());}
@Test public void testCopy()throws Exception {SummaryStatistics u=createSummaryStatistics();u.addValue(2d);u.addValue(1d);u.addValue(3d);u.addValue(4d);SummaryStatistics v=new SummaryStatistics(u);Assert.assertEquals(u,v);Assert.assertEquals(v,u);Assert.assertTrue(v.geoMean == v.getGeoMeanImpl());Assert.assertTrue(v.mean == v.getMeanImpl());Assert.assertTrue(v.min == v.getMinImpl());Assert.assertTrue(v.max == v.getMaxImpl());Assert.assertTrue(v.sum == v.getSumImpl());Assert.assertTrue(v.sumsq == v.getSumsqImpl());Assert.assertTrue(v.sumLog == v.getSumLogImpl());Assert.assertTrue(v.variance == v.getVarianceImpl());u.addValue(7d);u.addValue(9d);u.addValue(11d);u.addValue(23d);v.addValue(7d);v.addValue(9d);v.addValue(11d);v.addValue(23d);Assert.assertEquals(u,v);Assert.assertEquals(v,u);u.clear();u.setSumImpl(new Sum());SummaryStatistics.copy(u,v);Assert.assertEquals(u.sum,v.sum);Assert.assertEquals(u.getSumImpl(),v.getSumImpl());}
@Test public void testSetterInjection()throws Exception {SummaryStatistics u=createSummaryStatistics();u.setMeanImpl(new Sum());u.setSumLogImpl(new Sum());u.addValue(1);u.addValue(3);Assert.assertEquals(4,u.getMean(),1E-14);Assert.assertEquals(4,u.getSumOfLogs(),1E-14);Assert.assertEquals(FastMath.exp(2),u.getGeometricMean(),1E-14);u.clear();u.addValue(1);u.addValue(2);Assert.assertEquals(3,u.getMean(),1E-14);u.clear();u.setMeanImpl(new Mean());}
@Test public void testSetterIllegalState()throws Exception {SummaryStatistics u=createSummaryStatistics();u.addValue(1);u.addValue(3);try {u.setMeanImpl(new Sum());Assert.fail("Expecting IllegalStateException");}catch(IllegalStateException ex){}}
/** * JIRA: MATH-691*/@Test public void testOverrideVarianceWithMathClass()throws Exception {double[]scores={1,2,3,4};SummaryStatistics stats=new SummaryStatistics();stats.setVarianceImpl(new Variance(false));for(double i : scores){stats.addValue(i);}Assert.assertEquals((new Variance(false)).evaluate(scores),stats.getVariance(),0);}
@Test public void testOverrideMeanWithMathClass()throws Exception {double[]scores={1,2,3,4};SummaryStatistics stats=new SummaryStatistics();stats.setMeanImpl(new Mean());for(double i : scores){stats.addValue(i);}Assert.assertEquals((new Mean()).evaluate(scores),stats.getMean(),0);}
@Test public void testOverrideGeoMeanWithMathClass()throws Exception {double[]scores={1,2,3,4};SummaryStatistics stats=new SummaryStatistics();stats.setGeoMeanImpl(new GeometricMean());for(double i : scores){stats.addValue(i);}Assert.assertEquals((new GeometricMean()).evaluate(scores),stats.getGeometricMean(),0);}
@Test(expected=IllegalArgumentException.class)public void cannotAddXSampleData(){createRegression().newSampleData(new double[]{},null,null);}
@Test(expected=IllegalArgumentException.class)public void cannotAddNullYSampleData(){createRegression().newSampleData(null,new double[][]{},null);}
@Test(expected=IllegalArgumentException.class)public void cannotAddSampleDataWithSizeMismatch(){double[]y=new double[]{1.0,2.0};double[][]x=new double[1][];x[0]=new double[]{1.0,0};createRegression().newSampleData(y,x,null);}
@Test(expected=IllegalArgumentException.class)public void cannotAddNullCovarianceData(){createRegression().newSampleData(new double[]{},new double[][]{},null);}
@Test(expected=IllegalArgumentException.class)public void notEnoughData(){double[]reducedY=new double[y.length - 1];double[][]reducedX=new double[x.length - 1][];double[][]reducedO=new double[omega.length - 1][];System.arraycopy(y,0,reducedY,0,reducedY.length);System.arraycopy(x,0,reducedX,0,reducedX.length);System.arraycopy(omega,0,reducedO,0,reducedO.length);createRegression().newSampleData(reducedY,reducedX,reducedO);}
@Test(expected=IllegalArgumentException.class)public void cannotAddCovarianceDataWithSampleSizeMismatch(){double[]y=new double[]{1.0,2.0};double[][]x=new double[2][];x[0]=new double[]{1.0,0};x[1]=new double[]{0,1.0};double[][]omega=new double[1][];omega[0]=new double[]{1.0,0};createRegression().newSampleData(y,x,omega);}
@Test(expected=IllegalArgumentException.class)public void cannotAddCovarianceDataThatIsNotSquare(){double[]y=new double[]{1.0,2.0};double[][]x=new double[2][];x[0]=new double[]{1.0,0};x[1]=new double[]{0,1.0};double[][]omega=new double[3][];omega[0]=new double[]{1.0,0};omega[1]=new double[]{0,1.0};omega[2]=new double[]{0,2.0};createRegression().newSampleData(y,x,omega);}
/** * test calculateYVariance*/@Test public void testYVariance(){GLSMultipleLinearRegression model=new GLSMultipleLinearRegression();model.newSampleData(y,x,omega);TestUtils.assertEquals(model.calculateYVariance(),3.5,0);}
/** * Verifies that setting X,Y and covariance separately has the same effect as newSample(X,Y,cov).*/@Test public void testNewSample2()throws Exception {double[]y=new double[]{1,2,3,4};double[][]x=new double[][]{{19,22,33},{20,30,40},{25,35,45},{27,37,47}};double[][]covariance=MatrixUtils.createRealIdentityMatrix(4).scalarMultiply(2).getData();GLSMultipleLinearRegression regression=new GLSMultipleLinearRegression();regression.newSampleData(y,x,covariance);RealMatrix combinedX=regression.X.copy();RealVector combinedY=regression.Y.copy();RealMatrix combinedCovInv=regression.getOmegaInverse();regression.newXSampleData(x);regression.newYSampleData(y);Assert.assertEquals(combinedX,regression.X);Assert.assertEquals(combinedY,regression.Y);Assert.assertEquals(combinedCovInv,regression.getOmegaInverse());}
/** * Verifies that GLS with identity covariance matrix gives the same results as OLS.*/@Test public void testGLSOLSConsistency()throws Exception {RealMatrix identityCov=MatrixUtils.createRealIdentityMatrix(16);GLSMultipleLinearRegression glsModel=new GLSMultipleLinearRegression();OLSMultipleLinearRegression olsModel=new OLSMultipleLinearRegression();glsModel.newSampleData(longley,16,6);olsModel.newSampleData(longley,16,6);glsModel.newCovarianceData(identityCov.getData());double[]olsBeta=olsModel.calculateBeta().toArray();double[]glsBeta=glsModel.calculateBeta().toArray();for (int i=0;i < olsBeta.length;i++){TestUtils.assertRelativelyEquals(olsBeta[i],glsBeta[i],10E-7);}}
/** * Generate an error covariance matrix and sample data representing models with this error structure. Then verify that GLS estimated coefficients,on average,perform better than OLS.*/@Test public void testGLSEfficiency()throws Exception {RandomGenerator rg=new JDKRandomGenerator();rg.setSeed(200);final int nObs=16;double[]sigma=new double[nObs];for (int i=0;i < nObs;i++){sigma[i]=10 * rg.nextDouble();}final int numSeeds=1000;RealMatrix errorSeeds=MatrixUtils.createRealMatrix(numSeeds,nObs);for (int i=0;i < numSeeds;i++){for (int j=0;j < nObs;j++){errorSeeds.setEntry(i,j,rg.nextGaussian()* sigma[j]);}}RealMatrix cov=(new Covariance(errorSeeds)).getCovarianceMatrix();GaussianRandomGenerator rawGenerator=new GaussianRandomGenerator(rg);double[]errorMeans=new double[nObs];CorrelatedRandomVectorGenerator gen=new CorrelatedRandomVectorGenerator(errorMeans,cov,1.0e-12 * cov.getNorm(),rawGenerator);OLSMultipleLinearRegression ols=new OLSMultipleLinearRegression();ols.newSampleData(longley,nObs,6);final RealVector b=ols.calculateBeta().copy();final RealMatrix x=ols.X.copy();GLSMultipleLinearRegression gls=new GLSMultipleLinearRegression();gls.newSampleData(longley,nObs,6);gls.newCovarianceData(cov.getData());DescriptiveStatistics olsBetaStats=new DescriptiveStatistics();DescriptiveStatistics glsBetaStats=new DescriptiveStatistics();final int nModels=10000;for (int i=0;i < nModels;i++){RealVector u=MatrixUtils.createRealVector(gen.nextVector());double[]y=u.add(x.operate(b)).toArray();ols.newYSampleData(y);RealVector olsBeta=ols.calculateBeta();gls.newYSampleData(y);RealVector glsBeta=gls.calculateBeta();double dist=olsBeta.getDistance(b);olsBetaStats.addValue(dist * dist);dist=glsBeta.getDistance(b);glsBetaStats.addValue(dist * dist);}assert(olsBetaStats.getMean()> 1.5 * glsBetaStats.getMean());assert(olsBetaStats.getStandardDeviation()> glsBetaStats.getStandardDeviation());}
@Test public void testHighPercentile(){double[]d=new double[]{1,2,3};Percentile p=new Percentile(75);Assert.assertEquals(3.0,p.evaluate(d),1.0e-5);}
@Test public void testLowPercentile(){double[]d=new double[]{0,1};Percentile p=new Percentile(25);Assert.assertEquals(0d,p.evaluate(d),Double.MIN_VALUE);}
@Test public void testPercentile(){double[]d=new double[]{1,3,2,4};Percentile p=new Percentile(30);Assert.assertEquals(1.5,p.evaluate(d),1.0e-5);p.setQuantile(25);Assert.assertEquals(1.25,p.evaluate(d),1.0e-5);p.setQuantile(75);Assert.assertEquals(3.75,p.evaluate(d),1.0e-5);p.setQuantile(50);Assert.assertEquals(2.5,p.evaluate(d),1.0e-5);try {p.evaluate(d,0,d.length,-1.0);Assert.fail();}catch(MathIllegalArgumentException ex){}try {p.evaluate(d,0,d.length,101.0);Assert.fail();}catch(MathIllegalArgumentException ex){}}
@Test public void testNISTExample(){double[]d=new double[]{95.1772,95.1567,95.1937,95.1959,95.1442,95.0610,95.1591,95.1195,95.1772,95.0925,95.1990,95.1682};Percentile p=new Percentile(90);Assert.assertEquals(95.1981,p.evaluate(d),1.0e-4);Assert.assertEquals(95.1990,p.evaluate(d,0,d.length,100d),0);}
@Test public void test5(){Percentile percentile=new Percentile(5);Assert.assertEquals(this.percentile5,percentile.evaluate(testArray),getTolerance());}
@Test public void testNullEmpty(){Percentile percentile=new Percentile(50);double[]nullArray=null;double[]emptyArray=new double[]{};try {percentile.evaluate(nullArray);Assert.fail("Expecting MathIllegalArgumentException for null array");}catch(MathIllegalArgumentException ex){}Assert.assertTrue(Double.isNaN(percentile.evaluate(emptyArray)));}
@Test public void testSingleton(){Percentile percentile=new Percentile(50);double[]singletonArray=new double[]{1d};Assert.assertEquals(1d,percentile.evaluate(singletonArray),0);Assert.assertEquals(1d,percentile.evaluate(singletonArray,0,1),0);Assert.assertEquals(1d,percentile.evaluate(singletonArray,0,1,5),0);Assert.assertEquals(1d,percentile.evaluate(singletonArray,0,1,100),0);Assert.assertTrue(Double.isNaN(percentile.evaluate(singletonArray,0,0)));}
@Test public void testSpecialValues(){Percentile percentile=new Percentile(50);double[]specialValues=new double[]{0d,1d,2d,3d,4d,Double.NaN};Assert.assertEquals(2.5d,percentile.evaluate(specialValues),0);specialValues=new double[]{Double.NEGATIVE_INFINITY,1d,2d,3d,Double.NaN,Double.POSITIVE_INFINITY};Assert.assertEquals(2.5d,percentile.evaluate(specialValues),0);specialValues=new double[]{1d,1d,Double.POSITIVE_INFINITY,Double.POSITIVE_INFINITY};Assert.assertTrue(Double.isInfinite(percentile.evaluate(specialValues)));specialValues=new double[]{1d,1d,Double.NaN,Double.NaN};Assert.assertTrue(Double.isNaN(percentile.evaluate(specialValues)));specialValues=new double[]{1d,1d,Double.NEGATIVE_INFINITY,Double.NEGATIVE_INFINITY};Assert.assertTrue(Double.isNaN(percentile.evaluate(specialValues)));}
@Test public void testSetQuantile(){Percentile percentile=new Percentile(10);percentile.setQuantile(100);Assert.assertEquals(100,percentile.getQuantile(),0);try {percentile.setQuantile(0);Assert.fail("Expecting MathIllegalArgumentException");}catch(MathIllegalArgumentException ex){}try {new Percentile(0);Assert.fail("Expecting MathIllegalArgumentException");}catch(MathIllegalArgumentException ex){}}
@Test public void testEvaluation()throws Exception {Assert.assertEquals(expectedValue(),getUnivariateStatistic().evaluate(testArray),getTolerance());}
@Test public void testEvaluateArraySegment(){final UnivariateStatistic stat=getUnivariateStatistic();final double[]arrayZero=new double[5];System.arraycopy(testArray,0,arrayZero,0,5);Assert.assertEquals(stat.evaluate(arrayZero),stat.evaluate(testArray,0,5),0);final double[]arrayOne=new double[5];System.arraycopy(testArray,5,arrayOne,0,5);Assert.assertEquals(stat.evaluate(arrayOne),stat.evaluate(testArray,5,5),0);final double[]arrayEnd=new double[5];System.arraycopy(testArray,testArray.length - 5,arrayEnd,0,5);Assert.assertEquals(stat.evaluate(arrayEnd),stat.evaluate(testArray,testArray.length - 5,5),0);}
@Test public void testEvaluateArraySegmentWeighted(){UnivariateStatistic statistic=getUnivariateStatistic();if (!(statistic instanceof WeightedEvaluation)){return;}final WeightedEvaluation stat=(WeightedEvaluation)getUnivariateStatistic();final double[]arrayZero=new double[5];final double[]weightZero=new double[5];System.arraycopy(testArray,0,arrayZero,0,5);System.arraycopy(testWeightsArray,0,weightZero,0,5);Assert.assertEquals(stat.evaluate(arrayZero,weightZero),stat.evaluate(testArray,testWeightsArray,0,5),0);final double[]arrayOne=new double[5];final double[]weightOne=new double[5];System.arraycopy(testArray,5,arrayOne,0,5);System.arraycopy(testWeightsArray,5,weightOne,0,5);Assert.assertEquals(stat.evaluate(arrayOne,weightOne),stat.evaluate(testArray,testWeightsArray,5,5),0);final double[]arrayEnd=new double[5];final double[]weightEnd=new double[5];System.arraycopy(testArray,testArray.length - 5,arrayEnd,0,5);System.arraycopy(testWeightsArray,testArray.length - 5,weightEnd,0,5);Assert.assertEquals(stat.evaluate(arrayEnd,weightEnd),stat.evaluate(testArray,testWeightsArray,testArray.length - 5,5),0);}
@Test public void testCopy()throws Exception {UnivariateStatistic original=getUnivariateStatistic();UnivariateStatistic copy=original.copy();Assert.assertEquals(expectedValue(),copy.evaluate(testArray),getTolerance());}
/** * Tests consistency of weighted statistic computation. For statistics that support weighted evaluation,this test case compares the result of direct computation on an array with repeated values with a weighted computation on the corresponding (shorter)array with each value appearing only once but with a weight value equal to its multiplicity in the repeating array.*/@Test public void testWeightedConsistency()throws Exception {UnivariateStatistic statistic=getUnivariateStatistic();if (!(statistic instanceof WeightedEvaluation)){return;}final int len=10;final double mu=0;final double sigma=5;double[]values=new double[len];double[]weights=new double[len];RandomData randomData=new RandomDataImpl();int[]intWeights=new int[len];for (int i=0;i < len;i++){intWeights[i]=randomData.nextInt(1,5);weights[i]=intWeights[i];}List<Double> valuesList=new ArrayList<Double>();for (int i=0;i < len;i++){double value=randomData.nextGaussian(mu,sigma);values[i]=value;for (int j=0;j < intWeights[i];j++){valuesList.add(new Double(value));}}int sumWeights=valuesList.size();double[]repeatedValues=new double[sumWeights];for (int i=0;i < sumWeights;i++){repeatedValues[i]=valuesList.get(i);}WeightedEvaluation weightedStatistic=(WeightedEvaluation)statistic;TestUtils.assertRelativelyEquals(statistic.evaluate(repeatedValues),weightedStatistic.evaluate(values,weights,0,values.length),10E-14);Assert.assertEquals(weightedStatistic.evaluate(values,weights,0,values.length),weightedStatistic.evaluate(values,weights),Double.MIN_VALUE);}
@Test public void testDerivativesConsistency(){TestProblem3 pb=new TestProblem3();double step=(pb.getFinalTime()- pb.getInitialTime())* 0.001;GillIntegrator integ=new GillIntegrator(step);StepInterpolatorTestUtils.checkDerivativesConsistency(integ,pb,1.0e-10);}
@Test public void serialization()throws IOException,ClassNotFoundException {TestProblem3 pb=new TestProblem3(0.9);double step=(pb.getFinalTime()- pb.getInitialTime())* 0.0003;GillIntegrator integ=new GillIntegrator(step);integ.addStepHandler(new ContinuousOutputModel());integ.integrate(pb,pb.getInitialTime(),pb.getInitialState(),pb.getFinalTime(),new double[pb.getDimension()]);ByteArrayOutputStream bos=new ByteArrayOutputStream();ObjectOutputStream oos=new ObjectOutputStream(bos);for(StepHandler handler : integ.getStepHandlers()){oos.writeObject(handler);}Assert.assertTrue(bos.size()> 880000);Assert.assertTrue(bos.size()< 900000);ByteArrayInputStream bis=new ByteArrayInputStream(bos.toByteArray());ObjectInputStream ois=new ObjectInputStream(bis);ContinuousOutputModel cm=(ContinuousOutputModel)ois.readObject();Random random=new Random(347588535632l);double maxError=0.0;for (int i=0;i < 1000;++i){double r=random.nextDouble();double time=r * pb.getInitialTime()+ (1.0 - r)* pb.getFinalTime();cm.setInterpolatedTime(time);double[]interpolatedY=cm.getInterpolatedState();double[]theoreticalY=pb.computeTheoreticalState(time);double dx=interpolatedY[0]- theoreticalY[0];double dy=interpolatedY[1]- theoreticalY[1];double error=dx * dx + dy * dy;if (error > maxError){maxError=error;}}Assert.assertTrue(maxError < 0.003);}
@Test public void testBox(){PolyhedronsSet tree=new PolyhedronsSet(0,1,0,1,0,1);Assert.assertEquals(1.0,tree.getSize(),1.0e-10);Assert.assertEquals(6.0,tree.getBoundarySize(),1.0e-10);Vector3D barycenter=(Vector3D)tree.getBarycenter();Assert.assertEquals(0.5,barycenter.getX(),1.0e-10);Assert.assertEquals(0.5,barycenter.getY(),1.0e-10);Assert.assertEquals(0.5,barycenter.getZ(),1.0e-10);for (double x=-0.25;x < 1.25;x+=0.1){boolean xOK=(x >= 0.0)&& (x <= 1.0);for (double y=-0.25;y < 1.25;y+=0.1){boolean yOK=(y >= 0.0)&& (y <= 1.0);for (double z=-0.25;z < 1.25;z+=0.1){boolean zOK=(z >= 0.0)&& (z <= 1.0);Region.Location expected=(xOK && yOK && zOK)? Region.Location.INSIDE : Region.Location.OUTSIDE;Assert.assertEquals(expected,tree.checkPoint(new Vector3D(x,y,z)));}}}checkPoints(Region.Location.BOUNDARY,tree,new Vector3D[]{new Vector3D(0.0,0.5,0.5),new Vector3D(1.0,0.5,0.5),new Vector3D(0.5,0.0,0.5),new Vector3D(0.5,1.0,0.5),new Vector3D(0.5,0.5,0.0),new Vector3D(0.5,0.5,1.0)});checkPoints(Region.Location.OUTSIDE,tree,new Vector3D[]{new Vector3D(0.0,1.2,1.2),new Vector3D(1.0,1.2,1.2),new Vector3D(1.2,0.0,1.2),new Vector3D(1.2,1.0,1.2),new Vector3D(1.2,1.2,0.0),new Vector3D(1.2,1.2,1.0)});}
@Test public void testTetrahedron(){Vector3D vertex1=new Vector3D(1,2,3);Vector3D vertex2=new Vector3D(2,2,4);Vector3D vertex3=new Vector3D(2,3,3);Vector3D vertex4=new Vector3D(1,3,4);@SuppressWarnings("unchecked")PolyhedronsSet tree=(PolyhedronsSet)new RegionFactory<Euclidean3D>().buildConvex(new Plane(vertex3,vertex2,vertex1),new Plane(vertex2,vertex3,vertex4),new Plane(vertex4,vertex3,vertex1),new Plane(vertex1,vertex2,vertex4));Assert.assertEquals(1.0 / 3.0,tree.getSize(),1.0e-10);Assert.assertEquals(2.0 * FastMath.sqrt(3.0),tree.getBoundarySize(),1.0e-10);Vector3D barycenter=(Vector3D)tree.getBarycenter();Assert.assertEquals(1.5,barycenter.getX(),1.0e-10);Assert.assertEquals(2.5,barycenter.getY(),1.0e-10);Assert.assertEquals(3.5,barycenter.getZ(),1.0e-10);double third=1.0 / 3.0;checkPoints(Region.Location.BOUNDARY,tree,new Vector3D[]{vertex1,vertex2,vertex3,vertex4,new Vector3D(third,vertex1,third,vertex2,third,vertex3),new Vector3D(third,vertex2,third,vertex3,third,vertex4),new Vector3D(third,vertex3,third,vertex4,third,vertex1),new Vector3D(third,vertex4,third,vertex1,third,vertex2)});checkPoints(Region.Location.OUTSIDE,tree,new Vector3D[]{new Vector3D(1,2,4),new Vector3D(2,2,3),new Vector3D(2,3,4),new Vector3D(1,3,3)});}
@Test public void testIsometry(){Vector3D vertex1=new Vector3D(1.1,2.2,3.3);Vector3D vertex2=new Vector3D(2.0,2.4,4.2);Vector3D vertex3=new Vector3D(2.8,3.3,3.7);Vector3D vertex4=new Vector3D(1.0,3.6,4.5);@SuppressWarnings("unchecked")PolyhedronsSet tree=(PolyhedronsSet)new RegionFactory<Euclidean3D>().buildConvex(new Plane(vertex3,vertex2,vertex1),new Plane(vertex2,vertex3,vertex4),new Plane(vertex4,vertex3,vertex1),new Plane(vertex1,vertex2,vertex4));Vector3D barycenter=(Vector3D)tree.getBarycenter();Vector3D s=new Vector3D(10.2,4.3,-6.7);Vector3D c=new Vector3D(-0.2,2.1,-3.2);Rotation r=new Rotation(new Vector3D(6.2,-4.4,2.1),0.12);tree=tree.rotate(c,r).translate(s);Vector3D newB=new Vector3D(1.0,s,1.0,c,1.0,r.applyTo(barycenter.subtract(c)));Assert.assertEquals(0.0,newB.subtract(tree.getBarycenter()).getNorm(),1.0e-10);final Vector3D[]expectedV=new Vector3D[]{new Vector3D(1.0,s,1.0,c,1.0,r.applyTo(vertex1.subtract(c))),new Vector3D(1.0,s,1.0,c,1.0,r.applyTo(vertex2.subtract(c))),new Vector3D(1.0,s,1.0,c,1.0,r.applyTo(vertex3.subtract(c))),new Vector3D(1.0,s,1.0,c,1.0,r.applyTo(vertex4.subtract(c)))};tree.getTree(true).visit(new BSPTreeVisitor<Euclidean3D>(){public Order visitOrder(BSPTree<Euclidean3D> node){return Order.MINUS_SUB_PLUS;}public void visitInternalNode(BSPTree<Euclidean3D> node){@SuppressWarnings("unchecked")BoundaryAttribute<Euclidean3D> attribute=(BoundaryAttribute<Euclidean3D>)node.getAttribute();if (attribute.getPlusOutside()!= null){checkFacet((SubPlane)attribute.getPlusOutside());}if (attribute.getPlusInside()!= null){checkFacet((SubPlane)attribute.getPlusInside());}}public void visitLeafNode(BSPTree<Euclidean3D> node){}private void checkFacet(SubPlane facet){Plane plane=(Plane)facet.getHyperplane();Vector2D[][]vertices=((PolygonsSet)facet.getRemainingRegion()).getVertices();Assert.assertEquals(1,vertices.length);for (int i=0;i < vertices[0].length;++i){Vector3D v=plane.toSpace(vertices[0][i]);double d=Double.POSITIVE_INFINITY;for (int k=0;k < expectedV.length;++k){d=FastMath.min(d,v.subtract(expectedV[k]).getNorm());}Assert.assertEquals(0,d,1.0e-10);}}});}
@Test public void testBuildBox(){double x=1.0;double y=2.0;double z=3.0;double w=0.1;double l=1.0;PolyhedronsSet tree=new PolyhedronsSet(x - l,x + l,y - w,y + w,z - w,z + w);Vector3D barycenter=(Vector3D)tree.getBarycenter();Assert.assertEquals(x,barycenter.getX(),1.0e-10);Assert.assertEquals(y,barycenter.getY(),1.0e-10);Assert.assertEquals(z,barycenter.getZ(),1.0e-10);Assert.assertEquals(8 * l * w* w,tree.getSize(),1.0e-10);Assert.assertEquals(8 * w * (2 * l + w),tree.getBoundarySize(),1.0e-10);}
@Test public void testCross(){double x=1.0;double y=2.0;double z=3.0;double w=0.1;double l=1.0;PolyhedronsSet xBeam=new PolyhedronsSet(x - l,x + l,y - w,y + w,z - w,z + w);PolyhedronsSet yBeam=new PolyhedronsSet(x - w,x + w,y - l,y + l,z - w,z + w);PolyhedronsSet zBeam=new PolyhedronsSet(x - w,x + w,y - w,y + w,z - l,z + l);RegionFactory<Euclidean3D> factory=new RegionFactory<Euclidean3D>();PolyhedronsSet tree=(PolyhedronsSet)factory.union(xBeam,factory.union(yBeam,zBeam));Vector3D barycenter=(Vector3D)tree.getBarycenter();Assert.assertEquals(x,barycenter.getX(),1.0e-10);Assert.assertEquals(y,barycenter.getY(),1.0e-10);Assert.assertEquals(z,barycenter.getZ(),1.0e-10);Assert.assertEquals(8 * w * w* (3 * l - 2 * w),tree.getSize(),1.0e-10);Assert.assertEquals(24 * w * (2 * l - w),tree.getBoundarySize(),1.0e-10);}
/** * Test of polynomial for the linear function.*/@Test public void testLinearFunction(){PolynomialFunctionLagrangeForm p;double c[],z,expected,result,tolerance=1E-12;double x[]={0.0,3.0};double y[]={-4.0,0.5};p=new PolynomialFunctionLagrangeForm(x,y);z=2.0;expected=-1.0;result=p.value(z);Assert.assertEquals(expected,result,tolerance);z=4.5;expected=2.75;result=p.value(z);Assert.assertEquals(expected,result,tolerance);z=6.0;expected=5.0;result=p.value(z);Assert.assertEquals(expected,result,tolerance);Assert.assertEquals(1,p.degree());c=p.getCoefficients();Assert.assertEquals(2,c.length);Assert.assertEquals(-4.0,c[0],tolerance);Assert.assertEquals(1.5,c[1],tolerance);}
/** * Test of polynomial for the quadratic function.*/@Test public void testQuadraticFunction(){PolynomialFunctionLagrangeForm p;double c[],z,expected,result,tolerance=1E-12;double x[]={0.0,-1.0,0.5};double y[]={-3.0,-6.0,0.0};p=new PolynomialFunctionLagrangeForm(x,y);z=1.0;expected=4.0;result=p.value(z);Assert.assertEquals(expected,result,tolerance);z=2.5;expected=22.0;result=p.value(z);Assert.assertEquals(expected,result,tolerance);z=-2.0;expected=-5.0;result=p.value(z);Assert.assertEquals(expected,result,tolerance);Assert.assertEquals(2,p.degree());c=p.getCoefficients();Assert.assertEquals(3,c.length);Assert.assertEquals(-3.0,c[0],tolerance);Assert.assertEquals(5.0,c[1],tolerance);Assert.assertEquals(2.0,c[2],tolerance);}
/** * Test of polynomial for the quintic function.*/@Test public void testQuinticFunction(){PolynomialFunctionLagrangeForm p;double c[],z,expected,result,tolerance=1E-12;double x[]={1.0,-1.0,2.0,3.0,-3.0,0.5};double y[]={0.0,0.0,-24.0,0.0,-144.0,2.34375};p=new PolynomialFunctionLagrangeForm(x,y);z=0.0;expected=0.0;result=p.value(z);Assert.assertEquals(expected,result,tolerance);z=-2.0;expected=0.0;result=p.value(z);Assert.assertEquals(expected,result,tolerance);z=4.0;expected=360.0;result=p.value(z);Assert.assertEquals(expected,result,tolerance);Assert.assertEquals(5,p.degree());c=p.getCoefficients();Assert.assertEquals(6,c.length);Assert.assertEquals(0.0,c[0],tolerance);Assert.assertEquals(6.0,c[1],tolerance);Assert.assertEquals(1.0,c[2],tolerance);Assert.assertEquals(-7.0,c[3],tolerance);Assert.assertEquals(-1.0,c[4],tolerance);Assert.assertEquals(1.0,c[5],tolerance);}
/** * Test of parameters for the polynomial.*/@Test public void testParameters()throws Exception {try {double x[]={1.0};double y[]={2.0};new PolynomialFunctionLagrangeForm(x,y);Assert.fail("Expecting MathIllegalArgumentException - bad input array length");}catch(MathIllegalArgumentException ex){}try {double x[]={1.0,2.0,3.0,4.0};double y[]={0.0,-4.0,-24.0};new PolynomialFunctionLagrangeForm(x,y);Assert.fail("Expecting MathIllegalArgumentException - mismatch input arrays");}catch(MathIllegalArgumentException ex){}}
@Test(expected=ConvergenceException.class)public void testIssue631(){final UnivariateFunction f=new UnivariateFunction(){/** * {@inheritDoc}*/public double value(double x){return Math.exp(x)- Math.pow(Math.PI,3.0);}};final UnivariateRealSolver solver=new RegulaFalsiSolver();final double root=solver.solve(3624,f,1,10);Assert.assertEquals(3.4341896575482003,root,1e-15);}
@Test public void testSinZero(){UnivariateFunction f=new SinFunction();double result;UnivariateRealSolver solver=getSolver();result=solver.solve(100,f,3,4);Assert.assertEquals(result,FastMath.PI,solver.getAbsoluteAccuracy());Assert.assertTrue(solver.getEvaluations()<= 6);result=solver.solve(100,f,1,4);Assert.assertEquals(result,FastMath.PI,solver.getAbsoluteAccuracy());Assert.assertTrue(solver.getEvaluations()<= 7);}
@Test public void testQuinticZero(){UnivariateFunction f=new QuinticFunction();double result;UnivariateRealSolver solver=getSolver();double atol=solver.getAbsoluteAccuracy();int[]counts=getQuinticEvalCounts();double[][]testsData={{-0.2,0.2,0.0},{-0.1,0.3,0.0},{-0.3,0.45,0.0},{0.3,0.7,0.5},{0.2,0.6,0.5},{0.05,0.95,0.5},{0.85,1.25,1.0},{0.8,1.2,1.0},{0.85,1.75,1.0},{0.55,1.45,1.0},{0.85,5.0,1.0}};int maxIter=500;for (int i=0;i < testsData.length;i++){if (counts[i]== -1)continue;double[]testData=testsData[i];result=solver.solve(maxIter,f,testData[0],testData[1]);Assert.assertEquals(result,testData[2],atol);Assert.assertTrue(solver.getEvaluations()<= counts[i]+ 1);}}
@Test public void testRootEndpoints(){UnivariateFunction f=new XMinus5Function();UnivariateRealSolver solver=getSolver();double result=solver.solve(100,f,5.0,6.0);Assert.assertEquals(5.0,result,0.0);result=solver.solve(100,f,4.0,5.0);Assert.assertEquals(5.0,result,0.0);result=solver.solve(100,f,5.0,6.0,5.5);Assert.assertEquals(5.0,result,0.0);result=solver.solve(100,f,4.0,5.0,4.5);Assert.assertEquals(5.0,result,0.0);}
@Test public void testBadEndpoints(){UnivariateFunction f=new SinFunction();UnivariateRealSolver solver=getSolver();try {solver.solve(100,f,1,-1);Assert.fail("Expecting NumberIsTooLargeException - bad interval");}catch(NumberIsTooLargeException ex){}try {solver.solve(100,f,1,1.5);Assert.fail("Expecting NoBracketingException - non-bracketing");}catch(NoBracketingException ex){}try {solver.solve(100,f,1,1.5,1.2);Assert.fail("Expecting NoBracketingException - non-bracketing");}catch(NoBracketingException ex){}}
@Test public void testSolutionLeftSide(){UnivariateFunction f=new SinFunction();UnivariateRealSolver solver=getSolver();double left=-1.5;double right=0.05;for (int i=0;i < 10;i++){double solution=getSolution(solver,100,f,left,right,AllowedSolution.LEFT_SIDE);if (!Double.isNaN(solution)){Assert.assertTrue(solution <= 0.0);}left-=0.1;right+=0.3;}}
@Test public void testSolutionRightSide(){UnivariateFunction f=new SinFunction();UnivariateRealSolver solver=getSolver();double left=-1.5;double right=0.05;for (int i=0;i < 10;i++){double solution=getSolution(solver,100,f,left,right,AllowedSolution.RIGHT_SIDE);if (!Double.isNaN(solution)){Assert.assertTrue(solution >= 0.0);}left-=0.1;right+=0.3;}}
@Test public void testSolutionBelowSide(){UnivariateFunction f=new SinFunction();UnivariateRealSolver solver=getSolver();double left=-1.5;double right=0.05;for (int i=0;i < 10;i++){double solution=getSolution(solver,100,f,left,right,AllowedSolution.BELOW_SIDE);if (!Double.isNaN(solution)){Assert.assertTrue(f.value(solution)<= 0.0);}left-=0.1;right+=0.3;}}
@Test public void testSolutionAboveSide(){UnivariateFunction f=new SinFunction();UnivariateRealSolver solver=getSolver();double left=-1.5;double right=0.05;for (int i=0;i < 10;i++){double solution=getSolution(solver,100,f,left,right,AllowedSolution.ABOVE_SIDE);if (!Double.isNaN(solution)){Assert.assertTrue(f.value(solution)>= 0.0);}left-=0.1;right+=0.3;}}
public void saundersTest(final int n,final boolean goodb,final boolean precon,final double shift,final double pertbn){final RealLinearOperator a=new RealLinearOperator(){@Override public RealVector operate(final RealVector x){if (x.getDimension()!= n){throw new DimensionMismatchException(x.getDimension(),n);}final double[]y=new double[n];for (int i=0;i < n;i++){y[i]=(i + 1)* 1.1 / n * x.getEntry(i);}return new ArrayRealVector(y,false);}@Override public int getRowDimension(){return n;}@Override public int getColumnDimension(){return n;}};final double shiftm=shift;final double pertm=FastMath.abs(pertbn);final InvertibleRealLinearOperator m;if (precon){m=new InvertibleRealLinearOperator(){@Override public RealVector operate(final RealVector x){if (x.getDimension()!= n){throw new DimensionMismatchException(x.getDimension(),n);}final double[]y=new double[n];for (int i=0;i < n;i++){double d=(i + 1)* 1.1 / n;d=FastMath.abs(d - shiftm);if (i % 10 == 0){d+=pertm;}y[i]=d * x.getEntry(i);}return new ArrayRealVector(y,false);}@Override public int getRowDimension(){return n;}@Override public int getColumnDimension(){return n;}@Override public RealVector solve(final RealVector b){if (b.getDimension()!= n){throw new DimensionMismatchException(b.getDimension(),n);}final double[]x=new double[n];for (int i=0;i < n;i++){double d=(i + 1)* 1.1 / n;d=FastMath.abs(d - shiftm);if (i % 10 == 0){d+=pertm;}x[i]=b.getEntry(i)/ d;}return new ArrayRealVector(x,false);}};}else {m=null;}final RealVector xtrue=new ArrayRealVector(n);for (int i=0;i < n;i++){xtrue.setEntry(i,n - i);}final RealVector b=a.operate(xtrue);b.combineToSelf(1.0,-shift,xtrue);final SymmLQ solver=new SymmLQ(2 * n,1E-12,true);final RealVector x=solver.solve(a,m,b,goodb,shift);final RealVector y=a.operate(x);final RealVector r1=new ArrayRealVector(n);for (int i=0;i < n;i++){final double bi=b.getEntry(i);final double yi=y.getEntry(i);final double xi=x.getEntry(i);r1.setEntry(i,bi - yi + shift * xi);}final double enorm=x.subtract(xtrue).getNorm()/ xtrue.getNorm();final double etol=1E-5;Assert.assertTrue("enorm=" + enorm + ","+ solver.getIterationManager().getIterations(),enorm <= etol);}
@Test public void testSolveSaunders1(){saundersTest(1,false,false,0.,0.);}
@Test public void testSolveSaunders2(){saundersTest(2,false,false,0.,0.);}
@Test public void testSolveSaunders3(){saundersTest(1,false,true,0.,0.);}
@Test public void testSolveSaunders4(){saundersTest(2,false,true,0.,0.);}
@Test public void testSolveSaunders5(){saundersTest(5,false,true,0.,0.);}
@Test public void testSolveSaunders6(){saundersTest(5,false,true,0.25,0.);}
@Test public void testSolveSaunders7(){saundersTest(50,false,false,0.,0.);}
@Test public void testSolveSaunders8(){saundersTest(50,false,false,0.25,0.);}
@Test public void testSolveSaunders9(){saundersTest(50,false,true,0.,0.10);}
@Test public void testSolveSaunders10(){saundersTest(50,false,true,0.25,0.10);}
@Test public void testSolveSaunders11(){saundersTest(1,true,false,0.,0.);}
@Test public void testSolveSaunders12(){saundersTest(2,true,false,0.,0.);}
@Test public void testSolveSaunders13(){saundersTest(1,true,true,0.,0.);}
@Test public void testSolveSaunders14(){saundersTest(2,true,true,0.,0.);}
@Test public void testSolveSaunders15(){saundersTest(5,true,true,0.,0.);}
@Test public void testSolveSaunders16(){saundersTest(5,true,true,0.25,0.);}
@Test public void testSolveSaunders17(){saundersTest(50,true,false,0.,0.);}
@Test public void testSolveSaunders18(){saundersTest(50,true,false,0.25,0.);}
@Test public void testSolveSaunders19(){saundersTest(50,true,true,0.,0.10);}
@Test public void testSolveSaunders20(){saundersTest(50,true,true,0.25,0.10);}
@Test(expected=NonSquareOperatorException.class)public void testNonSquareOperator(){final Array2DRowRealMatrix a=new Array2DRowRealMatrix(2,3);final IterativeLinearSolver solver;solver=new SymmLQ(10,0.,false);final ArrayRealVector b=new ArrayRealVector(a.getRowDimension());final ArrayRealVector x=new ArrayRealVector(a.getColumnDimension());solver.solve(a,b,x);}
@Test(expected=DimensionMismatchException.class)public void testDimensionMismatchRightHandSide(){final Array2DRowRealMatrix a=new Array2DRowRealMatrix(3,3);final IterativeLinearSolver solver;solver=new SymmLQ(10,0.,false);final ArrayRealVector b=new ArrayRealVector(2);solver.solve(a,b);}
@Test(expected=DimensionMismatchException.class)public void testDimensionMismatchSolution(){final Array2DRowRealMatrix a=new Array2DRowRealMatrix(3,3);final IterativeLinearSolver solver;solver=new SymmLQ(10,0.,false);final ArrayRealVector b=new ArrayRealVector(3);final ArrayRealVector x=new ArrayRealVector(2);solver.solve(a,b,x);}
@Test public void testUnpreconditionedSolution(){final int n=5;final int maxIterations=100;final RealLinearOperator a=new HilbertMatrix(n);final InverseHilbertMatrix ainv=new InverseHilbertMatrix(n);final IterativeLinearSolver solver;solver=new SymmLQ(maxIterations,1E-10,true);final RealVector b=new ArrayRealVector(n);for (int j=0;j < n;j++){b.set(0.);b.setEntry(j,1.);final RealVector x=solver.solve(a,b);for (int i=0;i < n;i++){final double actual=x.getEntry(i);final double expected=ainv.getEntry(i,j);final double delta=1E-6 * Math.abs(expected);final String msg=String.format("entry[%d][%d]",i,j);Assert.assertEquals(msg,expected,actual,delta);}}}
@Test public void testUnpreconditionedInPlaceSolutionWithInitialGuess(){final int n=5;final int maxIterations=100;final RealLinearOperator a=new HilbertMatrix(n);final InverseHilbertMatrix ainv=new InverseHilbertMatrix(n);final IterativeLinearSolver solver;solver=new SymmLQ(maxIterations,1E-10,true);final RealVector b=new ArrayRealVector(n);for (int j=0;j < n;j++){b.set(0.);b.setEntry(j,1.);final RealVector x0=new ArrayRealVector(n);x0.set(1.);final RealVector x=solver.solveInPlace(a,b,x0);Assert.assertSame("x should be a reference to x0",x0,x);for (int i=0;i < n;i++){final double actual=x.getEntry(i);final double expected=ainv.getEntry(i,j);final double delta=1E-6 * Math.abs(expected);final String msg=String.format("entry[%d][%d)",i,j);Assert.assertEquals(msg,expected,actual,delta);}}}
@Test public void testUnpreconditionedSolutionWithInitialGuess(){final int n=5;final int maxIterations=100;final RealLinearOperator a=new HilbertMatrix(n);final InverseHilbertMatrix ainv=new InverseHilbertMatrix(n);final IterativeLinearSolver solver;solver=new SymmLQ(maxIterations,1E-10,true);final RealVector b=new ArrayRealVector(n);for (int j=0;j < n;j++){b.set(0.);b.setEntry(j,1.);final RealVector x0=new ArrayRealVector(n);x0.set(1.);final RealVector x=solver.solve(a,b,x0);Assert.assertNotSame("x should not be a reference to x0",x0,x);for (int i=0;i < n;i++){final double actual=x.getEntry(i);final double expected=ainv.getEntry(i,j);final double delta=1E-6 * Math.abs(expected);final String msg=String.format("entry[%d][%d]",i,j);Assert.assertEquals(msg,expected,actual,delta);Assert.assertEquals(msg,x0.getEntry(i),1.,Math.ulp(1.));}}}
@Test(expected=NonSquareOperatorException.class)public void testNonSquarePreconditioner(){final Array2DRowRealMatrix a=new Array2DRowRealMatrix(2,2);final InvertibleRealLinearOperator m;m=new InvertibleRealLinearOperator(){@Override public RealVector operate(final RealVector x){throw new UnsupportedOperationException();}@Override public int getRowDimension(){return 2;}@Override public int getColumnDimension(){return 3;}@Override public RealVector solve(final RealVector b){throw new UnsupportedOperationException();}};final PreconditionedIterativeLinearSolver solver;solver=new SymmLQ(10,0.,false);final ArrayRealVector b=new ArrayRealVector(a.getRowDimension());solver.solve(a,m,b);}
@Test(expected=DimensionMismatchException.class)public void testMismatchedOperatorDimensions(){final Array2DRowRealMatrix a=new Array2DRowRealMatrix(2,2);final InvertibleRealLinearOperator m;m=new InvertibleRealLinearOperator(){@Override public RealVector operate(final RealVector x){throw new UnsupportedOperationException();}@Override public int getRowDimension(){return 3;}@Override public int getColumnDimension(){return 3;}@Override public RealVector solve(final RealVector b){throw new UnsupportedOperationException();}};final PreconditionedIterativeLinearSolver solver;solver=new SymmLQ(10,0d,false);final ArrayRealVector b=new ArrayRealVector(a.getRowDimension());solver.solve(a,m,b);}
@Test(expected=NonPositiveDefiniteOperatorException.class)public void testNonPositiveDefinitePreconditioner(){final Array2DRowRealMatrix a=new Array2DRowRealMatrix(2,2);a.setEntry(0,0,1d);a.setEntry(0,1,2d);a.setEntry(1,0,3d);a.setEntry(1,1,4d);final InvertibleRealLinearOperator m;m=new InvertibleRealLinearOperator(){@Override public RealVector operate(final RealVector x){final ArrayRealVector y=new ArrayRealVector(2);y.setEntry(0,-x.getEntry(0));y.setEntry(1,-x.getEntry(1));return y;}@Override public int getRowDimension(){return 2;}@Override public int getColumnDimension(){return 2;}@Override public RealVector solve(final RealVector b){final ArrayRealVector x=new ArrayRealVector(2);x.setEntry(0,-b.getEntry(0));x.setEntry(1,-b.getEntry(1));return x;}};final PreconditionedIterativeLinearSolver solver;solver=new SymmLQ(10,0d,true);final ArrayRealVector b=new ArrayRealVector(2);b.setEntry(0,-1d);b.setEntry(1,-1d);solver.solve(a,m,b);}
@Test public void testPreconditionedSolution(){final int n=8;final int maxIterations=100;final RealLinearOperator a=new HilbertMatrix(n);final InverseHilbertMatrix ainv=new InverseHilbertMatrix(n);final InvertibleRealLinearOperator m=JacobiPreconditioner.create(a);final PreconditionedIterativeLinearSolver solver;solver=new SymmLQ(maxIterations,1E-15,true);final RealVector b=new ArrayRealVector(n);for (int j=0;j < n;j++){b.set(0.);b.setEntry(j,1.);final RealVector x=solver.solve(a,m,b);for (int i=0;i < n;i++){final double actual=x.getEntry(i);final double expected=ainv.getEntry(i,j);final double delta=1E-6 * Math.abs(expected);final String msg=String.format("coefficient (%d,%d)",i,j);Assert.assertEquals(msg,expected,actual,delta);}}}
@Test public void testPreconditionedSolution2(){final int n=100;final int maxIterations=100000;final Array2DRowRealMatrix a=new Array2DRowRealMatrix(n,n);double daux=1.;for (int i=0;i < n;i++){a.setEntry(i,i,daux);daux*=1.2;for (int j=i + 1;j < n;j++){if (i == j){}else {final double value=1.0;a.setEntry(i,j,value);a.setEntry(j,i,value);}}}final InvertibleRealLinearOperator m=JacobiPreconditioner.create(a);final PreconditionedIterativeLinearSolver prec;final IterativeLinearSolver unprec;prec=new SymmLQ(maxIterations,1E-15,true);unprec=new SymmLQ(maxIterations,1E-15,true);final RealVector b=new ArrayRealVector(n);final String pattern="preconditioned SymmLQ (%d iterations)should" + " have been faster than unpreconditioned (%d iterations)";String msg;for (int j=0;j < 1;j++){b.set(0.);b.setEntry(j,1.);final RealVector px=prec.solve(a,m,b);final RealVector x=unprec.solve(a,b);final int npcg=prec.getIterationManager().getIterations();final int ncg=unprec.getIterationManager().getIterations();msg=String.format(pattern,npcg,ncg);Assert.assertTrue(msg,npcg < ncg);for (int i=0;i < n;i++){msg=String.format("row %d,column %d",i,j);final double expected=x.getEntry(i);final double actual=px.getEntry(i);final double delta=5E-5 * Math.abs(expected);Assert.assertEquals(msg,expected,actual,delta);}}}
@Test public void testEventManagement(){final int n=5;final int maxIterations=100;final RealLinearOperator a=new HilbertMatrix(n);final IterativeLinearSolver solver;final int[]count=new int[]{0,0,0,0};final IterationListener listener=new IterationListener(){public void initializationPerformed(final IterationEvent e){count[0]=1;count[1]=0;count[2]=0;count[3]=0;}public void iterationPerformed(final IterationEvent e){++count[2];}public void iterationStarted(final IterationEvent e){++count[1];}public void terminationPerformed(final IterationEvent e){++count[3];}};solver=new SymmLQ(maxIterations,1E-10,true);solver.getIterationManager().addIterationListener(listener);final RealVector b=new ArrayRealVector(n);for (int j=0;j < n;j++){b.set(0.);b.setEntry(j,1.);solver.solve(a,b);String msg=String.format("column %d (initialization)",j);Assert.assertEquals(msg,1,count[0]);msg=String.format("column %d (iterations started)",j);Assert.assertEquals(msg,solver.getIterationManager().getIterations()- 1,count[1]);msg=String.format("column %d (iterations performed)",j);Assert.assertEquals(msg,solver.getIterationManager().getIterations()- 1,count[2]);msg=String.format("column %d (finalization)",j);Assert.assertEquals(msg,1,count[3]);}}
@Test(expected=NonSelfAdjointOperatorException.class)public void testNonSelfAdjointOperator(){final RealLinearOperator a;a=new Array2DRowRealMatrix(new double[][]{{1.,2.,3.},{2.,4.,5.},{2.999,5.,6.}});final RealVector b;b=new ArrayRealVector(new double[]{1.,1.,1.});new SymmLQ(100,1.,true).solve(a,b);}
@Test(expected=NonSelfAdjointOperatorException.class)public void testNonSelfAdjointPreconditioner(){final RealLinearOperator a=new Array2DRowRealMatrix(new double[][]{{1.,2.,3.},{2.,4.,5.},{3.,5.,6.}});final Array2DRowRealMatrix mMat;mMat=new Array2DRowRealMatrix(new double[][]{{1.,0.,1.},{0.,1.,0.},{0.,0.,1.}});final DecompositionSolver mSolver;mSolver=new LUDecomposition(mMat).getSolver();final InvertibleRealLinearOperator m;m=new InvertibleRealLinearOperator(){@Override public RealVector operate(final RealVector x){return mMat.operate(x);}@Override public int getRowDimension(){return mMat.getRowDimension();}@Override public int getColumnDimension(){return mMat.getColumnDimension();}@Override public RealVector solve(final RealVector b){return mSolver.solve(b);}};final RealVector b=new ArrayRealVector(new double[]{1.,1.,1.});new SymmLQ(100,1.,true).solve(a,m,b);}
@Test public void testDimension1(){RealMatrix matrix=MatrixUtils.createRealMatrix(new double[][]{{1.5}});EigenDecomposition ed;ed=new EigenDecomposition(matrix,Precision.SAFE_MIN);Assert.assertEquals(1.5,ed.getRealEigenvalue(0),1.0e-15);}
@Test public void testDimension2(){RealMatrix matrix=MatrixUtils.createRealMatrix(new double[][]{{59.0,12.0},{12.0,66.0}});EigenDecomposition ed;ed=new EigenDecomposition(matrix,Precision.SAFE_MIN);Assert.assertEquals(75.0,ed.getRealEigenvalue(0),1.0e-15);Assert.assertEquals(50.0,ed.getRealEigenvalue(1),1.0e-15);}
@Test public void testDimension3(){RealMatrix matrix=MatrixUtils.createRealMatrix(new double[][]{{39632.0,-4824.0,-16560.0},{-4824.0,8693.0,7920.0},{-16560.0,7920.0,17300.0}});EigenDecomposition ed;ed=new EigenDecomposition(matrix,Precision.SAFE_MIN);Assert.assertEquals(50000.0,ed.getRealEigenvalue(0),3.0e-11);Assert.assertEquals(12500.0,ed.getRealEigenvalue(1),3.0e-11);Assert.assertEquals(3125.0,ed.getRealEigenvalue(2),3.0e-11);}
@Test public void testDimension3MultipleRoot(){RealMatrix matrix=MatrixUtils.createRealMatrix(new double[][]{{5,10,15},{10,20,30},{15,30,45}});EigenDecomposition ed;ed=new EigenDecomposition(matrix,Precision.SAFE_MIN);Assert.assertEquals(70.0,ed.getRealEigenvalue(0),3.0e-11);Assert.assertEquals(0.0,ed.getRealEigenvalue(1),3.0e-11);Assert.assertEquals(0.0,ed.getRealEigenvalue(2),3.0e-11);}
@Test public void testDimension4WithSplit(){RealMatrix matrix=MatrixUtils.createRealMatrix(new double[][]{{0.784,-0.288,0.000,0.000},{-0.288,0.616,0.000,0.000},{0.000,0.000,0.164,-0.048},{0.000,0.000,-0.048,0.136}});EigenDecomposition ed;ed=new EigenDecomposition(matrix,Precision.SAFE_MIN);Assert.assertEquals(1.0,ed.getRealEigenvalue(0),1.0e-15);Assert.assertEquals(0.4,ed.getRealEigenvalue(1),1.0e-15);Assert.assertEquals(0.2,ed.getRealEigenvalue(2),1.0e-15);Assert.assertEquals(0.1,ed.getRealEigenvalue(3),1.0e-15);}
@Test public void testDimension4WithoutSplit(){RealMatrix matrix=MatrixUtils.createRealMatrix(new double[][]{{0.5608,-0.2016,0.1152,-0.2976},{-0.2016,0.4432,-0.2304,0.1152},{0.1152,-0.2304,0.3088,-0.1344},{-0.2976,0.1152,-0.1344,0.3872}});EigenDecomposition ed;ed=new EigenDecomposition(matrix,Precision.SAFE_MIN);Assert.assertEquals(1.0,ed.getRealEigenvalue(0),1.0e-15);Assert.assertEquals(0.4,ed.getRealEigenvalue(1),1.0e-15);Assert.assertEquals(0.2,ed.getRealEigenvalue(2),1.0e-15);Assert.assertEquals(0.1,ed.getRealEigenvalue(3),1.0e-15);}
@Test public void testMath308(){double[]mainTridiagonal={22.330154644539597,46.65485522478641,17.393672330044705,54.46687435351116,80.17800767709437};double[]secondaryTridiagonal={13.04450406501361,-5.977590941539671,2.9040909856707517,7.1570352792841225};double[]refEigenValues={82.044413207204002,53.456697699894512,52.536278520113882,18.847969733754262,14.138204224043099};RealVector[]refEigenVectors={new ArrayRealVector(new double[]{-0.000462690386766,-0.002118073109055,0.011530080757413,0.252322434584915,0.967572088232592}),new ArrayRealVector(new double[]{0.314647769490148,0.750806415553905,-0.167700312025760,-0.537092972407375,0.143854968127780}),new ArrayRealVector(new double[]{0.222368839324646,0.514921891363332,-0.021377019336614,0.801196801016305,-0.207446991247740}),new ArrayRealVector(new double[]{-0.713933751051495,0.190582113553930,-0.671410443368332,0.056056055955050,-0.006541576993581}),new ArrayRealVector(new double[]{-0.584677060845929,0.367177264979103,0.721453187784497,-0.052971054621812,0.005740715188257})};EigenDecomposition decomposition;decomposition=new EigenDecomposition(mainTridiagonal,secondaryTridiagonal,Precision.SAFE_MIN);double[]eigenValues=decomposition.getRealEigenvalues();for (int i=0;i < refEigenValues.length;++i){Assert.assertEquals(refEigenValues[i],eigenValues[i],1.0e-5);Assert.assertEquals(0,refEigenVectors[i].subtract(decomposition.getEigenvector(i)).getNorm(),2.0e-7);}}
@Test public void testMathpbx02(){double[]mainTridiagonal={7484.860960227216,18405.28129035345,13855.225609560746,10016.708722343366,559.8117399576674,6750.190788301587,71.21428769782159};double[]secondaryTridiagonal={-4175.088570476366,1975.7955858241994,5193.178422374075,1995.286659169179,75.34535882933804,-234.0808002076056};double[]refEigenValues={20654.744890306974412,16828.208208485466457,6893.155912634994820,6757.083016675340332,5887.799885688558788,64.309089923240379,57.992628792736340};RealVector[]refEigenVectors={new ArrayRealVector(new double[]{-0.270356342026904,0.852811091326997,0.399639490702077,0.198794657813990,0.019739323307666,0.000106983022327,-0.000001216636321}),new ArrayRealVector(new double[]{0.179995273578326,-0.402807848153042,0.701870993525734,0.555058211014888,0.068079148898236,0.000509139115227,-0.000007112235617}),new ArrayRealVector(new double[]{-0.399582721284727,-0.056629954519333,-0.514406488522827,0.711168164518580,0.225548081276367,0.125943999652923,-0.004321507456014}),new ArrayRealVector(new double[]{0.058515721572821,0.010200130057739,0.063516274916536,-0.090696087449378,-0.017148420432597,0.991318870265707,-0.034707338554096}),new ArrayRealVector(new double[]{0.855205995537564,0.327134656629775,-0.265382397060548,0.282690729026706,0.105736068025572,-0.009138126622039,0.000367751821196}),new ArrayRealVector(new double[]{-0.002913069901144,-0.005177515777101,0.041906334478672,-0.109315918416258,0.436192305456741,0.026307315639535,0.891797507436344}),new ArrayRealVector(new double[]{-0.005738311176435,-0.010207611670378,0.082662420517928,-0.215733886094368,0.861606487840411,-0.025478530652759,-0.451080697503958})};EigenDecomposition decomposition;decomposition=new EigenDecomposition(mainTridiagonal,secondaryTridiagonal,Precision.SAFE_MIN);double[]eigenValues=decomposition.getRealEigenvalues();for (int i=0;i < refEigenValues.length;++i){Assert.assertEquals(refEigenValues[i],eigenValues[i],1.0e-3);if (refEigenVectors[i].dotProduct(decomposition.getEigenvector(i))< 0){Assert.assertEquals(0,refEigenVectors[i].add(decomposition.getEigenvector(i)).getNorm(),1.0e-5);}else {Assert.assertEquals(0,refEigenVectors[i].subtract(decomposition.getEigenvector(i)).getNorm(),1.0e-5);}}}
@Test public void testMathpbx03(){double[]mainTridiagonal={1809.0978259647177,3395.4763425956166,1832.1894584712693,3804.364873592377,806.0482458637571,2403.656427234185,28.48691431556015};double[]secondaryTridiagonal={-656.8932064545833,-469.30804108920734,-1021.7714889369421,-1152.540497328983,-939.9765163817368,-12.885877015422391};double[]refEigenValues={4603.121913685183245,3691.195818048970978,2743.442955402465032,1657.596442107321764,1336.797819095331306,30.129865209677519,17.035352085224986};RealVector[]refEigenVectors={new ArrayRealVector(new double[]{-0.036249830202337,0.154184732411519,-0.346016328392363,0.867540105133093,-0.294483395433451,0.125854235969548,-0.000354507444044}),new ArrayRealVector(new double[]{-0.318654191697157,0.912992309960507,-0.129270874079777,-0.184150038178035,0.096521712579439,-0.070468788536461,0.000247918177736}),new ArrayRealVector(new double[]{-0.051394668681147,0.073102235876933,0.173502042943743,-0.188311980310942,-0.327158794289386,0.905206581432676,-0.004296342252659}),new ArrayRealVector(new double[]{0.838150199198361,0.193305209055716,-0.457341242126146,-0.166933875895419,0.094512811358535,0.119062381338757,-0.000941755685226}),new ArrayRealVector(new double[]{0.438071395458547,0.314969169786246,0.768480630802146,0.227919171600705,-0.193317045298647,-0.170305467485594,0.001677380536009}),new ArrayRealVector(new double[]{-0.003726503878741,-0.010091946369146,-0.067152015137611,-0.113798146542187,-0.313123000097908,-0.118940107954918,0.932862311396062}),new ArrayRealVector(new double[]{0.009373003194332,0.025570377559400,0.170955836081348,0.291954519805750,0.807824267665706,0.320108347088646,0.360202112392266})};EigenDecomposition decomposition;decomposition=new EigenDecomposition(mainTridiagonal,secondaryTridiagonal,Precision.SAFE_MIN);double[]eigenValues=decomposition.getRealEigenvalues();for (int i=0;i < refEigenValues.length;++i){Assert.assertEquals(refEigenValues[i],eigenValues[i],1.0e-4);if (refEigenVectors[i].dotProduct(decomposition.getEigenvector(i))< 0){Assert.assertEquals(0,refEigenVectors[i].add(decomposition.getEigenvector(i)).getNorm(),1.0e-5);}else {Assert.assertEquals(0,refEigenVectors[i].subtract(decomposition.getEigenvector(i)).getNorm(),1.0e-5);}}}
/** * test a matrix already in tridiagonal form. */@Test public void testTridiagonal(){Random r=new Random(4366663527842l);double[]ref=new double[30];for (int i=0;i < ref.length;++i){if (i < 5){ref[i]=2 * r.nextDouble()- 1;}else {ref[i]=0.0001 * r.nextDouble()+ 6;}}Arrays.sort(ref);TriDiagonalTransformer t=new TriDiagonalTransformer(createTestMatrix(r,ref));EigenDecomposition ed;ed=new EigenDecomposition(t.getMainDiagonalRef(),t.getSecondaryDiagonalRef(),Precision.SAFE_MIN);double[]eigenValues=ed.getRealEigenvalues();Assert.assertEquals(ref.length,eigenValues.length);for (int i=0;i < ref.length;++i){Assert.assertEquals(ref[ref.length - i - 1],eigenValues[i],2.0e-14);}}
/** * test dimensions */@Test public void testDimensions(){final int m=matrix.getRowDimension();EigenDecomposition ed;ed=new EigenDecomposition(matrix,Precision.SAFE_MIN);Assert.assertEquals(m,ed.getV().getRowDimension());Assert.assertEquals(m,ed.getV().getColumnDimension());Assert.assertEquals(m,ed.getD().getColumnDimension());Assert.assertEquals(m,ed.getD().getColumnDimension());Assert.assertEquals(m,ed.getVT().getRowDimension());Assert.assertEquals(m,ed.getVT().getColumnDimension());}
/** * test eigenvalues */@Test public void testEigenvalues(){EigenDecomposition ed;ed=new EigenDecomposition(matrix,Precision.SAFE_MIN);double[]eigenValues=ed.getRealEigenvalues();Assert.assertEquals(refValues.length,eigenValues.length);for (int i=0;i < refValues.length;++i){Assert.assertEquals(refValues[i],eigenValues[i],3.0e-15);}}
/** * test eigenvalues for a big matrix. */@Test public void testBigMatrix(){Random r=new Random(17748333525117l);double[]bigValues=new double[200];for (int i=0;i < bigValues.length;++i){bigValues[i]=2 * r.nextDouble()- 1;}Arrays.sort(bigValues);EigenDecomposition ed;ed=new EigenDecomposition(createTestMatrix(r,bigValues),Precision.SAFE_MIN);double[]eigenValues=ed.getRealEigenvalues();Assert.assertEquals(bigValues.length,eigenValues.length);for (int i=0;i < bigValues.length;++i){Assert.assertEquals(bigValues[bigValues.length - i - 1],eigenValues[i],2.0e-14);}}
/** * test eigenvectors */@Test public void testEigenvectors(){EigenDecomposition ed;ed=new EigenDecomposition(matrix,Precision.SAFE_MIN);for (int i=0;i < matrix.getRowDimension();++i){double lambda=ed.getRealEigenvalue(i);RealVector v=ed.getEigenvector(i);RealVector mV=matrix.operate(v);Assert.assertEquals(0,mV.subtract(v.mapMultiplyToSelf(lambda)).getNorm(),1.0e-13);}}
/** * test A = VDVt */@Test public void testAEqualVDVt(){EigenDecomposition ed;ed=new EigenDecomposition(matrix,Precision.SAFE_MIN);RealMatrix v=ed.getV();RealMatrix d=ed.getD();RealMatrix vT=ed.getVT();double norm=v.multiply(d).multiply(vT).subtract(matrix).getNorm();Assert.assertEquals(0,norm,6.0e-13);}
/** * test that V is orthogonal */@Test public void testVOrthogonal(){RealMatrix v=new EigenDecomposition(matrix,Precision.SAFE_MIN).getV();RealMatrix vTv=v.transpose().multiply(v);RealMatrix id=MatrixUtils.createRealIdentityMatrix(vTv.getRowDimension());Assert.assertEquals(0,vTv.subtract(id).getNorm(),2.0e-13);}
/** * test diagonal matrix */@Test public void testDiagonal(){double[]diagonal=new double[]{-3.0,-2.0,2.0,5.0};RealMatrix m=createDiagonalMatrix(diagonal,diagonal.length,diagonal.length);EigenDecomposition ed;ed=new EigenDecomposition(m,Precision.SAFE_MIN);Assert.assertEquals(diagonal[0],ed.getRealEigenvalue(3),2.0e-15);Assert.assertEquals(diagonal[1],ed.getRealEigenvalue(2),2.0e-15);Assert.assertEquals(diagonal[2],ed.getRealEigenvalue(1),2.0e-15);Assert.assertEquals(diagonal[3],ed.getRealEigenvalue(0),2.0e-15);}
/** * Matrix with eigenvalues {8,-1,-1}*/@Test public void testRepeatedEigenvalue(){RealMatrix repeated=MatrixUtils.createRealMatrix(new double[][]{{3,2,4},{2,0,2},{4,2,3}});EigenDecomposition ed;ed=new EigenDecomposition(repeated,Precision.SAFE_MIN);checkEigenValues((new double[]{8,-1,-1}),ed,1E-12);checkEigenVector((new double[]{2,1,2}),ed,1E-12);}
/** * Matrix with eigenvalues {2,0,12}*/@Test public void testDistinctEigenvalues(){RealMatrix distinct=MatrixUtils.createRealMatrix(new double[][]{{3,1,-4},{1,3,-4},{-4,-4,8}});EigenDecomposition ed;ed=new EigenDecomposition(distinct,Precision.SAFE_MIN);checkEigenValues((new double[]{2,0,12}),ed,1E-12);checkEigenVector((new double[]{1,-1,0}),ed,1E-12);checkEigenVector((new double[]{1,1,1}),ed,1E-12);checkEigenVector((new double[]{-1,-1,2}),ed,1E-12);}
/** * Verifies operation on indefinite matrix*/@Test public void testZeroDivide(){RealMatrix indefinite=MatrixUtils.createRealMatrix(new double[][]{{0.0,1.0,-1.0},{1.0,1.0,0.0},{-1.0,0.0,1.0}});EigenDecomposition ed;ed=new EigenDecomposition(indefinite,Precision.SAFE_MIN);checkEigenValues((new double[]{2,1,-1}),ed,1E-12);double isqrt3=1 / FastMath.sqrt(3.0);checkEigenVector((new double[]{isqrt3,isqrt3,-isqrt3}),ed,1E-12);double isqrt2=1 / FastMath.sqrt(2.0);checkEigenVector((new double[]{0.0,-isqrt2,-isqrt2}),ed,1E-12);double isqrt6=1 / FastMath.sqrt(6.0);checkEigenVector((new double[]{2 * isqrt6,-isqrt6,isqrt6}),ed,1E-12);}
@Test public void noReset(){double[]y={0.0,1.0,-2.0};double[][]yDot={{1.0,2.0,-2.0}};EulerStepInterpolator interpolator=new EulerStepInterpolator();interpolator.reinitialize(new DummyIntegrator(interpolator),y,yDot,true,new EquationsMapper(0,y.length),new EquationsMapper[0]);interpolator.storeTime(0);interpolator.shift();interpolator.storeTime(1);double[]result=interpolator.getInterpolatedState();for (int i=0;i < result.length;++i){Assert.assertTrue(FastMath.abs(result[i]- y[i])< 1.0e-10);}}
@Test public void interpolationAtBounds(){double t0=0;double[]y0={0.0,1.0,-2.0};double[]y=y0.clone();double[][]yDot={new double[y0.length]};EulerStepInterpolator interpolator=new EulerStepInterpolator();interpolator.reinitialize(new DummyIntegrator(interpolator),y,yDot,true,new EquationsMapper(0,y.length),new EquationsMapper[0]);interpolator.storeTime(t0);double dt=1.0;interpolator.shift();y[0]=1.0;y[1]=3.0;y[2]=-4.0;yDot[0][0]=(y[0]- y0[0])/ dt;yDot[0][1]=(y[1]- y0[1])/ dt;yDot[0][2]=(y[2]- y0[2])/ dt;interpolator.storeTime(t0 + dt);interpolator.setInterpolatedTime(interpolator.getPreviousTime());double[]result=interpolator.getInterpolatedState();for (int i=0;i < result.length;++i){Assert.assertTrue(FastMath.abs(result[i]- y0[i])< 1.0e-10);}interpolator.setInterpolatedTime(interpolator.getCurrentTime());result=interpolator.getInterpolatedState();for (int i=0;i < result.length;++i){Assert.assertTrue(FastMath.abs(result[i]- y[i])< 1.0e-10);}}
@Test public void interpolationInside(){double[]y={0.0,1.0,-2.0};double[][]yDot={{1.0,2.0,-2.0}};EulerStepInterpolator interpolator=new EulerStepInterpolator();interpolator.reinitialize(new DummyIntegrator(interpolator),y,yDot,true,new EquationsMapper(0,y.length),new EquationsMapper[0]);interpolator.storeTime(0);interpolator.shift();y[0]=1.0;y[1]=3.0;y[2]=-4.0;interpolator.storeTime(1);interpolator.setInterpolatedTime(0.1);double[]result=interpolator.getInterpolatedState();Assert.assertTrue(FastMath.abs(result[0]- 0.1)< 1.0e-10);Assert.assertTrue(FastMath.abs(result[1]- 1.2)< 1.0e-10);Assert.assertTrue(FastMath.abs(result[2]+ 2.2)< 1.0e-10);interpolator.setInterpolatedTime(0.5);result=interpolator.getInterpolatedState();Assert.assertTrue(FastMath.abs(result[0]- 0.5)< 1.0e-10);Assert.assertTrue(FastMath.abs(result[1]- 2.0)< 1.0e-10);Assert.assertTrue(FastMath.abs(result[2]+ 3.0)< 1.0e-10);}
@Test public void derivativesConsistency(){TestProblem3 pb=new TestProblem3();double step=(pb.getFinalTime()- pb.getInitialTime())* 0.001;EulerIntegrator integ=new EulerIntegrator(step);StepInterpolatorTestUtils.checkDerivativesConsistency(integ,pb,1.0e-10);}
@Test public void serialization()throws IOException,ClassNotFoundException {TestProblem1 pb=new TestProblem1();double step=(pb.getFinalTime()- pb.getInitialTime())* 0.001;EulerIntegrator integ=new EulerIntegrator(step);integ.addStepHandler(new ContinuousOutputModel());integ.integrate(pb,pb.getInitialTime(),pb.getInitialState(),pb.getFinalTime(),new double[pb.getDimension()]);ByteArrayOutputStream bos=new ByteArrayOutputStream();ObjectOutputStream oos=new ObjectOutputStream(bos);for(StepHandler handler : integ.getStepHandlers()){oos.writeObject(handler);}ByteArrayInputStream bis=new ByteArrayInputStream(bos.toByteArray());ObjectInputStream ois=new ObjectInputStream(bis);ContinuousOutputModel cm=(ContinuousOutputModel)ois.readObject();Random random=new Random(347588535632l);double maxError=0.0;for (int i=0;i < 1000;++i){double r=random.nextDouble();double time=r * pb.getInitialTime()+ (1.0 - r)* pb.getFinalTime();cm.setInterpolatedTime(time);double[]interpolatedY=cm.getInterpolatedState();double[]theoreticalY=pb.computeTheoreticalState(time);double dx=interpolatedY[0]- theoreticalY[0];double dy=interpolatedY[1]- theoreticalY[1];double error=dx * dx + dy * dy;if (error > maxError){maxError=error;}}Assert.assertTrue(maxError < 0.001);}
@Test public void testLowAccuracyExternalDifferentiation(){FirstOrderIntegrator integ=new DormandPrince54Integrator(1.0e-8,100.0,new double[]{1.0e-4,1.0e-4},new double[]{1.0e-4,1.0e-4});double hP=1.0e-12;SummaryStatistics residualsP0=new SummaryStatistics();SummaryStatistics residualsP1=new SummaryStatistics();for (double b=2.88;b < 3.08;b+=0.001){Brusselator brusselator=new Brusselator(b);double[]y={1.3,b};integ.integrate(brusselator,0,y,20.0,y);double[]yP={1.3,b + hP};integ.integrate(brusselator,0,yP,20.0,yP);residualsP0.addValue((yP[0]- y[0])/ hP - brusselator.dYdP0());residualsP1.addValue((yP[1]- y[1])/ hP - brusselator.dYdP1());}Assert.assertTrue((residualsP0.getMax()- residualsP0.getMin())> 500);Assert.assertTrue(residualsP0.getStandardDeviation()> 30);Assert.assertTrue((residualsP1.getMax()- residualsP1.getMin())> 700);Assert.assertTrue(residualsP1.getStandardDeviation()> 40);}
@Test public void testHighAccuracyExternalDifferentiation(){FirstOrderIntegrator integ=new DormandPrince54Integrator(1.0e-8,100.0,new double[]{1.0e-10,1.0e-10},new double[]{1.0e-10,1.0e-10});double hP=1.0e-12;SummaryStatistics residualsP0=new SummaryStatistics();SummaryStatistics residualsP1=new SummaryStatistics();for (double b=2.88;b < 3.08;b+=0.001){ParamBrusselator brusselator=new ParamBrusselator(b);double[]y={1.3,b};integ.integrate(brusselator,0,y,20.0,y);double[]yP={1.3,b + hP};brusselator.setParameter("b",b + hP);integ.integrate(brusselator,0,yP,20.0,yP);residualsP0.addValue((yP[0]- y[0])/ hP - brusselator.dYdP0());residualsP1.addValue((yP[1]- y[1])/ hP - brusselator.dYdP1());}Assert.assertTrue((residualsP0.getMax()- residualsP0.getMin())> 0.02);Assert.assertTrue((residualsP0.getMax()- residualsP0.getMin())< 0.03);Assert.assertTrue(residualsP0.getStandardDeviation()> 0.003);Assert.assertTrue(residualsP0.getStandardDeviation()< 0.004);Assert.assertTrue((residualsP1.getMax()- residualsP1.getMin())> 0.04);Assert.assertTrue((residualsP1.getMax()- residualsP1.getMin())< 0.05);Assert.assertTrue(residualsP1.getStandardDeviation()> 0.007);Assert.assertTrue(residualsP1.getStandardDeviation()< 0.008);}
@Test public void testInternalDifferentiation(){AbstractIntegrator integ=new DormandPrince54Integrator(1.0e-8,100.0,new double[]{1.0e-4,1.0e-4},new double[]{1.0e-4,1.0e-4});double hP=1.0e-12;double hY=1.0e-12;SummaryStatistics residualsP0=new SummaryStatistics();SummaryStatistics residualsP1=new SummaryStatistics();for (double b=2.88;b < 3.08;b+=0.001){ParamBrusselator brusselator=new ParamBrusselator(b);brusselator.setParameter(ParamBrusselator.B,b);double[]z={1.3,b};double[][]dZdZ0=new double[2][2];double[]dZdP=new double[2];JacobianMatrices jacob=new JacobianMatrices(brusselator,new double[]{hY,hY},ParamBrusselator.B);jacob.setParameterizedODE(brusselator);jacob.setParameterStep(ParamBrusselator.B,hP);jacob.setInitialParameterJacobian(ParamBrusselator.B,new double[]{0.0,1.0});ExpandableStatefulODE efode=new ExpandableStatefulODE(brusselator);efode.setTime(0);efode.setPrimaryState(z);jacob.registerVariationalEquations(efode);integ.setMaxEvaluations(5000);integ.integrate(efode,20.0);jacob.getCurrentMainSetJacobian(dZdZ0);jacob.getCurrentParameterJacobian(ParamBrusselator.B,dZdP);residualsP0.addValue(dZdP[0]- brusselator.dYdP0());residualsP1.addValue(dZdP[1]- brusselator.dYdP1());}Assert.assertTrue((residualsP0.getMax()- residualsP0.getMin())< 0.02);Assert.assertTrue(residualsP0.getStandardDeviation()< 0.003);Assert.assertTrue((residualsP1.getMax()- residualsP1.getMin())< 0.05);Assert.assertTrue(residualsP1.getStandardDeviation()< 0.01);}
@Test public void testAnalyticalDifferentiation(){AbstractIntegrator integ=new DormandPrince54Integrator(1.0e-8,100.0,new double[]{1.0e-4,1.0e-4},new double[]{1.0e-4,1.0e-4});SummaryStatistics residualsP0=new SummaryStatistics();SummaryStatistics residualsP1=new SummaryStatistics();for (double b=2.88;b < 3.08;b+=0.001){Brusselator brusselator=new Brusselator(b);double[]z={1.3,b};double[][]dZdZ0=new double[2][2];double[]dZdP=new double[2];JacobianMatrices jacob=new JacobianMatrices(brusselator,Brusselator.B);jacob.addParameterJacobianProvider(brusselator);jacob.setInitialParameterJacobian(Brusselator.B,new double[]{0.0,1.0});ExpandableStatefulODE efode=new ExpandableStatefulODE(brusselator);efode.setTime(0);efode.setPrimaryState(z);jacob.registerVariationalEquations(efode);integ.setMaxEvaluations(5000);integ.integrate(efode,20.0);jacob.getCurrentMainSetJacobian(dZdZ0);jacob.getCurrentParameterJacobian(Brusselator.B,dZdP);residualsP0.addValue(dZdP[0]- brusselator.dYdP0());residualsP1.addValue(dZdP[1]- brusselator.dYdP1());}Assert.assertTrue((residualsP0.getMax()- residualsP0.getMin())< 0.014);Assert.assertTrue(residualsP0.getStandardDeviation()< 0.003);Assert.assertTrue((residualsP1.getMax()- residualsP1.getMin())< 0.05);Assert.assertTrue(residualsP1.getStandardDeviation()< 0.01);}
@Test public void testFinalResult(){AbstractIntegrator integ=new DormandPrince54Integrator(1.0e-8,100.0,new double[]{1.0e-10,1.0e-10},new double[]{1.0e-10,1.0e-10});double[]y=new double[]{0.0,1.0};Circle circle=new Circle(y,1.0,1.0,0.1);JacobianMatrices jacob=new JacobianMatrices(circle,Circle.CX,Circle.CY,Circle.OMEGA);jacob.addParameterJacobianProvider(circle);jacob.setInitialMainStateJacobian(circle.exactDyDy0(0));jacob.setInitialParameterJacobian(Circle.CX,circle.exactDyDcx(0));jacob.setInitialParameterJacobian(Circle.CY,circle.exactDyDcy(0));jacob.setInitialParameterJacobian(Circle.OMEGA,circle.exactDyDom(0));ExpandableStatefulODE efode=new ExpandableStatefulODE(circle);efode.setTime(0);efode.setPrimaryState(y);jacob.registerVariationalEquations(efode);integ.setMaxEvaluations(5000);double t=18 * FastMath.PI;integ.integrate(efode,t);y=efode.getPrimaryState();for (int i=0;i < y.length;++i){Assert.assertEquals(circle.exactY(t)[i],y[i],1.0e-9);}double[][]dydy0=new double[2][2];jacob.getCurrentMainSetJacobian(dydy0);for (int i=0;i < dydy0.length;++i){for (int j=0;j < dydy0[i].length;++j){Assert.assertEquals(circle.exactDyDy0(t)[i][j],dydy0[i][j],1.0e-9);}}double[]dydcx=new double[2];jacob.getCurrentParameterJacobian(Circle.CX,dydcx);for (int i=0;i < dydcx.length;++i){Assert.assertEquals(circle.exactDyDcx(t)[i],dydcx[i],1.0e-7);}double[]dydcy=new double[2];jacob.getCurrentParameterJacobian(Circle.CY,dydcy);for (int i=0;i < dydcy.length;++i){Assert.assertEquals(circle.exactDyDcy(t)[i],dydcy[i],1.0e-7);}double[]dydom=new double[2];jacob.getCurrentParameterJacobian(Circle.OMEGA,dydom);for (int i=0;i < dydom.length;++i){Assert.assertEquals(circle.exactDyDom(t)[i],dydom[i],1.0e-7);}}
@Test public void testParameterizable(){AbstractIntegrator integ=new DormandPrince54Integrator(1.0e-8,100.0,new double[]{1.0e-10,1.0e-10},new double[]{1.0e-10,1.0e-10});double[]y=new double[]{0.0,1.0};ParameterizedCircle pcircle=new ParameterizedCircle(y,1.0,1.0,0.1);double hP=1.0e-12;double hY=1.0e-12;JacobianMatrices jacob=new JacobianMatrices(pcircle,new double[]{hY,hY},Circle.CX,Circle.OMEGA);jacob.addParameterJacobianProvider(pcircle);jacob.setParameterizedODE(pcircle);jacob.setParameterStep(Circle.OMEGA,hP);jacob.setInitialMainStateJacobian(pcircle.exactDyDy0(0));jacob.setInitialParameterJacobian(Circle.CX,pcircle.exactDyDcx(0));jacob.setInitialParameterJacobian(Circle.OMEGA,pcircle.exactDyDom(0));ExpandableStatefulODE efode=new ExpandableStatefulODE(pcircle);efode.setTime(0);efode.setPrimaryState(y);jacob.registerVariationalEquations(efode);integ.setMaxEvaluations(50000);double t=18 * FastMath.PI;integ.integrate(efode,t);y=efode.getPrimaryState();for (int i=0;i < y.length;++i){Assert.assertEquals(pcircle.exactY(t)[i],y[i],1.0e-9);}double[][]dydy0=new double[2][2];jacob.getCurrentMainSetJacobian(dydy0);for (int i=0;i < dydy0.length;++i){for (int j=0;j < dydy0[i].length;++j){Assert.assertEquals(pcircle.exactDyDy0(t)[i][j],dydy0[i][j],5.0e-4);}}double[]dydp0=new double[2];jacob.getCurrentParameterJacobian(Circle.CX,dydp0);for (int i=0;i < dydp0.length;++i){Assert.assertEquals(pcircle.exactDyDcx(t)[i],dydp0[i],5.0e-4);}double[]dydp1=new double[2];jacob.getCurrentParameterJacobian(Circle.OMEGA,dydp1);for (int i=0;i < dydp1.length;++i){Assert.assertEquals(pcircle.exactDyDom(t)[i],dydp1[i],1.0e-2);}}
/** * Test the normal approximation of the Poisson distribution by calculating P(90 &le;X &le;110)for X = Po(100)and P(9900 &le;X &le;10200)for X  = Po(10000)*/@Test public void testNormalApproximateProbability()throws Exception {PoissonDistribution dist=new PoissonDistribution(100);double result=dist.normalApproximateProbability(110)- dist.normalApproximateProbability(89);Assert.assertEquals(0.706281887248,result,1E-10);dist=new PoissonDistribution(10000);result=dist.normalApproximateProbability(10200)- dist.normalApproximateProbability(9899);Assert.assertEquals(0.820070051552,result,1E-10);}
/** * Test the degenerate cases of a 0.0 and 1.0 inverse cumulative probability.* @throws Exception*/@Test public void testDegenerateInverseCumulativeProbability()throws Exception {PoissonDistribution dist=new PoissonDistribution(DEFAULT_TEST_POISSON_PARAMETER);Assert.assertEquals(Integer.MAX_VALUE,dist.inverseCumulativeProbability(1.0d));Assert.assertEquals(-1,dist.inverseCumulativeProbability(0d));}
@Test(expected=NotStrictlyPositiveException.class)public void testNegativeMean(){new PoissonDistribution(-1);}
@Test public void testMean(){PoissonDistribution dist=new PoissonDistribution(10.0);Assert.assertEquals(10.0,dist.getMean(),0.0);}
@Test public void testLargeMeanCumulativeProbability(){double mean=1.0;while (mean <= 10000000.0){PoissonDistribution dist=new PoissonDistribution(mean);double x=mean * 2.0;double dx=x / 10.0;double p=Double.NaN;double sigma=FastMath.sqrt(mean);while (x >= 0){try {p=dist.cumulativeProbability(x);Assert.assertFalse("NaN cumulative probability returned for mean = " + mean + " x = "+ x,Double.isNaN(p));if (x > mean - 2 * sigma){Assert.assertTrue("Zero cum probaility returned for mean = " + mean + " x = "+ x,p > 0);}}catch(Exception ex){Assert.fail("mean of " + mean + " and x of "+ x+ " caused "+ ex.getMessage());}x-=dx;}mean*=10.0;}}
/** * JIRA: MATH-282*/@Test public void testCumulativeProbabilitySpecial()throws Exception {PoissonDistribution dist;dist=new PoissonDistribution(9120);checkProbability(dist,9075);checkProbability(dist,9102);dist=new PoissonDistribution(5058);checkProbability(dist,5044);dist=new PoissonDistribution(6986);checkProbability(dist,6950);}
@Test public void testLargeMeanInverseCumulativeProbability()throws Exception {double mean=1.0;while (mean <= 100000.0){PoissonDistribution dist=new PoissonDistribution(mean);double p=0.1;double dp=p;while (p < .99){double ret=Double.NaN;try {ret=dist.inverseCumulativeProbability(p);Assert.assertTrue(p >= dist.cumulativeProbability(ret));Assert.assertTrue(p < dist.cumulativeProbability(ret + 1));}catch(Exception ex){Assert.fail("mean of " + mean + " and p of "+ p+ " caused "+ ex.getMessage());}p+=dp;}mean*=10.0;}}
@Test public void testMoments(){final double tol=1e-9;PoissonDistribution dist;dist=new PoissonDistribution(1);Assert.assertEquals(dist.getNumericalMean(),1,tol);Assert.assertEquals(dist.getNumericalVariance(),1,tol);dist=new PoissonDistribution(11.23);Assert.assertEquals(dist.getNumericalMean(),11.23,tol);Assert.assertEquals(dist.getNumericalVariance(),11.23,tol);}
/** * Verifies that probability density calculations match expected values using default test instance data*/@Test public void testDensities()throws Exception {verifyDensities();}
/** * Verifies that cumulative probability density calculations match expected values using default test instance data*/@Test public void testCumulativeProbabilities()throws Exception {verifyCumulativeProbabilities();}
/** * Verifies that floating point arguments are correctly handled by cumulativeProbablility(-,-)JIRA: MATH-184*/@Test public void testFloatingPointArguments()throws Exception {for (int i=0;i < cumulativeTestPoints.length;i++){double arg=cumulativeTestPoints[i];Assert.assertEquals("Incorrect cumulative probability value returned for " + cumulativeTestPoints[i],cumulativeTestValues[i],distribution.cumulativeProbability(arg),tolerance);if (i < cumulativeTestPoints.length - 1){double arg2=cumulativeTestPoints[i + 1];Assert.assertEquals("Inconsistent probability for discrete range " + "[" + arg + ","+ arg2+ " ]",distribution.cumulativeProbability(cumulativeTestPoints[i],cumulativeTestPoints[i + 1]),distribution.cumulativeProbability(arg,arg2),tolerance);arg=arg - FastMath.random();arg2=arg2 + FastMath.random();Assert.assertEquals("Inconsistent probability for discrete range " + "[" + arg + ","+ arg2+ " ]",distribution.cumulativeProbability(cumulativeTestPoints[i],cumulativeTestPoints[i + 1]),distribution.cumulativeProbability(arg,arg2),tolerance);}}int one=1;int ten=10;int two=2;double oned=one;double twod=two;double tend=ten;Assert.assertEquals(distribution.cumulativeProbability(one,two),distribution.cumulativeProbability(oned,twod),tolerance);Assert.assertEquals(distribution.cumulativeProbability(one,two),distribution.cumulativeProbability(oned - tolerance,twod + 0.9),tolerance);Assert.assertEquals(distribution.cumulativeProbability(two,ten),distribution.cumulativeProbability(twod,tend),tolerance);Assert.assertEquals(distribution.cumulativeProbability(two,ten),distribution.cumulativeProbability(twod - tolerance,tend + 0.9),tolerance);}
/** * Verifies that inverse cumulative probability density calculations match expected values using default test instance data*/@Test public void testInverseCumulativeProbabilities()throws Exception {verifyInverseCumulativeProbabilities();}
/** * Verifies that illegal arguments are correctly handled*/@Test public void testIllegalArguments()throws Exception {try {distribution.cumulativeProbability(1,0);Assert.fail("Expecting MathIllegalArgumentException for bad cumulativeProbability interval");}catch(MathIllegalArgumentException ex){}try {distribution.inverseCumulativeProbability(-1);Assert.fail("Expecting MathIllegalArgumentException for p = -1");}catch(MathIllegalArgumentException ex){}try {distribution.inverseCumulativeProbability(2);Assert.fail("Expecting MathIllegalArgumentException for p = 2");}catch(MathIllegalArgumentException ex){}}
/** * Test sampling*/@Test public void testSampling()throws Exception {int[]densityPoints=makeDensityTestPoints();double[]densityValues=makeDensityTestValues();int sampleSize=1000;int length=TestUtils.eliminateZeroMassPoints(densityPoints,densityValues);AbstractIntegerDistribution distribution=(AbstractIntegerDistribution)makeDistribution();double[]expectedCounts=new double[length];long[]observedCounts=new long[length];for (int i=0;i < length;i++){expectedCounts[i]=sampleSize * densityValues[i];}distribution.reseedRandomGenerator(1000);int[]sample=distribution.sample(sampleSize);for (int i=0;i < sampleSize;i++){for (int j=0;j < length;j++){if (sample[i]== densityPoints[j]){observedCounts[j]++;}}}TestUtils.assertChiSquareAccept(densityPoints,expectedCounts,observedCounts,.001);}
@Test public void testPow(){test(DfpMath.pow(factory.newDfp("0"),factory.newDfp("0")),factory.newDfp("1"),0,"pow #1");test(DfpMath.pow(factory.newDfp("0"),factory.newDfp("-0")),factory.newDfp("1"),0,"pow #2");test(DfpMath.pow(factory.newDfp("2"),factory.newDfp("0")),factory.newDfp("1"),0,"pow #3");test(DfpMath.pow(factory.newDfp("-2"),factory.newDfp("-0")),factory.newDfp("1"),0,"pow #4");test(DfpMath.pow(pinf,factory.newDfp("-0")),factory.newDfp("1"),0,"pow #5");test(DfpMath.pow(pinf,factory.newDfp("0")),factory.newDfp("1"),0,"pow #6");test(DfpMath.pow(ninf,factory.newDfp("-0")),factory.newDfp("1"),0,"pow #7");test(DfpMath.pow(ninf,factory.newDfp("0")),factory.newDfp("1"),0,"pow #8");test(DfpMath.pow(qnan,factory.newDfp("0")),factory.newDfp("1"),0,"pow #8");test(DfpMath.pow(factory.newDfp("0"),factory.newDfp("1")),factory.newDfp("0"),0,"pow #9");test(DfpMath.pow(factory.newDfp("-0"),factory.newDfp("1")),factory.newDfp("-0"),0,"pow #10");test(DfpMath.pow(factory.newDfp("2"),factory.newDfp("1")),factory.newDfp("2"),0,"pow #11");test(DfpMath.pow(factory.newDfp("-2"),factory.newDfp("1")),factory.newDfp("-2"),0,"pow #12");test(DfpMath.pow(pinf,factory.newDfp("1")),pinf,0,"pow #13");test(DfpMath.pow(ninf,factory.newDfp("1")),ninf,0,"pow #14");test(DfpMath.pow(qnan,factory.newDfp("1")),qnan,DfpField.FLAG_INVALID,"pow #14.1");test(DfpMath.pow(factory.newDfp("0"),qnan),qnan,DfpField.FLAG_INVALID,"pow #15");test(DfpMath.pow(factory.newDfp("-0"),qnan),qnan,DfpField.FLAG_INVALID,"pow #16");test(DfpMath.pow(factory.newDfp("2"),qnan),qnan,DfpField.FLAG_INVALID,"pow #17");test(DfpMath.pow(factory.newDfp("-2"),qnan),qnan,DfpField.FLAG_INVALID,"pow #18");test(DfpMath.pow(pinf,qnan),qnan,DfpField.FLAG_INVALID,"pow #19");test(DfpMath.pow(ninf,qnan),qnan,DfpField.FLAG_INVALID,"pow #20");test(DfpMath.pow(qnan,qnan),qnan,DfpField.FLAG_INVALID,"pow #21");test(DfpMath.pow(qnan,factory.newDfp("1")),qnan,DfpField.FLAG_INVALID,"pow #22");test(DfpMath.pow(qnan,factory.newDfp("-1")),qnan,DfpField.FLAG_INVALID,"pow #23");test(DfpMath.pow(qnan,pinf),qnan,DfpField.FLAG_INVALID,"pow #24");test(DfpMath.pow(qnan,ninf),qnan,DfpField.FLAG_INVALID,"pow #25");test(DfpMath.pow(qnan,qnan),qnan,DfpField.FLAG_INVALID,"pow #26");test(DfpMath.pow(factory.newDfp("2"),pinf),pinf,0,"pow #27");test(DfpMath.pow(factory.newDfp("-2"),pinf),pinf,0,"pow #28");test(DfpMath.pow(pinf,pinf),pinf,0,"pow #29");test(DfpMath.pow(ninf,pinf),pinf,0,"pow #30");test(DfpMath.pow(factory.newDfp("2"),ninf),factory.getZero(),0,"pow #31");test(DfpMath.pow(factory.newDfp("-2"),ninf),factory.getZero(),0,"pow #32");test(DfpMath.pow(pinf,ninf),factory.getZero(),0,"pow #33");test(DfpMath.pow(ninf,ninf),factory.getZero(),0,"pow #34");test(DfpMath.pow(factory.newDfp("0.5"),pinf),factory.getZero(),0,"pow #35");test(DfpMath.pow(factory.newDfp("-0.5"),pinf),factory.getZero(),0,"pow #36");test(DfpMath.pow(factory.newDfp("0.5"),ninf),pinf,0,"pow #37");test(DfpMath.pow(factory.newDfp("-0.5"),ninf),pinf,0,"pow #38");test(DfpMath.pow(factory.getOne(),pinf),qnan,DfpField.FLAG_INVALID,"pow #39");test(DfpMath.pow(factory.getOne(),ninf),qnan,DfpField.FLAG_INVALID,"pow #40");test(DfpMath.pow(factory.newDfp("-1"),pinf),qnan,DfpField.FLAG_INVALID,"pow #41");test(DfpMath.pow(factory.getOne().negate(),ninf),qnan,DfpField.FLAG_INVALID,"pow #42");test(DfpMath.pow(factory.newDfp("0"),factory.newDfp("1")),factory.newDfp("0"),0,"pow #43");test(DfpMath.pow(factory.newDfp("0"),factory.newDfp("1e30")),factory.newDfp("0"),0,"pow #44");test(DfpMath.pow(factory.newDfp("0"),factory.newDfp("1e-30")),factory.newDfp("0"),0,"pow #45");test(DfpMath.pow(factory.newDfp("0"),pinf),factory.newDfp("0"),0,"pow #46");test(DfpMath.pow(factory.newDfp("-0"),factory.newDfp("2")),factory.newDfp("0"),0,"pow #47");test(DfpMath.pow(factory.newDfp("-0"),factory.newDfp("1e30")),factory.newDfp("0"),0,"pow #48");test(DfpMath.pow(factory.newDfp("-0"),factory.newDfp("1e-30")),factory.newDfp("0"),DfpField.FLAG_INEXACT,"pow #49");test(DfpMath.pow(factory.newDfp("-0"),pinf),factory.newDfp("0"),0,"pow #50");test(DfpMath.pow(factory.newDfp("0"),factory.newDfp("-1")),pinf,0,"pow #51");test(DfpMath.pow(factory.newDfp("0"),factory.newDfp("-1e30")),pinf,0,"pow #52");test(DfpMath.pow(factory.newDfp("0"),factory.newDfp("-1e-30")),pinf,0,"pow #53");test(DfpMath.pow(factory.newDfp("0"),ninf),pinf,0,"pow #54");test(DfpMath.pow(factory.newDfp("-0"),factory.newDfp("-2")),pinf,0,"pow #55");test(DfpMath.pow(factory.newDfp("-0"),factory.newDfp("-1e30")),pinf,0,"pow #56");test(DfpMath.pow(factory.newDfp("-0"),factory.newDfp("-1e-30")),pinf,DfpField.FLAG_INEXACT,"pow #57");test(DfpMath.pow(factory.newDfp("-0"),ninf),pinf,0,"pow #58");test(DfpMath.pow(factory.newDfp("-0"),factory.newDfp("-1")),ninf,DfpField.FLAG_INEXACT,"pow #59");test(DfpMath.pow(factory.newDfp("-0"),factory.newDfp("-12345")),ninf,DfpField.FLAG_INEXACT,"pow #60");test(DfpMath.pow(factory.newDfp("-0"),factory.newDfp("3")),factory.newDfp("-0"),DfpField.FLAG_INEXACT,"pow #61");test(DfpMath.pow(factory.newDfp("-0"),factory.newDfp("12345")),factory.newDfp("-0"),DfpField.FLAG_INEXACT,"pow #62");test(DfpMath.pow(pinf,factory.newDfp("3")),pinf,0,"pow #63");test(DfpMath.pow(pinf,factory.newDfp("1e30")),pinf,0,"pow #64");test(DfpMath.pow(pinf,factory.newDfp("1e-30")),pinf,0,"pow #65");test(DfpMath.pow(pinf,pinf),pinf,0,"pow #66");test(DfpMath.pow(pinf,factory.newDfp("-3")),factory.getZero(),0,"pow #67");test(DfpMath.pow(pinf,factory.newDfp("-1e30")),factory.getZero(),0,"pow #68");test(DfpMath.pow(pinf,factory.newDfp("-1e-30")),factory.getZero(),0,"pow #69");test(DfpMath.pow(pinf,ninf),factory.getZero(),0,"pow #70");test(DfpMath.pow(ninf,factory.newDfp("-2")),factory.newDfp("0"),0,"pow #71");test(DfpMath.pow(ninf,factory.newDfp("-1e30")),factory.newDfp("0"),0,"pow #72");test(DfpMath.pow(ninf,factory.newDfp("-1e-30")),factory.newDfp("0"),DfpField.FLAG_INEXACT,"pow #73");test(DfpMath.pow(ninf,ninf),factory.newDfp("0"),0,"pow #74");test(DfpMath.pow(ninf,factory.newDfp("2")),pinf,0,"pow #75");test(DfpMath.pow(ninf,factory.newDfp("1e30")),pinf,0,"pow #76");test(DfpMath.pow(ninf,factory.newDfp("1e-30")),pinf,DfpField.FLAG_INEXACT,"pow #77");test(DfpMath.pow(ninf,pinf),pinf,0,"pow #78");test(DfpMath.pow(ninf,factory.newDfp("3")),ninf,DfpField.FLAG_INEXACT,"pow #79");test(DfpMath.pow(ninf,factory.newDfp("12345")),ninf,DfpField.FLAG_INEXACT,"pow #80");test(DfpMath.pow(ninf,factory.newDfp("-3")),factory.newDfp("-0"),DfpField.FLAG_INEXACT,"pow #81");test(DfpMath.pow(ninf,factory.newDfp("-12345")),factory.newDfp("-0"),DfpField.FLAG_INEXACT,"pow #82");test(DfpMath.pow(factory.newDfp("-2"),factory.newDfp("3")),factory.newDfp("-8"),DfpField.FLAG_INEXACT,"pow #83");test(DfpMath.pow(factory.newDfp("-2"),factory.newDfp("16")),factory.newDfp("65536"),0,"pow #84");test(DfpMath.pow(factory.newDfp("-2"),factory.newDfp("-3")),factory.newDfp("-0.125"),DfpField.FLAG_INEXACT,"pow #85");test(DfpMath.pow(factory.newDfp("-2"),factory.newDfp("-4")),factory.newDfp("0.0625"),0,"pow #86");test(DfpMath.pow(factory.newDfp("-2"),factory.newDfp("-4.1")),qnan,DfpField.FLAG_INVALID | DfpField.FLAG_INEXACT,"pow #87");test(DfpMath.pow(factory.newDfp("2"),factory.newDfp("1.5")),factory.newDfp("2.8284271247461901"),DfpField.FLAG_INEXACT,"pow #88");}
@Test public void testSin(){test(DfpMath.sin(pinf),nan,DfpField.FLAG_INVALID | DfpField.FLAG_INEXACT,"sin #1");test(DfpMath.sin(nan),nan,DfpField.FLAG_INVALID | DfpField.FLAG_INEXACT,"sin #2");test(DfpMath.sin(factory.getZero()),factory.getZero(),DfpField.FLAG_INEXACT,"sin #3");test(DfpMath.sin(factory.getPi()),factory.getZero(),DfpField.FLAG_INEXACT,"sin #4");test(DfpMath.sin(factory.getPi().negate()),factory.newDfp("-0"),DfpField.FLAG_INEXACT,"sin #5");test(DfpMath.sin(factory.getPi().multiply(2)),factory.getZero(),DfpField.FLAG_INEXACT,"sin #6");test(DfpMath.sin(factory.getPi().divide(2)),factory.getOne(),DfpField.FLAG_INEXACT,"sin #7");test(DfpMath.sin(factory.getPi().divide(2).negate()),factory.getOne().negate(),DfpField.FLAG_INEXACT,"sin #8");test(DfpMath.sin(DfpMath.atan(factory.getOne())),factory.newDfp("0.5").sqrt(),DfpField.FLAG_INEXACT,"sin #9");test(DfpMath.sin(DfpMath.atan(factory.getOne())).negate(),factory.newDfp("0.5").sqrt().negate(),DfpField.FLAG_INEXACT,"sin #10");test(DfpMath.sin(DfpMath.atan(factory.getOne())).negate(),factory.newDfp("0.5").sqrt().negate(),DfpField.FLAG_INEXACT,"sin #11");test(DfpMath.sin(factory.newDfp("0.1")),factory.newDfp("0.0998334166468281523"),DfpField.FLAG_INEXACT,"sin #12");test(DfpMath.sin(factory.newDfp("0.2")),factory.newDfp("0.19866933079506121546"),DfpField.FLAG_INEXACT,"sin #13");test(DfpMath.sin(factory.newDfp("0.3")),factory.newDfp("0.2955202066613395751"),DfpField.FLAG_INEXACT,"sin #14");test(DfpMath.sin(factory.newDfp("0.4")),factory.newDfp("0.38941834230865049166"),DfpField.FLAG_INEXACT,"sin #15");test(DfpMath.sin(factory.newDfp("0.5")),factory.newDfp("0.47942553860420300026"),DfpField.FLAG_INEXACT,"sin #16");test(DfpMath.sin(factory.newDfp("0.6")),factory.newDfp("0.56464247339503535721"),DfpField.FLAG_INEXACT,"sin #17");test(DfpMath.sin(factory.newDfp("0.7")),factory.newDfp("0.64421768723769105367"),DfpField.FLAG_INEXACT,"sin #18");test(DfpMath.sin(factory.newDfp("0.8")),factory.newDfp("0.71735609089952276163"),DfpField.FLAG_INEXACT,"sin #19");test(DfpMath.sin(factory.newDfp("0.9")),factory.newDfp("0.78332690962748338847"),DfpField.FLAG_INEXACT,"sin #20");test(DfpMath.sin(factory.newDfp("1.0")),factory.newDfp("0.84147098480789650666"),DfpField.FLAG_INEXACT,"sin #21");test(DfpMath.sin(factory.newDfp("1.1")),factory.newDfp("0.89120736006143533995"),DfpField.FLAG_INEXACT,"sin #22");test(DfpMath.sin(factory.newDfp("1.2")),factory.newDfp("0.93203908596722634968"),DfpField.FLAG_INEXACT,"sin #23");test(DfpMath.sin(factory.newDfp("1.3")),factory.newDfp("0.9635581854171929647"),DfpField.FLAG_INEXACT,"sin #24");test(DfpMath.sin(factory.newDfp("1.4")),factory.newDfp("0.98544972998846018066"),DfpField.FLAG_INEXACT,"sin #25");test(DfpMath.sin(factory.newDfp("1.5")),factory.newDfp("0.99749498660405443096"),DfpField.FLAG_INEXACT,"sin #26");test(DfpMath.sin(factory.newDfp("1.6")),factory.newDfp("0.99957360304150516323"),DfpField.FLAG_INEXACT,"sin #27");}
@Test public void testSerialization(){StatisticalSummaryValues u=new StatisticalSummaryValues(1,2,3,4,5,6);TestUtils.checkSerializedEquality(u);StatisticalSummaryValues t=(StatisticalSummaryValues)TestUtils.serializeAndRecover(u);verifyEquality(u,t);}
@Test public void testEqualsAndHashCode(){StatisticalSummaryValues u=new StatisticalSummaryValues(1,2,3,4,5,6);StatisticalSummaryValues t=null;Assert.assertTrue("reflexive",u.equals(u));Assert.assertFalse("non-null compared to null",u.equals(t));Assert.assertFalse("wrong type",u.equals(Double.valueOf(0)));t=new StatisticalSummaryValues(1,2,3,4,5,6);Assert.assertTrue("instances with same data should be equal",t.equals(u));Assert.assertEquals("hash code",u.hashCode(),t.hashCode());u=new StatisticalSummaryValues(Double.NaN,2,3,4,5,6);t=new StatisticalSummaryValues(1,Double.NaN,3,4,5,6);Assert.assertFalse("instances based on different data should be different",(u.equals(t)|| t.equals(u)));}
@Test public void testToString(){StatisticalSummaryValues u=new StatisticalSummaryValues(4.5,16,10,5,4,45);Locale d=Locale.getDefault();Locale.setDefault(Locale.US);Assert.assertEquals("StatisticalSummaryValues:\n" + "n: 10\n" + "min: 4.0\n"+ "max: 5.0\n"+ "mean: 4.5\n"+ "std dev: 4.0\n"+ "variance: 16.0\n"+ "sum: 45.0\n",u.toString());Locale.setDefault(d);}
@Test(expected=DimensionMismatchException.class)public void testDimensionCheck(){TestProblem1 pb=new TestProblem1();new MidpointIntegrator(0.01).integrate(pb,0.0,new double[pb.getDimension()+ 10],1.0,new double[pb.getDimension()+ 10]);Assert.fail("an exception should have been thrown");}
@Test public void testDecreasingSteps(){TestProblemAbstract[]problems=TestProblemFactory.getProblems();for (int k=0;k < problems.length;++k){double previousValueError=Double.NaN;double previousTimeError=Double.NaN;for (int i=4;i < 10;++i){TestProblemAbstract pb=problems[k].copy();double step=(pb.getFinalTime()- pb.getInitialTime())* FastMath.pow(2.0,-i);FirstOrderIntegrator integ=new MidpointIntegrator(step);TestProblemHandler handler=new TestProblemHandler(pb,integ);integ.addStepHandler(handler);EventHandler[]functions=pb.getEventsHandlers();for (int l=0;l < functions.length;++l){integ.addEventHandler(functions[l],Double.POSITIVE_INFINITY,1.0e-6 * step,1000);}double stopTime=integ.integrate(pb,pb.getInitialTime(),pb.getInitialState(),pb.getFinalTime(),new double[pb.getDimension()]);if (functions.length == 0){Assert.assertEquals(pb.getFinalTime(),stopTime,1.0e-10);}double valueError=handler.getMaximalValueError();if (i > 4){Assert.assertTrue(valueError < FastMath.abs(previousValueError));}previousValueError=valueError;double timeError=handler.getMaximalTimeError();if (i > 4){Assert.assertTrue(timeError <= FastMath.abs(previousTimeError));}previousTimeError=timeError;}}}
@Test public void testSmallStep(){TestProblem1 pb=new TestProblem1();double step=(pb.getFinalTime()- pb.getInitialTime())* 0.001;FirstOrderIntegrator integ=new MidpointIntegrator(step);TestProblemHandler handler=new TestProblemHandler(pb,integ);integ.addStepHandler(handler);integ.integrate(pb,pb.getInitialTime(),pb.getInitialState(),pb.getFinalTime(),new double[pb.getDimension()]);Assert.assertTrue(handler.getLastError()< 2.0e-7);Assert.assertTrue(handler.getMaximalValueError()< 1.0e-6);Assert.assertEquals(0,handler.getMaximalTimeError(),1.0e-12);Assert.assertEquals("midpoint",integ.getName());}
@Test public void testBigStep(){TestProblem1 pb=new TestProblem1();double step=(pb.getFinalTime()- pb.getInitialTime())* 0.2;FirstOrderIntegrator integ=new MidpointIntegrator(step);TestProblemHandler handler=new TestProblemHandler(pb,integ);integ.addStepHandler(handler);integ.integrate(pb,pb.getInitialTime(),pb.getInitialState(),pb.getFinalTime(),new double[pb.getDimension()]);Assert.assertTrue(handler.getLastError()> 0.01);Assert.assertTrue(handler.getMaximalValueError()> 0.05);Assert.assertEquals(0,handler.getMaximalTimeError(),1.0e-12);}
@Test public void testBackward(){TestProblem5 pb=new TestProblem5();double step=FastMath.abs(pb.getFinalTime()- pb.getInitialTime())* 0.001;FirstOrderIntegrator integ=new MidpointIntegrator(step);TestProblemHandler handler=new TestProblemHandler(pb,integ);integ.addStepHandler(handler);integ.integrate(pb,pb.getInitialTime(),pb.getInitialState(),pb.getFinalTime(),new double[pb.getDimension()]);Assert.assertTrue(handler.getLastError()< 6.0e-4);Assert.assertTrue(handler.getMaximalValueError()< 6.0e-4);Assert.assertEquals(0,handler.getMaximalTimeError(),1.0e-12);Assert.assertEquals("midpoint",integ.getName());}
@Test public void testStepSize(){final double step=1.23456;FirstOrderIntegrator integ=new MidpointIntegrator(step);integ.addStepHandler(new StepHandler(){public void handleStep(StepInterpolator interpolator,boolean isLast){if (!isLast){Assert.assertEquals(step,interpolator.getCurrentTime()- interpolator.getPreviousTime(),1.0e-12);}}public void init(double t0,double[]y0,double t){}});integ.integrate(new FirstOrderDifferentialEquations(){public void computeDerivatives(double t,double[]y,double[]dot){dot[0]=1.0;}public int getDimension(){return 1;}},0.0,new double[]{0.0},5.0,new double[1]);}
@Test public void testZero(){Assert.assertEquals(Complex.ZERO,ComplexField.getInstance().getZero());}
@Test public void testOne(){Assert.assertEquals(Complex.ONE,ComplexField.getInstance().getOne());}
@Test public void testSerial(){ComplexField field=ComplexField.getInstance();Assert.assertTrue(field == TestUtils.serializeAndRecover(field));}
@Test public void testErf0(){double actual=Erf.erf(0.0);double expected=0.0;Assert.assertEquals(expected,actual,1.0e-15);Assert.assertEquals(1 - expected,Erf.erfc(0.0),1.0e-15);}
@Test public void testErf1960(){double x=1.960 / FastMath.sqrt(2.0);double actual=Erf.erf(x);double expected=0.95;Assert.assertEquals(expected,actual,1.0e-5);Assert.assertEquals(1 - actual,Erf.erfc(x),1.0e-15);actual=Erf.erf(-x);expected=-expected;Assert.assertEquals(expected,actual,1.0e-5);Assert.assertEquals(1 - actual,Erf.erfc(-x),1.0e-15);}
@Test public void testErf2576(){double x=2.576 / FastMath.sqrt(2.0);double actual=Erf.erf(x);double expected=0.99;Assert.assertEquals(expected,actual,1.0e-5);Assert.assertEquals(1 - actual,Erf.erfc(x),1e-15);actual=Erf.erf(-x);expected=-expected;Assert.assertEquals(expected,actual,1.0e-5);Assert.assertEquals(1 - actual,Erf.erfc(-x),1.0e-15);}
@Test public void testErf2807(){double x=2.807 / FastMath.sqrt(2.0);double actual=Erf.erf(x);double expected=0.995;Assert.assertEquals(expected,actual,1.0e-5);Assert.assertEquals(1 - actual,Erf.erfc(x),1.0e-15);actual=Erf.erf(-x);expected=-expected;Assert.assertEquals(expected,actual,1.0e-5);Assert.assertEquals(1 - actual,Erf.erfc(-x),1.0e-15);}
@Test public void testErf3291(){double x=3.291 / FastMath.sqrt(2.0);double actual=Erf.erf(x);double expected=0.999;Assert.assertEquals(expected,actual,1.0e-5);Assert.assertEquals(1 - expected,Erf.erfc(x),1.0e-5);actual=Erf.erf(-x);expected=-expected;Assert.assertEquals(expected,actual,1.0e-5);Assert.assertEquals(1 - expected,Erf.erfc(-x),1.0e-5);}
/** * MATH-301,MATH-456*/@Test public void testLargeValues()throws Exception {for (int i=1;i < 200;i*=10){double result=Erf.erf(i);Assert.assertFalse(Double.isNaN(result));Assert.assertTrue(result > 0 && result <= 1);result=Erf.erf(-i);Assert.assertFalse(Double.isNaN(result));Assert.assertTrue(result >= -1 && result < 0);result=Erf.erfc(i);Assert.assertFalse(Double.isNaN(result));Assert.assertTrue(result >= 0 && result < 1);result=Erf.erfc(-i);Assert.assertFalse(Double.isNaN(result));Assert.assertTrue(result >= 1 && result <= 2);}Assert.assertEquals(-1,Erf.erf(Double.NEGATIVE_INFINITY),0);Assert.assertEquals(1,Erf.erf(Double.POSITIVE_INFINITY),0);Assert.assertEquals(2,Erf.erfc(Double.NEGATIVE_INFINITY),0);Assert.assertEquals(0,Erf.erfc(Double.POSITIVE_INFINITY),0);}
/** * Compare Erf.erf against reference values computed using GCC 4.2.1 (Apple OSX packaged version)erfl (extended precision erf).*/@Test public void testErfGnu()throws Exception {final double tol=1E-15;final double[]gnuValues=new double[]{-1,-1,-1,-1,-1,-1,-1,-1,-0.99999999999999997848,-0.99999999999999264217,-0.99999999999846254017,-0.99999999980338395581,-0.99999998458274209971,-0.9999992569016276586,-0.99997790950300141459,-0.99959304798255504108,-0.99532226501895273415,-0.96610514647531072711,-0.84270079294971486948,-0.52049987781304653809,0,0.52049987781304653809,0.84270079294971486948,0.96610514647531072711,0.99532226501895273415,0.99959304798255504108,0.99997790950300141459,0.9999992569016276586,0.99999998458274209971,0.99999999980338395581,0.99999999999846254017,0.99999999999999264217,0.99999999999999997848,1,1,1,1,1,1,1,1};double x=-10d;for (int i=0;i < 41;i++){Assert.assertEquals(gnuValues[i],Erf.erf(x),tol);x+=0.5d;}}
/** * Compare Erf.erfc against reference values computed using GCC 4.2.1 (Apple OSX packaged version)erfcl (extended precision erfc).*/@Test public void testErfcGnu()throws Exception {final double tol=1E-15;final double[]gnuValues=new double[]{2,2,2,2,2,2,2,2,1.9999999999999999785,1.9999999999999926422,1.9999999999984625402,1.9999999998033839558,1.9999999845827420998,1.9999992569016276586,1.9999779095030014146,1.9995930479825550411,1.9953222650189527342,1.9661051464753107271,1.8427007929497148695,1.5204998778130465381,1,0.47950012218695346194,0.15729920705028513051,0.033894853524689272893,0.0046777349810472658333,0.00040695201744495893941,2.2090496998585441366E-05,7.4309837234141274516E-07,1.5417257900280018858E-08,1.966160441542887477E-10,1.5374597944280348501E-12,7.3578479179743980661E-15,2.1519736712498913103E-17,3.8421483271206474691E-20,4.1838256077794144006E-23,2.7766493860305691016E-26,1.1224297172982927079E-29,2.7623240713337714448E-33,4.1370317465138102353E-37,3.7692144856548799402E-41,2.0884875837625447567E-45};double x=-10d;for (int i=0;i < 41;i++){Assert.assertEquals(gnuValues[i],Erf.erfc(x),tol);x+=0.5d;}}
/** * Tests erfc against reference data computed using Maple reported in Marsaglia,G,,"Evaluating the Normal Distribution," Journal of Statistical Software,July,2004. http//www.jstatsoft.org/v11/a05/paper*/@Test public void testErfcMaple()throws Exception {double[][]ref=new double[][]{{0.1,4.60172162722971e-01},{1.2,1.15069670221708e-01},{2.3,1.07241100216758e-02},{3.4,3.36929265676881e-04},{4.5,3.39767312473006e-06},{5.6,1.07175902583109e-08},{6.7,1.04209769879652e-11},{7.8,3.09535877195870e-15},{8.9,2.79233437493966e-19},{10.0,7.61985302416053e-24},{11.1,6.27219439321703e-29},{12.2,1.55411978638959e-34},{13.3,1.15734162836904e-40},{14.4,2.58717592540226e-47},{15.5,1.73446079179387e-54},{16.6,3.48454651995041e-62}};for (int i=0;i < 15;i++){final double result=0.5 * Erf.erfc(ref[i][0]/ Math.sqrt(2));Assert.assertEquals(ref[i][1],result,1E-15);TestUtils.assertRelativelyEquals(ref[i][1],result,1E-13);}}
/** * Test the implementation of Erf.erf(double,double)for consistency with results obtained from Erf.erf(double)and Erf.erfc(double).*/@Test public void testTwoArgumentErf()throws Exception {double[]xi=new double[]{-2.0,-1.0,-0.9,-0.1,0.0,0.1,0.9,1.0,2.0};for(double x1 : xi){for(double x2 : xi){double a=Erf.erf(x1,x2);double b=Erf.erf(x2)- Erf.erf(x1);double c=Erf.erfc(x1)- Erf.erfc(x2);Assert.assertEquals(a,b,1E-15);Assert.assertEquals(a,c,1E-15);}}}
@Test public void testCrossover(){Integer[]p1=new Integer[]{1,0,1,0,0,1,0,1,1};Integer[]p2=new Integer[]{0,1,1,0,1,0,1,1,1};BinaryChromosome p1c=new DummyBinaryChromosome(p1);BinaryChromosome p2c=new DummyBinaryChromosome(p2);OnePointCrossover<Integer> opc=new OnePointCrossover<Integer>();for (int i=0;i < 20;i++){ChromosomePair pair=opc.crossover(p1c,p2c);Integer[]c1=new Integer[p1.length];Integer[]c2=new Integer[p2.length];c1=((BinaryChromosome)pair.getFirst()).getRepresentation().toArray(c1);c2=((BinaryChromosome)pair.getSecond()).getRepresentation().toArray(c2);Assert.assertEquals((int)p1[0],(int)c1[0]);Assert.assertEquals((int)p2[0],(int)c2[0]);Assert.assertEquals((int)p1[p1.length - 1],(int)c1[c1.length - 1]);Assert.assertEquals((int)p2[p2.length - 1],(int)c2[c2.length - 1]);Assert.assertEquals((int)p1[2],(int)c1[2]);Assert.assertEquals((int)p2[2],(int)c2[2]);Assert.assertEquals((int)p1[3],(int)c1[3]);Assert.assertEquals((int)p2[3],(int)c2[3]);Assert.assertEquals((int)p1[7],(int)c1[7]);Assert.assertEquals((int)p2[7],(int)c2[7]);}}
@Test public void testTrivial(){LinearProblem problem=new LinearProblem(new double[][]{{2}},new double[]{3});NonLinearConjugateGradientOptimizer optimizer=new NonLinearConjugateGradientOptimizer(ConjugateGradientFormula.POLAK_RIBIERE,new SimpleScalarValueChecker(1e-6,1e-6));RealPointValuePair optimum=optimizer.optimize(100,problem,GoalType.MINIMIZE,new double[]{0});Assert.assertEquals(1.5,optimum.getPoint()[0],1.0e-10);Assert.assertEquals(0.0,optimum.getValue(),1.0e-10);}
@Test public void testColumnsPermutation(){LinearProblem problem=new LinearProblem(new double[][]{{1.0,-1.0},{0.0,2.0},{1.0,-2.0}},new double[]{4.0,6.0,1.0});NonLinearConjugateGradientOptimizer optimizer=new NonLinearConjugateGradientOptimizer(ConjugateGradientFormula.POLAK_RIBIERE,new SimpleScalarValueChecker(1e-6,1e-6));RealPointValuePair optimum=optimizer.optimize(100,problem,GoalType.MINIMIZE,new double[]{0,0});Assert.assertEquals(7.0,optimum.getPoint()[0],1.0e-10);Assert.assertEquals(3.0,optimum.getPoint()[1],1.0e-10);Assert.assertEquals(0.0,optimum.getValue(),1.0e-10);}
@Test public void testNoDependency(){LinearProblem problem=new LinearProblem(new double[][]{{2,0,0,0,0,0},{0,2,0,0,0,0},{0,0,2,0,0,0},{0,0,0,2,0,0},{0,0,0,0,2,0},{0,0,0,0,0,2}},new double[]{0.0,1.1,2.2,3.3,4.4,5.5});NonLinearConjugateGradientOptimizer optimizer=new NonLinearConjugateGradientOptimizer(ConjugateGradientFormula.POLAK_RIBIERE,new SimpleScalarValueChecker(1e-6,1e-6));RealPointValuePair optimum=optimizer.optimize(100,problem,GoalType.MINIMIZE,new double[]{0,0,0,0,0,0});for (int i=0;i < problem.target.length;++i){Assert.assertEquals(0.55 * i,optimum.getPoint()[i],1.0e-10);}}
@Test public void testOneSet(){LinearProblem problem=new LinearProblem(new double[][]{{1,0,0},{-1,1,0},{0,-1,1}},new double[]{1,1,1});NonLinearConjugateGradientOptimizer optimizer=new NonLinearConjugateGradientOptimizer(ConjugateGradientFormula.POLAK_RIBIERE,new SimpleScalarValueChecker(1e-6,1e-6));RealPointValuePair optimum=optimizer.optimize(100,problem,GoalType.MINIMIZE,new double[]{0,0,0});Assert.assertEquals(1.0,optimum.getPoint()[0],1.0e-10);Assert.assertEquals(2.0,optimum.getPoint()[1],1.0e-10);Assert.assertEquals(3.0,optimum.getPoint()[2],1.0e-10);}
@Test public void testTwoSets(){final double epsilon=1.0e-7;LinearProblem problem=new LinearProblem(new double[][]{{2,1,0,4,0,0},{-4,-2,3,-7,0,0},{4,1,-2,8,0,0},{0,-3,-12,-1,0,0},{0,0,0,0,epsilon,1},{0,0,0,0,1,1}},new double[]{2,-9,2,2,1 + epsilon * epsilon,2});final Preconditioner preconditioner=new Preconditioner(){public double[]precondition(double[]point,double[]r){double[]d=r.clone();d[0]/=72.0;d[1]/=30.0;d[2]/=314.0;d[3]/=260.0;d[4]/=2 * (1 + epsilon * epsilon);d[5]/=4.0;return d;}};NonLinearConjugateGradientOptimizer optimizer=new NonLinearConjugateGradientOptimizer(ConjugateGradientFormula.POLAK_RIBIERE,new SimpleScalarValueChecker(1e-13,1e-13),new BrentSolver(),preconditioner);RealPointValuePair optimum=optimizer.optimize(100,problem,GoalType.MINIMIZE,new double[]{0,0,0,0,0,0});Assert.assertEquals(3.0,optimum.getPoint()[0],1.0e-10);Assert.assertEquals(4.0,optimum.getPoint()[1],1.0e-10);Assert.assertEquals(-1.0,optimum.getPoint()[2],1.0e-10);Assert.assertEquals(-2.0,optimum.getPoint()[3],1.0e-10);Assert.assertEquals(1.0 + epsilon,optimum.getPoint()[4],1.0e-10);Assert.assertEquals(1.0 - epsilon,optimum.getPoint()[5],1.0e-10);}
@Test public void testNonInversible(){LinearProblem problem=new LinearProblem(new double[][]{{1,2,-3},{2,1,3},{-3,0,-9}},new double[]{1,1,1});NonLinearConjugateGradientOptimizer optimizer=new NonLinearConjugateGradientOptimizer(ConjugateGradientFormula.POLAK_RIBIERE,new SimpleScalarValueChecker(1e-6,1e-6));RealPointValuePair optimum=optimizer.optimize(100,problem,GoalType.MINIMIZE,new double[]{0,0,0});Assert.assertTrue(optimum.getValue()> 0.5);}
@Test public void testIllConditioned(){LinearProblem problem1=new LinearProblem(new double[][]{{10.0,7.0,8.0,7.0},{7.0,5.0,6.0,5.0},{8.0,6.0,10.0,9.0},{7.0,5.0,9.0,10.0}},new double[]{32,23,33,31});NonLinearConjugateGradientOptimizer optimizer=new NonLinearConjugateGradientOptimizer(ConjugateGradientFormula.POLAK_RIBIERE,new SimpleScalarValueChecker(1e-13,1e-13),new BrentSolver(1e-15,1e-15));RealPointValuePair optimum1=optimizer.optimize(200,problem1,GoalType.MINIMIZE,new double[]{0,1,2,3});Assert.assertEquals(1.0,optimum1.getPoint()[0],1.0e-4);Assert.assertEquals(1.0,optimum1.getPoint()[1],1.0e-4);Assert.assertEquals(1.0,optimum1.getPoint()[2],1.0e-4);Assert.assertEquals(1.0,optimum1.getPoint()[3],1.0e-4);LinearProblem problem2=new LinearProblem(new double[][]{{10.00,7.00,8.10,7.20},{7.08,5.04,6.00,5.00},{8.00,5.98,9.89,9.00},{6.99,4.99,9.00,9.98}},new double[]{32,23,33,31});RealPointValuePair optimum2=optimizer.optimize(200,problem2,GoalType.MINIMIZE,new double[]{0,1,2,3});Assert.assertEquals(-81.0,optimum2.getPoint()[0],1.0e-1);Assert.assertEquals(137.0,optimum2.getPoint()[1],1.0e-1);Assert.assertEquals(-34.0,optimum2.getPoint()[2],1.0e-1);Assert.assertEquals(22.0,optimum2.getPoint()[3],1.0e-1);}
@Test public void testMoreEstimatedParametersSimple(){LinearProblem problem=new LinearProblem(new double[][]{{3.0,2.0,0.0,0.0},{0.0,1.0,-1.0,1.0},{2.0,0.0,1.0,0.0}},new double[]{7.0,3.0,5.0});NonLinearConjugateGradientOptimizer optimizer=new NonLinearConjugateGradientOptimizer(ConjugateGradientFormula.POLAK_RIBIERE,new SimpleScalarValueChecker(1e-6,1e-6));RealPointValuePair optimum=optimizer.optimize(100,problem,GoalType.MINIMIZE,new double[]{7,6,5,4});Assert.assertEquals(0,optimum.getValue(),1.0e-10);}
@Test public void testMoreEstimatedParametersUnsorted(){LinearProblem problem=new LinearProblem(new double[][]{{1.0,1.0,0.0,0.0,0.0,0.0},{0.0,0.0,1.0,1.0,1.0,0.0},{0.0,0.0,0.0,0.0,1.0,-1.0},{0.0,0.0,-1.0,1.0,0.0,1.0},{0.0,0.0,0.0,-1.0,1.0,0.0}},new double[]{3.0,12.0,-1.0,7.0,1.0});NonLinearConjugateGradientOptimizer optimizer=new NonLinearConjugateGradientOptimizer(ConjugateGradientFormula.POLAK_RIBIERE,new SimpleScalarValueChecker(1e-6,1e-6));RealPointValuePair optimum=optimizer.optimize(100,problem,GoalType.MINIMIZE,new double[]{2,2,2,2,2,2});Assert.assertEquals(0,optimum.getValue(),1.0e-10);}
@Test public void testRedundantEquations(){LinearProblem problem=new LinearProblem(new double[][]{{1.0,1.0},{1.0,-1.0},{1.0,3.0}},new double[]{3.0,1.0,5.0});NonLinearConjugateGradientOptimizer optimizer=new NonLinearConjugateGradientOptimizer(ConjugateGradientFormula.POLAK_RIBIERE,new SimpleScalarValueChecker(1e-6,1e-6));RealPointValuePair optimum=optimizer.optimize(100,problem,GoalType.MINIMIZE,new double[]{1,1});Assert.assertEquals(2.0,optimum.getPoint()[0],1.0e-8);Assert.assertEquals(1.0,optimum.getPoint()[1],1.0e-8);}
@Test public void testInconsistentEquations(){LinearProblem problem=new LinearProblem(new double[][]{{1.0,1.0},{1.0,-1.0},{1.0,3.0}},new double[]{3.0,1.0,4.0});NonLinearConjugateGradientOptimizer optimizer=new NonLinearConjugateGradientOptimizer(ConjugateGradientFormula.POLAK_RIBIERE,new SimpleScalarValueChecker(1e-6,1e-6));RealPointValuePair optimum=optimizer.optimize(100,problem,GoalType.MINIMIZE,new double[]{1,1});Assert.assertTrue(optimum.getValue()> 0.1);}
@Test public void testCircleFitting(){CircleScalar circle=new CircleScalar();circle.addPoint(30.0,68.0);circle.addPoint(50.0,-6.0);circle.addPoint(110.0,-20.0);circle.addPoint(35.0,15.0);circle.addPoint(45.0,97.0);NonLinearConjugateGradientOptimizer optimizer=new NonLinearConjugateGradientOptimizer(ConjugateGradientFormula.POLAK_RIBIERE,new SimpleScalarValueChecker(1e-30,1e-30),new BrentSolver(1e-15,1e-13));RealPointValuePair optimum=optimizer.optimize(100,circle,GoalType.MINIMIZE,new double[]{98.680,47.345});Point2D.Double center=new Point2D.Double(optimum.getPointRef()[0],optimum.getPointRef()[1]);Assert.assertEquals(69.960161753,circle.getRadius(center),1.0e-8);Assert.assertEquals(96.075902096,center.x,1.0e-8);Assert.assertEquals(48.135167894,center.y,1.0e-8);}
@Test public void testMinpackLinearFullRank(){minpackTest(new LinearFullRankFunction(10,5,1.0,5.0,2.23606797749979),false);minpackTest(new LinearFullRankFunction(50,5,1.0,8.06225774829855,6.70820393249937),false);}
@Test public void testMinpackLinearRank1(){minpackTest(new LinearRank1Function(10,5,1.0,291.521868819476,1.4638501094228),false);minpackTest(new LinearRank1Function(50,5,1.0,3101.60039334535,3.48263016573496),false);}
@Test public void testMinpackLinearRank1ZeroColsAndRows(){minpackTest(new LinearRank1ZeroColsAndRowsFunction(10,5,1.0),false);minpackTest(new LinearRank1ZeroColsAndRowsFunction(50,5,1.0),false);}
@Test public void testMinpackRosenbrok(){minpackTest(new RosenbrockFunction(new double[]{-1.2,1.0},FastMath.sqrt(24.2)),false);minpackTest(new RosenbrockFunction(new double[]{-12.0,10.0},FastMath.sqrt(1795769.0)),false);minpackTest(new RosenbrockFunction(new double[]{-120.0,100.0},11.0 * FastMath.sqrt(169000121.0)),false);}
@Test public void testMinpackHelicalValley(){minpackTest(new HelicalValleyFunction(new double[]{-1.0,0.0,0.0},50.0),false);minpackTest(new HelicalValleyFunction(new double[]{-10.0,0.0,0.0},102.95630140987),false);minpackTest(new HelicalValleyFunction(new double[]{-100.0,0.0,0.0},991.261822123701),false);}
@Test public void testMinpackPowellSingular(){minpackTest(new PowellSingularFunction(new double[]{3.0,-1.0,0.0,1.0},14.6628782986152),false);minpackTest(new PowellSingularFunction(new double[]{30.0,-10.0,0.0,10.0},1270.9838708654),false);minpackTest(new PowellSingularFunction(new double[]{300.0,-100.0,0.0,100.0},126887.903284750),false);}
@Test public void testMinpackFreudensteinRoth(){minpackTest(new FreudensteinRothFunction(new double[]{0.5,-2.0},20.0124960961895,6.99887517584575,new double[]{11.4124844654993,-0.896827913731509}),false);minpackTest(new FreudensteinRothFunction(new double[]{5.0,-20.0},12432.833948863,6.9988751744895,new double[]{11.41300466147456,-0.896796038685959}),false);minpackTest(new FreudensteinRothFunction(new double[]{50.0,-200.0},11426454.595762,6.99887517242903,new double[]{11.412781785788564,-0.8968051074920405}),false);}
@Test public void testMinpackBard(){minpackTest(new BardFunction(1.0,6.45613629515967,0.0906359603390466,new double[]{0.0824105765758334,1.1330366534715,2.34369463894115}),false);minpackTest(new BardFunction(10.0,36.1418531596785,4.17476870138539,new double[]{0.840666673818329,-158848033.259565,-164378671.653535}),false);minpackTest(new BardFunction(100.0,384.114678637399,4.17476870135969,new double[]{0.840666673867645,-158946167.205518,-164464906.857771}),false);}
@Test public void testMinpackKowalikOsborne(){minpackTest(new KowalikOsborneFunction(new double[]{0.25,0.39,0.415,0.39},0.0728915102882945,0.017535837721129,new double[]{0.192807810476249,0.191262653354071,0.123052801046931,0.136053221150517}),false);minpackTest(new KowalikOsborneFunction(new double[]{2.5,3.9,4.15,3.9},2.97937007555202,0.032052192917937,new double[]{728675.473768287,-14.0758803129393,-32977797.7841797,-20571594.1977912}),false);minpackTest(new KowalikOsborneFunction(new double[]{25.0,39.0,41.5,39.0},29.9590617016037,0.0175364017658228,new double[]{0.192948328597594,0.188053165007911,0.122430604321144,0.134575665392506}),false);}
@Test public void testMinpackMeyer(){minpackTest(new MeyerFunction(new double[]{0.02,4000.0,250.0},41153.4665543031,9.37794514651874,new double[]{0.00560963647102661,6181.34634628659,345.223634624144}),false);minpackTest(new MeyerFunction(new double[]{0.2,40000.0,2500.0},4168216.89130846,792.917871779501,new double[]{1.42367074157994e-11,33695.7133432541,901.268527953801}),true);}
@Test public void testMinpackWatson(){minpackTest(new WatsonFunction(6,0.0,5.47722557505166,0.0478295939097601,new double[]{-0.0157249615083782,1.01243488232965,-0.232991722387673,1.26043101102818,-1.51373031394421,0.99299727291842}),false);minpackTest(new WatsonFunction(6,10.0,6433.12578950026,0.0478295939096951,new double[]{-0.0157251901386677,1.01243485860105,-0.232991545843829,1.26042932089163,-1.51372776706575,0.99299573426328}),false);minpackTest(new WatsonFunction(6,100.0,674256.040605213,0.047829593911544,new double[]{-0.0157247019712586,1.01243490925658,-0.232991922761641,1.26043292929555,-1.51373320452707,0.99299901922322}),false);minpackTest(new WatsonFunction(9,0.0,5.47722557505166,0.00118311459212420,new double[]{-0.153070644166722e-4,0.999789703934597,0.0147639634910978,0.146342330145992,1.00082109454817,-2.61773112070507,4.10440313943354,-3.14361226236241,1.05262640378759}),false);minpackTest(new WatsonFunction(9,10.0,12088.127069307,0.00118311459212513,new double[]{-0.153071334849279e-4,0.999789703941234,0.0147639629786217,0.146342334818836,1.00082107321386,-2.61773107084722,4.10440307655564,-3.14361222178686,1.05262639322589}),false);minpackTest(new WatsonFunction(9,100.0,1269109.29043834,0.00118311459212384,new double[]{-0.153069523352176e-4,0.999789703958371,0.0147639625185392,0.146342341096326,1.00082104729164,-2.61773101573645,4.10440301427286,-3.14361218602503,1.05262638516774}),false);minpackTest(new WatsonFunction(12,0.0,5.47722557505166,0.217310402535861e-4,new double[]{-0.660266001396382e-8,1.00000164411833,-0.000563932146980154,0.347820540050756,-0.156731500244233,1.05281515825593,-3.24727109519451,7.2884347837505,-10.271848098614,9.07411353715783,-4.54137541918194,1.01201187975044}),false);minpackTest(new WatsonFunction(12,10.0,19220.7589790951,0.217310402518509e-4,new double[]{-0.663710223017410e-8,1.00000164411787,-0.000563932208347327,0.347820540486998,-0.156731503955652,1.05281517654573,-3.2472711515214,7.28843489430665,-10.2718482369638,9.07411364383733,-4.54137546533666,1.01201188830857}),false);minpackTest(new WatsonFunction(12,100.0,2018918.04462367,0.217310402539845e-4,new double[]{-0.663806046485249e-8,1.00000164411786,-0.000563932210324959,0.347820540503588,-0.156731504091375,1.05281517718031,-3.24727115337025,7.28843489775302,-10.2718482410813,9.07411364688464,-4.54137546660822,1.0120118885369}),false);}
@Test public void testMinpackBox3Dimensional(){minpackTest(new Box3DimensionalFunction(10,new double[]{0.0,10.0,20.0},32.1115837449572),false);}
@Test public void testMinpackJennrichSampson(){minpackTest(new JennrichSampsonFunction(10,new double[]{0.3,0.4},64.5856498144943,11.1517793413499,new double[]{0.2578199266368004,0.25782997676455244}),false);}
@Test public void testMinpackBrownDennis(){minpackTest(new BrownDennisFunction(20,new double[]{25.0,5.0,-5.0,-1.0},2815.43839161816,292.954288244866,new double[]{-11.59125141003,13.2024883984741,-0.403574643314272,0.236736269844604}),false);minpackTest(new BrownDennisFunction(20,new double[]{250.0,50.0,-50.0,-10.0},555073.354173069,292.954270581415,new double[]{-11.5959274272203,13.2041866926242,-0.403417362841545,0.236771143410386}),false);minpackTest(new BrownDennisFunction(20,new double[]{2500.0,500.0,-500.0,-100.0},61211252.2338581,292.954306151134,new double[]{-11.5902596937374,13.2020628854665,-0.403688070279258,0.236665033746463}),false);}
@Test public void testMinpackChebyquad(){minpackTest(new ChebyquadFunction(1,8,1.0,1.88623796907732,1.88623796907732,new double[]{0.5}),false);minpackTest(new ChebyquadFunction(1,8,10.0,5383344372.34005,1.88424820499951,new double[]{0.9817314924684}),false);minpackTest(new ChebyquadFunction(1,8,100.0,0.118088726698392e19,1.88424820499347,new double[]{0.9817314852934}),false);minpackTest(new ChebyquadFunction(8,8,1.0,0.196513862833975,0.0593032355046727,new double[]{0.0431536648587336,0.193091637843267,0.266328593812698,0.499999334628884,0.500000665371116,0.733671406187302,0.806908362156733,0.956846335141266}),false);minpackTest(new ChebyquadFunction(9,9,1.0,0.16994993465202,0.0,new double[]{0.0442053461357828,0.199490672309881,0.23561910847106,0.416046907892598,0.5,0.583953092107402,0.764380891528940,0.800509327690119,0.955794653864217}),false);minpackTest(new ChebyquadFunction(10,10,1.0,0.183747831178711,0.0806471004038253,new double[]{0.0596202671753563,0.166708783805937,0.239171018813509,0.398885290346268,0.398883667870681,0.601116332129320,0.60111470965373,0.760828981186491,0.833291216194063,0.940379732824644}),false);}
@Test public void testMinpackBrownAlmostLinear(){minpackTest(new BrownAlmostLinearFunction(10,0.5,16.5302162063499,0.0,new double[]{0.979430303349862,0.979430303349862,0.979430303349862,0.979430303349862,0.979430303349862,0.979430303349862,0.979430303349862,0.979430303349862,0.979430303349862,1.20569696650138}),false);minpackTest(new BrownAlmostLinearFunction(10,5.0,9765624.00089211,0.0,new double[]{0.979430303349865,0.979430303349865,0.979430303349865,0.979430303349865,0.979430303349865,0.979430303349865,0.979430303349865,0.979430303349865,0.979430303349865,1.20569696650135}),false);minpackTest(new BrownAlmostLinearFunction(10,50.0,0.9765625e17,0.0,new double[]{1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0}),false);minpackTest(new BrownAlmostLinearFunction(30,0.5,83.476044467848,0.0,new double[]{0.997754216442807,0.997754216442807,0.997754216442807,0.997754216442807,0.997754216442807,0.997754216442807,0.997754216442807,0.997754216442807,0.997754216442807,0.997754216442807,0.997754216442807,0.997754216442807,0.997754216442807,0.997754216442807,0.997754216442807,0.997754216442807,0.997754216442807,0.997754216442807,0.997754216442807,0.997754216442807,0.997754216442807,0.997754216442807,0.997754216442807,0.997754216442807,0.997754216442807,0.997754216442807,0.997754216442807,0.997754216442807,0.997754216442807,1.06737350671578}),false);minpackTest(new BrownAlmostLinearFunction(40,0.5,128.026364472323,0.0,new double[]{1.00000000000002,1.00000000000002,1.00000000000002,1.00000000000002,1.00000000000002,1.00000000000002,1.00000000000002,1.00000000000002,1.00000000000002,1.00000000000002,1.00000000000002,1.00000000000002,1.00000000000002,1.00000000000002,1.00000000000002,1.00000000000002,1.00000000000002,1.00000000000002,1.00000000000002,1.00000000000002,1.00000000000002,1.00000000000002,1.00000000000002,1.00000000000002,1.00000000000002,1.00000000000002,1.00000000000002,1.00000000000002,1.00000000000002,1.00000000000002,1.00000000000002,1.00000000000002,1.00000000000002,1.00000000000002,0.999999999999121}),false);}
@Test public void testMinpackOsborne1(){minpackTest(new Osborne1Function(new double[]{0.5,1.5,-1.0,0.01,0.02},0.937564021037838,0.00739249260904843,new double[]{0.375410049244025,1.93584654543108,-1.46468676748716,0.0128675339110439,0.0221227011813076}),false);}
@Test public void testMinpackOsborne2(){minpackTest(new Osborne2Function(new double[]{1.3,0.65,0.65,0.7,0.6,3.0,5.0,7.0,2.0,4.5,5.5},1.44686540984712,0.20034404483314,new double[]{1.30997663810096,0.43155248076,0.633661261602859,0.599428560991695,0.754179768272449,0.904300082378518,1.36579949521007,4.82373199748107,2.39868475104871,4.56887554791452,5.67534206273052}),false);}
@Test public void testPutAndGetWith0ExpectedSize(){OpenIntToFieldHashMap<Fraction> map=new OpenIntToFieldHashMap<Fraction>(field,0);assertPutAndGet(map);}
@Test public void testPutAndGetWithExpectedSize(){OpenIntToFieldHashMap<Fraction> map=new OpenIntToFieldHashMap<Fraction>(field,500);assertPutAndGet(map);}
@Test public void testPutAndGet(){OpenIntToFieldHashMap<Fraction> map=new OpenIntToFieldHashMap<Fraction>(field);assertPutAndGet(map);}
@Test public void testPutAbsentOnExisting(){OpenIntToFieldHashMap<Fraction> map=createFromJavaMap(field);int size=javaMap.size();for(Map.Entry<Integer,Fraction> mapEntry : generateAbsent().entrySet()){map.put(mapEntry.getKey(),mapEntry.getValue());Assert.assertEquals(++size,map.size());Assert.assertEquals(mapEntry.getValue(),map.get(mapEntry.getKey()));}}
@Test public void testPutOnExisting(){OpenIntToFieldHashMap<Fraction> map=createFromJavaMap(field);for(Map.Entry<Integer,Fraction> mapEntry : javaMap.entrySet()){map.put(mapEntry.getKey(),mapEntry.getValue());Assert.assertEquals(javaMap.size(),map.size());Assert.assertEquals(mapEntry.getValue(),map.get(mapEntry.getKey()));}}
@Test public void testGetAbsent(){Map<Integer,Fraction> generated=generateAbsent();OpenIntToFieldHashMap<Fraction> map=createFromJavaMap(field);for(Map.Entry<Integer,Fraction> mapEntry : generated.entrySet())Assert.assertTrue(field.getZero().equals(map.get(mapEntry.getKey())));}
@Test public void testGetFromEmpty(){OpenIntToFieldHashMap<Fraction> map=new OpenIntToFieldHashMap<Fraction>(field);Assert.assertTrue(field.getZero().equals(map.get(5)));Assert.assertTrue(field.getZero().equals(map.get(0)));Assert.assertTrue(field.getZero().equals(map.get(50)));}
@Test public void testRemove(){OpenIntToFieldHashMap<Fraction> map=createFromJavaMap(field);int mapSize=javaMap.size();Assert.assertEquals(mapSize,map.size());for(Map.Entry<Integer,Fraction> mapEntry : javaMap.entrySet()){map.remove(mapEntry.getKey());Assert.assertEquals(--mapSize,map.size());Assert.assertTrue(field.getZero().equals(map.get(mapEntry.getKey())));}assertPutAndGet(map);}
@Test public void testRemove2(){OpenIntToFieldHashMap<Fraction> map=createFromJavaMap(field);int mapSize=javaMap.size();int count=0;Set<Integer> keysInMap=new HashSet<Integer>(javaMap.keySet());for(Map.Entry<Integer,Fraction> mapEntry : javaMap.entrySet()){keysInMap.remove(mapEntry.getKey());map.remove(mapEntry.getKey());Assert.assertEquals(--mapSize,map.size());Assert.assertTrue(field.getZero().equals(map.get(mapEntry.getKey())));if (count++ > 5)break;}assertPutAndGet(map,mapSize,keysInMap);}
@Test public void testRemoveFromEmpty(){OpenIntToFieldHashMap<Fraction> map=new OpenIntToFieldHashMap<Fraction>(field);Assert.assertTrue(field.getZero().equals(map.remove(50)));}
@Test public void testRemoveAbsent(){Map<Integer,Fraction> generated=generateAbsent();OpenIntToFieldHashMap<Fraction> map=createFromJavaMap(field);int mapSize=map.size();for(Map.Entry<Integer,Fraction> mapEntry : generated.entrySet()){map.remove(mapEntry.getKey());Assert.assertEquals(mapSize,map.size());Assert.assertTrue(field.getZero().equals(map.get(mapEntry.getKey())));}}
@Test public void testCopy(){OpenIntToFieldHashMap<Fraction> copy=new OpenIntToFieldHashMap<Fraction>(createFromJavaMap(field));Assert.assertEquals(javaMap.size(),copy.size());for(Map.Entry<Integer,Fraction> mapEntry : javaMap.entrySet())Assert.assertEquals(mapEntry.getValue(),copy.get(mapEntry.getKey()));}
@Test public void testContainsKey(){OpenIntToFieldHashMap<Fraction> map=createFromJavaMap(field);for(Entry<Integer,Fraction> mapEntry : javaMap.entrySet()){Assert.assertTrue(map.containsKey(mapEntry.getKey()));}for(Map.Entry<Integer,Fraction> mapEntry : generateAbsent().entrySet()){Assert.assertFalse(map.containsKey(mapEntry.getKey()));}for(Entry<Integer,Fraction> mapEntry : javaMap.entrySet()){int key=mapEntry.getKey();Assert.assertTrue(map.containsKey(key));map.remove(key);Assert.assertFalse(map.containsKey(key));}}
@Test public void testIterator(){OpenIntToFieldHashMap<Fraction> map=createFromJavaMap(field);OpenIntToFieldHashMap<Fraction>.Iterator iterator=map.iterator();for (int i=0;i < map.size();++i){Assert.assertTrue(iterator.hasNext());iterator.advance();int key=iterator.key();Assert.assertTrue(map.containsKey(key));Assert.assertEquals(javaMap.get(key),map.get(key));Assert.assertEquals(javaMap.get(key),iterator.value());Assert.assertTrue(javaMap.containsKey(key));}Assert.assertFalse(iterator.hasNext());try {iterator.advance();Assert.fail("an exception should have been thrown");}catch(NoSuchElementException nsee){}}
@Test public void testConcurrentModification(){OpenIntToFieldHashMap<Fraction> map=createFromJavaMap(field);OpenIntToFieldHashMap<Fraction>.Iterator iterator=map.iterator();map.put(3,new Fraction(3));try {iterator.advance();Assert.fail("an exception should have been thrown");}catch(ConcurrentModificationException cme){}}
/** * Regression test for a bug in findInsertionIndex where the hashing in the second probing loop was inconsistent with the first causing duplicate keys after the right sequence of puts and removes.*/@Test public void testPutKeysWithCollisions(){OpenIntToFieldHashMap<Fraction> map=new OpenIntToFieldHashMap<Fraction>(field);int key1=-1996012590;Fraction value1=new Fraction(1);map.put(key1,value1);int key2=835099822;map.put(key2,value1);int key3=1008859686;map.put(key3,value1);Assert.assertEquals(value1,map.get(key3));Assert.assertEquals(3,map.size());map.remove(key2);Fraction value2=new Fraction(2);map.put(key3,value2);Assert.assertEquals(value2,map.get(key3));Assert.assertEquals(2,map.size());}
/** * Similar to testPutKeysWithCollisions()but exercises the codepaths in a slightly different manner.*/@Test public void testPutKeysWithCollision2(){OpenIntToFieldHashMap<Fraction> map=new OpenIntToFieldHashMap<Fraction>(field);int key1=837989881;Fraction value1=new Fraction(1);map.put(key1,value1);int key2=476463321;map.put(key2,value1);Assert.assertEquals(2,map.size());Assert.assertEquals(value1,map.get(key2));map.remove(key1);Fraction value2=new Fraction(2);map.put(key2,value2);Assert.assertEquals(1,map.size());Assert.assertEquals(value2,map.get(key2));}
@Test public void testInvalidConstructor(){Integer[][]reprs=new Integer[][]{new Integer[]{0,1,0,1,2},new Integer[]{0,1,0,1,-1}};for(Integer[]repr : reprs){try {new DummyBinaryChromosome(repr);Assert.fail("Exception not caught");}catch(IllegalArgumentException e){}}}
@Test public void testRandomConstructor(){for (int i=0;i < 20;i++){new DummyBinaryChromosome(BinaryChromosome.randomBinaryRepresentation(10));}}
@Test public void testIsSame(){Chromosome c1=new DummyBinaryChromosome(new Integer[]{0,1,0,1,0,1});Chromosome c2=new DummyBinaryChromosome(new Integer[]{0,1,1,0,1});Chromosome c3=new DummyBinaryChromosome(new Integer[]{0,1,0,1,0,1,1});Chromosome c4=new DummyBinaryChromosome(new Integer[]{1,1,0,1,0,1});Chromosome c5=new DummyBinaryChromosome(new Integer[]{0,1,0,1,0,0});Chromosome c6=new DummyBinaryChromosome(new Integer[]{0,1,0,1,0,1});Assert.assertFalse(c1.isSame(c2));Assert.assertFalse(c1.isSame(c3));Assert.assertFalse(c1.isSame(c4));Assert.assertFalse(c1.isSame(c5));Assert.assertTrue(c1.isSame(c6));}
/** * Test preconditions.*/@Test public void testPreconditions()throws Exception {double[]xval=new double[]{3,4,5,6.5};double[]yval=new double[]{-4,-3,-1,2.5};double[]zval=new double[]{-12,-8,-5.5,-3,0,2.5};double[][][]fval=new double[xval.length][yval.length][zval.length];@SuppressWarnings("unused")TrivariateRealFunction tcf=new TricubicSplineInterpolatingFunction(xval,yval,zval,fval,fval,fval,fval,fval,fval,fval,fval);double[]wxval=new double[]{3,2,5,6.5};try {tcf=new TricubicSplineInterpolatingFunction(wxval,yval,zval,fval,fval,fval,fval,fval,fval,fval,fval);Assert.fail("an exception should have been thrown");}catch(MathIllegalArgumentException e){}double[]wyval=new double[]{-4,-1,-1,2.5};try {tcf=new TricubicSplineInterpolatingFunction(xval,wyval,zval,fval,fval,fval,fval,fval,fval,fval,fval);Assert.fail("an exception should have been thrown");}catch(MathIllegalArgumentException e){}double[]wzval=new double[]{-12,-8,-9,-3,0,2.5};try {tcf=new TricubicSplineInterpolatingFunction(xval,yval,wzval,fval,fval,fval,fval,fval,fval,fval,fval);Assert.fail("an exception should have been thrown");}catch(MathIllegalArgumentException e){}double[][][]wfval=new double[xval.length - 1][yval.length - 1][zval.length];try {tcf=new TricubicSplineInterpolatingFunction(xval,yval,zval,wfval,fval,fval,fval,fval,fval,fval,fval);Assert.fail("an exception should have been thrown");}catch(DimensionMismatchException e){}try {tcf=new TricubicSplineInterpolatingFunction(xval,yval,zval,fval,wfval,fval,fval,fval,fval,fval,fval);Assert.fail("an exception should have been thrown");}catch(DimensionMismatchException e){}try {tcf=new TricubicSplineInterpolatingFunction(xval,yval,zval,fval,fval,wfval,fval,fval,fval,fval,fval);Assert.fail("an exception should have been thrown");}catch(DimensionMismatchException e){}try {tcf=new TricubicSplineInterpolatingFunction(xval,yval,zval,fval,fval,fval,wfval,fval,fval,fval,fval);Assert.fail("an exception should have been thrown");}catch(DimensionMismatchException e){}try {tcf=new TricubicSplineInterpolatingFunction(xval,yval,zval,fval,fval,fval,fval,wfval,fval,fval,fval);Assert.fail("an exception should have been thrown");}catch(DimensionMismatchException e){}try {tcf=new TricubicSplineInterpolatingFunction(xval,yval,zval,fval,fval,fval,fval,fval,wfval,fval,fval);Assert.fail("an exception should have been thrown");}catch(DimensionMismatchException e){}try {tcf=new TricubicSplineInterpolatingFunction(xval,yval,zval,fval,fval,fval,fval,fval,fval,wfval,fval);Assert.fail("an exception should have been thrown");}catch(DimensionMismatchException e){}try {tcf=new TricubicSplineInterpolatingFunction(xval,yval,zval,fval,fval,fval,fval,fval,fval,fval,wfval);Assert.fail("an exception should have been thrown");}catch(DimensionMismatchException e){}wfval=new double[xval.length][yval.length - 1][zval.length];try {tcf=new TricubicSplineInterpolatingFunction(xval,yval,zval,wfval,fval,fval,fval,fval,fval,fval,fval);Assert.fail("an exception should have been thrown");}catch(DimensionMismatchException e){}try {tcf=new TricubicSplineInterpolatingFunction(xval,yval,zval,fval,wfval,fval,fval,fval,fval,fval,fval);Assert.fail("an exception should have been thrown");}catch(DimensionMismatchException e){}try {tcf=new TricubicSplineInterpolatingFunction(xval,yval,zval,fval,fval,wfval,fval,fval,fval,fval,fval);Assert.fail("an exception should have been thrown");}catch(DimensionMismatchException e){}try {tcf=new TricubicSplineInterpolatingFunction(xval,yval,zval,fval,fval,fval,wfval,fval,fval,fval,fval);Assert.fail("an exception should have been thrown");}catch(DimensionMismatchException e){}try {tcf=new TricubicSplineInterpolatingFunction(xval,yval,zval,fval,fval,fval,fval,wfval,fval,fval,fval);Assert.fail("an exception should have been thrown");}catch(DimensionMismatchException e){}try {tcf=new TricubicSplineInterpolatingFunction(xval,yval,zval,fval,fval,fval,fval,fval,wfval,fval,fval);Assert.fail("an exception should have been thrown");}catch(DimensionMismatchException e){}try {tcf=new TricubicSplineInterpolatingFunction(xval,yval,zval,fval,fval,fval,fval,fval,fval,wfval,fval);Assert.fail("an exception should have been thrown");}catch(DimensionMismatchException e){}try {tcf=new TricubicSplineInterpolatingFunction(xval,yval,zval,fval,fval,fval,fval,fval,fval,fval,wfval);Assert.fail("an exception should have been thrown");}catch(DimensionMismatchException e){}wfval=new double[xval.length][yval.length][zval.length - 1];try {tcf=new TricubicSplineInterpolatingFunction(xval,yval,zval,wfval,fval,fval,fval,fval,fval,fval,fval);Assert.fail("an exception should have been thrown");}catch(DimensionMismatchException e){}try {tcf=new TricubicSplineInterpolatingFunction(xval,yval,zval,fval,wfval,fval,fval,fval,fval,fval,fval);Assert.fail("an exception should have been thrown");}catch(DimensionMismatchException e){}try {tcf=new TricubicSplineInterpolatingFunction(xval,yval,zval,fval,fval,wfval,fval,fval,fval,fval,fval);Assert.fail("an exception should have been thrown");}catch(DimensionMismatchException e){}try {tcf=new TricubicSplineInterpolatingFunction(xval,yval,zval,fval,fval,fval,wfval,fval,fval,fval,fval);Assert.fail("an exception should have been thrown");}catch(DimensionMismatchException e){}try {tcf=new TricubicSplineInterpolatingFunction(xval,yval,zval,fval,fval,fval,fval,wfval,fval,fval,fval);Assert.fail("an exception should have been thrown");}catch(DimensionMismatchException e){}try {tcf=new TricubicSplineInterpolatingFunction(xval,yval,zval,fval,fval,fval,fval,fval,wfval,fval,fval);Assert.fail("an exception should have been thrown");}catch(DimensionMismatchException e){}try {tcf=new TricubicSplineInterpolatingFunction(xval,yval,zval,fval,fval,fval,fval,fval,fval,wfval,fval);Assert.fail("an exception should have been thrown");}catch(DimensionMismatchException e){}try {tcf=new TricubicSplineInterpolatingFunction(xval,yval,zval,fval,fval,fval,fval,fval,fval,fval,wfval);Assert.fail("an exception should have been thrown");}catch(DimensionMismatchException e){}}
/** * Test for a plane. <p> f(x,y,z)= 2 x - 3 y - 4 z + 5 </p>*/@Test public void testPlane(){double[]xval=new double[]{3,4,5,6.5};double[]yval=new double[]{-4,-3,-1,2,2.5};double[]zval=new double[]{-12,-8,-5.5,-3,0,2.5};TrivariateRealFunction f=new TrivariateRealFunction(){public double value(double x,double y,double z){return 2 * x - 3 * y - 4 * z + 5;}};double[][][]fval=new double[xval.length][yval.length][zval.length];for (int i=0;i < xval.length;i++){for (int j=0;j < yval.length;j++){for (int k=0;k < zval.length;k++){fval[i][j][k]=f.value(xval[i],yval[j],zval[k]);}}}double[][][]dFdX=new double[xval.length][yval.length][zval.length];for (int i=0;i < xval.length;i++){for (int j=0;j < yval.length;j++){for (int k=0;k < zval.length;k++){dFdX[i][j][k]=2;}}}double[][][]dFdY=new double[xval.length][yval.length][zval.length];for (int i=0;i < xval.length;i++){for (int j=0;j < yval.length;j++){for (int k=0;k < zval.length;k++){dFdY[i][j][k]=-3;}}}double[][][]dFdZ=new double[xval.length][yval.length][zval.length];for (int i=0;i < xval.length;i++){for (int j=0;j < yval.length;j++){for (int k=0;k < zval.length;k++){dFdZ[i][j][k]=-4;}}}double[][][]d2FdXdY=new double[xval.length][yval.length][zval.length];double[][][]d2FdXdZ=new double[xval.length][yval.length][zval.length];double[][][]d2FdYdZ=new double[xval.length][yval.length][zval.length];double[][][]d3FdXdYdZ=new double[xval.length][yval.length][zval.length];for (int i=0;i < xval.length;i++){for (int j=0;j < yval.length;j++){for (int k=0;k < zval.length;k++){d2FdXdY[i][j][k]=0;d2FdXdZ[i][j][k]=0;d2FdYdZ[i][j][k]=0;d3FdXdYdZ[i][j][k]=0;}}}TrivariateRealFunction tcf=new TricubicSplineInterpolatingFunction(xval,yval,zval,fval,dFdX,dFdY,dFdZ,d2FdXdY,d2FdXdZ,d2FdYdZ,d3FdXdYdZ);double x,y,z;double expected,result;x=4;y=-3;z=0;expected=f.value(x,y,z);result=tcf.value(x,y,z);Assert.assertEquals("On sample point",expected,result,1e-15);x=4.5;y=-1.5;z=-4.25;expected=f.value(x,y,z);result=tcf.value(x,y,z);Assert.assertEquals("Half-way between sample points (middle of the patch)",expected,result,0.3);x=3.5;y=-3.5;z=-10;expected=f.value(x,y,z);result=tcf.value(x,y,z);Assert.assertEquals("Half-way between sample points (border of the patch)",expected,result,0.3);}
/** * Sine wave. <p> f(x,y,z)= a cos [&omega;z - k<sub>y</sub> x - k<sub>y</sub> y]</p> with A = 0.2,&omega;= 0.5,k<sub>x</sub> = 2,k<sub>y</sub> = 1.*/@Test public void testWave(){double[]xval=new double[]{3,4,5,6.5};double[]yval=new double[]{-4,-3,-1,2,2.5};double[]zval=new double[]{-12,-8,-5.5,-3,0,4};final double a=0.2;final double omega=0.5;final double kx=2;final double ky=1;TrivariateRealFunction f=new TrivariateRealFunction(){public double value(double x,double y,double z){return a * FastMath.cos(omega * z - kx * x - ky * y);}};double[][][]fval=new double[xval.length][yval.length][zval.length];for (int i=0;i < xval.length;i++){for (int j=0;j < yval.length;j++){for (int k=0;k < zval.length;k++){fval[i][j][k]=f.value(xval[i],yval[j],zval[k]);}}}double[][][]dFdX=new double[xval.length][yval.length][zval.length];TrivariateRealFunction dFdX_f=new TrivariateRealFunction(){public double value(double x,double y,double z){return a * FastMath.sin(omega * z - kx * x - ky * y)* kx;}};for (int i=0;i < xval.length;i++){for (int j=0;j < yval.length;j++){for (int k=0;k < zval.length;k++){dFdX[i][j][k]=dFdX_f.value(xval[i],yval[j],zval[k]);}}}double[][][]dFdY=new double[xval.length][yval.length][zval.length];TrivariateRealFunction dFdY_f=new TrivariateRealFunction(){public double value(double x,double y,double z){return a * FastMath.sin(omega * z - kx * x - ky * y)* ky;}};for (int i=0;i < xval.length;i++){for (int j=0;j < yval.length;j++){for (int k=0;k < zval.length;k++){dFdY[i][j][k]=dFdY_f.value(xval[i],yval[j],zval[k]);}}}double[][][]dFdZ=new double[xval.length][yval.length][zval.length];TrivariateRealFunction dFdZ_f=new TrivariateRealFunction(){public double value(double x,double y,double z){return -a * FastMath.sin(omega * z - kx * x - ky * y)* omega;}};for (int i=0;i < xval.length;i++){for (int j=0;j < yval.length;j++){for (int k=0;k < zval.length;k++){dFdZ[i][j][k]=dFdZ_f.value(xval[i],yval[j],zval[k]);}}}double[][][]d2FdXdY=new double[xval.length][yval.length][zval.length];TrivariateRealFunction d2FdXdY_f=new TrivariateRealFunction(){public double value(double x,double y,double z){return -a * FastMath.cos(omega * z - kx * x - ky * y)* kx* ky;}};for (int i=0;i < xval.length;i++){for (int j=0;j < yval.length;j++){for (int k=0;k < zval.length;k++){d2FdXdY[i][j][k]=d2FdXdY_f.value(xval[i],yval[j],zval[k]);}}}double[][][]d2FdXdZ=new double[xval.length][yval.length][zval.length];TrivariateRealFunction d2FdXdZ_f=new TrivariateRealFunction(){public double value(double x,double y,double z){return a * FastMath.cos(omega * z - kx * x - ky * y)* kx* omega;}};for (int i=0;i < xval.length;i++){for (int j=0;j < yval.length;j++){for (int k=0;k < zval.length;k++){d2FdXdZ[i][j][k]=d2FdXdZ_f.value(xval[i],yval[j],zval[k]);}}}double[][][]d2FdYdZ=new double[xval.length][yval.length][zval.length];TrivariateRealFunction d2FdYdZ_f=new TrivariateRealFunction(){public double value(double x,double y,double z){return a * FastMath.cos(omega * z - kx * x - ky * y)* ky* omega;}};for (int i=0;i < xval.length;i++){for (int j=0;j < yval.length;j++){for (int k=0;k < zval.length;k++){d2FdYdZ[i][j][k]=d2FdYdZ_f.value(xval[i],yval[j],zval[k]);}}}double[][][]d3FdXdYdZ=new double[xval.length][yval.length][zval.length];TrivariateRealFunction d3FdXdYdZ_f=new TrivariateRealFunction(){public double value(double x,double y,double z){return a * FastMath.sin(omega * z - kx * x - ky * y)* kx* ky* omega;}};for (int i=0;i < xval.length;i++){for (int j=0;j < yval.length;j++){for (int k=0;k < zval.length;k++){d3FdXdYdZ[i][j][k]=d3FdXdYdZ_f.value(xval[i],yval[j],zval[k]);}}}TrivariateRealFunction tcf=new TricubicSplineInterpolatingFunction(xval,yval,zval,fval,dFdX,dFdY,dFdZ,d2FdXdY,d2FdXdZ,d2FdYdZ,d3FdXdYdZ);double x,y,z;double expected,result;x=4;y=-3;z=0;expected=f.value(x,y,z);result=tcf.value(x,y,z);Assert.assertEquals("On sample point",expected,result,1e-14);x=4.5;y=-1.5;z=-4.25;expected=f.value(x,y,z);result=tcf.value(x,y,z);Assert.assertEquals("Half-way between sample points (middle of the patch)",expected,result,0.1);x=3.5;y=-3.5;z=-10;expected=f.value(x,y,z);result=tcf.value(x,y,z);Assert.assertEquals("Half-way between sample points (border of the patch)",expected,result,0.1);}
/** * Verifies that increment()and incrementAll work properly.*/@Test public void testIncrementation()throws Exception {StorelessUnivariateStatistic statistic=(StorelessUnivariateStatistic)getUnivariateStatistic();for (int i=0;i < testArray.length;i++){statistic.increment(testArray[i]);}Assert.assertEquals(expectedValue(),statistic.getResult(),getTolerance());Assert.assertEquals(testArray.length,statistic.getN());statistic.clear();statistic.incrementAll(testArray);Assert.assertEquals(expectedValue(),statistic.getResult(),getTolerance());Assert.assertEquals(testArray.length,statistic.getN());statistic.clear();checkClearValue(statistic);Assert.assertEquals(0,statistic.getN());}
@Test public void testSerialization()throws Exception {StorelessUnivariateStatistic statistic=(StorelessUnivariateStatistic)getUnivariateStatistic();TestUtils.checkSerializedEquality(statistic);statistic.clear();for (int i=0;i < testArray.length;i++){statistic.increment(testArray[i]);if (i % 5 == 0)statistic=(StorelessUnivariateStatistic)TestUtils.serializeAndRecover(statistic);}TestUtils.checkSerializedEquality(statistic);Assert.assertEquals(expectedValue(),statistic.getResult(),getTolerance());statistic.clear();checkClearValue(statistic);}
@Test public void testEqualsAndHashCode(){StorelessUnivariateStatistic statistic=(StorelessUnivariateStatistic)getUnivariateStatistic();StorelessUnivariateStatistic statistic2=null;Assert.assertTrue("non-null,compared to null",!statistic.equals(statistic2));Assert.assertTrue("reflexive,non-null",statistic.equals(statistic));int emptyHash=statistic.hashCode();statistic2=(StorelessUnivariateStatistic)getUnivariateStatistic();Assert.assertTrue("empty stats should be equal",statistic.equals(statistic2));Assert.assertEquals("empty stats should have the same hashcode",emptyHash,statistic2.hashCode());statistic.increment(1d);Assert.assertTrue("reflexive,non-empty",statistic.equals(statistic));Assert.assertTrue("non-empty,compared to empty",!statistic.equals(statistic2));Assert.assertTrue("non-empty,compared to empty",!statistic2.equals(statistic));Assert.assertTrue("non-empty stat should have different hashcode from empty stat",statistic.hashCode()!= emptyHash);statistic2.increment(1d);Assert.assertTrue("stats with same data should be equal",statistic.equals(statistic2));Assert.assertEquals("stats with same data should have the same hashcode",statistic.hashCode(),statistic2.hashCode());statistic.increment(Double.POSITIVE_INFINITY);Assert.assertTrue("stats with different n's should not be equal",!statistic2.equals(statistic));Assert.assertTrue("stats with different n's should have different hashcodes",statistic.hashCode()!= statistic2.hashCode());statistic2.increment(Double.POSITIVE_INFINITY);Assert.assertTrue("stats with same data should be equal",statistic.equals(statistic2));Assert.assertEquals("stats with same data should have the same hashcode",statistic.hashCode(),statistic2.hashCode());statistic.clear();statistic2.clear();Assert.assertTrue("cleared stats should be equal",statistic.equals(statistic2));Assert.assertEquals("cleared stats should have thashcode of empty stat",emptyHash,statistic2.hashCode());Assert.assertEquals("cleared stats should have thashcode of empty stat",emptyHash,statistic.hashCode());}
@Test public void testMomentSmallSamples(){UnivariateStatistic stat=getUnivariateStatistic();if (stat instanceof SecondMoment){SecondMoment moment=(SecondMoment)getUnivariateStatistic();Assert.assertTrue(Double.isNaN(moment.getResult()));moment.increment(1d);Assert.assertEquals(0d,moment.getResult(),0);}}
/** * Make sure that evaluate(double[])and inrementAll(double[]),getResult()give same results.*/@Test public void testConsistency(){StorelessUnivariateStatistic stat=(StorelessUnivariateStatistic)getUnivariateStatistic();stat.incrementAll(testArray);Assert.assertEquals(stat.getResult(),stat.evaluate(testArray),getTolerance());for (int i=0;i < smallSamples.length;i++){stat.clear();for (int j=0;j < smallSamples[i].length;j++){stat.increment(smallSamples[i][j]);}TestUtils.assertEquals(stat.getResult(),stat.evaluate(smallSamples[i]),getTolerance());}}
/** * Verifies that copied statistics remain equal to originals when incremented the same way.*/@Test public void testCopyConsistency(){StorelessUnivariateStatistic master=(StorelessUnivariateStatistic)getUnivariateStatistic();StorelessUnivariateStatistic replica=null;long index=FastMath.round((FastMath.random())* testArray.length);master.incrementAll(testArray,0,(int)index);replica=master.copy();Assert.assertTrue(replica.equals(master));Assert.assertTrue(master.equals(replica));master.incrementAll(testArray,(int)index,(int)(testArray.length - index));replica.incrementAll(testArray,(int)index,(int)(testArray.length - index));Assert.assertTrue(replica.equals(master));Assert.assertTrue(master.equals(replica));}
@Test public void testSerial(){StorelessUnivariateStatistic s=(StorelessUnivariateStatistic)getUnivariateStatistic();Assert.assertEquals(s,TestUtils.serializeAndRecover(s));}
@Test public void testEvaluation()throws Exception {Assert.assertEquals(expectedValue(),getUnivariateStatistic().evaluate(testArray),getTolerance());}
@Test public void testEvaluateArraySegment(){final UnivariateStatistic stat=getUnivariateStatistic();final double[]arrayZero=new double[5];System.arraycopy(testArray,0,arrayZero,0,5);Assert.assertEquals(stat.evaluate(arrayZero),stat.evaluate(testArray,0,5),0);final double[]arrayOne=new double[5];System.arraycopy(testArray,5,arrayOne,0,5);Assert.assertEquals(stat.evaluate(arrayOne),stat.evaluate(testArray,5,5),0);final double[]arrayEnd=new double[5];System.arraycopy(testArray,testArray.length - 5,arrayEnd,0,5);Assert.assertEquals(stat.evaluate(arrayEnd),stat.evaluate(testArray,testArray.length - 5,5),0);}
@Test public void testEvaluateArraySegmentWeighted(){UnivariateStatistic statistic=getUnivariateStatistic();if (!(statistic instanceof WeightedEvaluation)){return;}final WeightedEvaluation stat=(WeightedEvaluation)getUnivariateStatistic();final double[]arrayZero=new double[5];final double[]weightZero=new double[5];System.arraycopy(testArray,0,arrayZero,0,5);System.arraycopy(testWeightsArray,0,weightZero,0,5);Assert.assertEquals(stat.evaluate(arrayZero,weightZero),stat.evaluate(testArray,testWeightsArray,0,5),0);final double[]arrayOne=new double[5];final double[]weightOne=new double[5];System.arraycopy(testArray,5,arrayOne,0,5);System.arraycopy(testWeightsArray,5,weightOne,0,5);Assert.assertEquals(stat.evaluate(arrayOne,weightOne),stat.evaluate(testArray,testWeightsArray,5,5),0);final double[]arrayEnd=new double[5];final double[]weightEnd=new double[5];System.arraycopy(testArray,testArray.length - 5,arrayEnd,0,5);System.arraycopy(testWeightsArray,testArray.length - 5,weightEnd,0,5);Assert.assertEquals(stat.evaluate(arrayEnd,weightEnd),stat.evaluate(testArray,testWeightsArray,testArray.length - 5,5),0);}
@Test public void testCopy()throws Exception {UnivariateStatistic original=getUnivariateStatistic();UnivariateStatistic copy=original.copy();Assert.assertEquals(expectedValue(),copy.evaluate(testArray),getTolerance());}
/** * Tests consistency of weighted statistic computation. For statistics that support weighted evaluation,this test case compares the result of direct computation on an array with repeated values with a weighted computation on the corresponding (shorter)array with each value appearing only once but with a weight value equal to its multiplicity in the repeating array.*/@Test public void testWeightedConsistency()throws Exception {UnivariateStatistic statistic=getUnivariateStatistic();if (!(statistic instanceof WeightedEvaluation)){return;}final int len=10;final double mu=0;final double sigma=5;double[]values=new double[len];double[]weights=new double[len];RandomData randomData=new RandomDataImpl();int[]intWeights=new int[len];for (int i=0;i < len;i++){intWeights[i]=randomData.nextInt(1,5);weights[i]=intWeights[i];}List<Double> valuesList=new ArrayList<Double>();for (int i=0;i < len;i++){double value=randomData.nextGaussian(mu,sigma);values[i]=value;for (int j=0;j < intWeights[i];j++){valuesList.add(new Double(value));}}int sumWeights=valuesList.size();double[]repeatedValues=new double[sumWeights];for (int i=0;i < sumWeights;i++){repeatedValues[i]=valuesList.get(i);}WeightedEvaluation weightedStatistic=(WeightedEvaluation)statistic;TestUtils.assertRelativelyEquals(statistic.evaluate(repeatedValues),weightedStatistic.evaluate(values,weights,0,values.length),10E-14);Assert.assertEquals(weightedStatistic.evaluate(values,weights,0,values.length),weightedStatistic.evaluate(values,weights),Double.MIN_VALUE);}
@Test public void testLonglySimpleVar(){double rCov=12333921.73333333246;StorelessBivariateCovariance cov=new StorelessBivariateCovariance();for (int i=0;i < longleyDataSimple.length;i++){cov.increment(longleyDataSimple[i][0],longleyDataSimple[i][0]);}TestUtils.assertEquals("simple covariance test",rCov,cov.getResult(),10E-7);}
@Test public void testLonglySimpleCov(){double rCov=36796.660000;StorelessBivariateCovariance cov=new StorelessBivariateCovariance();for (int i=0;i < longleyDataSimple.length;i++){cov.increment(longleyDataSimple[i][0],longleyDataSimple[i][1]);}TestUtils.assertEquals("simple covariance test",rCov,cov.getResult(),10E-7);}
/** * Test Longley dataset against R. Data Source: J. Longley (1967)"An Appraisal of Least Squares Programs for the Electronic Computer from the Point of View of the User" Journal of the American Statistical Association,vol. 62. September,pp. 819-841. Data are from NIST: http://www.itl.nist.gov/div898/strd/lls/data/LINKS/DATA/Longley.dat*/@Test public void testLonglyByRow(){RealMatrix matrix=createRealMatrix(longleyData,16,7);double[]rData=new double[]{12333921.73333333246,3.679666000000000e+04,343330206.333333313,1649102.666666666744,1117681.066666666651,23461965.733333334,16240.93333333333248,36796.66000000000,1.164576250000000e+02,1063604.115416667,6258.666250000000,3490.253750000000,73503.000000000,50.92333333333334,343330206.33333331347,1.063604115416667e+06,9879353659.329166412,56124369.854166664183,30880428.345833335072,685240944.600000024,470977.90000000002328,1649102.66666666674,6.258666250000000e+03,56124369.854166664,873223.429166666698,-115378.762499999997,4462741.533333333,2973.03333333333330,1117681.06666666665,3.490253750000000e+03,30880428.345833335,-115378.762499999997,484304.095833333326,1764098.133333333,1382.43333333333339,23461965.73333333433,7.350300000000000e+04,685240944.600000024,4462741.533333333209,1764098.133333333302,48387348.933333330,32917.40000000000146,16240.93333333333,5.092333333333334e+01,470977.900000000,2973.033333333333,1382.433333333333,32917.40000000,22.66666666666667};StorelessCovariance covMatrix=new StorelessCovariance(7,7);for (int i=0;i < matrix.getRowDimension();i++){covMatrix.incrementRow(matrix.getRow(i));}RealMatrix covarianceMatrix=covMatrix.getCovarianceMatrix();TestUtils.assertEquals("covariance matrix",createRealMatrix(rData,7,7),covarianceMatrix,10E-7);}
/** * Test R Swiss fertility dataset against R. Data Source: R datasets package*/@Test public void testSwissFertilityByRow(){RealMatrix matrix=createRealMatrix(swissData,47,5);double[]rData=new double[]{156.0424976873265,100.1691489361702,-64.36692876965772,-79.7295097132285,241.5632030527289,100.169148936170251,515.7994172062905,-124.39283071230344,-139.6574005550416,379.9043755781684,-64.3669287696577,-124.3928307123034,63.64662349676226,53.5758556891767,-190.5606105457909,-79.7295097132285,-139.6574005550416,53.57585568917669,92.4560592044403,-61.6988297872340,241.5632030527289,379.9043755781684,-190.56061054579092,-61.6988297872340,1739.2945371877890};StorelessCovariance covMatrix=new StorelessCovariance(5,5);for (int i=0;i < matrix.getRowDimension();i++){covMatrix.incrementRow(matrix.getRow(i));}RealMatrix covarianceMatrix=covMatrix.getCovarianceMatrix();TestUtils.assertEquals("covariance matrix",createRealMatrix(rData,5,5),covarianceMatrix,10E-13);}
/** * Test Longley dataset against R. Data Source: J. Longley (1967)"An Appraisal of Least Squares Programs for the Electronic Computer from the Point of View of the User" Journal of the American Statistical Association,vol. 62. September,pp. 819-841. Data are from NIST: http://www.itl.nist.gov/div898/strd/lls/data/LINKS/DATA/Longley.dat*/@Test public void testLonglyByEntry(){RealMatrix matrix=createRealMatrix(longleyData,16,7);double[]rData=new double[]{12333921.73333333246,3.679666000000000e+04,343330206.333333313,1649102.666666666744,1117681.066666666651,23461965.733333334,16240.93333333333248,36796.66000000000,1.164576250000000e+02,1063604.115416667,6258.666250000000,3490.253750000000,73503.000000000,50.92333333333334,343330206.33333331347,1.063604115416667e+06,9879353659.329166412,56124369.854166664183,30880428.345833335072,685240944.600000024,470977.90000000002328,1649102.66666666674,6.258666250000000e+03,56124369.854166664,873223.429166666698,-115378.762499999997,4462741.533333333,2973.03333333333330,1117681.06666666665,3.490253750000000e+03,30880428.345833335,-115378.762499999997,484304.095833333326,1764098.133333333,1382.43333333333339,23461965.73333333433,7.350300000000000e+04,685240944.600000024,4462741.533333333209,1764098.133333333302,48387348.933333330,32917.40000000000146,16240.93333333333,5.092333333333334e+01,470977.900000000,2973.033333333333,1382.433333333333,32917.40000000,22.66666666666667};int row=matrix.getRowDimension();int col=matrix.getColumnDimension();double x=0.0;double y=0.0;StorelessCovariance covMatrix=new StorelessCovariance(7,7);for (int i=0;i < row;i++){for (int j=0;j < col;j++){x=matrix.getEntry(i,j);for (int k=0;k < col;k++){y=matrix.getEntry(i,k);covMatrix.incrementCovariance(j,k,x,y);}}}RealMatrix covarianceMatrix=covMatrix.getCovarianceMatrix();TestUtils.assertEquals("covariance matrix",createRealMatrix(rData,7,7),covarianceMatrix,10E-7);}
/** * Test R Swiss fertility dataset against R. Data Source: R datasets package*/@Test public void testSwissFertilityByEntry(){RealMatrix matrix=createRealMatrix(swissData,47,5);double[]rData=new double[]{156.0424976873265,100.1691489361702,-64.36692876965772,-79.7295097132285,241.5632030527289,100.169148936170251,515.7994172062905,-124.39283071230344,-139.6574005550416,379.9043755781684,-64.3669287696577,-124.3928307123034,63.64662349676226,53.5758556891767,-190.5606105457909,-79.7295097132285,-139.6574005550416,53.57585568917669,92.4560592044403,-61.6988297872340,241.5632030527289,379.9043755781684,-190.56061054579092,-61.6988297872340,1739.2945371877890};int row=matrix.getRowDimension();int col=matrix.getColumnDimension();double x=0.0;double y=0.0;StorelessCovariance covMatrix=new StorelessCovariance(5,5);for (int i=0;i < row;i++){for (int j=0;j < col;j++){x=matrix.getEntry(i,j);for (int k=0;k < col;k++){y=matrix.getEntry(i,k);covMatrix.incrementCovariance(j,k,x,y);}}}RealMatrix covarianceMatrix=covMatrix.getCovarianceMatrix();TestUtils.assertEquals("covariance matrix",createRealMatrix(rData,5,5),covarianceMatrix,10E-13);}
@Test public void testSpecialValues(){double[]testArray={0d,Double.NaN,Double.POSITIVE_INFINITY,Double.NEGATIVE_INFINITY};Min min=new Min();Assert.assertTrue(Double.isNaN(min.getResult()));min.increment(testArray[0]);Assert.assertEquals(0d,min.getResult(),0);min.increment(testArray[1]);Assert.assertEquals(0d,min.getResult(),0);min.increment(testArray[2]);Assert.assertEquals(0d,min.getResult(),0);min.increment(testArray[3]);Assert.assertEquals(Double.NEGATIVE_INFINITY,min.getResult(),0);Assert.assertEquals(Double.NEGATIVE_INFINITY,min.evaluate(testArray),0);}
@Test public void testNaNs(){Min min=new Min();double nan=Double.NaN;Assert.assertEquals(2d,min.evaluate(new double[]{nan,2d,3d}),0);Assert.assertEquals(1d,min.evaluate(new double[]{1d,nan,3d}),0);Assert.assertEquals(1d,min.evaluate(new double[]{1d,2d,nan}),0);Assert.assertTrue(Double.isNaN(min.evaluate(new double[]{nan,nan,nan})));}
/** * Verifies that increment()and incrementAll work properly.*/@Test public void testIncrementation()throws Exception {StorelessUnivariateStatistic statistic=(StorelessUnivariateStatistic)getUnivariateStatistic();for (int i=0;i < testArray.length;i++){statistic.increment(testArray[i]);}Assert.assertEquals(expectedValue(),statistic.getResult(),getTolerance());Assert.assertEquals(testArray.length,statistic.getN());statistic.clear();statistic.incrementAll(testArray);Assert.assertEquals(expectedValue(),statistic.getResult(),getTolerance());Assert.assertEquals(testArray.length,statistic.getN());statistic.clear();checkClearValue(statistic);Assert.assertEquals(0,statistic.getN());}
@Test public void testSerialization()throws Exception {StorelessUnivariateStatistic statistic=(StorelessUnivariateStatistic)getUnivariateStatistic();TestUtils.checkSerializedEquality(statistic);statistic.clear();for (int i=0;i < testArray.length;i++){statistic.increment(testArray[i]);if (i % 5 == 0)statistic=(StorelessUnivariateStatistic)TestUtils.serializeAndRecover(statistic);}TestUtils.checkSerializedEquality(statistic);Assert.assertEquals(expectedValue(),statistic.getResult(),getTolerance());statistic.clear();checkClearValue(statistic);}
@Test public void testEqualsAndHashCode(){StorelessUnivariateStatistic statistic=(StorelessUnivariateStatistic)getUnivariateStatistic();StorelessUnivariateStatistic statistic2=null;Assert.assertTrue("non-null,compared to null",!statistic.equals(statistic2));Assert.assertTrue("reflexive,non-null",statistic.equals(statistic));int emptyHash=statistic.hashCode();statistic2=(StorelessUnivariateStatistic)getUnivariateStatistic();Assert.assertTrue("empty stats should be equal",statistic.equals(statistic2));Assert.assertEquals("empty stats should have the same hashcode",emptyHash,statistic2.hashCode());statistic.increment(1d);Assert.assertTrue("reflexive,non-empty",statistic.equals(statistic));Assert.assertTrue("non-empty,compared to empty",!statistic.equals(statistic2));Assert.assertTrue("non-empty,compared to empty",!statistic2.equals(statistic));Assert.assertTrue("non-empty stat should have different hashcode from empty stat",statistic.hashCode()!= emptyHash);statistic2.increment(1d);Assert.assertTrue("stats with same data should be equal",statistic.equals(statistic2));Assert.assertEquals("stats with same data should have the same hashcode",statistic.hashCode(),statistic2.hashCode());statistic.increment(Double.POSITIVE_INFINITY);Assert.assertTrue("stats with different n's should not be equal",!statistic2.equals(statistic));Assert.assertTrue("stats with different n's should have different hashcodes",statistic.hashCode()!= statistic2.hashCode());statistic2.increment(Double.POSITIVE_INFINITY);Assert.assertTrue("stats with same data should be equal",statistic.equals(statistic2));Assert.assertEquals("stats with same data should have the same hashcode",statistic.hashCode(),statistic2.hashCode());statistic.clear();statistic2.clear();Assert.assertTrue("cleared stats should be equal",statistic.equals(statistic2));Assert.assertEquals("cleared stats should have thashcode of empty stat",emptyHash,statistic2.hashCode());Assert.assertEquals("cleared stats should have thashcode of empty stat",emptyHash,statistic.hashCode());}
@Test public void testMomentSmallSamples(){UnivariateStatistic stat=getUnivariateStatistic();if (stat instanceof SecondMoment){SecondMoment moment=(SecondMoment)getUnivariateStatistic();Assert.assertTrue(Double.isNaN(moment.getResult()));moment.increment(1d);Assert.assertEquals(0d,moment.getResult(),0);}}
/** * Make sure that evaluate(double[])and inrementAll(double[]),getResult()give same results.*/@Test public void testConsistency(){StorelessUnivariateStatistic stat=(StorelessUnivariateStatistic)getUnivariateStatistic();stat.incrementAll(testArray);Assert.assertEquals(stat.getResult(),stat.evaluate(testArray),getTolerance());for (int i=0;i < smallSamples.length;i++){stat.clear();for (int j=0;j < smallSamples[i].length;j++){stat.increment(smallSamples[i][j]);}TestUtils.assertEquals(stat.getResult(),stat.evaluate(smallSamples[i]),getTolerance());}}
/** * Verifies that copied statistics remain equal to originals when incremented the same way.*/@Test public void testCopyConsistency(){StorelessUnivariateStatistic master=(StorelessUnivariateStatistic)getUnivariateStatistic();StorelessUnivariateStatistic replica=null;long index=FastMath.round((FastMath.random())* testArray.length);master.incrementAll(testArray,0,(int)index);replica=master.copy();Assert.assertTrue(replica.equals(master));Assert.assertTrue(master.equals(replica));master.incrementAll(testArray,(int)index,(int)(testArray.length - index));replica.incrementAll(testArray,(int)index,(int)(testArray.length - index));Assert.assertTrue(replica.equals(master));Assert.assertTrue(master.equals(replica));}
@Test public void testSerial(){StorelessUnivariateStatistic s=(StorelessUnivariateStatistic)getUnivariateStatistic();Assert.assertEquals(s,TestUtils.serializeAndRecover(s));}
@Test public void testEvaluation()throws Exception {Assert.assertEquals(expectedValue(),getUnivariateStatistic().evaluate(testArray),getTolerance());}
@Test public void testEvaluateArraySegment(){final UnivariateStatistic stat=getUnivariateStatistic();final double[]arrayZero=new double[5];System.arraycopy(testArray,0,arrayZero,0,5);Assert.assertEquals(stat.evaluate(arrayZero),stat.evaluate(testArray,0,5),0);final double[]arrayOne=new double[5];System.arraycopy(testArray,5,arrayOne,0,5);Assert.assertEquals(stat.evaluate(arrayOne),stat.evaluate(testArray,5,5),0);final double[]arrayEnd=new double[5];System.arraycopy(testArray,testArray.length - 5,arrayEnd,0,5);Assert.assertEquals(stat.evaluate(arrayEnd),stat.evaluate(testArray,testArray.length - 5,5),0);}
@Test public void testEvaluateArraySegmentWeighted(){UnivariateStatistic statistic=getUnivariateStatistic();if (!(statistic instanceof WeightedEvaluation)){return;}final WeightedEvaluation stat=(WeightedEvaluation)getUnivariateStatistic();final double[]arrayZero=new double[5];final double[]weightZero=new double[5];System.arraycopy(testArray,0,arrayZero,0,5);System.arraycopy(testWeightsArray,0,weightZero,0,5);Assert.assertEquals(stat.evaluate(arrayZero,weightZero),stat.evaluate(testArray,testWeightsArray,0,5),0);final double[]arrayOne=new double[5];final double[]weightOne=new double[5];System.arraycopy(testArray,5,arrayOne,0,5);System.arraycopy(testWeightsArray,5,weightOne,0,5);Assert.assertEquals(stat.evaluate(arrayOne,weightOne),stat.evaluate(testArray,testWeightsArray,5,5),0);final double[]arrayEnd=new double[5];final double[]weightEnd=new double[5];System.arraycopy(testArray,testArray.length - 5,arrayEnd,0,5);System.arraycopy(testWeightsArray,testArray.length - 5,weightEnd,0,5);Assert.assertEquals(stat.evaluate(arrayEnd,weightEnd),stat.evaluate(testArray,testWeightsArray,testArray.length - 5,5),0);}
@Test public void testCopy()throws Exception {UnivariateStatistic original=getUnivariateStatistic();UnivariateStatistic copy=original.copy();Assert.assertEquals(expectedValue(),copy.evaluate(testArray),getTolerance());}
/** * Tests consistency of weighted statistic computation. For statistics that support weighted evaluation,this test case compares the result of direct computation on an array with repeated values with a weighted computation on the corresponding (shorter)array with each value appearing only once but with a weight value equal to its multiplicity in the repeating array.*/@Test public void testWeightedConsistency()throws Exception {UnivariateStatistic statistic=getUnivariateStatistic();if (!(statistic instanceof WeightedEvaluation)){return;}final int len=10;final double mu=0;final double sigma=5;double[]values=new double[len];double[]weights=new double[len];RandomData randomData=new RandomDataImpl();int[]intWeights=new int[len];for (int i=0;i < len;i++){intWeights[i]=randomData.nextInt(1,5);weights[i]=intWeights[i];}List<Double> valuesList=new ArrayList<Double>();for (int i=0;i < len;i++){double value=randomData.nextGaussian(mu,sigma);values[i]=value;for (int j=0;j < intWeights[i];j++){valuesList.add(new Double(value));}}int sumWeights=valuesList.size();double[]repeatedValues=new double[sumWeights];for (int i=0;i < sumWeights;i++){repeatedValues[i]=valuesList.get(i);}WeightedEvaluation weightedStatistic=(WeightedEvaluation)statistic;TestUtils.assertRelativelyEquals(statistic.evaluate(repeatedValues),weightedStatistic.evaluate(values,weights,0,values.length),10E-14);Assert.assertEquals(weightedStatistic.evaluate(values,weights,0,values.length),weightedStatistic.evaluate(values,weights),Double.MIN_VALUE);}
@Test(expected=NotStrictlyPositiveException.class)public void testPreconditions1(){new ZipfDistribution(0,1);}
@Test(expected=NotStrictlyPositiveException.class)public void testPreconditions2(){new ZipfDistribution(1,0);}
@Test public void testMoments(){final double tol=1e-9;ZipfDistribution dist;dist=new ZipfDistribution(2,0.5);Assert.assertEquals(dist.getNumericalMean(),FastMath.sqrt(2),tol);Assert.assertEquals(dist.getNumericalVariance(),0.24264068711928521,tol);}
/** * Verifies that probability density calculations match expected values using default test instance data*/@Test public void testDensities()throws Exception {verifyDensities();}
/** * Verifies that cumulative probability density calculations match expected values using default test instance data*/@Test public void testCumulativeProbabilities()throws Exception {verifyCumulativeProbabilities();}
/** * Verifies that floating point arguments are correctly handled by cumulativeProbablility(-,-)JIRA: MATH-184*/@Test public void testFloatingPointArguments()throws Exception {for (int i=0;i < cumulativeTestPoints.length;i++){double arg=cumulativeTestPoints[i];Assert.assertEquals("Incorrect cumulative probability value returned for " + cumulativeTestPoints[i],cumulativeTestValues[i],distribution.cumulativeProbability(arg),tolerance);if (i < cumulativeTestPoints.length - 1){double arg2=cumulativeTestPoints[i + 1];Assert.assertEquals("Inconsistent probability for discrete range " + "[" + arg + ","+ arg2+ " ]",distribution.cumulativeProbability(cumulativeTestPoints[i],cumulativeTestPoints[i + 1]),distribution.cumulativeProbability(arg,arg2),tolerance);arg=arg - FastMath.random();arg2=arg2 + FastMath.random();Assert.assertEquals("Inconsistent probability for discrete range " + "[" + arg + ","+ arg2+ " ]",distribution.cumulativeProbability(cumulativeTestPoints[i],cumulativeTestPoints[i + 1]),distribution.cumulativeProbability(arg,arg2),tolerance);}}int one=1;int ten=10;int two=2;double oned=one;double twod=two;double tend=ten;Assert.assertEquals(distribution.cumulativeProbability(one,two),distribution.cumulativeProbability(oned,twod),tolerance);Assert.assertEquals(distribution.cumulativeProbability(one,two),distribution.cumulativeProbability(oned - tolerance,twod + 0.9),tolerance);Assert.assertEquals(distribution.cumulativeProbability(two,ten),distribution.cumulativeProbability(twod,tend),tolerance);Assert.assertEquals(distribution.cumulativeProbability(two,ten),distribution.cumulativeProbability(twod - tolerance,tend + 0.9),tolerance);}
/** * Verifies that inverse cumulative probability density calculations match expected values using default test instance data*/@Test public void testInverseCumulativeProbabilities()throws Exception {verifyInverseCumulativeProbabilities();}
/** * Verifies that illegal arguments are correctly handled*/@Test public void testIllegalArguments()throws Exception {try {distribution.cumulativeProbability(1,0);Assert.fail("Expecting MathIllegalArgumentException for bad cumulativeProbability interval");}catch(MathIllegalArgumentException ex){}try {distribution.inverseCumulativeProbability(-1);Assert.fail("Expecting MathIllegalArgumentException for p = -1");}catch(MathIllegalArgumentException ex){}try {distribution.inverseCumulativeProbability(2);Assert.fail("Expecting MathIllegalArgumentException for p = 2");}catch(MathIllegalArgumentException ex){}}
/** * Test sampling*/@Test public void testSampling()throws Exception {int[]densityPoints=makeDensityTestPoints();double[]densityValues=makeDensityTestValues();int sampleSize=1000;int length=TestUtils.eliminateZeroMassPoints(densityPoints,densityValues);AbstractIntegerDistribution distribution=(AbstractIntegerDistribution)makeDistribution();double[]expectedCounts=new double[length];long[]observedCounts=new long[length];for (int i=0;i < length;i++){expectedCounts[i]=sampleSize * densityValues[i];}distribution.reseedRandomGenerator(1000);int[]sample=distribution.sample(sampleSize);for (int i=0;i < sampleSize;i++){for (int j=0;j < length;j++){if (sample[i]== densityPoints[j]){observedCounts[j]++;}}}TestUtils.assertChiSquareAccept(densityPoints,expectedCounts,observedCounts,.001);}
@Test public void testSinZero(){UnivariateFunction f=new SinFunction();double result;UnivariateRealSolver solver=getSolver();result=solver.solve(100,f,3,4);Assert.assertEquals(result,FastMath.PI,solver.getAbsoluteAccuracy());Assert.assertTrue(solver.getEvaluations()<= 6);result=solver.solve(100,f,1,4);Assert.assertEquals(result,FastMath.PI,solver.getAbsoluteAccuracy());Assert.assertTrue(solver.getEvaluations()<= 7);}
@Test public void testQuinticZero(){UnivariateFunction f=new QuinticFunction();double result;UnivariateRealSolver solver=getSolver();double atol=solver.getAbsoluteAccuracy();int[]counts=getQuinticEvalCounts();double[][]testsData={{-0.2,0.2,0.0},{-0.1,0.3,0.0},{-0.3,0.45,0.0},{0.3,0.7,0.5},{0.2,0.6,0.5},{0.05,0.95,0.5},{0.85,1.25,1.0},{0.8,1.2,1.0},{0.85,1.75,1.0},{0.55,1.45,1.0},{0.85,5.0,1.0}};int maxIter=500;for (int i=0;i < testsData.length;i++){if (counts[i]== -1)continue;double[]testData=testsData[i];result=solver.solve(maxIter,f,testData[0],testData[1]);Assert.assertEquals(result,testData[2],atol);Assert.assertTrue(solver.getEvaluations()<= counts[i]+ 1);}}
@Test public void testRootEndpoints(){UnivariateFunction f=new XMinus5Function();UnivariateRealSolver solver=getSolver();double result=solver.solve(100,f,5.0,6.0);Assert.assertEquals(5.0,result,0.0);result=solver.solve(100,f,4.0,5.0);Assert.assertEquals(5.0,result,0.0);result=solver.solve(100,f,5.0,6.0,5.5);Assert.assertEquals(5.0,result,0.0);result=solver.solve(100,f,4.0,5.0,4.5);Assert.assertEquals(5.0,result,0.0);}
@Test public void testBadEndpoints(){UnivariateFunction f=new SinFunction();UnivariateRealSolver solver=getSolver();try {solver.solve(100,f,1,-1);Assert.fail("Expecting NumberIsTooLargeException - bad interval");}catch(NumberIsTooLargeException ex){}try {solver.solve(100,f,1,1.5);Assert.fail("Expecting NoBracketingException - non-bracketing");}catch(NoBracketingException ex){}try {solver.solve(100,f,1,1.5,1.2);Assert.fail("Expecting NoBracketingException - non-bracketing");}catch(NoBracketingException ex){}}
@Test public void testSolutionLeftSide(){UnivariateFunction f=new SinFunction();UnivariateRealSolver solver=getSolver();double left=-1.5;double right=0.05;for (int i=0;i < 10;i++){double solution=getSolution(solver,100,f,left,right,AllowedSolution.LEFT_SIDE);if (!Double.isNaN(solution)){Assert.assertTrue(solution <= 0.0);}left-=0.1;right+=0.3;}}
@Test public void testSolutionRightSide(){UnivariateFunction f=new SinFunction();UnivariateRealSolver solver=getSolver();double left=-1.5;double right=0.05;for (int i=0;i < 10;i++){double solution=getSolution(solver,100,f,left,right,AllowedSolution.RIGHT_SIDE);if (!Double.isNaN(solution)){Assert.assertTrue(solution >= 0.0);}left-=0.1;right+=0.3;}}
@Test public void testSolutionBelowSide(){UnivariateFunction f=new SinFunction();UnivariateRealSolver solver=getSolver();double left=-1.5;double right=0.05;for (int i=0;i < 10;i++){double solution=getSolution(solver,100,f,left,right,AllowedSolution.BELOW_SIDE);if (!Double.isNaN(solution)){Assert.assertTrue(f.value(solution)<= 0.0);}left-=0.1;right+=0.3;}}
@Test public void testSolutionAboveSide(){UnivariateFunction f=new SinFunction();UnivariateRealSolver solver=getSolver();double left=-1.5;double right=0.05;for (int i=0;i < 10;i++){double solution=getSolution(solver,100,f,left,right,AllowedSolution.ABOVE_SIDE);if (!Double.isNaN(solution)){Assert.assertTrue(f.value(solution)>= 0.0);}left-=0.1;right+=0.3;}}
/** * test dimensions */@Test public void testDimensions(){BlockFieldMatrix<Fraction> m=new BlockFieldMatrix<Fraction>(testData);BlockFieldMatrix<Fraction> m2=new BlockFieldMatrix<Fraction>(testData2);Assert.assertEquals("testData row dimension",3,m.getRowDimension());Assert.assertEquals("testData column dimension",3,m.getColumnDimension());Assert.assertTrue("testData is square",m.isSquare());Assert.assertEquals("testData2 row dimension",m2.getRowDimension(),2);Assert.assertEquals("testData2 column dimension",m2.getColumnDimension(),3);Assert.assertTrue("testData2 is not square",!m2.isSquare());}
/** * test copy functions */@Test public void testCopyFunctions(){Random r=new Random(66636328996002l);BlockFieldMatrix<Fraction> m1=createRandomMatrix(r,47,83);BlockFieldMatrix<Fraction> m2=new BlockFieldMatrix<Fraction>(m1.getData());Assert.assertEquals(m1,m2);BlockFieldMatrix<Fraction> m3=new BlockFieldMatrix<Fraction>(testData);BlockFieldMatrix<Fraction> m4=new BlockFieldMatrix<Fraction>(m3.getData());Assert.assertEquals(m3,m4);}
/** * test add */@Test public void testAdd(){BlockFieldMatrix<Fraction> m=new BlockFieldMatrix<Fraction>(testData);BlockFieldMatrix<Fraction> mInv=new BlockFieldMatrix<Fraction>(testDataInv);FieldMatrix<Fraction> mPlusMInv=m.add(mInv);Fraction[][]sumEntries=mPlusMInv.getData();for (int row=0;row < m.getRowDimension();row++){for (int col=0;col < m.getColumnDimension();col++){Assert.assertEquals(testDataPlusInv[row][col],sumEntries[row][col]);}}}
/** * test add failure */@Test public void testAddFail(){BlockFieldMatrix<Fraction> m=new BlockFieldMatrix<Fraction>(testData);BlockFieldMatrix<Fraction> m2=new BlockFieldMatrix<Fraction>(testData2);try {m.add(m2);Assert.fail("MathIllegalArgumentException expected");}catch(MathIllegalArgumentException ex){}}
/** * test m-n = m + -n */@Test public void testPlusMinus(){BlockFieldMatrix<Fraction> m=new BlockFieldMatrix<Fraction>(testData);BlockFieldMatrix<Fraction> m2=new BlockFieldMatrix<Fraction>(testDataInv);TestUtils.assertEquals(m.subtract(m2),m2.scalarMultiply(new Fraction(-1)).add(m));try {m.subtract(new BlockFieldMatrix<Fraction>(testData2));Assert.fail("Expecting illegalArgumentException");}catch(MathIllegalArgumentException ex){}}
/** * test multiply */@Test public void testMultiply(){BlockFieldMatrix<Fraction> m=new BlockFieldMatrix<Fraction>(testData);BlockFieldMatrix<Fraction> mInv=new BlockFieldMatrix<Fraction>(testDataInv);BlockFieldMatrix<Fraction> identity=new BlockFieldMatrix<Fraction>(id);BlockFieldMatrix<Fraction> m2=new BlockFieldMatrix<Fraction>(testData2);TestUtils.assertEquals(m.multiply(mInv),identity);TestUtils.assertEquals(mInv.multiply(m),identity);TestUtils.assertEquals(m.multiply(identity),m);TestUtils.assertEquals(identity.multiply(mInv),mInv);TestUtils.assertEquals(m2.multiply(identity),m2);try {m.multiply(new BlockFieldMatrix<Fraction>(bigSingular));Assert.fail("Expecting illegalArgumentException");}catch(MathIllegalArgumentException ex){}}
@Test public void testSeveralBlocks(){FieldMatrix<Fraction> m=new BlockFieldMatrix<Fraction>(FractionField.getInstance(),37,41);for (int i=0;i < m.getRowDimension();++i){for (int j=0;j < m.getColumnDimension();++j){m.setEntry(i,j,new Fraction(i * 11 + j,11));}}FieldMatrix<Fraction> mT=m.transpose();Assert.assertEquals(m.getRowDimension(),mT.getColumnDimension());Assert.assertEquals(m.getColumnDimension(),mT.getRowDimension());for (int i=0;i < mT.getRowDimension();++i){for (int j=0;j < mT.getColumnDimension();++j){Assert.assertEquals(m.getEntry(j,i),mT.getEntry(i,j));}}FieldMatrix<Fraction> mPm=m.add(m);for (int i=0;i < mPm.getRowDimension();++i){for (int j=0;j < mPm.getColumnDimension();++j){Assert.assertEquals(m.getEntry(i,j).multiply(new Fraction(2)),mPm.getEntry(i,j));}}FieldMatrix<Fraction> mPmMm=mPm.subtract(m);for (int i=0;i < mPmMm.getRowDimension();++i){for (int j=0;j < mPmMm.getColumnDimension();++j){Assert.assertEquals(m.getEntry(i,j),mPmMm.getEntry(i,j));}}FieldMatrix<Fraction> mTm=mT.multiply(m);for (int i=0;i < mTm.getRowDimension();++i){for (int j=0;j < mTm.getColumnDimension();++j){Fraction sum=Fraction.ZERO;for (int k=0;k < mT.getColumnDimension();++k){sum=sum.add(new Fraction(k * 11 + i,11).multiply(new Fraction(k * 11 + j,11)));}Assert.assertEquals(sum,mTm.getEntry(i,j));}}FieldMatrix<Fraction> mmT=m.multiply(mT);for (int i=0;i < mmT.getRowDimension();++i){for (int j=0;j < mmT.getColumnDimension();++j){Fraction sum=Fraction.ZERO;for (int k=0;k < m.getColumnDimension();++k){sum=sum.add(new Fraction(i * 11 + k,11).multiply(new Fraction(j * 11 + k,11)));}Assert.assertEquals(sum,mmT.getEntry(i,j));}}FieldMatrix<Fraction> sub1=m.getSubMatrix(2,9,5,20);for (int i=0;i < sub1.getRowDimension();++i){for (int j=0;j < sub1.getColumnDimension();++j){Assert.assertEquals(new Fraction((i + 2)* 11 + (j + 5),11),sub1.getEntry(i,j));}}FieldMatrix<Fraction> sub2=m.getSubMatrix(10,12,3,40);for (int i=0;i < sub2.getRowDimension();++i){for (int j=0;j < sub2.getColumnDimension();++j){Assert.assertEquals(new Fraction((i + 10)* 11 + (j + 3),11),sub2.getEntry(i,j));}}FieldMatrix<Fraction> sub3=m.getSubMatrix(30,34,0,5);for (int i=0;i < sub3.getRowDimension();++i){for (int j=0;j < sub3.getColumnDimension();++j){Assert.assertEquals(new Fraction((i + 30)* 11 + (j + 0),11),sub3.getEntry(i,j));}}FieldMatrix<Fraction> sub4=m.getSubMatrix(30,32,32,35);for (int i=0;i < sub4.getRowDimension();++i){for (int j=0;j < sub4.getColumnDimension();++j){Assert.assertEquals(new Fraction((i + 30)* 11 + (j + 32),11),sub4.getEntry(i,j));}}}
@Test public void testMultiply2(){FieldMatrix<Fraction> m3=new BlockFieldMatrix<Fraction>(d3);FieldMatrix<Fraction> m4=new BlockFieldMatrix<Fraction>(d4);FieldMatrix<Fraction> m5=new BlockFieldMatrix<Fraction>(d5);TestUtils.assertEquals(m3.multiply(m4),m5);}
/** * test trace */@Test public void testTrace(){FieldMatrix<Fraction> m=new BlockFieldMatrix<Fraction>(id);Assert.assertEquals(new Fraction(3),m.getTrace());m=new BlockFieldMatrix<Fraction>(testData2);try {m.getTrace();Assert.fail("Expecting NonSquareMatrixException");}catch(NonSquareMatrixException ex){}}
/** * test scalarAdd */@Test public void testScalarAdd(){FieldMatrix<Fraction> m=new BlockFieldMatrix<Fraction>(testData);TestUtils.assertEquals(new BlockFieldMatrix<Fraction>(testDataPlus2),m.scalarAdd(new Fraction(2)));}
/** * test operate */@Test public void testOperate(){FieldMatrix<Fraction> m=new BlockFieldMatrix<Fraction>(id);TestUtils.assertEquals(testVector,m.operate(testVector));TestUtils.assertEquals(testVector,m.operate(new ArrayFieldVector<Fraction>(testVector)).getData());m=new BlockFieldMatrix<Fraction>(bigSingular);try {m.operate(testVector);Assert.fail("Expecting illegalArgumentException");}catch(MathIllegalArgumentException ex){}}
@Test public void testOperateLarge(){int p=(11 * BlockFieldMatrix.BLOCK_SIZE)/ 10;int q=(11 * BlockFieldMatrix.BLOCK_SIZE)/ 10;int r=BlockFieldMatrix.BLOCK_SIZE / 2;Random random=new Random(111007463902334l);FieldMatrix<Fraction> m1=createRandomMatrix(random,p,q);FieldMatrix<Fraction> m2=createRandomMatrix(random,q,r);FieldMatrix<Fraction> m1m2=m1.multiply(m2);for (int i=0;i < r;++i){TestUtils.assertEquals(m1m2.getColumn(i),m1.operate(m2.getColumn(i)));}}
@Test public void testOperatePremultiplyLarge(){int p=(11 * BlockFieldMatrix.BLOCK_SIZE)/ 10;int q=(11 * BlockFieldMatrix.BLOCK_SIZE)/ 10;int r=BlockFieldMatrix.BLOCK_SIZE / 2;Random random=new Random(111007463902334l);FieldMatrix<Fraction> m1=createRandomMatrix(random,p,q);FieldMatrix<Fraction> m2=createRandomMatrix(random,q,r);FieldMatrix<Fraction> m1m2=m1.multiply(m2);for (int i=0;i < p;++i){TestUtils.assertEquals(m1m2.getRow(i),m2.preMultiply(m1.getRow(i)));}}
/** * test issue MATH-209 */@Test public void testMath209(){FieldMatrix<Fraction> a=new BlockFieldMatrix<Fraction>(new Fraction[][]{{new Fraction(1),new Fraction(2)},{new Fraction(3),new Fraction(4)},{new Fraction(5),new Fraction(6)}});Fraction[]b=a.operate(new Fraction[]{new Fraction(1),new Fraction(1)});Assert.assertEquals(a.getRowDimension(),b.length);Assert.assertEquals(new Fraction(3),b[0]);Assert.assertEquals(new Fraction(7),b[1]);Assert.assertEquals(new Fraction(11),b[2]);}
/** * test transpose */@Test public void testTranspose(){FieldMatrix<Fraction> m=new BlockFieldMatrix<Fraction>(testData);FieldMatrix<Fraction> mIT=new FieldLUDecomposition<Fraction>(m).getSolver().getInverse().transpose();FieldMatrix<Fraction> mTI=new FieldLUDecomposition<Fraction>(m.transpose()).getSolver().getInverse();TestUtils.assertEquals(mIT,mTI);m=new BlockFieldMatrix<Fraction>(testData2);FieldMatrix<Fraction> mt=new BlockFieldMatrix<Fraction>(testData2T);TestUtils.assertEquals(mt,m.transpose());}
/** * test preMultiply by vector */@Test public void testPremultiplyVector(){FieldMatrix<Fraction> m=new BlockFieldMatrix<Fraction>(testData);TestUtils.assertEquals(m.preMultiply(testVector),preMultTest);TestUtils.assertEquals(m.preMultiply(new ArrayFieldVector<Fraction>(testVector).getData()),preMultTest);m=new BlockFieldMatrix<Fraction>(bigSingular);try {m.preMultiply(testVector);Assert.fail("expecting MathIllegalArgumentException");}catch(MathIllegalArgumentException ex){}}
@Test public void testPremultiply(){FieldMatrix<Fraction> m3=new BlockFieldMatrix<Fraction>(d3);FieldMatrix<Fraction> m4=new BlockFieldMatrix<Fraction>(d4);FieldMatrix<Fraction> m5=new BlockFieldMatrix<Fraction>(d5);TestUtils.assertEquals(m4.preMultiply(m3),m5);BlockFieldMatrix<Fraction> m=new BlockFieldMatrix<Fraction>(testData);BlockFieldMatrix<Fraction> mInv=new BlockFieldMatrix<Fraction>(testDataInv);BlockFieldMatrix<Fraction> identity=new BlockFieldMatrix<Fraction>(id);TestUtils.assertEquals(m.preMultiply(mInv),identity);TestUtils.assertEquals(mInv.preMultiply(m),identity);TestUtils.assertEquals(m.preMultiply(identity),m);TestUtils.assertEquals(identity.preMultiply(mInv),mInv);try {m.preMultiply(new BlockFieldMatrix<Fraction>(bigSingular));Assert.fail("Expecting illegalArgumentException");}catch(MathIllegalArgumentException ex){}}
@Test public void testGetVectors(){FieldMatrix<Fraction> m=new BlockFieldMatrix<Fraction>(testData);TestUtils.assertEquals(m.getRow(0),testDataRow1);TestUtils.assertEquals(m.getColumn(2),testDataCol3);try {m.getRow(10);Assert.fail("expecting OutOfRangeException");}catch(OutOfRangeException ex){}try {m.getColumn(-1);Assert.fail("expecting OutOfRangeException");}catch(OutOfRangeException ex){}}
@Test public void testGetEntry(){FieldMatrix<Fraction> m=new BlockFieldMatrix<Fraction>(testData);Assert.assertEquals(m.getEntry(0,1),new Fraction(2));try {m.getEntry(10,4);Assert.fail("Expecting OutOfRangeException");}catch(OutOfRangeException ex){}}
/** * test examples in user guide */@Test public void testExamples(){Fraction[][]matrixData={{new Fraction(1),new Fraction(2),new Fraction(3)},{new Fraction(2),new Fraction(5),new Fraction(3)}};FieldMatrix<Fraction> m=new BlockFieldMatrix<Fraction>(matrixData);Fraction[][]matrixData2={{new Fraction(1),new Fraction(2)},{new Fraction(2),new Fraction(5)},{new Fraction(1),new Fraction(7)}};FieldMatrix<Fraction> n=new BlockFieldMatrix<Fraction>(matrixData2);FieldMatrix<Fraction> p=m.multiply(n);Assert.assertEquals(2,p.getRowDimension());Assert.assertEquals(2,p.getColumnDimension());FieldMatrix<Fraction> pInverse=new FieldLUDecomposition<Fraction>(p).getSolver().getInverse();Assert.assertEquals(2,pInverse.getRowDimension());Assert.assertEquals(2,pInverse.getColumnDimension());Fraction[][]coefficientsData={{new Fraction(2),new Fraction(3),new Fraction(-2)},{new Fraction(-1),new Fraction(7),new Fraction(6)},{new Fraction(4),new Fraction(-3),new Fraction(-5)}};FieldMatrix<Fraction> coefficients=new BlockFieldMatrix<Fraction>(coefficientsData);Fraction[]constants={new Fraction(1),new Fraction(-2),new Fraction(1)};Fraction[]solution;solution=new FieldLUDecomposition<Fraction>(coefficients).getSolver().solve(new ArrayFieldVector<Fraction>(constants,false)).toArray();Assert.assertEquals(new Fraction(2).multiply(solution[0]).add(new Fraction(3).multiply(solution[1])).subtract(new Fraction(2).multiply(solution[2])),constants[0]);Assert.assertEquals(new Fraction(-1).multiply(solution[0]).add(new Fraction(7).multiply(solution[1])).add(new Fraction(6).multiply(solution[2])),constants[1]);Assert.assertEquals(new Fraction(4).multiply(solution[0]).subtract(new Fraction(3).multiply(solution[1])).subtract(new Fraction(5).multiply(solution[2])),constants[2]);}
@Test public void testGetSubMatrix(){FieldMatrix<Fraction> m=new BlockFieldMatrix<Fraction>(subTestData);checkGetSubMatrix(m,subRows23Cols00,2,3,0,0);checkGetSubMatrix(m,subRows00Cols33,0,0,3,3);checkGetSubMatrix(m,subRows01Cols23,0,1,2,3);checkGetSubMatrix(m,subRows02Cols13,new int[]{0,2},new int[]{1,3});checkGetSubMatrix(m,subRows03Cols12,new int[]{0,3},new int[]{1,2});checkGetSubMatrix(m,subRows03Cols123,new int[]{0,3},new int[]{1,2,3});checkGetSubMatrix(m,subRows20Cols123,new int[]{2,0},new int[]{1,2,3});checkGetSubMatrix(m,subRows31Cols31,new int[]{3,1},new int[]{3,1});checkGetSubMatrix(m,subRows31Cols31,new int[]{3,1},new int[]{3,1});checkGetSubMatrix(m,null,1,0,2,4);checkGetSubMatrix(m,null,-1,1,2,2);checkGetSubMatrix(m,null,1,0,2,2);checkGetSubMatrix(m,null,1,0,2,4);checkGetSubMatrix(m,null,new int[]{},new int[]{0});checkGetSubMatrix(m,null,new int[]{0},new int[]{4});}
@Test public void testGetSetMatrixLarge(){int n=3 * BlockFieldMatrix.BLOCK_SIZE;FieldMatrix<Fraction> m=new BlockFieldMatrix<Fraction>(FractionField.getInstance(),n,n);FieldMatrix<Fraction> sub=new BlockFieldMatrix<Fraction>(FractionField.getInstance(),n - 4,n - 4).scalarAdd(new Fraction(1));m.setSubMatrix(sub.getData(),2,2);for (int i=0;i < n;++i){for (int j=0;j < n;++j){if ((i < 2)|| (i > n - 3)|| (j < 2)|| (j > n - 3)){Assert.assertEquals(new Fraction(0),m.getEntry(i,j));}else {Assert.assertEquals(new Fraction(1),m.getEntry(i,j));}}}Assert.assertEquals(sub,m.getSubMatrix(2,n - 3,2,n - 3));}
@Test public void testCopySubMatrix(){FieldMatrix<Fraction> m=new BlockFieldMatrix<Fraction>(subTestData);checkCopy(m,subRows23Cols00,2,3,0,0);checkCopy(m,subRows00Cols33,0,0,3,3);checkCopy(m,subRows01Cols23,0,1,2,3);checkCopy(m,subRows02Cols13,new int[]{0,2},new int[]{1,3});checkCopy(m,subRows03Cols12,new int[]{0,3},new int[]{1,2});checkCopy(m,subRows03Cols123,new int[]{0,3},new int[]{1,2,3});checkCopy(m,subRows20Cols123,new int[]{2,0},new int[]{1,2,3});checkCopy(m,subRows31Cols31,new int[]{3,1},new int[]{3,1});checkCopy(m,subRows31Cols31,new int[]{3,1},new int[]{3,1});checkCopy(m,null,1,0,2,4);checkCopy(m,null,-1,1,2,2);checkCopy(m,null,1,0,2,2);checkCopy(m,null,1,0,2,4);checkCopy(m,null,new int[]{},new int[]{0});checkCopy(m,null,new int[]{0},new int[]{4});}
@Test public void testGetRowMatrix(){FieldMatrix<Fraction> m=new BlockFieldMatrix<Fraction>(subTestData);FieldMatrix<Fraction> mRow0=new BlockFieldMatrix<Fraction>(subRow0);FieldMatrix<Fraction> mRow3=new BlockFieldMatrix<Fraction>(subRow3);Assert.assertEquals("Row0",mRow0,m.getRowMatrix(0));Assert.assertEquals("Row3",mRow3,m.getRowMatrix(3));try {m.getRowMatrix(-1);Assert.fail("Expecting OutOfRangeException");}catch(OutOfRangeException ex){}try {m.getRowMatrix(4);Assert.fail("Expecting OutOfRangeException");}catch(OutOfRangeException ex){}}
@Test public void testSetRowMatrix(){FieldMatrix<Fraction> m=new BlockFieldMatrix<Fraction>(subTestData);FieldMatrix<Fraction> mRow3=new BlockFieldMatrix<Fraction>(subRow3);Assert.assertNotSame(mRow3,m.getRowMatrix(0));m.setRowMatrix(0,mRow3);Assert.assertEquals(mRow3,m.getRowMatrix(0));try {m.setRowMatrix(-1,mRow3);Assert.fail("Expecting OutOfRangeException");}catch(OutOfRangeException ex){}try {m.setRowMatrix(0,m);Assert.fail("Expecting MatrixDimensionMismatchException");}catch(MatrixDimensionMismatchException ex){}}
@Test public void testGetSetRowMatrixLarge(){int n=3 * BlockFieldMatrix.BLOCK_SIZE;FieldMatrix<Fraction> m=new BlockFieldMatrix<Fraction>(FractionField.getInstance(),n,n);FieldMatrix<Fraction> sub=new BlockFieldMatrix<Fraction>(FractionField.getInstance(),1,n).scalarAdd(new Fraction(1));m.setRowMatrix(2,sub);for (int i=0;i < n;++i){for (int j=0;j < n;++j){if (i != 2){Assert.assertEquals(new Fraction(0),m.getEntry(i,j));}else {Assert.assertEquals(new Fraction(1),m.getEntry(i,j));}}}Assert.assertEquals(sub,m.getRowMatrix(2));}
@Test public void testGetColumnMatrix(){FieldMatrix<Fraction> m=new BlockFieldMatrix<Fraction>(subTestData);FieldMatrix<Fraction> mColumn1=new BlockFieldMatrix<Fraction>(subColumn1);FieldMatrix<Fraction> mColumn3=new BlockFieldMatrix<Fraction>(subColumn3);Assert.assertEquals(mColumn1,m.getColumnMatrix(1));Assert.assertEquals(mColumn3,m.getColumnMatrix(3));try {m.getColumnMatrix(-1);Assert.fail("Expecting OutOfRangeException");}catch(OutOfRangeException ex){}try {m.getColumnMatrix(4);Assert.fail("Expecting OutOfRangeException");}catch(OutOfRangeException ex){}}
@Test public void testSetColumnMatrix(){FieldMatrix<Fraction> m=new BlockFieldMatrix<Fraction>(subTestData);FieldMatrix<Fraction> mColumn3=new BlockFieldMatrix<Fraction>(subColumn3);Assert.assertNotSame(mColumn3,m.getColumnMatrix(1));m.setColumnMatrix(1,mColumn3);Assert.assertEquals(mColumn3,m.getColumnMatrix(1));try {m.setColumnMatrix(-1,mColumn3);Assert.fail("Expecting OutOfRangeException");}catch(OutOfRangeException ex){}try {m.setColumnMatrix(0,m);Assert.fail("Expecting MatrixDimensionMismatchException");}catch(MatrixDimensionMismatchException ex){}}
@Test public void testGetSetColumnMatrixLarge(){int n=3 * BlockFieldMatrix.BLOCK_SIZE;FieldMatrix<Fraction> m=new BlockFieldMatrix<Fraction>(FractionField.getInstance(),n,n);FieldMatrix<Fraction> sub=new BlockFieldMatrix<Fraction>(FractionField.getInstance(),n,1).scalarAdd(new Fraction(1));m.setColumnMatrix(2,sub);for (int i=0;i < n;++i){for (int j=0;j < n;++j){if (j != 2){Assert.assertEquals(new Fraction(0),m.getEntry(i,j));}else {Assert.assertEquals(new Fraction(1),m.getEntry(i,j));}}}Assert.assertEquals(sub,m.getColumnMatrix(2));}
@Test public void testGetRowVector(){FieldMatrix<Fraction> m=new BlockFieldMatrix<Fraction>(subTestData);FieldVector<Fraction> mRow0=new ArrayFieldVector<Fraction>(subRow0[0]);FieldVector<Fraction> mRow3=new ArrayFieldVector<Fraction>(subRow3[0]);Assert.assertEquals(mRow0,m.getRowVector(0));Assert.assertEquals(mRow3,m.getRowVector(3));try {m.getRowVector(-1);Assert.fail("Expecting OutOfRangeException");}catch(OutOfRangeException ex){}try {m.getRowVector(4);Assert.fail("Expecting OutOfRangeException");}catch(OutOfRangeException ex){}}
@Test public void testSetRowVector(){FieldMatrix<Fraction> m=new BlockFieldMatrix<Fraction>(subTestData);FieldVector<Fraction> mRow3=new ArrayFieldVector<Fraction>(subRow3[0]);Assert.assertNotSame(mRow3,m.getRowMatrix(0));m.setRowVector(0,mRow3);Assert.assertEquals(mRow3,m.getRowVector(0));try {m.setRowVector(-1,mRow3);Assert.fail("Expecting OutOfRangeException");}catch(OutOfRangeException ex){}try {m.setRowVector(0,new ArrayFieldVector<Fraction>(FractionField.getInstance(),5));Assert.fail("Expecting MatrixDimensionMismatchException");}catch(MatrixDimensionMismatchException ex){}}
@Test public void testGetSetRowVectorLarge(){int n=3 * BlockFieldMatrix.BLOCK_SIZE;FieldMatrix<Fraction> m=new BlockFieldMatrix<Fraction>(FractionField.getInstance(),n,n);FieldVector<Fraction> sub=new ArrayFieldVector<Fraction>(n,new Fraction(1));m.setRowVector(2,sub);for (int i=0;i < n;++i){for (int j=0;j < n;++j){if (i != 2){Assert.assertEquals(new Fraction(0),m.getEntry(i,j));}else {Assert.assertEquals(new Fraction(1),m.getEntry(i,j));}}}Assert.assertEquals(sub,m.getRowVector(2));}
@Test public void testGetColumnVector(){FieldMatrix<Fraction> m=new BlockFieldMatrix<Fraction>(subTestData);FieldVector<Fraction> mColumn1=columnToVector(subColumn1);FieldVector<Fraction> mColumn3=columnToVector(subColumn3);Assert.assertEquals(mColumn1,m.getColumnVector(1));Assert.assertEquals(mColumn3,m.getColumnVector(3));try {m.getColumnVector(-1);Assert.fail("Expecting OutOfRangeException");}catch(OutOfRangeException ex){}try {m.getColumnVector(4);Assert.fail("Expecting OutOfRangeException");}catch(OutOfRangeException ex){}}
@Test public void testSetColumnVector(){FieldMatrix<Fraction> m=new BlockFieldMatrix<Fraction>(subTestData);FieldVector<Fraction> mColumn3=columnToVector(subColumn3);Assert.assertNotSame(mColumn3,m.getColumnVector(1));m.setColumnVector(1,mColumn3);Assert.assertEquals(mColumn3,m.getColumnVector(1));try {m.setColumnVector(-1,mColumn3);Assert.fail("Expecting OutOfRangeException");}catch(OutOfRangeException ex){}try {m.setColumnVector(0,new ArrayFieldVector<Fraction>(FractionField.getInstance(),5));Assert.fail("Expecting MatrixDimensionMismatchException");}catch(MatrixDimensionMismatchException ex){}}
@Test public void testGetSetColumnVectorLarge(){int n=3 * BlockFieldMatrix.BLOCK_SIZE;FieldMatrix<Fraction> m=new BlockFieldMatrix<Fraction>(FractionField.getInstance(),n,n);FieldVector<Fraction> sub=new ArrayFieldVector<Fraction>(n,new Fraction(1));m.setColumnVector(2,sub);for (int i=0;i < n;++i){for (int j=0;j < n;++j){if (j != 2){Assert.assertEquals(new Fraction(0),m.getEntry(i,j));}else {Assert.assertEquals(new Fraction(1),m.getEntry(i,j));}}}Assert.assertEquals(sub,m.getColumnVector(2));}
@Test public void testGetRow(){FieldMatrix<Fraction> m=new BlockFieldMatrix<Fraction>(subTestData);checkArrays(subRow0[0],m.getRow(0));checkArrays(subRow3[0],m.getRow(3));try {m.getRow(-1);Assert.fail("Expecting OutOfRangeException");}catch(OutOfRangeException ex){}try {m.getRow(4);Assert.fail("Expecting OutOfRangeException");}catch(OutOfRangeException ex){}}
@Test public void testSetRow(){FieldMatrix<Fraction> m=new BlockFieldMatrix<Fraction>(subTestData);Assert.assertTrue(subRow3[0][0]!= m.getRow(0)[0]);m.setRow(0,subRow3[0]);checkArrays(subRow3[0],m.getRow(0));try {m.setRow(-1,subRow3[0]);Assert.fail("Expecting OutOfRangeException");}catch(OutOfRangeException ex){}try {m.setRow(0,new Fraction[5]);Assert.fail("Expecting MatrixDimensionMismatchException");}catch(MatrixDimensionMismatchException ex){}}
@Test public void testGetSetRowLarge(){int n=3 * BlockFieldMatrix.BLOCK_SIZE;FieldMatrix<Fraction> m=new BlockFieldMatrix<Fraction>(FractionField.getInstance(),n,n);Fraction[]sub=new Fraction[n];Arrays.fill(sub,new Fraction(1));m.setRow(2,sub);for (int i=0;i < n;++i){for (int j=0;j < n;++j){if (i != 2){Assert.assertEquals(new Fraction(0),m.getEntry(i,j));}else {Assert.assertEquals(new Fraction(1),m.getEntry(i,j));}}}checkArrays(sub,m.getRow(2));}
@Test public void testGetColumn(){FieldMatrix<Fraction> m=new BlockFieldMatrix<Fraction>(subTestData);Fraction[]mColumn1=columnToArray(subColumn1);Fraction[]mColumn3=columnToArray(subColumn3);checkArrays(mColumn1,m.getColumn(1));checkArrays(mColumn3,m.getColumn(3));try {m.getColumn(-1);Assert.fail("Expecting OutOfRangeException");}catch(OutOfRangeException ex){}try {m.getColumn(4);Assert.fail("Expecting OutOfRangeException");}catch(OutOfRangeException ex){}}
@Test public void testSetColumn(){FieldMatrix<Fraction> m=new BlockFieldMatrix<Fraction>(subTestData);Fraction[]mColumn3=columnToArray(subColumn3);Assert.assertTrue(mColumn3[0]!= m.getColumn(1)[0]);m.setColumn(1,mColumn3);checkArrays(mColumn3,m.getColumn(1));try {m.setColumn(-1,mColumn3);Assert.fail("Expecting OutOfRangeException");}catch(OutOfRangeException ex){}try {m.setColumn(0,new Fraction[5]);Assert.fail("Expecting MatrixDimensionMismatchException");}catch(MatrixDimensionMismatchException ex){}}
@Test public void testGetSetColumnLarge(){int n=3 * BlockFieldMatrix.BLOCK_SIZE;FieldMatrix<Fraction> m=new BlockFieldMatrix<Fraction>(FractionField.getInstance(),n,n);Fraction[]sub=new Fraction[n];Arrays.fill(sub,new Fraction(1));m.setColumn(2,sub);for (int i=0;i < n;++i){for (int j=0;j < n;++j){if (j != 2){Assert.assertEquals(new Fraction(0),m.getEntry(i,j));}else {Assert.assertEquals(new Fraction(1),m.getEntry(i,j));}}}checkArrays(sub,m.getColumn(2));}
@Test public void testEqualsAndHashCode(){BlockFieldMatrix<Fraction> m=new BlockFieldMatrix<Fraction>(testData);BlockFieldMatrix<Fraction> m1=(BlockFieldMatrix<Fraction>)m.copy();BlockFieldMatrix<Fraction> mt=(BlockFieldMatrix<Fraction>)m.transpose();Assert.assertTrue(m.hashCode()!= mt.hashCode());Assert.assertEquals(m.hashCode(),m1.hashCode());Assert.assertEquals(m,m);Assert.assertEquals(m,m1);Assert.assertFalse(m.equals(null));Assert.assertFalse(m.equals(mt));Assert.assertFalse(m.equals(new BlockFieldMatrix<Fraction>(bigSingular)));}
@Test public void testToString(){BlockFieldMatrix<Fraction> m=new BlockFieldMatrix<Fraction>(testData);Assert.assertEquals("BlockFieldMatrix{{1,2,3},{2,5,3},{1,0,8}}",m.toString());}
@Test public void testSetSubMatrix()throws Exception {BlockFieldMatrix<Fraction> m=new BlockFieldMatrix<Fraction>(testData);m.setSubMatrix(detData2,1,1);FieldMatrix<Fraction> expected=new BlockFieldMatrix<Fraction>(new Fraction[][]{{new Fraction(1),new Fraction(2),new Fraction(3)},{new Fraction(2),new Fraction(1),new Fraction(3)},{new Fraction(1),new Fraction(2),new Fraction(4)}});Assert.assertEquals(expected,m);m.setSubMatrix(detData2,0,0);expected=new BlockFieldMatrix<Fraction>(new Fraction[][]{{new Fraction(1),new Fraction(3),new Fraction(3)},{new Fraction(2),new Fraction(4),new Fraction(3)},{new Fraction(1),new Fraction(2),new Fraction(4)}});Assert.assertEquals(expected,m);m.setSubMatrix(testDataPlus2,0,0);expected=new BlockFieldMatrix<Fraction>(new Fraction[][]{{new Fraction(3),new Fraction(4),new Fraction(5)},{new Fraction(4),new Fraction(7),new Fraction(5)},{new Fraction(3),new Fraction(2),new Fraction(10)}});Assert.assertEquals(expected,m);BlockFieldMatrix<Fraction> matrix=new BlockFieldMatrix<Fraction>(new Fraction[][]{{new Fraction(1),new Fraction(2),new Fraction(3),new Fraction(4)},{new Fraction(5),new Fraction(6),new Fraction(7),new Fraction(8)},{new Fraction(9),new Fraction(0),new Fraction(1),new Fraction(2)}});matrix.setSubMatrix(new Fraction[][]{{new Fraction(3),new Fraction(4)},{new Fraction(5),new Fraction(6)}},1,1);expected=new BlockFieldMatrix<Fraction>(new Fraction[][]{{new Fraction(1),new Fraction(2),new Fraction(3),new Fraction(4)},{new Fraction(5),new Fraction(3),new Fraction(4),new Fraction(8)},{new Fraction(9),new Fraction(5),new Fraction(6),new Fraction(2)}});Assert.assertEquals(expected,matrix);try {m.setSubMatrix(testData,1,1);Assert.fail("expecting OutOfRangeException");}catch(OutOfRangeException e){}try {m.setSubMatrix(testData,-1,1);Assert.fail("expecting OutOfRangeException");}catch(OutOfRangeException e){}try {m.setSubMatrix(testData,1,-1);Assert.fail("expecting OutOfRangeException");}catch(OutOfRangeException e){}try {m.setSubMatrix(null,1,1);Assert.fail("expecting NullArgumentException");}catch(NullArgumentException e){}try {m.setSubMatrix(new Fraction[][]{{new Fraction(1)},{new Fraction(2),new Fraction(3)}},0,0);Assert.fail("expecting MathIllegalArgumentException");}catch(MathIllegalArgumentException e){}try {m.setSubMatrix(new Fraction[][]{{}},0,0);Assert.fail("expecting MathIllegalArgumentException");}catch(MathIllegalArgumentException e){}}
@Test public void testWalk(){int rows=150;int columns=75;FieldMatrix<Fraction> m=new BlockFieldMatrix<Fraction>(FractionField.getInstance(),rows,columns);m.walkInRowOrder(new SetVisitor());GetVisitor getVisitor=new GetVisitor();m.walkInOptimizedOrder(getVisitor);Assert.assertEquals(rows * columns,getVisitor.getCount());m=new BlockFieldMatrix<Fraction>(FractionField.getInstance(),rows,columns);m.walkInRowOrder(new SetVisitor(),1,rows - 2,1,columns - 2);getVisitor=new GetVisitor();m.walkInOptimizedOrder(getVisitor,1,rows - 2,1,columns - 2);Assert.assertEquals((rows - 2)* (columns - 2),getVisitor.getCount());for (int i=0;i < rows;++i){Assert.assertEquals(new Fraction(0),m.getEntry(i,0));Assert.assertEquals(new Fraction(0),m.getEntry(i,columns - 1));}for (int j=0;j < columns;++j){Assert.assertEquals(new Fraction(0),m.getEntry(0,j));Assert.assertEquals(new Fraction(0),m.getEntry(rows - 1,j));}m=new BlockFieldMatrix<Fraction>(FractionField.getInstance(),rows,columns);m.walkInColumnOrder(new SetVisitor());getVisitor=new GetVisitor();m.walkInOptimizedOrder(getVisitor);Assert.assertEquals(rows * columns,getVisitor.getCount());m=new BlockFieldMatrix<Fraction>(FractionField.getInstance(),rows,columns);m.walkInColumnOrder(new SetVisitor(),1,rows - 2,1,columns - 2);getVisitor=new GetVisitor();m.walkInOptimizedOrder(getVisitor,1,rows - 2,1,columns - 2);Assert.assertEquals((rows - 2)* (columns - 2),getVisitor.getCount());for (int i=0;i < rows;++i){Assert.assertEquals(new Fraction(0),m.getEntry(i,0));Assert.assertEquals(new Fraction(0),m.getEntry(i,columns - 1));}for (int j=0;j < columns;++j){Assert.assertEquals(new Fraction(0),m.getEntry(0,j));Assert.assertEquals(new Fraction(0),m.getEntry(rows - 1,j));}m=new BlockFieldMatrix<Fraction>(FractionField.getInstance(),rows,columns);m.walkInOptimizedOrder(new SetVisitor());getVisitor=new GetVisitor();m.walkInRowOrder(getVisitor);Assert.assertEquals(rows * columns,getVisitor.getCount());m=new BlockFieldMatrix<Fraction>(FractionField.getInstance(),rows,columns);m.walkInOptimizedOrder(new SetVisitor(),1,rows - 2,1,columns - 2);getVisitor=new GetVisitor();m.walkInRowOrder(getVisitor,1,rows - 2,1,columns - 2);Assert.assertEquals((rows - 2)* (columns - 2),getVisitor.getCount());for (int i=0;i < rows;++i){Assert.assertEquals(new Fraction(0),m.getEntry(i,0));Assert.assertEquals(new Fraction(0),m.getEntry(i,columns - 1));}for (int j=0;j < columns;++j){Assert.assertEquals(new Fraction(0),m.getEntry(0,j));Assert.assertEquals(new Fraction(0),m.getEntry(rows - 1,j));}m=new BlockFieldMatrix<Fraction>(FractionField.getInstance(),rows,columns);m.walkInOptimizedOrder(new SetVisitor());getVisitor=new GetVisitor();m.walkInColumnOrder(getVisitor);Assert.assertEquals(rows * columns,getVisitor.getCount());m=new BlockFieldMatrix<Fraction>(FractionField.getInstance(),rows,columns);m.walkInOptimizedOrder(new SetVisitor(),1,rows - 2,1,columns - 2);getVisitor=new GetVisitor();m.walkInColumnOrder(getVisitor,1,rows - 2,1,columns - 2);Assert.assertEquals((rows - 2)* (columns - 2),getVisitor.getCount());for (int i=0;i < rows;++i){Assert.assertEquals(new Fraction(0),m.getEntry(i,0));Assert.assertEquals(new Fraction(0),m.getEntry(i,columns - 1));}for (int j=0;j < columns;++j){Assert.assertEquals(new Fraction(0),m.getEntry(0,j));Assert.assertEquals(new Fraction(0),m.getEntry(rows - 1,j));}}
@Test public void testSerial(){BlockFieldMatrix<Fraction> m=new BlockFieldMatrix<Fraction>(testData);Assert.assertEquals(m,TestUtils.serializeAndRecover(m));}
@Test public void testOneSampleT()throws Exception {double[]observed={93.0,103.0,95.0,101.0,91.0,105.0,96.0,94.0,101.0,88.0,98.0,94.0,101.0,92.0,95.0};double mu=100.0;SummaryStatistics sampleStats=null;sampleStats=new SummaryStatistics();for (int i=0;i < observed.length;i++){sampleStats.addValue(observed[i]);}Assert.assertEquals("t statistic",-2.81976445346,testStatistic.t(mu,observed),10E-10);Assert.assertEquals("t statistic",-2.81976445346,testStatistic.t(mu,sampleStats),10E-10);Assert.assertEquals("p value",0.0136390585873,testStatistic.tTest(mu,observed),10E-10);Assert.assertEquals("p value",0.0136390585873,testStatistic.tTest(mu,sampleStats),10E-10);try {testStatistic.t(mu,(double[])null);Assert.fail("arguments too short,MathIllegalArgumentException expected");}catch(MathIllegalArgumentException ex){}try {testStatistic.t(mu,(SummaryStatistics)null);Assert.fail("arguments too short,MathIllegalArgumentException expected");}catch(MathIllegalArgumentException ex){}try {testStatistic.t(mu,emptyObs);Assert.fail("arguments too short,MathIllegalArgumentException expected");}catch(MathIllegalArgumentException ex){}try {testStatistic.t(mu,emptyStats);Assert.fail("arguments too short,MathIllegalArgumentException expected");}catch(MathIllegalArgumentException ex){}try {testStatistic.t(mu,tooShortObs);Assert.fail("insufficient data to compute t statistic,MathIllegalArgumentException expected");}catch(MathIllegalArgumentException ex){}try {testStatistic.tTest(mu,tooShortObs);Assert.fail("insufficient data to perform t test,MathIllegalArgumentException expected");}catch(MathIllegalArgumentException ex){}try {testStatistic.t(mu,tooShortStats);Assert.fail("insufficient data to compute t statistic,MathIllegalArgumentException expected");}catch(MathIllegalArgumentException ex){}try {testStatistic.tTest(mu,tooShortStats);Assert.fail("insufficient data to perform t test,MathIllegalArgumentException expected");}catch(MathIllegalArgumentException ex){}}
@Test public void testOneSampleTTest()throws Exception {double[]oneSidedP={2d,0d,6d,6d,3d,3d,2d,3d,-6d,6d,6d,6d,3d,0d,1d,1d,0d,2d,3d,3d};SummaryStatistics oneSidedPStats=new SummaryStatistics();for (int i=0;i < oneSidedP.length;i++){oneSidedPStats.addValue(oneSidedP[i]);}Assert.assertEquals("one sample t stat",3.86485535541,testStatistic.t(0d,oneSidedP),10E-10);Assert.assertEquals("one sample t stat",3.86485535541,testStatistic.t(0d,oneSidedPStats),1E-10);Assert.assertEquals("one sample p value",0.000521637019637,testStatistic.tTest(0d,oneSidedP)/ 2d,10E-10);Assert.assertEquals("one sample p value",0.000521637019637,testStatistic.tTest(0d,oneSidedPStats)/ 2d,10E-5);Assert.assertTrue("one sample t-test reject",testStatistic.tTest(0d,oneSidedP,0.01));Assert.assertTrue("one sample t-test reject",testStatistic.tTest(0d,oneSidedPStats,0.01));Assert.assertTrue("one sample t-test accept",!testStatistic.tTest(0d,oneSidedP,0.0001));Assert.assertTrue("one sample t-test accept",!testStatistic.tTest(0d,oneSidedPStats,0.0001));try {testStatistic.tTest(0d,oneSidedP,95);Assert.fail("alpha out of range,MathIllegalArgumentException expected");}catch(MathIllegalArgumentException ex){}try {testStatistic.tTest(0d,oneSidedPStats,95);Assert.fail("alpha out of range,MathIllegalArgumentException expected");}catch(MathIllegalArgumentException ex){}}
@Test public void testTwoSampleTHeterscedastic()throws Exception {double[]sample1={7d,-4d,18d,17d,-3d,-5d,1d,10d,11d,-2d};double[]sample2={-1d,12d,-1d,-3d,3d,-5d,5d,2d,-11d,-1d,-3d};SummaryStatistics sampleStats1=new SummaryStatistics();for (int i=0;i < sample1.length;i++){sampleStats1.addValue(sample1[i]);}SummaryStatistics sampleStats2=new SummaryStatistics();for (int i=0;i < sample2.length;i++){sampleStats2.addValue(sample2[i]);}Assert.assertEquals("two sample heteroscedastic t stat",1.60371728768,testStatistic.t(sample1,sample2),1E-10);Assert.assertEquals("two sample heteroscedastic t stat",1.60371728768,testStatistic.t(sampleStats1,sampleStats2),1E-10);Assert.assertEquals("two sample heteroscedastic p value",0.128839369622,testStatistic.tTest(sample1,sample2),1E-10);Assert.assertEquals("two sample heteroscedastic p value",0.128839369622,testStatistic.tTest(sampleStats1,sampleStats2),1E-10);Assert.assertTrue("two sample heteroscedastic t-test reject",testStatistic.tTest(sample1,sample2,0.2));Assert.assertTrue("two sample heteroscedastic t-test reject",testStatistic.tTest(sampleStats1,sampleStats2,0.2));Assert.assertTrue("two sample heteroscedastic t-test accept",!testStatistic.tTest(sample1,sample2,0.1));Assert.assertTrue("two sample heteroscedastic t-test accept",!testStatistic.tTest(sampleStats1,sampleStats2,0.1));try {testStatistic.tTest(sample1,sample2,.95);Assert.fail("alpha out of range,MathIllegalArgumentException expected");}catch(MathIllegalArgumentException ex){}try {testStatistic.tTest(sampleStats1,sampleStats2,.95);Assert.fail("alpha out of range,MathIllegalArgumentException expected");}catch(MathIllegalArgumentException ex){}try {testStatistic.tTest(sample1,tooShortObs,.01);Assert.fail("insufficient data,MathIllegalArgumentException expected");}catch(MathIllegalArgumentException ex){}try {testStatistic.tTest(sampleStats1,tooShortStats,.01);Assert.fail("insufficient data,MathIllegalArgumentException expected");}catch(MathIllegalArgumentException ex){}try {testStatistic.tTest(sample1,tooShortObs);Assert.fail("insufficient data,MathIllegalArgumentException expected");}catch(MathIllegalArgumentException ex){}try {testStatistic.tTest(sampleStats1,tooShortStats);Assert.fail("insufficient data,MathIllegalArgumentException expected");}catch(MathIllegalArgumentException ex){}try {testStatistic.t(sample1,tooShortObs);Assert.fail("insufficient data,MathIllegalArgumentException expected");}catch(MathIllegalArgumentException ex){}try {testStatistic.t(sampleStats1,tooShortStats);Assert.fail("insufficient data,MathIllegalArgumentException expected");}catch(MathIllegalArgumentException ex){}}
@Test public void testTwoSampleTHomoscedastic()throws Exception {double[]sample1={2,4,6,8,10,97};double[]sample2={4,6,8,10,16};SummaryStatistics sampleStats1=new SummaryStatistics();for (int i=0;i < sample1.length;i++){sampleStats1.addValue(sample1[i]);}SummaryStatistics sampleStats2=new SummaryStatistics();for (int i=0;i < sample2.length;i++){sampleStats2.addValue(sample2[i]);}Assert.assertEquals("two sample homoscedastic t stat",0.73096310086,testStatistic.homoscedasticT(sample1,sample2),10E-11);Assert.assertEquals("two sample homoscedastic p value",0.4833963785,testStatistic.homoscedasticTTest(sampleStats1,sampleStats2),1E-10);Assert.assertTrue("two sample homoscedastic t-test reject",testStatistic.homoscedasticTTest(sample1,sample2,0.49));Assert.assertTrue("two sample homoscedastic t-test accept",!testStatistic.homoscedasticTTest(sample1,sample2,0.48));}
@Test public void testSmallSamples()throws Exception {double[]sample1={1d,3d};double[]sample2={4d,5d};Assert.assertEquals(-2.2360679775,testStatistic.t(sample1,sample2),1E-10);Assert.assertEquals(0.198727388935,testStatistic.tTest(sample1,sample2),1E-10);}
@Test public void testPaired()throws Exception {double[]sample1={1d,3d,5d,7d};double[]sample2={0d,6d,11d,2d};double[]sample3={5d,7d,8d,10d};Assert.assertEquals(-0.3133,testStatistic.pairedT(sample1,sample2),1E-4);Assert.assertEquals(0.774544295819,testStatistic.pairedTTest(sample1,sample2),1E-10);Assert.assertEquals(0.001208,testStatistic.pairedTTest(sample1,sample3),1E-6);Assert.assertFalse(testStatistic.pairedTTest(sample1,sample3,.001));Assert.assertTrue(testStatistic.pairedTTest(sample1,sample3,.002));}
/** * test non invertible matrix */@Test public void testNonInvertible(){Random r=new Random(9994100315209l);RealMatrix m=EigenDecompositionTest.createTestMatrix(r,new double[]{1.0,0.0,-1.0,-2.0,-3.0});DecompositionSolver es=new EigenDecomposition(m,Precision.SAFE_MIN).getSolver();Assert.assertFalse(es.isNonSingular());try {es.getInverse();Assert.fail("an exception should have been thrown");}catch(SingularMatrixException ime){}}
/** * test invertible matrix */@Test public void testInvertible(){Random r=new Random(9994100315209l);RealMatrix m=EigenDecompositionTest.createTestMatrix(r,new double[]{1.0,0.5,-1.0,-2.0,-3.0});DecompositionSolver es=new EigenDecomposition(m,Precision.SAFE_MIN).getSolver();Assert.assertTrue(es.isNonSingular());RealMatrix inverse=es.getInverse();RealMatrix error=m.multiply(inverse).subtract(MatrixUtils.createRealIdentityMatrix(m.getRowDimension()));Assert.assertEquals(0,error.getNorm(),4.0e-15);}
/** * test solve dimension errors */@Test public void testSolveDimensionErrors(){final double[]refValues=new double[]{2.003,2.002,2.001,1.001,1.000,0.001};final RealMatrix matrix=EigenDecompositionTest.createTestMatrix(new Random(35992629946426l),refValues);DecompositionSolver es=new EigenDecomposition(matrix,Precision.SAFE_MIN).getSolver();RealMatrix b=MatrixUtils.createRealMatrix(new double[2][2]);try {es.solve(b);Assert.fail("an exception should have been thrown");}catch(MathIllegalArgumentException iae){}try {es.solve(b.getColumnVector(0));Assert.fail("an exception should have been thrown");}catch(MathIllegalArgumentException iae){}try {es.solve(new ArrayRealVectorTest.RealVectorTestImpl(b.getColumn(0)));Assert.fail("an exception should have been thrown");}catch(MathIllegalArgumentException iae){}}
/** * test solve */@Test public void testSolve(){RealMatrix m=MatrixUtils.createRealMatrix(new double[][]{{91,5,29,32,40,14},{5,34,-1,0,2,-1},{29,-1,12,9,21,8},{32,0,9,14,9,0},{40,2,21,9,51,19},{14,-1,8,0,19,14}});DecompositionSolver es=new EigenDecomposition(m,Precision.SAFE_MIN).getSolver();RealMatrix b=MatrixUtils.createRealMatrix(new double[][]{{1561,269,188},{69,-21,70},{739,108,63},{324,86,59},{1624,194,107},{796,69,36}});RealMatrix xRef=MatrixUtils.createRealMatrix(new double[][]{{1,2,1},{2,-1,2},{4,2,3},{8,-1,0},{16,2,0},{32,-1,0}});RealMatrix solution=es.solve(b);Assert.assertEquals(0,solution.subtract(xRef).getNorm(),2.5e-12);for (int i=0;i < b.getColumnDimension();++i){Assert.assertEquals(0,es.solve(b.getColumnVector(i)).subtract(xRef.getColumnVector(i)).getNorm(),2.0e-11);}for (int i=0;i < b.getColumnDimension();++i){ArrayRealVectorTest.RealVectorTestImpl v=new ArrayRealVectorTest.RealVectorTestImpl(b.getColumn(i));Assert.assertEquals(0,es.solve(v).subtract(xRef.getColumnVector(i)).getNorm(),2.0e-11);}}
@Test(expected=DimensionMismatchException.class)public void testDimensionCheck(){TestProblem1 pb=new TestProblem1();DormandPrince54Integrator integrator=new DormandPrince54Integrator(0.0,1.0,1.0e-10,1.0e-10);integrator.integrate(pb,0.0,new double[pb.getDimension()+ 10],1.0,new double[pb.getDimension()+ 10]);}
@Test(expected=NumberIsTooSmallException.class)public void testMinStep(){TestProblem1 pb=new TestProblem1();double minStep=0.1 * (pb.getFinalTime()- pb.getInitialTime());double maxStep=pb.getFinalTime()- pb.getInitialTime();double[]vecAbsoluteTolerance={1.0e-15,1.0e-16};double[]vecRelativeTolerance={1.0e-15,1.0e-16};FirstOrderIntegrator integ=new DormandPrince54Integrator(minStep,maxStep,vecAbsoluteTolerance,vecRelativeTolerance);TestProblemHandler handler=new TestProblemHandler(pb,integ);integ.addStepHandler(handler);integ.integrate(pb,pb.getInitialTime(),pb.getInitialState(),pb.getFinalTime(),new double[pb.getDimension()]);Assert.fail("an exception should have been thrown");}
@Test public void testSmallLastStep(){TestProblemAbstract pb=new TestProblem5();double minStep=1.25;double maxStep=FastMath.abs(pb.getFinalTime()- pb.getInitialTime());double scalAbsoluteTolerance=6.0e-4;double scalRelativeTolerance=6.0e-4;AdaptiveStepsizeIntegrator integ=new DormandPrince54Integrator(minStep,maxStep,scalAbsoluteTolerance,scalRelativeTolerance);DP54SmallLastHandler handler=new DP54SmallLastHandler(minStep);integ.addStepHandler(handler);integ.setInitialStepSize(1.7);integ.integrate(pb,pb.getInitialTime(),pb.getInitialState(),pb.getFinalTime(),new double[pb.getDimension()]);Assert.assertTrue(handler.wasLastSeen());Assert.assertEquals("Dormand-Prince 5(4)",integ.getName());}
@Test public void testBackward(){TestProblem5 pb=new TestProblem5();double minStep=0;double maxStep=pb.getFinalTime()- pb.getInitialTime();double scalAbsoluteTolerance=1.0e-8;double scalRelativeTolerance=0.01 * scalAbsoluteTolerance;FirstOrderIntegrator integ=new DormandPrince54Integrator(minStep,maxStep,scalAbsoluteTolerance,scalRelativeTolerance);TestProblemHandler handler=new TestProblemHandler(pb,integ);integ.addStepHandler(handler);integ.integrate(pb,pb.getInitialTime(),pb.getInitialState(),pb.getFinalTime(),new double[pb.getDimension()]);Assert.assertTrue(handler.getLastError()< 2.0e-7);Assert.assertTrue(handler.getMaximalValueError()< 2.0e-7);Assert.assertEquals(0,handler.getMaximalTimeError(),1.0e-12);Assert.assertEquals("Dormand-Prince 5(4)",integ.getName());}
@Test public void testIncreasingTolerance(){int previousCalls=Integer.MAX_VALUE;for (int i=-12;i < -2;++i){TestProblem1 pb=new TestProblem1();double minStep=0;double maxStep=pb.getFinalTime()- pb.getInitialTime();double scalAbsoluteTolerance=FastMath.pow(10.0,i);double scalRelativeTolerance=0.01 * scalAbsoluteTolerance;EmbeddedRungeKuttaIntegrator integ=new DormandPrince54Integrator(minStep,maxStep,scalAbsoluteTolerance,scalRelativeTolerance);TestProblemHandler handler=new TestProblemHandler(pb,integ);integ.setSafety(0.8);integ.setMaxGrowth(5.0);integ.setMinReduction(0.3);integ.addStepHandler(handler);integ.integrate(pb,pb.getInitialTime(),pb.getInitialState(),pb.getFinalTime(),new double[pb.getDimension()]);Assert.assertEquals(0.8,integ.getSafety(),1.0e-12);Assert.assertEquals(5.0,integ.getMaxGrowth(),1.0e-12);Assert.assertEquals(0.3,integ.getMinReduction(),1.0e-12);Assert.assertTrue(handler.getMaximalValueError()< (0.7 * scalAbsoluteTolerance));Assert.assertEquals(0,handler.getMaximalTimeError(),1.0e-12);int calls=pb.getCalls();Assert.assertEquals(integ.getEvaluations(),calls);Assert.assertTrue(calls <= previousCalls);previousCalls=calls;}}
@Test public void testEvents(){TestProblem4 pb=new TestProblem4();double minStep=0;double maxStep=pb.getFinalTime()- pb.getInitialTime();double scalAbsoluteTolerance=1.0e-8;double scalRelativeTolerance=0.01 * scalAbsoluteTolerance;FirstOrderIntegrator integ=new DormandPrince54Integrator(minStep,maxStep,scalAbsoluteTolerance,scalRelativeTolerance);TestProblemHandler handler=new TestProblemHandler(pb,integ);integ.addStepHandler(handler);EventHandler[]functions=pb.getEventsHandlers();double convergence=1.0e-8 * maxStep;for (int l=0;l < functions.length;++l){integ.addEventHandler(functions[l],Double.POSITIVE_INFINITY,convergence,1000);}Assert.assertEquals(functions.length,integ.getEventHandlers().size());integ.integrate(pb,pb.getInitialTime(),pb.getInitialState(),pb.getFinalTime(),new double[pb.getDimension()]);Assert.assertTrue(handler.getMaximalValueError()< 5.0e-6);Assert.assertEquals(0,handler.getMaximalTimeError(),convergence);Assert.assertEquals(12.0,handler.getLastTime(),convergence);integ.clearEventHandlers();Assert.assertEquals(0,integ.getEventHandlers().size());}
@Test public void testKepler(){final TestProblem3 pb=new TestProblem3(0.9);double minStep=0;double maxStep=pb.getFinalTime()- pb.getInitialTime();double scalAbsoluteTolerance=1.0e-8;double scalRelativeTolerance=scalAbsoluteTolerance;FirstOrderIntegrator integ=new DormandPrince54Integrator(minStep,maxStep,scalAbsoluteTolerance,scalRelativeTolerance);integ.addStepHandler(new KeplerHandler(pb));integ.integrate(pb,pb.getInitialTime(),pb.getInitialState(),pb.getFinalTime(),new double[pb.getDimension()]);Assert.assertEquals(integ.getEvaluations(),pb.getCalls());Assert.assertTrue(pb.getCalls()< 2800);}
@Test public void testVariableSteps(){final TestProblem3 pb=new TestProblem3(0.9);double minStep=0;double maxStep=pb.getFinalTime()- pb.getInitialTime();double scalAbsoluteTolerance=1.0e-8;double scalRelativeTolerance=scalAbsoluteTolerance;FirstOrderIntegrator integ=new DormandPrince54Integrator(minStep,maxStep,scalAbsoluteTolerance,scalRelativeTolerance);integ.addStepHandler(new VariableHandler());double stopTime=integ.integrate(pb,pb.getInitialTime(),pb.getInitialState(),pb.getFinalTime(),new double[pb.getDimension()]);Assert.assertEquals(pb.getFinalTime(),stopTime,1.0e-10);}
@Test public void testSpecialValues(){Product product=new Product();Assert.assertEquals(1,product.getResult(),0);product.increment(1);Assert.assertEquals(1,product.getResult(),0);product.increment(Double.POSITIVE_INFINITY);Assert.assertEquals(Double.POSITIVE_INFINITY,product.getResult(),0);product.increment(Double.NEGATIVE_INFINITY);Assert.assertEquals(Double.NEGATIVE_INFINITY,product.getResult(),0);product.increment(Double.NaN);Assert.assertTrue(Double.isNaN(product.getResult()));product.increment(1);Assert.assertTrue(Double.isNaN(product.getResult()));}
@Test public void testWeightedProduct(){Product product=new Product();Assert.assertEquals(expectedWeightedValue(),product.evaluate(testArray,testWeightsArray,0,testArray.length),getTolerance());Assert.assertEquals(expectedValue(),product.evaluate(testArray,unitWeightsArray,0,testArray.length),getTolerance());}
/** * Verifies that increment()and incrementAll work properly.*/@Test public void testIncrementation()throws Exception {StorelessUnivariateStatistic statistic=(StorelessUnivariateStatistic)getUnivariateStatistic();for (int i=0;i < testArray.length;i++){statistic.increment(testArray[i]);}Assert.assertEquals(expectedValue(),statistic.getResult(),getTolerance());Assert.assertEquals(testArray.length,statistic.getN());statistic.clear();statistic.incrementAll(testArray);Assert.assertEquals(expectedValue(),statistic.getResult(),getTolerance());Assert.assertEquals(testArray.length,statistic.getN());statistic.clear();checkClearValue(statistic);Assert.assertEquals(0,statistic.getN());}
@Test public void testSerialization()throws Exception {StorelessUnivariateStatistic statistic=(StorelessUnivariateStatistic)getUnivariateStatistic();TestUtils.checkSerializedEquality(statistic);statistic.clear();for (int i=0;i < testArray.length;i++){statistic.increment(testArray[i]);if (i % 5 == 0)statistic=(StorelessUnivariateStatistic)TestUtils.serializeAndRecover(statistic);}TestUtils.checkSerializedEquality(statistic);Assert.assertEquals(expectedValue(),statistic.getResult(),getTolerance());statistic.clear();checkClearValue(statistic);}
@Test public void testEqualsAndHashCode(){StorelessUnivariateStatistic statistic=(StorelessUnivariateStatistic)getUnivariateStatistic();StorelessUnivariateStatistic statistic2=null;Assert.assertTrue("non-null,compared to null",!statistic.equals(statistic2));Assert.assertTrue("reflexive,non-null",statistic.equals(statistic));int emptyHash=statistic.hashCode();statistic2=(StorelessUnivariateStatistic)getUnivariateStatistic();Assert.assertTrue("empty stats should be equal",statistic.equals(statistic2));Assert.assertEquals("empty stats should have the same hashcode",emptyHash,statistic2.hashCode());statistic.increment(1d);Assert.assertTrue("reflexive,non-empty",statistic.equals(statistic));Assert.assertTrue("non-empty,compared to empty",!statistic.equals(statistic2));Assert.assertTrue("non-empty,compared to empty",!statistic2.equals(statistic));Assert.assertTrue("non-empty stat should have different hashcode from empty stat",statistic.hashCode()!= emptyHash);statistic2.increment(1d);Assert.assertTrue("stats with same data should be equal",statistic.equals(statistic2));Assert.assertEquals("stats with same data should have the same hashcode",statistic.hashCode(),statistic2.hashCode());statistic.increment(Double.POSITIVE_INFINITY);Assert.assertTrue("stats with different n's should not be equal",!statistic2.equals(statistic));Assert.assertTrue("stats with different n's should have different hashcodes",statistic.hashCode()!= statistic2.hashCode());statistic2.increment(Double.POSITIVE_INFINITY);Assert.assertTrue("stats with same data should be equal",statistic.equals(statistic2));Assert.assertEquals("stats with same data should have the same hashcode",statistic.hashCode(),statistic2.hashCode());statistic.clear();statistic2.clear();Assert.assertTrue("cleared stats should be equal",statistic.equals(statistic2));Assert.assertEquals("cleared stats should have thashcode of empty stat",emptyHash,statistic2.hashCode());Assert.assertEquals("cleared stats should have thashcode of empty stat",emptyHash,statistic.hashCode());}
@Test public void testMomentSmallSamples(){UnivariateStatistic stat=getUnivariateStatistic();if (stat instanceof SecondMoment){SecondMoment moment=(SecondMoment)getUnivariateStatistic();Assert.assertTrue(Double.isNaN(moment.getResult()));moment.increment(1d);Assert.assertEquals(0d,moment.getResult(),0);}}
/** * Make sure that evaluate(double[])and inrementAll(double[]),getResult()give same results.*/@Test public void testConsistency(){StorelessUnivariateStatistic stat=(StorelessUnivariateStatistic)getUnivariateStatistic();stat.incrementAll(testArray);Assert.assertEquals(stat.getResult(),stat.evaluate(testArray),getTolerance());for (int i=0;i < smallSamples.length;i++){stat.clear();for (int j=0;j < smallSamples[i].length;j++){stat.increment(smallSamples[i][j]);}TestUtils.assertEquals(stat.getResult(),stat.evaluate(smallSamples[i]),getTolerance());}}
/** * Verifies that copied statistics remain equal to originals when incremented the same way.*/@Test public void testCopyConsistency(){StorelessUnivariateStatistic master=(StorelessUnivariateStatistic)getUnivariateStatistic();StorelessUnivariateStatistic replica=null;long index=FastMath.round((FastMath.random())* testArray.length);master.incrementAll(testArray,0,(int)index);replica=master.copy();Assert.assertTrue(replica.equals(master));Assert.assertTrue(master.equals(replica));master.incrementAll(testArray,(int)index,(int)(testArray.length - index));replica.incrementAll(testArray,(int)index,(int)(testArray.length - index));Assert.assertTrue(replica.equals(master));Assert.assertTrue(master.equals(replica));}
@Test public void testSerial(){StorelessUnivariateStatistic s=(StorelessUnivariateStatistic)getUnivariateStatistic();Assert.assertEquals(s,TestUtils.serializeAndRecover(s));}
@Test public void testEvaluation()throws Exception {Assert.assertEquals(expectedValue(),getUnivariateStatistic().evaluate(testArray),getTolerance());}
@Test public void testEvaluateArraySegment(){final UnivariateStatistic stat=getUnivariateStatistic();final double[]arrayZero=new double[5];System.arraycopy(testArray,0,arrayZero,0,5);Assert.assertEquals(stat.evaluate(arrayZero),stat.evaluate(testArray,0,5),0);final double[]arrayOne=new double[5];System.arraycopy(testArray,5,arrayOne,0,5);Assert.assertEquals(stat.evaluate(arrayOne),stat.evaluate(testArray,5,5),0);final double[]arrayEnd=new double[5];System.arraycopy(testArray,testArray.length - 5,arrayEnd,0,5);Assert.assertEquals(stat.evaluate(arrayEnd),stat.evaluate(testArray,testArray.length - 5,5),0);}
@Test public void testEvaluateArraySegmentWeighted(){UnivariateStatistic statistic=getUnivariateStatistic();if (!(statistic instanceof WeightedEvaluation)){return;}final WeightedEvaluation stat=(WeightedEvaluation)getUnivariateStatistic();final double[]arrayZero=new double[5];final double[]weightZero=new double[5];System.arraycopy(testArray,0,arrayZero,0,5);System.arraycopy(testWeightsArray,0,weightZero,0,5);Assert.assertEquals(stat.evaluate(arrayZero,weightZero),stat.evaluate(testArray,testWeightsArray,0,5),0);final double[]arrayOne=new double[5];final double[]weightOne=new double[5];System.arraycopy(testArray,5,arrayOne,0,5);System.arraycopy(testWeightsArray,5,weightOne,0,5);Assert.assertEquals(stat.evaluate(arrayOne,weightOne),stat.evaluate(testArray,testWeightsArray,5,5),0);final double[]arrayEnd=new double[5];final double[]weightEnd=new double[5];System.arraycopy(testArray,testArray.length - 5,arrayEnd,0,5);System.arraycopy(testWeightsArray,testArray.length - 5,weightEnd,0,5);Assert.assertEquals(stat.evaluate(arrayEnd,weightEnd),stat.evaluate(testArray,testWeightsArray,testArray.length - 5,5),0);}
@Test public void testCopy()throws Exception {UnivariateStatistic original=getUnivariateStatistic();UnivariateStatistic copy=original.copy();Assert.assertEquals(expectedValue(),copy.evaluate(testArray),getTolerance());}
/** * Tests consistency of weighted statistic computation. For statistics that support weighted evaluation,this test case compares the result of direct computation on an array with repeated values with a weighted computation on the corresponding (shorter)array with each value appearing only once but with a weight value equal to its multiplicity in the repeating array.*/@Test public void testWeightedConsistency()throws Exception {UnivariateStatistic statistic=getUnivariateStatistic();if (!(statistic instanceof WeightedEvaluation)){return;}final int len=10;final double mu=0;final double sigma=5;double[]values=new double[len];double[]weights=new double[len];RandomData randomData=new RandomDataImpl();int[]intWeights=new int[len];for (int i=0;i < len;i++){intWeights[i]=randomData.nextInt(1,5);weights[i]=intWeights[i];}List<Double> valuesList=new ArrayList<Double>();for (int i=0;i < len;i++){double value=randomData.nextGaussian(mu,sigma);values[i]=value;for (int j=0;j < intWeights[i];j++){valuesList.add(new Double(value));}}int sumWeights=valuesList.size();double[]repeatedValues=new double[sumWeights];for (int i=0;i < sumWeights;i++){repeatedValues[i]=valuesList.get(i);}WeightedEvaluation weightedStatistic=(WeightedEvaluation)statistic;TestUtils.assertRelativelyEquals(statistic.evaluate(repeatedValues),weightedStatistic.evaluate(values,weights,0,values.length),10E-14);Assert.assertEquals(weightedStatistic.evaluate(values,weights,0,values.length),weightedStatistic.evaluate(values,weights),Double.MIN_VALUE);}
@Test public void testNoError(){Random randomizer=new Random(64925784252l);for (int degree=1;degree < 10;++degree){PolynomialFunction p=buildRandomPolynomial(degree,randomizer);PolynomialFitter fitter=new PolynomialFitter(degree,new LevenbergMarquardtOptimizer());for (int i=0;i <= degree;++i){fitter.addObservedPoint(1.0,i,p.value(i));}PolynomialFunction fitted=new PolynomialFunction(fitter.fit());for (double x=-1.0;x < 1.0;x+=0.01){double error=FastMath.abs(p.value(x)- fitted.value(x))/ (1.0 + FastMath.abs(p.value(x)));Assert.assertEquals(0.0,error,1.0e-6);}}}
@Test public void testSmallError(){Random randomizer=new Random(53882150042l);double maxError=0;for (int degree=0;degree < 10;++degree){PolynomialFunction p=buildRandomPolynomial(degree,randomizer);PolynomialFitter fitter=new PolynomialFitter(degree,new LevenbergMarquardtOptimizer());for (double x=-1.0;x < 1.0;x+=0.01){fitter.addObservedPoint(1.0,x,p.value(x)+ 0.1 * randomizer.nextGaussian());}PolynomialFunction fitted=new PolynomialFunction(fitter.fit());for (double x=-1.0;x < 1.0;x+=0.01){double error=FastMath.abs(p.value(x)- fitted.value(x))/ (1.0 + FastMath.abs(p.value(x)));maxError=FastMath.max(maxError,error);Assert.assertTrue(FastMath.abs(error)< 0.1);}}Assert.assertTrue(maxError > 0.01);}
@Test public void testRedundantSolvable(){checkUnsolvableProblem(new LevenbergMarquardtOptimizer(),true);}
@Test public void testRedundantUnsolvable(){DifferentiableMultivariateVectorialOptimizer optimizer=new GaussNewtonOptimizer(true);checkUnsolvableProblem(optimizer,false);}
@Test(expected=OutOfRangeException.class)public void testPreconditions1(){final double lo=-1;final double hi=2;final UnivariateFunction f=new Logit(lo,hi);f.value(lo - 1);}
@Test(expected=OutOfRangeException.class)public void testPreconditions2(){final double lo=-1;final double hi=2;final UnivariateFunction f=new Logit(lo,hi);f.value(hi + 1);}
@Test public void testSomeValues(){final double lo=1;final double hi=2;final UnivariateFunction f=new Logit(lo,hi);Assert.assertEquals(Double.NEGATIVE_INFINITY,f.value(1),EPS);Assert.assertEquals(Double.POSITIVE_INFINITY,f.value(2),EPS);Assert.assertEquals(0,f.value(1.5),EPS);}
@Test public void testDerivative(){final double lo=1;final double hi=2;final Logit f=new Logit(lo,hi);final UnivariateFunction dfdx=f.derivative();Assert.assertEquals(4,dfdx.value(1.5),EPS);}
@Test public void testDerivativeLargeArguments(){final Logit f=new Logit(1,2);final UnivariateFunction dfdx=f.derivative();Assert.assertEquals(0,dfdx.value(Double.NEGATIVE_INFINITY),0);Assert.assertEquals(0,dfdx.value(-Double.MAX_VALUE),0);Assert.assertEquals(0,dfdx.value(-1e155),0);Assert.assertEquals(0,dfdx.value(1e155),0);Assert.assertEquals(0,dfdx.value(Double.MAX_VALUE),0);Assert.assertEquals(0,dfdx.value(Double.POSITIVE_INFINITY),0);}
@Test(expected=NullArgumentException.class)public void testParametricUsage1(){final Logit.Parametric g=new Logit.Parametric();g.value(0,null);}
@Test(expected=DimensionMismatchException.class)public void testParametricUsage2(){final Logit.Parametric g=new Logit.Parametric();g.value(0,new double[]{0});}
@Test(expected=NullArgumentException.class)public void testParametricUsage3(){final Logit.Parametric g=new Logit.Parametric();g.gradient(0,null);}
@Test(expected=DimensionMismatchException.class)public void testParametricUsage4(){final Logit.Parametric g=new Logit.Parametric();g.gradient(0,new double[]{0});}
@Test(expected=OutOfRangeException.class)public void testParametricUsage5(){final Logit.Parametric g=new Logit.Parametric();g.value(-1,new double[]{0,1});}
@Test(expected=OutOfRangeException.class)public void testParametricUsage6(){final Logit.Parametric g=new Logit.Parametric();g.value(2,new double[]{0,1});}
@Test public void testParametricValue(){final double lo=2;final double hi=3;final Logit f=new Logit(lo,hi);final Logit.Parametric g=new Logit.Parametric();Assert.assertEquals(f.value(2),g.value(2,new double[]{lo,hi}),0);Assert.assertEquals(f.value(2.34567),g.value(2.34567,new double[]{lo,hi}),0);Assert.assertEquals(f.value(3),g.value(3,new double[]{lo,hi}),0);}
@Test public void testValueWithInverseFunction(){final double lo=2;final double hi=3;final Logit f=new Logit(lo,hi);final Sigmoid g=new Sigmoid(lo,hi);final UnivariateFunction id=FunctionUtils.compose(g,f);for (int i=0;i < 10;i++){final double x=lo + Math.random()* (hi - lo);Assert.assertEquals(x,id.value(x),EPS);}Assert.assertEquals(lo,id.value(lo),EPS);Assert.assertEquals(hi,id.value(hi),EPS);}
@Test public void testDerivativeWithInverseFunction(){final double lo=2;final double hi=3;final Logit f=new Logit(lo,hi);final UnivariateFunction dfdx=f.derivative();final Sigmoid g=new Sigmoid(lo,hi);final UnivariateFunction dgdx=g.derivative();final UnivariateFunction chain=FunctionUtils.compose(new Inverse(),FunctionUtils.compose(dgdx,f));for (int i=0;i < 10;i++){final double x=lo + Math.random()* (hi - lo);final double r=dfdx.value(x);Assert.assertEquals(r,chain.value(x),r * 1e-15);}Assert.assertEquals(dfdx.value(lo),chain.value(lo),0);Assert.assertEquals(dfdx.value(hi),chain.value(hi),0);}
@Test public void testSmallDf()throws Exception {setDistribution(new ChiSquaredDistribution(0.1d));setTolerance(1E-4);setCumulativeTestPoints(new double[]{1.168926E-60,1.168926E-40,1.063132E-32,1.144775E-26,1.168926E-20,5.472917,2.175255,1.13438,0.5318646,0.1526342});setInverseCumulativeTestValues(getCumulativeTestPoints());setInverseCumulativeTestPoints(getCumulativeTestValues());verifyCumulativeProbabilities();verifyInverseCumulativeProbabilities();}
@Test public void testDfAccessors(){ChiSquaredDistribution distribution=(ChiSquaredDistribution)getDistribution();Assert.assertEquals(5d,distribution.getDegreesOfFreedom(),Double.MIN_VALUE);}
@Test public void testDensity(){double[]x=new double[]{-0.1,1e-6,0.5,1,2,5};checkDensity(1,x,new double[]{0.00000000000,398.94208093034,0.43939128947,0.24197072452,0.10377687436,0.01464498256});checkDensity(0.1,x,new double[]{0.000000000e+00,2.486453997e+04,7.464238732e-02,3.009077718e-02,9.447299159e-03,8.827199396e-04});checkDensity(2,x,new double[]{0.00000000000,0.49999975000,0.38940039154,0.30326532986,0.18393972059,0.04104249931});checkDensity(10,x,new double[]{0.000000000e+00,1.302082682e-27,6.337896998e-05,7.897534632e-04,7.664155024e-03,6.680094289e-02});}
@Test public void testMoments(){final double tol=1e-9;ChiSquaredDistribution dist;dist=new ChiSquaredDistribution(1500);Assert.assertEquals(dist.getNumericalMean(),1500,tol);Assert.assertEquals(dist.getNumericalVariance(),3000,tol);dist=new ChiSquaredDistribution(1.12);Assert.assertEquals(dist.getNumericalMean(),1.12,tol);Assert.assertEquals(dist.getNumericalVariance(),2.24,tol);}
/** * Verifies that cumulative probability density calculations match expected values using default test instance data*/@Test public void testCumulativeProbabilities()throws Exception {verifyCumulativeProbabilities();}
/** * Verifies that inverse cumulative probability density calculations match expected values using default test instance data*/@Test public void testInverseCumulativeProbabilities()throws Exception {verifyInverseCumulativeProbabilities();}
/** * Verifies that density calculations return expected values for default test instance data*/@Test public void testDensities()throws Exception {verifyDensities();}
/** * Verifies that probability computations are consistent*/@Test public void testConsistency()throws Exception {for (int i=1;i < cumulativeTestPoints.length;i++){TestUtils.assertEquals(0d,distribution.cumulativeProbability(cumulativeTestPoints[i],cumulativeTestPoints[i]),tolerance);double upper=FastMath.max(cumulativeTestPoints[i],cumulativeTestPoints[i - 1]);double lower=FastMath.min(cumulativeTestPoints[i],cumulativeTestPoints[i - 1]);double diff=distribution.cumulativeProbability(upper)- distribution.cumulativeProbability(lower);double direct=distribution.cumulativeProbability(lower,upper);TestUtils.assertEquals("Inconsistent cumulative probabilities for (" + lower + ","+ upper+ ")",diff,direct,tolerance);}}
/** * Verifies that illegal arguments are correctly handled*/@Test public void testIllegalArguments()throws Exception {try {distribution.cumulativeProbability(1,0);Assert.fail("Expecting MathIllegalArgumentException for bad cumulativeProbability interval");}catch(MathIllegalArgumentException ex){}try {distribution.inverseCumulativeProbability(-1);Assert.fail("Expecting MathIllegalArgumentException for p = -1");}catch(MathIllegalArgumentException ex){}try {distribution.inverseCumulativeProbability(2);Assert.fail("Expecting MathIllegalArgumentException for p = 2");}catch(MathIllegalArgumentException ex){}}
/** * Test sampling*/@Test public void testSampling()throws Exception {AbstractContinuousDistribution dist=(AbstractContinuousDistribution)makeDistribution();final int sampleSize=1000;dist.reseedRandomGenerator(1000);double[]sample=dist.sample(sampleSize);double[]quartiles=TestUtils.getDistributionQuartiles(dist);double[]expected={250,250,250,250};long[]counts=new long[4];for (int i=0;i < sampleSize;i++){TestUtils.updateCounts(sample[i],counts,quartiles);}TestUtils.assertChiSquareAccept(expected,counts,0.001);}
@Test public void testShortcut(){final Sinc s=new Sinc();final UnivariateFunction f=new UnivariateFunction(){public double value(double x){return FastMath.sin(x)/ x;}};for (double x=1e-30;x < 1e10;x*=2){final double fX=f.value(x);final double sX=s.value(x);Assert.assertEquals("x=" + x,fX,sX,0);}}
@Test public void testCrossings(){final Sinc s=new Sinc(true);final int numCrossings=1000;final double tol=2e-16;for (int i=1;i <= numCrossings;i++){Assert.assertEquals("i=" + i,0,s.value(i),tol);}}
@Test public void testZero(){final Sinc s=new Sinc();Assert.assertEquals(1d,s.value(0),0);}
@Test public void testEuler(){final Sinc s=new Sinc();final double x=123456.789;double prod=1;double xOverPow2=x / 2;while (xOverPow2 > 0){prod*=FastMath.cos(xOverPow2);xOverPow2/=2;}Assert.assertEquals(prod,s.value(x),1e-13);}
@Test public void testDerivativeZero(){final UnivariateFunction sPrime=(new Sinc(true)).derivative();Assert.assertEquals(0,sPrime.value(0),0);}
@Test public void testDerivativeShortcut(){final UnivariateFunction sPrime=(new Sinc()).derivative();final UnivariateFunction f=new UnivariateFunction(){public double value(double x){return (FastMath.cos(x)- FastMath.sin(x)/ x)/ x;}};for (double x=1e-30;x < 1e10;x*=2){final double fX=f.value(x);final double sX=sPrime.value(x);Assert.assertEquals("x=" + x,fX,sX,0);}}
/** * Test SummaryStatistics - implementations that do not store the data and use single pass algorithms to compute statistics*/@Test public void testSummaryStatistics()throws Exception {SummaryStatistics u=new SummaryStatistics();loadStats("data/PiDigits.txt",u);Assert.assertEquals("PiDigits: std",std,u.getStandardDeviation(),1E-13);Assert.assertEquals("PiDigits: mean",mean,u.getMean(),1E-13);loadStats("data/Mavro.txt",u);Assert.assertEquals("Mavro: std",std,u.getStandardDeviation(),1E-14);Assert.assertEquals("Mavro: mean",mean,u.getMean(),1E-14);loadStats("data/Michelso.txt",u);Assert.assertEquals("Michelso: std",std,u.getStandardDeviation(),1E-13);Assert.assertEquals("Michelso: mean",mean,u.getMean(),1E-13);loadStats("data/NumAcc1.txt",u);Assert.assertEquals("NumAcc1: std",std,u.getStandardDeviation(),1E-14);Assert.assertEquals("NumAcc1: mean",mean,u.getMean(),1E-14);loadStats("data/NumAcc2.txt",u);Assert.assertEquals("NumAcc2: std",std,u.getStandardDeviation(),1E-14);Assert.assertEquals("NumAcc2: mean",mean,u.getMean(),1E-14);}
/** * Test DescriptiveStatistics - implementations that store full array of values and execute multi-pass algorithms*/@Test public void testDescriptiveStatistics()throws Exception {DescriptiveStatistics u=new DescriptiveStatistics();loadStats("data/PiDigits.txt",u);Assert.assertEquals("PiDigits: std",std,u.getStandardDeviation(),1E-14);Assert.assertEquals("PiDigits: mean",mean,u.getMean(),1E-14);loadStats("data/Mavro.txt",u);Assert.assertEquals("Mavro: std",std,u.getStandardDeviation(),1E-14);Assert.assertEquals("Mavro: mean",mean,u.getMean(),1E-14);loadStats("data/Michelso.txt",u);Assert.assertEquals("Michelso: std",std,u.getStandardDeviation(),1E-14);Assert.assertEquals("Michelso: mean",mean,u.getMean(),1E-14);loadStats("data/NumAcc1.txt",u);Assert.assertEquals("NumAcc1: std",std,u.getStandardDeviation(),1E-14);Assert.assertEquals("NumAcc1: mean",mean,u.getMean(),1E-14);loadStats("data/NumAcc2.txt",u);Assert.assertEquals("NumAcc2: std",std,u.getStandardDeviation(),1E-14);Assert.assertEquals("NumAcc2: mean",mean,u.getMean(),1E-14);}
/** * Make sure Double.NaN is returned iff n = 0*/@Test public void testNaN(){StandardDeviation std=new StandardDeviation();Assert.assertTrue(Double.isNaN(std.getResult()));std.increment(1d);Assert.assertEquals(0d,std.getResult(),0);}
/** * Test population version of variance*/@Test public void testPopulation(){double[]values={-1.0d,3.1d,4.0d,-2.1d,22d,11.7d,3d,14d};SecondMoment m=new SecondMoment();m.evaluate(values);Variance v1=new Variance();v1.setBiasCorrected(false);Assert.assertEquals(populationVariance(values),v1.evaluate(values),1E-14);v1.incrementAll(values);Assert.assertEquals(populationVariance(values),v1.getResult(),1E-14);v1=new Variance(false,m);Assert.assertEquals(populationVariance(values),v1.getResult(),1E-14);v1=new Variance(false);Assert.assertEquals(populationVariance(values),v1.evaluate(values),1E-14);v1.incrementAll(values);Assert.assertEquals(populationVariance(values),v1.getResult(),1E-14);}
@Test public void testWeightedVariance(){Variance variance=new Variance();Assert.assertEquals(expectedWeightedValue(),variance.evaluate(testArray,testWeightsArray,0,testArray.length),getTolerance());Assert.assertEquals(expectedValue(),variance.evaluate(testArray,unitWeightsArray,0,testArray.length),getTolerance());Assert.assertEquals(expectedValue(),variance.evaluate(testArray,MathArrays.normalizeArray(identicalWeightsArray,testArray.length),0,testArray.length),getTolerance());}
/** * Verifies that increment()and incrementAll work properly.*/@Test public void testIncrementation()throws Exception {StorelessUnivariateStatistic statistic=(StorelessUnivariateStatistic)getUnivariateStatistic();for (int i=0;i < testArray.length;i++){statistic.increment(testArray[i]);}Assert.assertEquals(expectedValue(),statistic.getResult(),getTolerance());Assert.assertEquals(testArray.length,statistic.getN());statistic.clear();statistic.incrementAll(testArray);Assert.assertEquals(expectedValue(),statistic.getResult(),getTolerance());Assert.assertEquals(testArray.length,statistic.getN());statistic.clear();checkClearValue(statistic);Assert.assertEquals(0,statistic.getN());}
@Test public void testSerialization()throws Exception {StorelessUnivariateStatistic statistic=(StorelessUnivariateStatistic)getUnivariateStatistic();TestUtils.checkSerializedEquality(statistic);statistic.clear();for (int i=0;i < testArray.length;i++){statistic.increment(testArray[i]);if (i % 5 == 0)statistic=(StorelessUnivariateStatistic)TestUtils.serializeAndRecover(statistic);}TestUtils.checkSerializedEquality(statistic);Assert.assertEquals(expectedValue(),statistic.getResult(),getTolerance());statistic.clear();checkClearValue(statistic);}
@Test public void testEqualsAndHashCode(){StorelessUnivariateStatistic statistic=(StorelessUnivariateStatistic)getUnivariateStatistic();StorelessUnivariateStatistic statistic2=null;Assert.assertTrue("non-null,compared to null",!statistic.equals(statistic2));Assert.assertTrue("reflexive,non-null",statistic.equals(statistic));int emptyHash=statistic.hashCode();statistic2=(StorelessUnivariateStatistic)getUnivariateStatistic();Assert.assertTrue("empty stats should be equal",statistic.equals(statistic2));Assert.assertEquals("empty stats should have the same hashcode",emptyHash,statistic2.hashCode());statistic.increment(1d);Assert.assertTrue("reflexive,non-empty",statistic.equals(statistic));Assert.assertTrue("non-empty,compared to empty",!statistic.equals(statistic2));Assert.assertTrue("non-empty,compared to empty",!statistic2.equals(statistic));Assert.assertTrue("non-empty stat should have different hashcode from empty stat",statistic.hashCode()!= emptyHash);statistic2.increment(1d);Assert.assertTrue("stats with same data should be equal",statistic.equals(statistic2));Assert.assertEquals("stats with same data should have the same hashcode",statistic.hashCode(),statistic2.hashCode());statistic.increment(Double.POSITIVE_INFINITY);Assert.assertTrue("stats with different n's should not be equal",!statistic2.equals(statistic));Assert.assertTrue("stats with different n's should have different hashcodes",statistic.hashCode()!= statistic2.hashCode());statistic2.increment(Double.POSITIVE_INFINITY);Assert.assertTrue("stats with same data should be equal",statistic.equals(statistic2));Assert.assertEquals("stats with same data should have the same hashcode",statistic.hashCode(),statistic2.hashCode());statistic.clear();statistic2.clear();Assert.assertTrue("cleared stats should be equal",statistic.equals(statistic2));Assert.assertEquals("cleared stats should have thashcode of empty stat",emptyHash,statistic2.hashCode());Assert.assertEquals("cleared stats should have thashcode of empty stat",emptyHash,statistic.hashCode());}
@Test public void testMomentSmallSamples(){UnivariateStatistic stat=getUnivariateStatistic();if (stat instanceof SecondMoment){SecondMoment moment=(SecondMoment)getUnivariateStatistic();Assert.assertTrue(Double.isNaN(moment.getResult()));moment.increment(1d);Assert.assertEquals(0d,moment.getResult(),0);}}
/** * Make sure that evaluate(double[])and inrementAll(double[]),getResult()give same results.*/@Test public void testConsistency(){StorelessUnivariateStatistic stat=(StorelessUnivariateStatistic)getUnivariateStatistic();stat.incrementAll(testArray);Assert.assertEquals(stat.getResult(),stat.evaluate(testArray),getTolerance());for (int i=0;i < smallSamples.length;i++){stat.clear();for (int j=0;j < smallSamples[i].length;j++){stat.increment(smallSamples[i][j]);}TestUtils.assertEquals(stat.getResult(),stat.evaluate(smallSamples[i]),getTolerance());}}
/** * Verifies that copied statistics remain equal to originals when incremented the same way.*/@Test public void testCopyConsistency(){StorelessUnivariateStatistic master=(StorelessUnivariateStatistic)getUnivariateStatistic();StorelessUnivariateStatistic replica=null;long index=FastMath.round((FastMath.random())* testArray.length);master.incrementAll(testArray,0,(int)index);replica=master.copy();Assert.assertTrue(replica.equals(master));Assert.assertTrue(master.equals(replica));master.incrementAll(testArray,(int)index,(int)(testArray.length - index));replica.incrementAll(testArray,(int)index,(int)(testArray.length - index));Assert.assertTrue(replica.equals(master));Assert.assertTrue(master.equals(replica));}
@Test public void testSerial(){StorelessUnivariateStatistic s=(StorelessUnivariateStatistic)getUnivariateStatistic();Assert.assertEquals(s,TestUtils.serializeAndRecover(s));}
@Test public void testEvaluation()throws Exception {Assert.assertEquals(expectedValue(),getUnivariateStatistic().evaluate(testArray),getTolerance());}
@Test public void testEvaluateArraySegment(){final UnivariateStatistic stat=getUnivariateStatistic();final double[]arrayZero=new double[5];System.arraycopy(testArray,0,arrayZero,0,5);Assert.assertEquals(stat.evaluate(arrayZero),stat.evaluate(testArray,0,5),0);final double[]arrayOne=new double[5];System.arraycopy(testArray,5,arrayOne,0,5);Assert.assertEquals(stat.evaluate(arrayOne),stat.evaluate(testArray,5,5),0);final double[]arrayEnd=new double[5];System.arraycopy(testArray,testArray.length - 5,arrayEnd,0,5);Assert.assertEquals(stat.evaluate(arrayEnd),stat.evaluate(testArray,testArray.length - 5,5),0);}
@Test public void testEvaluateArraySegmentWeighted(){UnivariateStatistic statistic=getUnivariateStatistic();if (!(statistic instanceof WeightedEvaluation)){return;}final WeightedEvaluation stat=(WeightedEvaluation)getUnivariateStatistic();final double[]arrayZero=new double[5];final double[]weightZero=new double[5];System.arraycopy(testArray,0,arrayZero,0,5);System.arraycopy(testWeightsArray,0,weightZero,0,5);Assert.assertEquals(stat.evaluate(arrayZero,weightZero),stat.evaluate(testArray,testWeightsArray,0,5),0);final double[]arrayOne=new double[5];final double[]weightOne=new double[5];System.arraycopy(testArray,5,arrayOne,0,5);System.arraycopy(testWeightsArray,5,weightOne,0,5);Assert.assertEquals(stat.evaluate(arrayOne,weightOne),stat.evaluate(testArray,testWeightsArray,5,5),0);final double[]arrayEnd=new double[5];final double[]weightEnd=new double[5];System.arraycopy(testArray,testArray.length - 5,arrayEnd,0,5);System.arraycopy(testWeightsArray,testArray.length - 5,weightEnd,0,5);Assert.assertEquals(stat.evaluate(arrayEnd,weightEnd),stat.evaluate(testArray,testWeightsArray,testArray.length - 5,5),0);}
@Test public void testCopy()throws Exception {UnivariateStatistic original=getUnivariateStatistic();UnivariateStatistic copy=original.copy();Assert.assertEquals(expectedValue(),copy.evaluate(testArray),getTolerance());}
/** * Tests consistency of weighted statistic computation. For statistics that support weighted evaluation,this test case compares the result of direct computation on an array with repeated values with a weighted computation on the corresponding (shorter)array with each value appearing only once but with a weight value equal to its multiplicity in the repeating array.*/@Test public void testWeightedConsistency()throws Exception {UnivariateStatistic statistic=getUnivariateStatistic();if (!(statistic instanceof WeightedEvaluation)){return;}final int len=10;final double mu=0;final double sigma=5;double[]values=new double[len];double[]weights=new double[len];RandomData randomData=new RandomDataImpl();int[]intWeights=new int[len];for (int i=0;i < len;i++){intWeights[i]=randomData.nextInt(1,5);weights[i]=intWeights[i];}List<Double> valuesList=new ArrayList<Double>();for (int i=0;i < len;i++){double value=randomData.nextGaussian(mu,sigma);values[i]=value;for (int j=0;j < intWeights[i];j++){valuesList.add(new Double(value));}}int sumWeights=valuesList.size();double[]repeatedValues=new double[sumWeights];for (int i=0;i < sumWeights;i++){repeatedValues[i]=valuesList.get(i);}WeightedEvaluation weightedStatistic=(WeightedEvaluation)statistic;TestUtils.assertRelativelyEquals(statistic.evaluate(repeatedValues),weightedStatistic.evaluate(values,weights,0,values.length),10E-14);Assert.assertEquals(weightedStatistic.evaluate(values,weights,0,values.length),weightedStatistic.evaluate(values,weights),Double.MIN_VALUE);}
@Test public void testSmallSamples(){Mean mean=new Mean();Assert.assertTrue(Double.isNaN(mean.getResult()));mean.increment(1d);Assert.assertEquals(1d,mean.getResult(),0);}
@Test public void testWeightedMean(){Mean mean=new Mean();Assert.assertEquals(expectedWeightedValue(),mean.evaluate(testArray,testWeightsArray,0,testArray.length),getTolerance());Assert.assertEquals(expectedValue(),mean.evaluate(testArray,identicalWeightsArray,0,testArray.length),getTolerance());}
/** * Verifies that increment()and incrementAll work properly.*/@Test public void testIncrementation()throws Exception {StorelessUnivariateStatistic statistic=(StorelessUnivariateStatistic)getUnivariateStatistic();for (int i=0;i < testArray.length;i++){statistic.increment(testArray[i]);}Assert.assertEquals(expectedValue(),statistic.getResult(),getTolerance());Assert.assertEquals(testArray.length,statistic.getN());statistic.clear();statistic.incrementAll(testArray);Assert.assertEquals(expectedValue(),statistic.getResult(),getTolerance());Assert.assertEquals(testArray.length,statistic.getN());statistic.clear();checkClearValue(statistic);Assert.assertEquals(0,statistic.getN());}
@Test public void testSerialization()throws Exception {StorelessUnivariateStatistic statistic=(StorelessUnivariateStatistic)getUnivariateStatistic();TestUtils.checkSerializedEquality(statistic);statistic.clear();for (int i=0;i < testArray.length;i++){statistic.increment(testArray[i]);if (i % 5 == 0)statistic=(StorelessUnivariateStatistic)TestUtils.serializeAndRecover(statistic);}TestUtils.checkSerializedEquality(statistic);Assert.assertEquals(expectedValue(),statistic.getResult(),getTolerance());statistic.clear();checkClearValue(statistic);}
@Test public void testEqualsAndHashCode(){StorelessUnivariateStatistic statistic=(StorelessUnivariateStatistic)getUnivariateStatistic();StorelessUnivariateStatistic statistic2=null;Assert.assertTrue("non-null,compared to null",!statistic.equals(statistic2));Assert.assertTrue("reflexive,non-null",statistic.equals(statistic));int emptyHash=statistic.hashCode();statistic2=(StorelessUnivariateStatistic)getUnivariateStatistic();Assert.assertTrue("empty stats should be equal",statistic.equals(statistic2));Assert.assertEquals("empty stats should have the same hashcode",emptyHash,statistic2.hashCode());statistic.increment(1d);Assert.assertTrue("reflexive,non-empty",statistic.equals(statistic));Assert.assertTrue("non-empty,compared to empty",!statistic.equals(statistic2));Assert.assertTrue("non-empty,compared to empty",!statistic2.equals(statistic));Assert.assertTrue("non-empty stat should have different hashcode from empty stat",statistic.hashCode()!= emptyHash);statistic2.increment(1d);Assert.assertTrue("stats with same data should be equal",statistic.equals(statistic2));Assert.assertEquals("stats with same data should have the same hashcode",statistic.hashCode(),statistic2.hashCode());statistic.increment(Double.POSITIVE_INFINITY);Assert.assertTrue("stats with different n's should not be equal",!statistic2.equals(statistic));Assert.assertTrue("stats with different n's should have different hashcodes",statistic.hashCode()!= statistic2.hashCode());statistic2.increment(Double.POSITIVE_INFINITY);Assert.assertTrue("stats with same data should be equal",statistic.equals(statistic2));Assert.assertEquals("stats with same data should have the same hashcode",statistic.hashCode(),statistic2.hashCode());statistic.clear();statistic2.clear();Assert.assertTrue("cleared stats should be equal",statistic.equals(statistic2));Assert.assertEquals("cleared stats should have thashcode of empty stat",emptyHash,statistic2.hashCode());Assert.assertEquals("cleared stats should have thashcode of empty stat",emptyHash,statistic.hashCode());}
@Test public void testMomentSmallSamples(){UnivariateStatistic stat=getUnivariateStatistic();if (stat instanceof SecondMoment){SecondMoment moment=(SecondMoment)getUnivariateStatistic();Assert.assertTrue(Double.isNaN(moment.getResult()));moment.increment(1d);Assert.assertEquals(0d,moment.getResult(),0);}}
/** * Make sure that evaluate(double[])and inrementAll(double[]),getResult()give same results.*/@Test public void testConsistency(){StorelessUnivariateStatistic stat=(StorelessUnivariateStatistic)getUnivariateStatistic();stat.incrementAll(testArray);Assert.assertEquals(stat.getResult(),stat.evaluate(testArray),getTolerance());for (int i=0;i < smallSamples.length;i++){stat.clear();for (int j=0;j < smallSamples[i].length;j++){stat.increment(smallSamples[i][j]);}TestUtils.assertEquals(stat.getResult(),stat.evaluate(smallSamples[i]),getTolerance());}}
/** * Verifies that copied statistics remain equal to originals when incremented the same way.*/@Test public void testCopyConsistency(){StorelessUnivariateStatistic master=(StorelessUnivariateStatistic)getUnivariateStatistic();StorelessUnivariateStatistic replica=null;long index=FastMath.round((FastMath.random())* testArray.length);master.incrementAll(testArray,0,(int)index);replica=master.copy();Assert.assertTrue(replica.equals(master));Assert.assertTrue(master.equals(replica));master.incrementAll(testArray,(int)index,(int)(testArray.length - index));replica.incrementAll(testArray,(int)index,(int)(testArray.length - index));Assert.assertTrue(replica.equals(master));Assert.assertTrue(master.equals(replica));}
@Test public void testSerial(){StorelessUnivariateStatistic s=(StorelessUnivariateStatistic)getUnivariateStatistic();Assert.assertEquals(s,TestUtils.serializeAndRecover(s));}
@Test public void testEvaluation()throws Exception {Assert.assertEquals(expectedValue(),getUnivariateStatistic().evaluate(testArray),getTolerance());}
@Test public void testEvaluateArraySegment(){final UnivariateStatistic stat=getUnivariateStatistic();final double[]arrayZero=new double[5];System.arraycopy(testArray,0,arrayZero,0,5);Assert.assertEquals(stat.evaluate(arrayZero),stat.evaluate(testArray,0,5),0);final double[]arrayOne=new double[5];System.arraycopy(testArray,5,arrayOne,0,5);Assert.assertEquals(stat.evaluate(arrayOne),stat.evaluate(testArray,5,5),0);final double[]arrayEnd=new double[5];System.arraycopy(testArray,testArray.length - 5,arrayEnd,0,5);Assert.assertEquals(stat.evaluate(arrayEnd),stat.evaluate(testArray,testArray.length - 5,5),0);}
@Test public void testEvaluateArraySegmentWeighted(){UnivariateStatistic statistic=getUnivariateStatistic();if (!(statistic instanceof WeightedEvaluation)){return;}final WeightedEvaluation stat=(WeightedEvaluation)getUnivariateStatistic();final double[]arrayZero=new double[5];final double[]weightZero=new double[5];System.arraycopy(testArray,0,arrayZero,0,5);System.arraycopy(testWeightsArray,0,weightZero,0,5);Assert.assertEquals(stat.evaluate(arrayZero,weightZero),stat.evaluate(testArray,testWeightsArray,0,5),0);final double[]arrayOne=new double[5];final double[]weightOne=new double[5];System.arraycopy(testArray,5,arrayOne,0,5);System.arraycopy(testWeightsArray,5,weightOne,0,5);Assert.assertEquals(stat.evaluate(arrayOne,weightOne),stat.evaluate(testArray,testWeightsArray,5,5),0);final double[]arrayEnd=new double[5];final double[]weightEnd=new double[5];System.arraycopy(testArray,testArray.length - 5,arrayEnd,0,5);System.arraycopy(testWeightsArray,testArray.length - 5,weightEnd,0,5);Assert.assertEquals(stat.evaluate(arrayEnd,weightEnd),stat.evaluate(testArray,testWeightsArray,testArray.length - 5,5),0);}
@Test public void testCopy()throws Exception {UnivariateStatistic original=getUnivariateStatistic();UnivariateStatistic copy=original.copy();Assert.assertEquals(expectedValue(),copy.evaluate(testArray),getTolerance());}
/** * Tests consistency of weighted statistic computation. For statistics that support weighted evaluation,this test case compares the result of direct computation on an array with repeated values with a weighted computation on the corresponding (shorter)array with each value appearing only once but with a weight value equal to its multiplicity in the repeating array.*/@Test public void testWeightedConsistency()throws Exception {UnivariateStatistic statistic=getUnivariateStatistic();if (!(statistic instanceof WeightedEvaluation)){return;}final int len=10;final double mu=0;final double sigma=5;double[]values=new double[len];double[]weights=new double[len];RandomData randomData=new RandomDataImpl();int[]intWeights=new int[len];for (int i=0;i < len;i++){intWeights[i]=randomData.nextInt(1,5);weights[i]=intWeights[i];}List<Double> valuesList=new ArrayList<Double>();for (int i=0;i < len;i++){double value=randomData.nextGaussian(mu,sigma);values[i]=value;for (int j=0;j < intWeights[i];j++){valuesList.add(new Double(value));}}int sumWeights=valuesList.size();double[]repeatedValues=new double[sumWeights];for (int i=0;i < sumWeights;i++){repeatedValues[i]=valuesList.get(i);}WeightedEvaluation weightedStatistic=(WeightedEvaluation)statistic;TestUtils.assertRelativelyEquals(statistic.evaluate(repeatedValues),weightedStatistic.evaluate(values,weights,0,values.length),10E-14);Assert.assertEquals(weightedStatistic.evaluate(values,weights,0,values.length),weightedStatistic.evaluate(values,weights),Double.MIN_VALUE);}
@Test public void testFlatten(){final List<Object> orig=new ArrayList<Object>();final Object[]struct=new Object[]{new Object[]{new Object[]{create(orig),create(orig)},create(orig),new Object[]{create(orig)}},create(orig),new Object[]{create(orig),new Object[]{create(orig),create(orig)}},create(orig)};Object[]flat=ArgUtils.flatten(struct);Assert.assertEquals(flat.length,orig.size());for (int i=0,max=orig.size();i < max;i++){Assert.assertEquals(orig.get(i),flat[i]);}}
/** * Test of integrator for the sine function.*/@Test public void testSinFunction(){UnivariateFunction f=new SinFunction();UnivariateRealIntegrator integrator=new RombergIntegrator();double min,max,expected,result,tolerance;min=0;max=FastMath.PI;expected=2;tolerance=FastMath.abs(expected * integrator.getRelativeAccuracy());result=integrator.integrate(100,f,min,max);Assert.assertTrue(integrator.getEvaluations()< 50);Assert.assertTrue(integrator.getIterations()< 10);Assert.assertEquals(expected,result,tolerance);min=-FastMath.PI / 3;max=0;expected=-0.5;tolerance=FastMath.abs(expected * integrator.getRelativeAccuracy());result=integrator.integrate(100,f,min,max);Assert.assertTrue(integrator.getEvaluations()< 50);Assert.assertTrue(integrator.getIterations()< 10);Assert.assertEquals(expected,result,tolerance);}
/** * Test of integrator for the quintic function.*/@Test public void testQuinticFunction(){UnivariateFunction f=new QuinticFunction();UnivariateRealIntegrator integrator=new RombergIntegrator();double min,max,expected,result,tolerance;min=0;max=1;expected=-1.0 / 48;tolerance=FastMath.abs(expected * integrator.getRelativeAccuracy());result=integrator.integrate(100,f,min,max);Assert.assertTrue(integrator.getEvaluations()< 10);Assert.assertTrue(integrator.getIterations()< 5);Assert.assertEquals(expected,result,tolerance);min=0;max=0.5;expected=11.0 / 768;tolerance=FastMath.abs(expected * integrator.getRelativeAccuracy());result=integrator.integrate(100,f,min,max);Assert.assertTrue(integrator.getEvaluations()< 10);Assert.assertTrue(integrator.getIterations()< 5);Assert.assertEquals(expected,result,tolerance);min=-1;max=4;expected=2048 / 3.0 - 78 + 1.0 / 48;tolerance=FastMath.abs(expected * integrator.getRelativeAccuracy());result=integrator.integrate(100,f,min,max);Assert.assertTrue(integrator.getEvaluations()< 10);Assert.assertTrue(integrator.getIterations()< 5);Assert.assertEquals(expected,result,tolerance);}
/** * Test of parameters for the integrator.*/@Test public void testParameters()throws Exception {UnivariateFunction f=new SinFunction();try {new RombergIntegrator().integrate(1000,f,1,-1);Assert.fail("Expecting NumberIsTooLargeException - bad interval");}catch(NumberIsTooLargeException ex){}try {new RombergIntegrator(5,4);Assert.fail("Expecting NumberIsTooSmallException - bad iteration limits");}catch(NumberIsTooSmallException ex){}try {new RombergIntegrator(10,50);Assert.fail("Expecting NumberIsTooLargeException - bad iteration limits");}catch(NumberIsTooLargeException ex){}}
/** * test stats */@Test public void testStats(){List<Object> externalList=new ArrayList<Object>();DescriptiveStatistics u=new ListUnivariateImpl(externalList,transformers);Assert.assertEquals("total count",0,u.getN(),tolerance);u.addValue(one);u.addValue(two);u.addValue(two);u.addValue(three);Assert.assertEquals("N",n,u.getN(),tolerance);Assert.assertEquals("sum",sum,u.getSum(),tolerance);Assert.assertEquals("sumsq",sumSq,u.getSumsq(),tolerance);Assert.assertEquals("var",var,u.getVariance(),tolerance);Assert.assertEquals("std",std,u.getStandardDeviation(),tolerance);Assert.assertEquals("mean",mean,u.getMean(),tolerance);Assert.assertEquals("min",min,u.getMin(),tolerance);Assert.assertEquals("max",max,u.getMax(),tolerance);u.clear();Assert.assertEquals("total count",0,u.getN(),tolerance);}
@Test public void testN0andN1Conditions()throws Exception {DescriptiveStatistics u=new ListUnivariateImpl(new ArrayList<Object>(),transformers);Assert.assertTrue("Mean of n = 0 set should be NaN",Double.isNaN(u.getMean()));Assert.assertTrue("Standard Deviation of n = 0 set should be NaN",Double.isNaN(u.getStandardDeviation()));Assert.assertTrue("Variance of n = 0 set should be NaN",Double.isNaN(u.getVariance()));u.addValue(one);Assert.assertTrue("Mean of n = 1 set should be value of single item n1,instead it is " + u.getMean(),u.getMean()== one);Assert.assertTrue("StdDev of n = 1 set should be zero,instead it is: " + u.getStandardDeviation(),u.getStandardDeviation()== 0);Assert.assertTrue("Variance of n = 1 set should be zero",u.getVariance()== 0);}
@Test public void testSkewAndKurtosis(){ListUnivariateImpl u=new ListUnivariateImpl(new ArrayList<Object>(),transformers);u.addObject("12.5");u.addObject(Integer.valueOf(12));u.addObject("11.8");u.addObject("14.2");u.addObject(new Foo());u.addObject("14.5");u.addObject(Long.valueOf(21));u.addObject("8.2");u.addObject("10.3");u.addObject("11.3");u.addObject(Float.valueOf(14.1f));u.addObject("9.9");u.addObject("12.2");u.addObject(new Bar());u.addObject("12.1");u.addObject("11");u.addObject(Double.valueOf(19.8));u.addObject("11");u.addObject("10");u.addObject("8.8");u.addObject("9");u.addObject("12.3");Assert.assertEquals("mean",12.40455,u.getMean(),0.0001);Assert.assertEquals("variance",10.00236,u.getVariance(),0.0001);Assert.assertEquals("skewness",1.437424,u.getSkewness(),0.0001);Assert.assertEquals("kurtosis",2.37719,u.getKurtosis(),0.0001);}
@Test public void testProductAndGeometricMean()throws Exception {ListUnivariateImpl u=new ListUnivariateImpl(new ArrayList<Object>(),transformers);u.setWindowSize(10);u.addValue(1.0);u.addValue(2.0);u.addValue(3.0);u.addValue(4.0);Assert.assertEquals("Geometric mean not expected",2.213364,u.getGeometricMean(),0.00001);for (int i=0;i < 10;i++){u.addValue(i + 2);}Assert.assertEquals("Geometric mean not expected",5.755931,u.getGeometricMean(),0.00001);}
/** * test dimensions */@Test public void testDimensions(){OpenMapRealMatrix m=createSparseMatrix(testData);OpenMapRealMatrix m2=createSparseMatrix(testData2);Assert.assertEquals("testData row dimension",3,m.getRowDimension());Assert.assertEquals("testData column dimension",3,m.getColumnDimension());Assert.assertTrue("testData is square",m.isSquare());Assert.assertEquals("testData2 row dimension",m2.getRowDimension(),2);Assert.assertEquals("testData2 column dimension",m2.getColumnDimension(),3);Assert.assertTrue("testData2 is not square",!m2.isSquare());}
/** * test copy functions */@Test public void testCopyFunctions(){OpenMapRealMatrix m1=createSparseMatrix(testData);RealMatrix m2=m1.copy();Assert.assertEquals(m1.getClass(),m2.getClass());Assert.assertEquals((m2),m1);OpenMapRealMatrix m3=createSparseMatrix(testData);RealMatrix m4=m3.copy();Assert.assertEquals(m3.getClass(),m4.getClass());Assert.assertEquals((m4),m3);}
/** * test add */@Test public void testAdd(){OpenMapRealMatrix m=createSparseMatrix(testData);OpenMapRealMatrix mInv=createSparseMatrix(testDataInv);OpenMapRealMatrix mDataPlusInv=createSparseMatrix(testDataPlusInv);RealMatrix mPlusMInv=m.add(mInv);for (int row=0;row < m.getRowDimension();row++){for (int col=0;col < m.getColumnDimension();col++){Assert.assertEquals("sum entry entry",mDataPlusInv.getEntry(row,col),mPlusMInv.getEntry(row,col),entryTolerance);}}}
/** * test add failure */@Test public void testAddFail(){OpenMapRealMatrix m=createSparseMatrix(testData);OpenMapRealMatrix m2=createSparseMatrix(testData2);try {m.add(m2);Assert.fail("MathIllegalArgumentException expected");}catch(MathIllegalArgumentException ex){}}
/** * test norm */@Test public void testNorm(){OpenMapRealMatrix m=createSparseMatrix(testData);OpenMapRealMatrix m2=createSparseMatrix(testData2);Assert.assertEquals("testData norm",14d,m.getNorm(),entryTolerance);Assert.assertEquals("testData2 norm",7d,m2.getNorm(),entryTolerance);}
/** * test m-n = m + -n */@Test public void testPlusMinus(){OpenMapRealMatrix m=createSparseMatrix(testData);OpenMapRealMatrix n=createSparseMatrix(testDataInv);assertClose("m-n = m + -n",m.subtract(n),n.scalarMultiply(-1d).add(m),entryTolerance);try {m.subtract(createSparseMatrix(testData2));Assert.fail("Expecting illegalArgumentException");}catch(MathIllegalArgumentException ex){}}
/** * test multiply */@Test public void testMultiply(){OpenMapRealMatrix m=createSparseMatrix(testData);OpenMapRealMatrix mInv=createSparseMatrix(testDataInv);OpenMapRealMatrix identity=createSparseMatrix(id);OpenMapRealMatrix m2=createSparseMatrix(testData2);assertClose("inverse multiply",m.multiply(mInv),identity,entryTolerance);assertClose("inverse multiply",m.multiply(new BlockRealMatrix(testDataInv)),identity,entryTolerance);assertClose("inverse multiply",mInv.multiply(m),identity,entryTolerance);assertClose("identity multiply",m.multiply(identity),m,entryTolerance);assertClose("identity multiply",identity.multiply(mInv),mInv,entryTolerance);assertClose("identity multiply",m2.multiply(identity),m2,entryTolerance);try {m.multiply(createSparseMatrix(bigSingular));Assert.fail("Expecting illegalArgumentException");}catch(MathIllegalArgumentException ex){}}
@Test public void testMultiply2(){RealMatrix m3=createSparseMatrix(d3);RealMatrix m4=createSparseMatrix(d4);RealMatrix m5=createSparseMatrix(d5);assertClose("m3*m4=m5",m3.multiply(m4),m5,entryTolerance);}
/** * test trace */@Test public void testTrace(){RealMatrix m=createSparseMatrix(id);Assert.assertEquals("identity trace",3d,m.getTrace(),entryTolerance);m=createSparseMatrix(testData2);try {m.getTrace();Assert.fail("Expecting NonSquareMatrixException");}catch(NonSquareMatrixException ex){}}
/** * test sclarAdd */@Test public void testScalarAdd(){RealMatrix m=createSparseMatrix(testData);assertClose("scalar add",createSparseMatrix(testDataPlus2),m.scalarAdd(2d),entryTolerance);}
/** * test operate */@Test public void testOperate(){RealMatrix m=createSparseMatrix(id);assertClose("identity operate",testVector,m.operate(testVector),entryTolerance);assertClose("identity operate",testVector,m.operate(new ArrayRealVector(testVector)).toArray(),entryTolerance);m=createSparseMatrix(bigSingular);try {m.operate(testVector);Assert.fail("Expecting illegalArgumentException");}catch(MathIllegalArgumentException ex){}}
/** * test issue MATH-209 */@Test public void testMath209(){RealMatrix a=createSparseMatrix(new double[][]{{1,2},{3,4},{5,6}});double[]b=a.operate(new double[]{1,1});Assert.assertEquals(a.getRowDimension(),b.length);Assert.assertEquals(3.0,b[0],1.0e-12);Assert.assertEquals(7.0,b[1],1.0e-12);Assert.assertEquals(11.0,b[2],1.0e-12);}
/** * test transpose */@Test public void testTranspose(){RealMatrix m=createSparseMatrix(testData);RealMatrix mIT=new LUDecomposition(m).getSolver().getInverse().transpose();RealMatrix mTI=new LUDecomposition(m.transpose()).getSolver().getInverse();assertClose("inverse-transpose",mIT,mTI,normTolerance);m=createSparseMatrix(testData2);RealMatrix mt=createSparseMatrix(testData2T);assertClose("transpose",mt,m.transpose(),normTolerance);}
/** * test preMultiply by vector */@Test public void testPremultiplyVector(){RealMatrix m=createSparseMatrix(testData);assertClose("premultiply",m.preMultiply(testVector),preMultTest,normTolerance);assertClose("premultiply",m.preMultiply(new ArrayRealVector(testVector).toArray()),preMultTest,normTolerance);m=createSparseMatrix(bigSingular);try {m.preMultiply(testVector);Assert.fail("expecting MathIllegalArgumentException");}catch(MathIllegalArgumentException ex){}}
@Test public void testPremultiply(){RealMatrix m3=createSparseMatrix(d3);RealMatrix m4=createSparseMatrix(d4);RealMatrix m5=createSparseMatrix(d5);assertClose("m3*m4=m5",m4.preMultiply(m3),m5,entryTolerance);OpenMapRealMatrix m=createSparseMatrix(testData);OpenMapRealMatrix mInv=createSparseMatrix(testDataInv);OpenMapRealMatrix identity=createSparseMatrix(id);assertClose("inverse multiply",m.preMultiply(mInv),identity,entryTolerance);assertClose("inverse multiply",mInv.preMultiply(m),identity,entryTolerance);assertClose("identity multiply",m.preMultiply(identity),m,entryTolerance);assertClose("identity multiply",identity.preMultiply(mInv),mInv,entryTolerance);try {m.preMultiply(createSparseMatrix(bigSingular));Assert.fail("Expecting illegalArgumentException");}catch(MathIllegalArgumentException ex){}}
@Test public void testGetVectors(){RealMatrix m=createSparseMatrix(testData);assertClose("get row",m.getRow(0),testDataRow1,entryTolerance);assertClose("get col",m.getColumn(2),testDataCol3,entryTolerance);try {m.getRow(10);Assert.fail("expecting OutOfRangeException");}catch(OutOfRangeException ex){}try {m.getColumn(-1);Assert.fail("expecting OutOfRangeException");}catch(OutOfRangeException ex){}}
@Test public void testGetEntry(){RealMatrix m=createSparseMatrix(testData);Assert.assertEquals("get entry",m.getEntry(0,1),2d,entryTolerance);try {m.getEntry(10,4);Assert.fail("Expecting OutOfRangeException");}catch(OutOfRangeException ex){}}
/** * test examples in user guide */@Test public void testExamples(){double[][]matrixData={{1d,2d,3d},{2d,5d,3d}};RealMatrix m=createSparseMatrix(matrixData);double[][]matrixData2={{1d,2d},{2d,5d},{1d,7d}};RealMatrix n=createSparseMatrix(matrixData2);RealMatrix p=m.multiply(n);Assert.assertEquals(2,p.getRowDimension());Assert.assertEquals(2,p.getColumnDimension());RealMatrix pInverse=new LUDecomposition(p).getSolver().getInverse();Assert.assertEquals(2,pInverse.getRowDimension());Assert.assertEquals(2,pInverse.getColumnDimension());double[][]coefficientsData={{2,3,-2},{-1,7,6},{4,-3,-5}};RealMatrix coefficients=createSparseMatrix(coefficientsData);RealVector constants=new ArrayRealVector(new double[]{1,-2,1},false);RealVector solution=new LUDecomposition(coefficients).getSolver().solve(constants);final double cst0=constants.getEntry(0);final double cst1=constants.getEntry(1);final double cst2=constants.getEntry(2);final double sol0=solution.getEntry(0);final double sol1=solution.getEntry(1);final double sol2=solution.getEntry(2);Assert.assertEquals(2 * sol0 + 3 * sol1 - 2 * sol2,cst0,1E-12);Assert.assertEquals(-1 * sol0 + 7 * sol1 + 6 * sol2,cst1,1E-12);Assert.assertEquals(4 * sol0 - 3 * sol1 - 5 * sol2,cst2,1E-12);}
@Test public void testSubMatrix(){RealMatrix m=createSparseMatrix(subTestData);RealMatrix mRows23Cols00=createSparseMatrix(subRows23Cols00);RealMatrix mRows00Cols33=createSparseMatrix(subRows00Cols33);RealMatrix mRows01Cols23=createSparseMatrix(subRows01Cols23);RealMatrix mRows02Cols13=createSparseMatrix(subRows02Cols13);RealMatrix mRows03Cols12=createSparseMatrix(subRows03Cols12);RealMatrix mRows03Cols123=createSparseMatrix(subRows03Cols123);RealMatrix mRows20Cols123=createSparseMatrix(subRows20Cols123);RealMatrix mRows31Cols31=createSparseMatrix(subRows31Cols31);Assert.assertEquals("Rows23Cols00",mRows23Cols00,m.getSubMatrix(2,3,0,0));Assert.assertEquals("Rows00Cols33",mRows00Cols33,m.getSubMatrix(0,0,3,3));Assert.assertEquals("Rows01Cols23",mRows01Cols23,m.getSubMatrix(0,1,2,3));Assert.assertEquals("Rows02Cols13",mRows02Cols13,m.getSubMatrix(new int[]{0,2},new int[]{1,3}));Assert.assertEquals("Rows03Cols12",mRows03Cols12,m.getSubMatrix(new int[]{0,3},new int[]{1,2}));Assert.assertEquals("Rows03Cols123",mRows03Cols123,m.getSubMatrix(new int[]{0,3},new int[]{1,2,3}));Assert.assertEquals("Rows20Cols123",mRows20Cols123,m.getSubMatrix(new int[]{2,0},new int[]{1,2,3}));Assert.assertEquals("Rows31Cols31",mRows31Cols31,m.getSubMatrix(new int[]{3,1},new int[]{3,1}));Assert.assertEquals("Rows31Cols31",mRows31Cols31,m.getSubMatrix(new int[]{3,1},new int[]{3,1}));try {m.getSubMatrix(1,0,2,4);Assert.fail("Expecting NumberIsTooSmallException");}catch(NumberIsTooSmallException ex){}try {m.getSubMatrix(-1,1,2,2);Assert.fail("Expecting OutOfRangeException");}catch(OutOfRangeException ex){}try {m.getSubMatrix(1,0,2,2);Assert.fail("Expecting NumberIsTooSmallException");}catch(NumberIsTooSmallException ex){}try {m.getSubMatrix(1,0,2,4);Assert.fail("Expecting NumberIsTooSmallException");}catch(NumberIsTooSmallException ex){}try {m.getSubMatrix(new int[]{},new int[]{0});Assert.fail("Expecting NoDataException");}catch(NoDataException ex){}try {m.getSubMatrix(new int[]{0},new int[]{4});Assert.fail("Expecting OutOfRangeException");}catch(OutOfRangeException ex){}}
@Test public void testGetRowMatrix(){RealMatrix m=createSparseMatrix(subTestData);RealMatrix mRow0=createSparseMatrix(subRow0);RealMatrix mRow3=createSparseMatrix(subRow3);Assert.assertEquals("Row0",mRow0,m.getRowMatrix(0));Assert.assertEquals("Row3",mRow3,m.getRowMatrix(3));try {m.getRowMatrix(-1);Assert.fail("Expecting OutOfRangeException");}catch(OutOfRangeException ex){}try {m.getRowMatrix(4);Assert.fail("Expecting OutOfRangeException");}catch(OutOfRangeException ex){}}
@Test public void testGetColumnMatrix(){RealMatrix m=createSparseMatrix(subTestData);RealMatrix mColumn1=createSparseMatrix(subColumn1);RealMatrix mColumn3=createSparseMatrix(subColumn3);Assert.assertEquals("Column1",mColumn1,m.getColumnMatrix(1));Assert.assertEquals("Column3",mColumn3,m.getColumnMatrix(3));try {m.getColumnMatrix(-1);Assert.fail("Expecting OutOfRangeException");}catch(OutOfRangeException ex){}try {m.getColumnMatrix(4);Assert.fail("Expecting OutOfRangeException");}catch(OutOfRangeException ex){}}
@Test public void testGetRowVector(){RealMatrix m=createSparseMatrix(subTestData);RealVector mRow0=new ArrayRealVector(subRow0[0]);RealVector mRow3=new ArrayRealVector(subRow3[0]);Assert.assertEquals("Row0",mRow0,m.getRowVector(0));Assert.assertEquals("Row3",mRow3,m.getRowVector(3));try {m.getRowVector(-1);Assert.fail("Expecting OutOfRangeException");}catch(OutOfRangeException ex){}try {m.getRowVector(4);Assert.fail("Expecting OutOfRangeException");}catch(OutOfRangeException ex){}}
@Test public void testGetColumnVector(){RealMatrix m=createSparseMatrix(subTestData);RealVector mColumn1=columnToVector(subColumn1);RealVector mColumn3=columnToVector(subColumn3);Assert.assertEquals("Column1",mColumn1,m.getColumnVector(1));Assert.assertEquals("Column3",mColumn3,m.getColumnVector(3));try {m.getColumnVector(-1);Assert.fail("Expecting OutOfRangeException");}catch(OutOfRangeException ex){}try {m.getColumnVector(4);Assert.fail("Expecting OutOfRangeException");}catch(OutOfRangeException ex){}}
@Test public void testEqualsAndHashCode(){OpenMapRealMatrix m=createSparseMatrix(testData);OpenMapRealMatrix m1=m.copy();OpenMapRealMatrix mt=(OpenMapRealMatrix)m.transpose();Assert.assertTrue(m.hashCode()!= mt.hashCode());Assert.assertEquals(m.hashCode(),m1.hashCode());Assert.assertEquals(m,m);Assert.assertEquals(m,m1);Assert.assertFalse(m.equals(null));Assert.assertFalse(m.equals(mt));Assert.assertFalse(m.equals(createSparseMatrix(bigSingular)));}
@Test public void testToString(){OpenMapRealMatrix m=createSparseMatrix(testData);Assert.assertEquals("OpenMapRealMatrix{{1.0,2.0,3.0},{2.0,5.0,3.0},{1.0,0.0,8.0}}",m.toString());m=new OpenMapRealMatrix(1,1);Assert.assertEquals("OpenMapRealMatrix{{0.0}}",m.toString());}
@Test public void testSetSubMatrix(){OpenMapRealMatrix m=createSparseMatrix(testData);m.setSubMatrix(detData2,1,1);RealMatrix expected=createSparseMatrix(new double[][]{{1.0,2.0,3.0},{2.0,1.0,3.0},{1.0,2.0,4.0}});Assert.assertEquals(expected,m);m.setSubMatrix(detData2,0,0);expected=createSparseMatrix(new double[][]{{1.0,3.0,3.0},{2.0,4.0,3.0},{1.0,2.0,4.0}});Assert.assertEquals(expected,m);m.setSubMatrix(testDataPlus2,0,0);expected=createSparseMatrix(new double[][]{{3.0,4.0,5.0},{4.0,7.0,5.0},{3.0,2.0,10.0}});Assert.assertEquals(expected,m);OpenMapRealMatrix matrix=createSparseMatrix(new double[][]{{1,2,3,4},{5,6,7,8},{9,0,1,2}});matrix.setSubMatrix(new double[][]{{3,4},{5,6}},1,1);expected=createSparseMatrix(new double[][]{{1,2,3,4},{5,3,4,8},{9,5,6,2}});Assert.assertEquals(expected,matrix);try {m.setSubMatrix(testData,1,1);Assert.fail("expecting OutOfRangeException");}catch(OutOfRangeException e){}try {m.setSubMatrix(testData,-1,1);Assert.fail("expecting OutOfRangeException");}catch(OutOfRangeException e){}try {m.setSubMatrix(testData,1,-1);Assert.fail("expecting OutOfRangeException");}catch(OutOfRangeException e){}try {m.setSubMatrix(null,1,1);Assert.fail("expecting NullArgumentException");}catch(NullArgumentException e){}try {new OpenMapRealMatrix(0,0);Assert.fail("expecting MathIllegalArgumentException");}catch(MathIllegalArgumentException e){}try {m.setSubMatrix(new double[][]{{1},{2,3}},0,0);Assert.fail("expecting MathIllegalArgumentException");}catch(MathIllegalArgumentException e){}try {m.setSubMatrix(new double[][]{{}},0,0);Assert.fail("expecting MathIllegalArgumentException");}catch(MathIllegalArgumentException e){}}
@Test public void testSerial(){OpenMapRealMatrix m=createSparseMatrix(testData);Assert.assertEquals(m,TestUtils.serializeAndRecover(m));}
/** * test rank */@Test public void testRank()throws ConvergenceException {DecompositionSolver solver=new PivotingQRDecomposition(MatrixUtils.createRealMatrix(testData3x3NonSingular)).getSolver();Assert.assertTrue(solver.isNonSingular());solver=new PivotingQRDecomposition(MatrixUtils.createRealMatrix(testData3x3Singular)).getSolver();Assert.assertFalse(solver.isNonSingular());solver=new PivotingQRDecomposition(MatrixUtils.createRealMatrix(testData3x4)).getSolver();Assert.assertTrue(solver.isNonSingular());solver=new PivotingQRDecomposition(MatrixUtils.createRealMatrix(testData4x3)).getSolver();Assert.assertTrue(solver.isNonSingular());}
/** * test solve dimension errors */@Test public void testSolveDimensionErrors()throws ConvergenceException {DecompositionSolver solver=new PivotingQRDecomposition(MatrixUtils.createRealMatrix(testData3x3NonSingular)).getSolver();RealMatrix b=MatrixUtils.createRealMatrix(new double[2][2]);try {solver.solve(b);Assert.fail("an exception should have been thrown");}catch(MathIllegalArgumentException iae){}try {solver.solve(b.getColumnVector(0));Assert.fail("an exception should have been thrown");}catch(MathIllegalArgumentException iae){}}
/** * test solve rank errors */@Test public void testSolveRankErrors()throws ConvergenceException {DecompositionSolver solver=new PivotingQRDecomposition(MatrixUtils.createRealMatrix(testData3x3Singular)).getSolver();RealMatrix b=MatrixUtils.createRealMatrix(new double[3][2]);try {solver.solve(b);Assert.fail("an exception should have been thrown");}catch(SingularMatrixException iae){}try {solver.solve(b.getColumnVector(0));Assert.fail("an exception should have been thrown");}catch(SingularMatrixException iae){}}
/** * test solve */@Test public void testSolve()throws ConvergenceException {PivotingQRDecomposition decomposition=new PivotingQRDecomposition(MatrixUtils.createRealMatrix(testData3x3NonSingular));DecompositionSolver solver=decomposition.getSolver();RealMatrix b=MatrixUtils.createRealMatrix(new double[][]{{-102,12250},{544,24500},{167,-36750}});RealMatrix xRef=MatrixUtils.createRealMatrix(new double[][]{{1,2515},{2,422},{-3,898}});Assert.assertEquals(0,solver.solve(b).subtract(xRef).getNorm(),2.0e-14 * xRef.getNorm());for (int i=0;i < b.getColumnDimension();++i){final RealVector x=solver.solve(b.getColumnVector(i));final double error=x.subtract(xRef.getColumnVector(i)).getNorm();Assert.assertEquals(0,error,3.0e-14 * xRef.getColumnVector(i).getNorm());}for (int i=0;i < b.getColumnDimension();++i){ArrayRealVectorTest.RealVectorTestImpl v=new ArrayRealVectorTest.RealVectorTestImpl(b.getColumn(i));final RealVector x=solver.solve(v);final double error=x.subtract(xRef.getColumnVector(i)).getNorm();Assert.assertEquals(0,error,3.0e-14 * xRef.getColumnVector(i).getNorm());}}
@Test public void testOverdetermined()throws ConvergenceException {final Random r=new Random(5559252868205245l);int p=(7 * BlockRealMatrix.BLOCK_SIZE)/ 4;int q=(5 * BlockRealMatrix.BLOCK_SIZE)/ 4;RealMatrix a=createTestMatrix(r,p,q);RealMatrix xRef=createTestMatrix(r,q,BlockRealMatrix.BLOCK_SIZE + 3);RealMatrix b=a.multiply(xRef);final double noise=0.001;b.walkInOptimizedOrder(new DefaultRealMatrixChangingVisitor(){@Override public double visit(int row,int column,double value){return value * (1.0 + noise * (2 * r.nextDouble()- 1));}});RealMatrix x=new PivotingQRDecomposition(a).getSolver().solve(b);Assert.assertEquals(0,x.subtract(xRef).getNorm(),0.01 * noise * p* q);}
@Test public void testUnderdetermined()throws ConvergenceException {final Random r=new Random(42185006424567123l);int p=(5 * BlockRealMatrix.BLOCK_SIZE)/ 4;int q=(7 * BlockRealMatrix.BLOCK_SIZE)/ 4;RealMatrix a=createTestMatrix(r,p,q);RealMatrix xRef=createTestMatrix(r,q,BlockRealMatrix.BLOCK_SIZE + 3);RealMatrix b=a.multiply(xRef);PivotingQRDecomposition pqr=new PivotingQRDecomposition(a);RealMatrix x=pqr.getSolver().solve(b);Assert.assertTrue(x.subtract(xRef).getNorm()/ (p * q)> 0.01);int count=0;for (int i=0;i < q;i++){if (x.getRowVector(i).getNorm()== 0.0){++count;}}Assert.assertEquals("Zeroed rows",q - p,count);}
@Test public void testAccessor(){final Pair<Integer,Double> p=new Pair<Integer,Double>(new Integer(1),new Double(2));Assert.assertEquals(new Integer(1),p.getKey());Assert.assertEquals(new Double(2),p.getValue(),Math.ulp(1d));}
@Test public void testEquals(){Pair<Integer,Double> p1=new Pair<Integer,Double>(null,null);Assert.assertFalse(p1.equals(null));Pair<Integer,Double> p2=new Pair<Integer,Double>(null,null);Assert.assertTrue(p1.equals(p2));p1=new Pair<Integer,Double>(new Integer(1),new Double(2));Assert.assertFalse(p1.equals(p2));p2=new Pair<Integer,Double>(new Integer(1),new Double(2));Assert.assertTrue(p1.equals(p2));Pair<Integer,Float> p3=new Pair<Integer,Float>(new Integer(1),new Float(2));Assert.assertFalse(p1.equals(p3));}
@Test public void testCumulativeProbabilityExtremes()throws Exception {setCumulativeTestPoints(new double[]{-2,0});setCumulativeTestValues(new double[]{0,0});verifyCumulativeProbabilities();}
@Test public void testInverseCumulativeProbabilityExtremes()throws Exception {setInverseCumulativeTestPoints(new double[]{0,1});setInverseCumulativeTestValues(new double[]{0,Double.POSITIVE_INFINITY});verifyInverseCumulativeProbabilities();}
@Test public void testDfAccessors(){FDistribution dist=(FDistribution)getDistribution();Assert.assertEquals(5d,dist.getNumeratorDegreesOfFreedom(),Double.MIN_VALUE);Assert.assertEquals(6d,dist.getDenominatorDegreesOfFreedom(),Double.MIN_VALUE);}
@Test public void testPreconditions(){try {new FDistribution(0,1);Assert.fail("Expecting NotStrictlyPositiveException for df = 0");}catch(NotStrictlyPositiveException ex){}try {new FDistribution(1,0);Assert.fail("Expecting NotStrictlyPositiveException for df = 0");}catch(NotStrictlyPositiveException ex){}}
@Test public void testLargeDegreesOfFreedom()throws Exception {FDistribution fd=new FDistribution(100000,100000);double p=fd.cumulativeProbability(.999);double x=fd.inverseCumulativeProbability(p);Assert.assertEquals(.999,x,1.0e-5);}
@Test public void testSmallDegreesOfFreedom()throws Exception {FDistribution fd=new FDistribution(1,1);double p=fd.cumulativeProbability(0.975);double x=fd.inverseCumulativeProbability(p);Assert.assertEquals(0.975,x,1.0e-5);fd=new FDistribution(1,2);p=fd.cumulativeProbability(0.975);x=fd.inverseCumulativeProbability(p);Assert.assertEquals(0.975,x,1.0e-5);}
@Test public void testMoments(){final double tol=1e-9;FDistribution dist;dist=new FDistribution(1,2);Assert.assertTrue(Double.isNaN(dist.getNumericalMean()));Assert.assertTrue(Double.isNaN(dist.getNumericalVariance()));dist=new FDistribution(1,3);Assert.assertEquals(dist.getNumericalMean(),3d / (3d - 2d),tol);Assert.assertTrue(Double.isNaN(dist.getNumericalVariance()));dist=new FDistribution(1,5);Assert.assertEquals(dist.getNumericalMean(),5d / (5d - 2d),tol);Assert.assertEquals(dist.getNumericalVariance(),(2d * 5d * 5d* 4d)/ 9d,tol);}
/** * Verifies that cumulative probability density calculations match expected values using default test instance data*/@Test public void testCumulativeProbabilities()throws Exception {verifyCumulativeProbabilities();}
/** * Verifies that inverse cumulative probability density calculations match expected values using default test instance data*/@Test public void testInverseCumulativeProbabilities()throws Exception {verifyInverseCumulativeProbabilities();}
/** * Verifies that density calculations return expected values for default test instance data*/@Test public void testDensities()throws Exception {verifyDensities();}
/** * Verifies that probability computations are consistent*/@Test public void testConsistency()throws Exception {for (int i=1;i < cumulativeTestPoints.length;i++){TestUtils.assertEquals(0d,distribution.cumulativeProbability(cumulativeTestPoints[i],cumulativeTestPoints[i]),tolerance);double upper=FastMath.max(cumulativeTestPoints[i],cumulativeTestPoints[i - 1]);double lower=FastMath.min(cumulativeTestPoints[i],cumulativeTestPoints[i - 1]);double diff=distribution.cumulativeProbability(upper)- distribution.cumulativeProbability(lower);double direct=distribution.cumulativeProbability(lower,upper);TestUtils.assertEquals("Inconsistent cumulative probabilities for (" + lower + ","+ upper+ ")",diff,direct,tolerance);}}
/** * Verifies that illegal arguments are correctly handled*/@Test public void testIllegalArguments()throws Exception {try {distribution.cumulativeProbability(1,0);Assert.fail("Expecting MathIllegalArgumentException for bad cumulativeProbability interval");}catch(MathIllegalArgumentException ex){}try {distribution.inverseCumulativeProbability(-1);Assert.fail("Expecting MathIllegalArgumentException for p = -1");}catch(MathIllegalArgumentException ex){}try {distribution.inverseCumulativeProbability(2);Assert.fail("Expecting MathIllegalArgumentException for p = 2");}catch(MathIllegalArgumentException ex){}}
/** * Test sampling*/@Test public void testSampling()throws Exception {AbstractContinuousDistribution dist=(AbstractContinuousDistribution)makeDistribution();final int sampleSize=1000;dist.reseedRandomGenerator(1000);double[]sample=dist.sample(sampleSize);double[]quartiles=TestUtils.getDistributionQuartiles(dist);double[]expected={250,250,250,250};long[]counts=new long[4];for (int i=0;i < sampleSize;i++){TestUtils.updateCounts(sample[i],counts,quartiles);}TestUtils.assertChiSquareAccept(expected,counts,0.001);}
/** * test dimensions */@Test public void testDimensions(){BlockRealMatrix m=new BlockRealMatrix(testData);BlockRealMatrix m2=new BlockRealMatrix(testData2);Assert.assertEquals("testData row dimension",3,m.getRowDimension());Assert.assertEquals("testData column dimension",3,m.getColumnDimension());Assert.assertTrue("testData is square",m.isSquare());Assert.assertEquals("testData2 row dimension",m2.getRowDimension(),2);Assert.assertEquals("testData2 column dimension",m2.getColumnDimension(),3);Assert.assertTrue("testData2 is not square",!m2.isSquare());}
/** * test copy functions */@Test public void testCopyFunctions(){Random r=new Random(66636328996002l);BlockRealMatrix m1=createRandomMatrix(r,47,83);BlockRealMatrix m2=new BlockRealMatrix(m1.getData());Assert.assertEquals(m1,m2);BlockRealMatrix m3=new BlockRealMatrix(testData);BlockRealMatrix m4=new BlockRealMatrix(m3.getData());Assert.assertEquals(m3,m4);}
/** * test add */@Test public void testAdd(){BlockRealMatrix m=new BlockRealMatrix(testData);BlockRealMatrix mInv=new BlockRealMatrix(testDataInv);RealMatrix mPlusMInv=m.add(mInv);double[][]sumEntries=mPlusMInv.getData();for (int row=0;row < m.getRowDimension();row++){for (int col=0;col < m.getColumnDimension();col++){Assert.assertEquals("sum entry entry",testDataPlusInv[row][col],sumEntries[row][col],entryTolerance);}}}
/** * test add failure */@Test public void testAddFail(){BlockRealMatrix m=new BlockRealMatrix(testData);BlockRealMatrix m2=new BlockRealMatrix(testData2);try {m.add(m2);Assert.fail("MathIllegalArgumentException expected");}catch(MathIllegalArgumentException ex){}}
/** * test norm */@Test public void testNorm(){BlockRealMatrix m=new BlockRealMatrix(testData);BlockRealMatrix m2=new BlockRealMatrix(testData2);Assert.assertEquals("testData norm",14d,m.getNorm(),entryTolerance);Assert.assertEquals("testData2 norm",7d,m2.getNorm(),entryTolerance);}
/** * test Frobenius norm */@Test public void testFrobeniusNorm(){BlockRealMatrix m=new BlockRealMatrix(testData);BlockRealMatrix m2=new BlockRealMatrix(testData2);Assert.assertEquals("testData Frobenius norm",FastMath.sqrt(117.0),m.getFrobeniusNorm(),entryTolerance);Assert.assertEquals("testData2 Frobenius norm",FastMath.sqrt(52.0),m2.getFrobeniusNorm(),entryTolerance);}
/** * test m-n = m + -n */@Test public void testPlusMinus(){BlockRealMatrix m=new BlockRealMatrix(testData);BlockRealMatrix m2=new BlockRealMatrix(testDataInv);assertClose(m.subtract(m2),m2.scalarMultiply(-1d).add(m),entryTolerance);try {m.subtract(new BlockRealMatrix(testData2));Assert.fail("Expecting illegalArgumentException");}catch(MathIllegalArgumentException ex){}}
/** * test multiply */@Test public void testMultiply(){BlockRealMatrix m=new BlockRealMatrix(testData);BlockRealMatrix mInv=new BlockRealMatrix(testDataInv);BlockRealMatrix identity=new BlockRealMatrix(id);BlockRealMatrix m2=new BlockRealMatrix(testData2);assertClose(m.multiply(mInv),identity,entryTolerance);assertClose(mInv.multiply(m),identity,entryTolerance);assertClose(m.multiply(identity),m,entryTolerance);assertClose(identity.multiply(mInv),mInv,entryTolerance);assertClose(m2.multiply(identity),m2,entryTolerance);try {m.multiply(new BlockRealMatrix(bigSingular));Assert.fail("Expecting illegalArgumentException");}catch(MathIllegalArgumentException ex){}}
@Test public void testSeveralBlocks(){RealMatrix m=new BlockRealMatrix(35,71);for (int i=0;i < m.getRowDimension();++i){for (int j=0;j < m.getColumnDimension();++j){m.setEntry(i,j,i + j / 1024.0);}}RealMatrix mT=m.transpose();Assert.assertEquals(m.getRowDimension(),mT.getColumnDimension());Assert.assertEquals(m.getColumnDimension(),mT.getRowDimension());for (int i=0;i < mT.getRowDimension();++i){for (int j=0;j < mT.getColumnDimension();++j){Assert.assertEquals(m.getEntry(j,i),mT.getEntry(i,j),0);}}RealMatrix mPm=m.add(m);for (int i=0;i < mPm.getRowDimension();++i){for (int j=0;j < mPm.getColumnDimension();++j){Assert.assertEquals(2 * m.getEntry(i,j),mPm.getEntry(i,j),0);}}RealMatrix mPmMm=mPm.subtract(m);for (int i=0;i < mPmMm.getRowDimension();++i){for (int j=0;j < mPmMm.getColumnDimension();++j){Assert.assertEquals(m.getEntry(i,j),mPmMm.getEntry(i,j),0);}}RealMatrix mTm=mT.multiply(m);for (int i=0;i < mTm.getRowDimension();++i){for (int j=0;j < mTm.getColumnDimension();++j){double sum=0;for (int k=0;k < mT.getColumnDimension();++k){sum+=(k + i / 1024.0)* (k + j / 1024.0);}Assert.assertEquals(sum,mTm.getEntry(i,j),0);}}RealMatrix mmT=m.multiply(mT);for (int i=0;i < mmT.getRowDimension();++i){for (int j=0;j < mmT.getColumnDimension();++j){double sum=0;for (int k=0;k < m.getColumnDimension();++k){sum+=(i + k / 1024.0)* (j + k / 1024.0);}Assert.assertEquals(sum,mmT.getEntry(i,j),0);}}RealMatrix sub1=m.getSubMatrix(2,9,5,20);for (int i=0;i < sub1.getRowDimension();++i){for (int j=0;j < sub1.getColumnDimension();++j){Assert.assertEquals((i + 2)+ (j + 5)/ 1024.0,sub1.getEntry(i,j),0);}}RealMatrix sub2=m.getSubMatrix(10,12,3,70);for (int i=0;i < sub2.getRowDimension();++i){for (int j=0;j < sub2.getColumnDimension();++j){Assert.assertEquals((i + 10)+ (j + 3)/ 1024.0,sub2.getEntry(i,j),0);}}RealMatrix sub3=m.getSubMatrix(30,34,0,5);for (int i=0;i < sub3.getRowDimension();++i){for (int j=0;j < sub3.getColumnDimension();++j){Assert.assertEquals((i + 30)+ (j + 0)/ 1024.0,sub3.getEntry(i,j),0);}}RealMatrix sub4=m.getSubMatrix(30,32,62,65);for (int i=0;i < sub4.getRowDimension();++i){for (int j=0;j < sub4.getColumnDimension();++j){Assert.assertEquals((i + 30)+ (j + 62)/ 1024.0,sub4.getEntry(i,j),0);}}}
@Test public void testMultiply2(){RealMatrix m3=new BlockRealMatrix(d3);RealMatrix m4=new BlockRealMatrix(d4);RealMatrix m5=new BlockRealMatrix(d5);assertClose(m3.multiply(m4),m5,entryTolerance);}
/** * test trace */@Test public void testTrace(){RealMatrix m=new BlockRealMatrix(id);Assert.assertEquals("identity trace",3d,m.getTrace(),entryTolerance);m=new BlockRealMatrix(testData2);try {m.getTrace();Assert.fail("Expecting NonSquareMatrixException");}catch(NonSquareMatrixException ex){}}
/** * test scalarAdd */@Test public void testScalarAdd(){RealMatrix m=new BlockRealMatrix(testData);assertClose(new BlockRealMatrix(testDataPlus2),m.scalarAdd(2d),entryTolerance);}
/** * test operate */@Test public void testOperate(){RealMatrix m=new BlockRealMatrix(id);assertClose(testVector,m.operate(testVector),entryTolerance);assertClose(testVector,m.operate(new ArrayRealVector(testVector)).toArray(),entryTolerance);m=new BlockRealMatrix(bigSingular);try {m.operate(testVector);Assert.fail("Expecting illegalArgumentException");}catch(MathIllegalArgumentException ex){}}
@Test public void testOperateLarge(){int p=(7 * BlockRealMatrix.BLOCK_SIZE)/ 2;int q=(5 * BlockRealMatrix.BLOCK_SIZE)/ 2;int r=3 * BlockRealMatrix.BLOCK_SIZE;Random random=new Random(111007463902334l);RealMatrix m1=createRandomMatrix(random,p,q);RealMatrix m2=createRandomMatrix(random,q,r);RealMatrix m1m2=m1.multiply(m2);for (int i=0;i < r;++i){checkArrays(m1m2.getColumn(i),m1.operate(m2.getColumn(i)));}}
@Test public void testOperatePremultiplyLarge(){int p=(7 * BlockRealMatrix.BLOCK_SIZE)/ 2;int q=(5 * BlockRealMatrix.BLOCK_SIZE)/ 2;int r=3 * BlockRealMatrix.BLOCK_SIZE;Random random=new Random(111007463902334l);RealMatrix m1=createRandomMatrix(random,p,q);RealMatrix m2=createRandomMatrix(random,q,r);RealMatrix m1m2=m1.multiply(m2);for (int i=0;i < p;++i){checkArrays(m1m2.getRow(i),m2.preMultiply(m1.getRow(i)));}}
/** * test issue MATH-209 */@Test public void testMath209(){RealMatrix a=new BlockRealMatrix(new double[][]{{1,2},{3,4},{5,6}});double[]b=a.operate(new double[]{1,1});Assert.assertEquals(a.getRowDimension(),b.length);Assert.assertEquals(3.0,b[0],1.0e-12);Assert.assertEquals(7.0,b[1],1.0e-12);Assert.assertEquals(11.0,b[2],1.0e-12);}
/** * test transpose */@Test public void testTranspose(){RealMatrix m=new BlockRealMatrix(testData);RealMatrix mIT=new LUDecomposition(m).getSolver().getInverse().transpose();RealMatrix mTI=new LUDecomposition(m.transpose()).getSolver().getInverse();assertClose(mIT,mTI,normTolerance);m=new BlockRealMatrix(testData2);RealMatrix mt=new BlockRealMatrix(testData2T);assertClose(mt,m.transpose(),normTolerance);}
/** * test preMultiply by vector */@Test public void testPremultiplyVector(){RealMatrix m=new BlockRealMatrix(testData);assertClose(m.preMultiply(testVector),preMultTest,normTolerance);assertClose(m.preMultiply(new ArrayRealVector(testVector).toArray()),preMultTest,normTolerance);m=new BlockRealMatrix(bigSingular);try {m.preMultiply(testVector);Assert.fail("expecting MathIllegalArgumentException");}catch(MathIllegalArgumentException ex){}}
@Test public void testPremultiply(){RealMatrix m3=new BlockRealMatrix(d3);RealMatrix m4=new BlockRealMatrix(d4);RealMatrix m5=new BlockRealMatrix(d5);assertClose(m4.preMultiply(m3),m5,entryTolerance);BlockRealMatrix m=new BlockRealMatrix(testData);BlockRealMatrix mInv=new BlockRealMatrix(testDataInv);BlockRealMatrix identity=new BlockRealMatrix(id);assertClose(m.preMultiply(mInv),identity,entryTolerance);assertClose(mInv.preMultiply(m),identity,entryTolerance);assertClose(m.preMultiply(identity),m,entryTolerance);assertClose(identity.preMultiply(mInv),mInv,entryTolerance);try {m.preMultiply(new BlockRealMatrix(bigSingular));Assert.fail("Expecting illegalArgumentException");}catch(MathIllegalArgumentException ex){}}
@Test public void testGetVectors(){RealMatrix m=new BlockRealMatrix(testData);assertClose(m.getRow(0),testDataRow1,entryTolerance);assertClose(m.getColumn(2),testDataCol3,entryTolerance);try {m.getRow(10);Assert.fail("expecting OutOfRangeException");}catch(OutOfRangeException ex){}try {m.getColumn(-1);Assert.fail("expecting OutOfRangeException");}catch(OutOfRangeException ex){}}
@Test public void testGetEntry(){RealMatrix m=new BlockRealMatrix(testData);Assert.assertEquals("get entry",m.getEntry(0,1),2d,entryTolerance);try {m.getEntry(10,4);Assert.fail("Expecting OutOfRangeException");}catch(OutOfRangeException ex){}}
/** * test examples in user guide */@Test public void testExamples(){double[][]matrixData={{1d,2d,3d},{2d,5d,3d}};RealMatrix m=new BlockRealMatrix(matrixData);double[][]matrixData2={{1d,2d},{2d,5d},{1d,7d}};RealMatrix n=new BlockRealMatrix(matrixData2);RealMatrix p=m.multiply(n);Assert.assertEquals(2,p.getRowDimension());Assert.assertEquals(2,p.getColumnDimension());RealMatrix pInverse=new LUDecomposition(p).getSolver().getInverse();Assert.assertEquals(2,pInverse.getRowDimension());Assert.assertEquals(2,pInverse.getColumnDimension());double[][]coefficientsData={{2,3,-2},{-1,7,6},{4,-3,-5}};RealMatrix coefficients=new BlockRealMatrix(coefficientsData);RealVector constants=new ArrayRealVector(new double[]{1,-2,1},false);RealVector solution=new LUDecomposition(coefficients).getSolver().solve(constants);final double cst0=constants.getEntry(0);final double cst1=constants.getEntry(1);final double cst2=constants.getEntry(2);final double sol0=solution.getEntry(0);final double sol1=solution.getEntry(1);final double sol2=solution.getEntry(2);Assert.assertEquals(2 * sol0 + 3 * sol1 - 2 * sol2,cst0,1E-12);Assert.assertEquals(-1 * sol0 + 7 * sol1 + 6 * sol2,cst1,1E-12);Assert.assertEquals(4 * sol0 - 3 * sol1 - 5 * sol2,cst2,1E-12);}
@Test public void testGetSubMatrix(){RealMatrix m=new BlockRealMatrix(subTestData);checkGetSubMatrix(m,subRows23Cols00,2,3,0,0);checkGetSubMatrix(m,subRows00Cols33,0,0,3,3);checkGetSubMatrix(m,subRows01Cols23,0,1,2,3);checkGetSubMatrix(m,subRows02Cols13,new int[]{0,2},new int[]{1,3});checkGetSubMatrix(m,subRows03Cols12,new int[]{0,3},new int[]{1,2});checkGetSubMatrix(m,subRows03Cols123,new int[]{0,3},new int[]{1,2,3});checkGetSubMatrix(m,subRows20Cols123,new int[]{2,0},new int[]{1,2,3});checkGetSubMatrix(m,subRows31Cols31,new int[]{3,1},new int[]{3,1});checkGetSubMatrix(m,subRows31Cols31,new int[]{3,1},new int[]{3,1});checkGetSubMatrix(m,null,1,0,2,4);checkGetSubMatrix(m,null,-1,1,2,2);checkGetSubMatrix(m,null,1,0,2,2);checkGetSubMatrix(m,null,1,0,2,4);checkGetSubMatrix(m,null,new int[]{},new int[]{0});checkGetSubMatrix(m,null,new int[]{0},new int[]{4});}
@Test public void testGetSetMatrixLarge(){int n=3 * BlockRealMatrix.BLOCK_SIZE;RealMatrix m=new BlockRealMatrix(n,n);RealMatrix sub=new BlockRealMatrix(n - 4,n - 4).scalarAdd(1);m.setSubMatrix(sub.getData(),2,2);for (int i=0;i < n;++i){for (int j=0;j < n;++j){if ((i < 2)|| (i > n - 3)|| (j < 2)|| (j > n - 3)){Assert.assertEquals(0.0,m.getEntry(i,j),0.0);}else {Assert.assertEquals(1.0,m.getEntry(i,j),0.0);}}}Assert.assertEquals(sub,m.getSubMatrix(2,n - 3,2,n - 3));}
@Test public void testCopySubMatrix(){RealMatrix m=new BlockRealMatrix(subTestData);checkCopy(m,subRows23Cols00,2,3,0,0);checkCopy(m,subRows00Cols33,0,0,3,3);checkCopy(m,subRows01Cols23,0,1,2,3);checkCopy(m,subRows02Cols13,new int[]{0,2},new int[]{1,3});checkCopy(m,subRows03Cols12,new int[]{0,3},new int[]{1,2});checkCopy(m,subRows03Cols123,new int[]{0,3},new int[]{1,2,3});checkCopy(m,subRows20Cols123,new int[]{2,0},new int[]{1,2,3});checkCopy(m,subRows31Cols31,new int[]{3,1},new int[]{3,1});checkCopy(m,subRows31Cols31,new int[]{3,1},new int[]{3,1});checkCopy(m,null,1,0,2,4);checkCopy(m,null,-1,1,2,2);checkCopy(m,null,1,0,2,2);checkCopy(m,null,1,0,2,4);checkCopy(m,null,new int[]{},new int[]{0});checkCopy(m,null,new int[]{0},new int[]{4});}
@Test public void testGetRowMatrix(){RealMatrix m=new BlockRealMatrix(subTestData);RealMatrix mRow0=new BlockRealMatrix(subRow0);RealMatrix mRow3=new BlockRealMatrix(subRow3);Assert.assertEquals("Row0",mRow0,m.getRowMatrix(0));Assert.assertEquals("Row3",mRow3,m.getRowMatrix(3));try {m.getRowMatrix(-1);Assert.fail("Expecting OutOfRangeException");}catch(OutOfRangeException ex){}try {m.getRowMatrix(4);Assert.fail("Expecting OutOfRangeException");}catch(OutOfRangeException ex){}}
@Test public void testSetRowMatrix(){RealMatrix m=new BlockRealMatrix(subTestData);RealMatrix mRow3=new BlockRealMatrix(subRow3);Assert.assertNotSame(mRow3,m.getRowMatrix(0));m.setRowMatrix(0,mRow3);Assert.assertEquals(mRow3,m.getRowMatrix(0));try {m.setRowMatrix(-1,mRow3);Assert.fail("Expecting OutOfRangeException");}catch(OutOfRangeException ex){}try {m.setRowMatrix(0,m);Assert.fail("Expecting MatrixDimensionMismatchException");}catch(MatrixDimensionMismatchException ex){}}
@Test public void testGetSetRowMatrixLarge(){int n=3 * BlockRealMatrix.BLOCK_SIZE;RealMatrix m=new BlockRealMatrix(n,n);RealMatrix sub=new BlockRealMatrix(1,n).scalarAdd(1);m.setRowMatrix(2,sub);for (int i=0;i < n;++i){for (int j=0;j < n;++j){if (i != 2){Assert.assertEquals(0.0,m.getEntry(i,j),0.0);}else {Assert.assertEquals(1.0,m.getEntry(i,j),0.0);}}}Assert.assertEquals(sub,m.getRowMatrix(2));}
@Test public void testGetColumnMatrix(){RealMatrix m=new BlockRealMatrix(subTestData);RealMatrix mColumn1=new BlockRealMatrix(subColumn1);RealMatrix mColumn3=new BlockRealMatrix(subColumn3);Assert.assertEquals(mColumn1,m.getColumnMatrix(1));Assert.assertEquals(mColumn3,m.getColumnMatrix(3));try {m.getColumnMatrix(-1);Assert.fail("Expecting OutOfRangeException");}catch(OutOfRangeException ex){}try {m.getColumnMatrix(4);Assert.fail("Expecting OutOfRangeException");}catch(OutOfRangeException ex){}}
@Test public void testSetColumnMatrix(){RealMatrix m=new BlockRealMatrix(subTestData);RealMatrix mColumn3=new BlockRealMatrix(subColumn3);Assert.assertNotSame(mColumn3,m.getColumnMatrix(1));m.setColumnMatrix(1,mColumn3);Assert.assertEquals(mColumn3,m.getColumnMatrix(1));try {m.setColumnMatrix(-1,mColumn3);Assert.fail("Expecting OutOfRangeException");}catch(OutOfRangeException ex){}try {m.setColumnMatrix(0,m);Assert.fail("Expecting MatrixDimensionMismatchException");}catch(MatrixDimensionMismatchException ex){}}
@Test public void testGetSetColumnMatrixLarge(){int n=3 * BlockRealMatrix.BLOCK_SIZE;RealMatrix m=new BlockRealMatrix(n,n);RealMatrix sub=new BlockRealMatrix(n,1).scalarAdd(1);m.setColumnMatrix(2,sub);for (int i=0;i < n;++i){for (int j=0;j < n;++j){if (j != 2){Assert.assertEquals(0.0,m.getEntry(i,j),0.0);}else {Assert.assertEquals(1.0,m.getEntry(i,j),0.0);}}}Assert.assertEquals(sub,m.getColumnMatrix(2));}
@Test public void testGetRowVector(){RealMatrix m=new BlockRealMatrix(subTestData);RealVector mRow0=new ArrayRealVector(subRow0[0]);RealVector mRow3=new ArrayRealVector(subRow3[0]);Assert.assertEquals(mRow0,m.getRowVector(0));Assert.assertEquals(mRow3,m.getRowVector(3));try {m.getRowVector(-1);Assert.fail("Expecting OutOfRangeException");}catch(OutOfRangeException ex){}try {m.getRowVector(4);Assert.fail("Expecting OutOfRangeException");}catch(OutOfRangeException ex){}}
@Test public void testSetRowVector(){RealMatrix m=new BlockRealMatrix(subTestData);RealVector mRow3=new ArrayRealVector(subRow3[0]);Assert.assertNotSame(mRow3,m.getRowMatrix(0));m.setRowVector(0,mRow3);Assert.assertEquals(mRow3,m.getRowVector(0));try {m.setRowVector(-1,mRow3);Assert.fail("Expecting OutOfRangeException");}catch(OutOfRangeException ex){}try {m.setRowVector(0,new ArrayRealVector(5));Assert.fail("Expecting MatrixDimensionMismatchException");}catch(MatrixDimensionMismatchException ex){}}
@Test public void testGetSetRowVectorLarge(){int n=3 * BlockRealMatrix.BLOCK_SIZE;RealMatrix m=new BlockRealMatrix(n,n);RealVector sub=new ArrayRealVector(n,1.0);m.setRowVector(2,sub);for (int i=0;i < n;++i){for (int j=0;j < n;++j){if (i != 2){Assert.assertEquals(0.0,m.getEntry(i,j),0.0);}else {Assert.assertEquals(1.0,m.getEntry(i,j),0.0);}}}Assert.assertEquals(sub,m.getRowVector(2));}
@Test public void testGetColumnVector(){RealMatrix m=new BlockRealMatrix(subTestData);RealVector mColumn1=columnToVector(subColumn1);RealVector mColumn3=columnToVector(subColumn3);Assert.assertEquals(mColumn1,m.getColumnVector(1));Assert.assertEquals(mColumn3,m.getColumnVector(3));try {m.getColumnVector(-1);Assert.fail("Expecting OutOfRangeException");}catch(OutOfRangeException ex){}try {m.getColumnVector(4);Assert.fail("Expecting OutOfRangeException");}catch(OutOfRangeException ex){}}
@Test public void testSetColumnVector(){RealMatrix m=new BlockRealMatrix(subTestData);RealVector mColumn3=columnToVector(subColumn3);Assert.assertNotSame(mColumn3,m.getColumnVector(1));m.setColumnVector(1,mColumn3);Assert.assertEquals(mColumn3,m.getColumnVector(1));try {m.setColumnVector(-1,mColumn3);Assert.fail("Expecting OutOfRangeException");}catch(OutOfRangeException ex){}try {m.setColumnVector(0,new ArrayRealVector(5));Assert.fail("Expecting MatrixDimensionMismatchException");}catch(MatrixDimensionMismatchException ex){}}
@Test public void testGetSetColumnVectorLarge(){int n=3 * BlockRealMatrix.BLOCK_SIZE;RealMatrix m=new BlockRealMatrix(n,n);RealVector sub=new ArrayRealVector(n,1.0);m.setColumnVector(2,sub);for (int i=0;i < n;++i){for (int j=0;j < n;++j){if (j != 2){Assert.assertEquals(0.0,m.getEntry(i,j),0.0);}else {Assert.assertEquals(1.0,m.getEntry(i,j),0.0);}}}Assert.assertEquals(sub,m.getColumnVector(2));}
@Test public void testGetRow(){RealMatrix m=new BlockRealMatrix(subTestData);checkArrays(subRow0[0],m.getRow(0));checkArrays(subRow3[0],m.getRow(3));try {m.getRow(-1);Assert.fail("Expecting OutOfRangeException");}catch(OutOfRangeException ex){}try {m.getRow(4);Assert.fail("Expecting OutOfRangeException");}catch(OutOfRangeException ex){}}
@Test public void testSetRow(){RealMatrix m=new BlockRealMatrix(subTestData);Assert.assertTrue(subRow3[0][0]!= m.getRow(0)[0]);m.setRow(0,subRow3[0]);checkArrays(subRow3[0],m.getRow(0));try {m.setRow(-1,subRow3[0]);Assert.fail("Expecting OutOfRangeException");}catch(OutOfRangeException ex){}try {m.setRow(0,new double[5]);Assert.fail("Expecting MatrixDimensionMismatchException");}catch(MatrixDimensionMismatchException ex){}}
@Test public void testGetSetRowLarge(){int n=3 * BlockRealMatrix.BLOCK_SIZE;RealMatrix m=new BlockRealMatrix(n,n);double[]sub=new double[n];Arrays.fill(sub,1.0);m.setRow(2,sub);for (int i=0;i < n;++i){for (int j=0;j < n;++j){if (i != 2){Assert.assertEquals(0.0,m.getEntry(i,j),0.0);}else {Assert.assertEquals(1.0,m.getEntry(i,j),0.0);}}}checkArrays(sub,m.getRow(2));}
@Test public void testGetColumn(){RealMatrix m=new BlockRealMatrix(subTestData);double[]mColumn1=columnToArray(subColumn1);double[]mColumn3=columnToArray(subColumn3);checkArrays(mColumn1,m.getColumn(1));checkArrays(mColumn3,m.getColumn(3));try {m.getColumn(-1);Assert.fail("Expecting OutOfRangeException");}catch(OutOfRangeException ex){}try {m.getColumn(4);Assert.fail("Expecting OutOfRangeException");}catch(OutOfRangeException ex){}}
@Test public void testSetColumn(){RealMatrix m=new BlockRealMatrix(subTestData);double[]mColumn3=columnToArray(subColumn3);Assert.assertTrue(mColumn3[0]!= m.getColumn(1)[0]);m.setColumn(1,mColumn3);checkArrays(mColumn3,m.getColumn(1));try {m.setColumn(-1,mColumn3);Assert.fail("Expecting OutOfRangeException");}catch(OutOfRangeException ex){}try {m.setColumn(0,new double[5]);Assert.fail("Expecting MatrixDimensionMismatchException");}catch(MatrixDimensionMismatchException ex){}}
@Test public void testGetSetColumnLarge(){int n=3 * BlockRealMatrix.BLOCK_SIZE;RealMatrix m=new BlockRealMatrix(n,n);double[]sub=new double[n];Arrays.fill(sub,1.0);m.setColumn(2,sub);for (int i=0;i < n;++i){for (int j=0;j < n;++j){if (j != 2){Assert.assertEquals(0.0,m.getEntry(i,j),0.0);}else {Assert.assertEquals(1.0,m.getEntry(i,j),0.0);}}}checkArrays(sub,m.getColumn(2));}
@Test public void testEqualsAndHashCode(){BlockRealMatrix m=new BlockRealMatrix(testData);BlockRealMatrix m1=m.copy();BlockRealMatrix mt=m.transpose();Assert.assertTrue(m.hashCode()!= mt.hashCode());Assert.assertEquals(m.hashCode(),m1.hashCode());Assert.assertEquals(m,m);Assert.assertEquals(m,m1);Assert.assertFalse(m.equals(null));Assert.assertFalse(m.equals(mt));Assert.assertFalse(m.equals(new BlockRealMatrix(bigSingular)));}
@Test public void testToString(){BlockRealMatrix m=new BlockRealMatrix(testData);Assert.assertEquals("BlockRealMatrix{{1.0,2.0,3.0},{2.0,5.0,3.0},{1.0,0.0,8.0}}",m.toString());}
@Test public void testSetSubMatrix()throws Exception {BlockRealMatrix m=new BlockRealMatrix(testData);m.setSubMatrix(detData2,1,1);RealMatrix expected=new BlockRealMatrix(new double[][]{{1.0,2.0,3.0},{2.0,1.0,3.0},{1.0,2.0,4.0}});Assert.assertEquals(expected,m);m.setSubMatrix(detData2,0,0);expected=new BlockRealMatrix(new double[][]{{1.0,3.0,3.0},{2.0,4.0,3.0},{1.0,2.0,4.0}});Assert.assertEquals(expected,m);m.setSubMatrix(testDataPlus2,0,0);expected=new BlockRealMatrix(new double[][]{{3.0,4.0,5.0},{4.0,7.0,5.0},{3.0,2.0,10.0}});Assert.assertEquals(expected,m);BlockRealMatrix matrix=new BlockRealMatrix(new double[][]{{1,2,3,4},{5,6,7,8},{9,0,1,2}});matrix.setSubMatrix(new double[][]{{3,4},{5,6}},1,1);expected=new BlockRealMatrix(new double[][]{{1,2,3,4},{5,3,4,8},{9,5,6,2}});Assert.assertEquals(expected,matrix);try {m.setSubMatrix(testData,1,1);Assert.fail("expecting OutOfRangeException");}catch(OutOfRangeException e){}try {m.setSubMatrix(testData,-1,1);Assert.fail("expecting OutOfRangeException");}catch(OutOfRangeException e){}try {m.setSubMatrix(testData,1,-1);Assert.fail("expecting OutOfRangeException");}catch(OutOfRangeException e){}try {m.setSubMatrix(null,1,1);Assert.fail("expecting NullArgumentException");}catch(NullArgumentException e){}try {m.setSubMatrix(new double[][]{{1},{2,3}},0,0);Assert.fail("expecting MathIllegalArgumentException");}catch(MathIllegalArgumentException e){}try {m.setSubMatrix(new double[][]{{}},0,0);Assert.fail("expecting MathIllegalArgumentException");}catch(MathIllegalArgumentException e){}}
@Test public void testWalk(){int rows=150;int columns=75;RealMatrix m=new BlockRealMatrix(rows,columns);m.walkInRowOrder(new SetVisitor());GetVisitor getVisitor=new GetVisitor();m.walkInOptimizedOrder(getVisitor);Assert.assertEquals(rows * columns,getVisitor.getCount());m=new BlockRealMatrix(rows,columns);m.walkInRowOrder(new SetVisitor(),1,rows - 2,1,columns - 2);getVisitor=new GetVisitor();m.walkInOptimizedOrder(getVisitor,1,rows - 2,1,columns - 2);Assert.assertEquals((rows - 2)* (columns - 2),getVisitor.getCount());for (int i=0;i < rows;++i){Assert.assertEquals(0.0,m.getEntry(i,0),0);Assert.assertEquals(0.0,m.getEntry(i,columns - 1),0);}for (int j=0;j < columns;++j){Assert.assertEquals(0.0,m.getEntry(0,j),0);Assert.assertEquals(0.0,m.getEntry(rows - 1,j),0);}m=new BlockRealMatrix(rows,columns);m.walkInColumnOrder(new SetVisitor());getVisitor=new GetVisitor();m.walkInOptimizedOrder(getVisitor);Assert.assertEquals(rows * columns,getVisitor.getCount());m=new BlockRealMatrix(rows,columns);m.walkInColumnOrder(new SetVisitor(),1,rows - 2,1,columns - 2);getVisitor=new GetVisitor();m.walkInOptimizedOrder(getVisitor,1,rows - 2,1,columns - 2);Assert.assertEquals((rows - 2)* (columns - 2),getVisitor.getCount());for (int i=0;i < rows;++i){Assert.assertEquals(0.0,m.getEntry(i,0),0);Assert.assertEquals(0.0,m.getEntry(i,columns - 1),0);}for (int j=0;j < columns;++j){Assert.assertEquals(0.0,m.getEntry(0,j),0);Assert.assertEquals(0.0,m.getEntry(rows - 1,j),0);}m=new BlockRealMatrix(rows,columns);m.walkInOptimizedOrder(new SetVisitor());getVisitor=new GetVisitor();m.walkInRowOrder(getVisitor);Assert.assertEquals(rows * columns,getVisitor.getCount());m=new BlockRealMatrix(rows,columns);m.walkInOptimizedOrder(new SetVisitor(),1,rows - 2,1,columns - 2);getVisitor=new GetVisitor();m.walkInRowOrder(getVisitor,1,rows - 2,1,columns - 2);Assert.assertEquals((rows - 2)* (columns - 2),getVisitor.getCount());for (int i=0;i < rows;++i){Assert.assertEquals(0.0,m.getEntry(i,0),0);Assert.assertEquals(0.0,m.getEntry(i,columns - 1),0);}for (int j=0;j < columns;++j){Assert.assertEquals(0.0,m.getEntry(0,j),0);Assert.assertEquals(0.0,m.getEntry(rows - 1,j),0);}m=new BlockRealMatrix(rows,columns);m.walkInOptimizedOrder(new SetVisitor());getVisitor=new GetVisitor();m.walkInColumnOrder(getVisitor);Assert.assertEquals(rows * columns,getVisitor.getCount());m=new BlockRealMatrix(rows,columns);m.walkInOptimizedOrder(new SetVisitor(),1,rows - 2,1,columns - 2);getVisitor=new GetVisitor();m.walkInColumnOrder(getVisitor,1,rows - 2,1,columns - 2);Assert.assertEquals((rows - 2)* (columns - 2),getVisitor.getCount());for (int i=0;i < rows;++i){Assert.assertEquals(0.0,m.getEntry(i,0),0);Assert.assertEquals(0.0,m.getEntry(i,columns - 1),0);}for (int j=0;j < columns;++j){Assert.assertEquals(0.0,m.getEntry(0,j),0);Assert.assertEquals(0.0,m.getEntry(rows - 1,j),0);}}
@Test public void testSerial(){BlockRealMatrix m=new BlockRealMatrix(testData);Assert.assertEquals(m,TestUtils.serializeAndRecover(m));}
@Test public void testConstructors(){double r=FastMath.sqrt(2)/ 2;checkVector(new Vector3D(2,new Vector3D(FastMath.PI / 3,-FastMath.PI / 4)),r,r * FastMath.sqrt(3),-2 * r);checkVector(new Vector3D(2,Vector3D.PLUS_I,-3,Vector3D.MINUS_K),2,0,3);checkVector(new Vector3D(2,Vector3D.PLUS_I,5,Vector3D.PLUS_J,-3,Vector3D.MINUS_K),2,5,3);checkVector(new Vector3D(2,Vector3D.PLUS_I,5,Vector3D.PLUS_J,5,Vector3D.MINUS_J,-3,Vector3D.MINUS_K),2,0,3);checkVector(new Vector3D(new double[]{2,5,-3}),2,5,-3);}
@Test(expected=DimensionMismatchException.class)public void testWrongDimension(){new Vector3D(new double[]{2,5});}
@Test public void testCoordinates(){Vector3D v=new Vector3D(1,2,3);Assert.assertTrue(FastMath.abs(v.getX()- 1)< 1.0e-12);Assert.assertTrue(FastMath.abs(v.getY()- 2)< 1.0e-12);Assert.assertTrue(FastMath.abs(v.getZ()- 3)< 1.0e-12);double[]coordinates=v.toArray();Assert.assertTrue(FastMath.abs(coordinates[0]- 1)< 1.0e-12);Assert.assertTrue(FastMath.abs(coordinates[1]- 2)< 1.0e-12);Assert.assertTrue(FastMath.abs(coordinates[2]- 3)< 1.0e-12);}
@Test public void testNorm1(){Assert.assertEquals(0.0,Vector3D.ZERO.getNorm1(),0);Assert.assertEquals(6.0,new Vector3D(1,-2,3).getNorm1(),0);}
@Test public void testNorm(){Assert.assertEquals(0.0,Vector3D.ZERO.getNorm(),0);Assert.assertEquals(FastMath.sqrt(14),new Vector3D(1,2,3).getNorm(),1.0e-12);}
@Test public void testNormInf(){Assert.assertEquals(0.0,Vector3D.ZERO.getNormInf(),0);Assert.assertEquals(3.0,new Vector3D(1,-2,3).getNormInf(),0);}
@Test public void testDistance1(){Vector3D v1=new Vector3D(1,-2,3);Vector3D v2=new Vector3D(-4,2,0);Assert.assertEquals(0.0,Vector3D.distance1(Vector3D.MINUS_I,Vector3D.MINUS_I),0);Assert.assertEquals(12.0,Vector3D.distance1(v1,v2),1.0e-12);Assert.assertEquals(v1.subtract(v2).getNorm1(),Vector3D.distance1(v1,v2),1.0e-12);}
@Test public void testDistance(){Vector3D v1=new Vector3D(1,-2,3);Vector3D v2=new Vector3D(-4,2,0);Assert.assertEquals(0.0,Vector3D.distance(Vector3D.MINUS_I,Vector3D.MINUS_I),0);Assert.assertEquals(FastMath.sqrt(50),Vector3D.distance(v1,v2),1.0e-12);Assert.assertEquals(v1.subtract(v2).getNorm(),Vector3D.distance(v1,v2),1.0e-12);}
@Test public void testDistanceSq(){Vector3D v1=new Vector3D(1,-2,3);Vector3D v2=new Vector3D(-4,2,0);Assert.assertEquals(0.0,Vector3D.distanceSq(Vector3D.MINUS_I,Vector3D.MINUS_I),0);Assert.assertEquals(50.0,Vector3D.distanceSq(v1,v2),1.0e-12);Assert.assertEquals(Vector3D.distance(v1,v2)* Vector3D.distance(v1,v2),Vector3D.distanceSq(v1,v2),1.0e-12);}
@Test public void testDistanceInf(){Vector3D v1=new Vector3D(1,-2,3);Vector3D v2=new Vector3D(-4,2,0);Assert.assertEquals(0.0,Vector3D.distanceInf(Vector3D.MINUS_I,Vector3D.MINUS_I),0);Assert.assertEquals(5.0,Vector3D.distanceInf(v1,v2),1.0e-12);Assert.assertEquals(v1.subtract(v2).getNormInf(),Vector3D.distanceInf(v1,v2),1.0e-12);}
@Test public void testSubtract(){Vector3D v1=new Vector3D(1,2,3);Vector3D v2=new Vector3D(-3,-2,-1);v1=v1.subtract(v2);checkVector(v1,4,4,4);checkVector(v2.subtract(v1),-7,-6,-5);checkVector(v2.subtract(3,v1),-15,-14,-13);}
@Test public void testAdd(){Vector3D v1=new Vector3D(1,2,3);Vector3D v2=new Vector3D(-3,-2,-1);v1=v1.add(v2);checkVector(v1,-2,0,2);checkVector(v2.add(v1),-5,-2,1);checkVector(v2.add(3,v1),-9,-2,5);}
@Test public void testScalarProduct(){Vector3D v=new Vector3D(1,2,3);v=v.scalarMultiply(3);checkVector(v,3,6,9);checkVector(v.scalarMultiply(0.5),1.5,3,4.5);}
@Test public void testVectorialProducts(){Vector3D v1=new Vector3D(2,1,-4);Vector3D v2=new Vector3D(3,1,-1);Assert.assertTrue(FastMath.abs(Vector3D.dotProduct(v1,v2)- 11)< 1.0e-12);Vector3D v3=Vector3D.crossProduct(v1,v2);checkVector(v3,3,-10,-1);Assert.assertTrue(FastMath.abs(Vector3D.dotProduct(v1,v3))< 1.0e-12);Assert.assertTrue(FastMath.abs(Vector3D.dotProduct(v2,v3))< 1.0e-12);}
@Test public void testCrossProductCancellation(){Vector3D v1=new Vector3D(9070467121.0,4535233560.0,1);Vector3D v2=new Vector3D(9070467123.0,4535233561.0,1);checkVector(Vector3D.crossProduct(v1,v2),-1,2,1);double scale=FastMath.scalb(1.0,100);Vector3D big1=new Vector3D(scale,v1);Vector3D small2=new Vector3D(1 / scale,v2);checkVector(Vector3D.crossProduct(big1,small2),-1,2,1);}
@Test public void testAngular(){Assert.assertEquals(0,Vector3D.PLUS_I.getAlpha(),1.0e-10);Assert.assertEquals(0,Vector3D.PLUS_I.getDelta(),1.0e-10);Assert.assertEquals(FastMath.PI / 2,Vector3D.PLUS_J.getAlpha(),1.0e-10);Assert.assertEquals(0,Vector3D.PLUS_J.getDelta(),1.0e-10);Assert.assertEquals(0,Vector3D.PLUS_K.getAlpha(),1.0e-10);Assert.assertEquals(FastMath.PI / 2,Vector3D.PLUS_K.getDelta(),1.0e-10);Vector3D u=new Vector3D(-1,1,-1);Assert.assertEquals(3 * FastMath.PI / 4,u.getAlpha(),1.0e-10);Assert.assertEquals(-1.0 / FastMath.sqrt(3),FastMath.sin(u.getDelta()),1.0e-10);}
@Test public void testAngularSeparation(){Vector3D v1=new Vector3D(2,-1,4);Vector3D k=v1.normalize();Vector3D i=k.orthogonal();Vector3D v2=k.scalarMultiply(FastMath.cos(1.2)).add(i.scalarMultiply(FastMath.sin(1.2)));Assert.assertTrue(FastMath.abs(Vector3D.angle(v1,v2)- 1.2)< 1.0e-12);}
@Test public void testNormalize(){Assert.assertEquals(1.0,new Vector3D(5,-4,2).normalize().getNorm(),1.0e-12);try {Vector3D.ZERO.normalize();Assert.fail("an exception should have been thrown");}catch(MathArithmeticException ae){}}
@Test public void testOrthogonal(){Vector3D v1=new Vector3D(0.1,2.5,1.3);Assert.assertEquals(0.0,Vector3D.dotProduct(v1,v1.orthogonal()),1.0e-12);Vector3D v2=new Vector3D(2.3,-0.003,7.6);Assert.assertEquals(0.0,Vector3D.dotProduct(v2,v2.orthogonal()),1.0e-12);Vector3D v3=new Vector3D(-1.7,1.4,0.2);Assert.assertEquals(0.0,Vector3D.dotProduct(v3,v3.orthogonal()),1.0e-12);try {new Vector3D(0,0,0).orthogonal();Assert.fail("an exception should have been thrown");}catch(MathArithmeticException ae){}}
@Test public void testAngle(){Assert.assertEquals(0.22572612855273393616,Vector3D.angle(new Vector3D(1,2,3),new Vector3D(4,5,6)),1.0e-12);Assert.assertEquals(7.98595620686106654517199e-8,Vector3D.angle(new Vector3D(1,2,3),new Vector3D(2,4,6.000001)),1.0e-12);Assert.assertEquals(3.14159257373023116985197793156,Vector3D.angle(new Vector3D(1,2,3),new Vector3D(-2,-4,-6.000001)),1.0e-12);try {Vector3D.angle(Vector3D.ZERO,Vector3D.PLUS_I);Assert.fail("an exception should have been thrown");}catch(MathArithmeticException ae){}}
@Test public void testAccurateDotProduct(){Vector3D u1=new Vector3D(-1321008684645961.0 / 268435456.0,-5774608829631843.0 / 268435456.0,-7645843051051357.0 / 8589934592.0);Vector3D u2=new Vector3D(-5712344449280879.0 / 2097152.0,-4550117129121957.0 / 2097152.0,8846951984510141.0 / 131072.0);double sNaive=u1.getX()* u2.getX()+ u1.getY()* u2.getY()+ u1.getZ()* u2.getZ();double sAccurate=u1.dotProduct(u2);Assert.assertEquals(0.0,sNaive,1.0e-30);Assert.assertEquals(-2088690039198397.0 / 1125899906842624.0,sAccurate,1.0e-16);}
@Test public void testDotProduct(){Well1024a random=new Well1024a(553267312521321234l);for (int i=0;i < 10000;++i){double ux=10000 * random.nextDouble();double uy=10000 * random.nextDouble();double uz=10000 * random.nextDouble();double vx=10000 * random.nextDouble();double vy=10000 * random.nextDouble();double vz=10000 * random.nextDouble();double sNaive=ux * vx + uy * vy + uz * vz;double sAccurate=new Vector3D(ux,uy,uz).dotProduct(new Vector3D(vx,vy,vz));Assert.assertEquals(sNaive,sAccurate,2.5e-16 * sAccurate);}}
@Test public void testAccurateCrossProduct(){final Vector3D u1=new Vector3D(-1321008684645961.0 / 268435456.0,-5774608829631843.0 / 268435456.0,-7645843051051357.0 / 8589934592.0);final Vector3D u2=new Vector3D(1796571811118507.0 / 2147483648.0,7853468008299307.0 / 2147483648.0,2599586637357461.0 / 17179869184.0);final Vector3D u3=new Vector3D(12753243807587107.0 / 18446744073709551616.0,-2313766922703915.0 / 18446744073709551616.0,-227970081415313.0 / 288230376151711744.0);Vector3D cNaive=new Vector3D(u1.getY()* u2.getZ()- u1.getZ()* u2.getY(),u1.getZ()* u2.getX()- u1.getX()* u2.getZ(),u1.getX()* u2.getY()- u1.getY()* u2.getX());Vector3D cAccurate=u1.crossProduct(u2);Assert.assertTrue(u3.distance(cNaive)> 2.9 * u3.getNorm());Assert.assertEquals(0.0,u3.distance(cAccurate),1.0e-30 * cAccurate.getNorm());}
@Test public void testCrossProduct(){Well1024a random=new Well1024a(885362227452043214l);for (int i=0;i < 10000;++i){double ux=10000 * random.nextDouble();double uy=10000 * random.nextDouble();double uz=10000 * random.nextDouble();double vx=10000 * random.nextDouble();double vy=10000 * random.nextDouble();double vz=10000 * random.nextDouble();Vector3D cNaive=new Vector3D(uy * vz - uz * vy,uz * vx - ux * vz,ux * vy - uy * vx);Vector3D cAccurate=new Vector3D(ux,uy,uz).crossProduct(new Vector3D(vx,vy,vz));Assert.assertEquals(0.0,cAccurate.distance(cNaive),6.0e-15 * cAccurate.getNorm());}}
@Test public void testInverseCumulativeProbabilityExtremes()throws Exception {setInverseCumulativeTestPoints(new double[]{0.0,1.0});setInverseCumulativeTestValues(new double[]{0.0,Double.POSITIVE_INFINITY});verifyInverseCumulativeProbabilities();}
@Test public void testAlpha(){WeibullDistribution dist=new WeibullDistribution(1,2);Assert.assertEquals(1,dist.getShape(),0);try {dist=new WeibullDistribution(0,2);Assert.fail("NotStrictlyPositiveException expected");}catch(NotStrictlyPositiveException e){}}
@Test public void testBeta(){WeibullDistribution dist=new WeibullDistribution(1,2);Assert.assertEquals(2,dist.getScale(),0);try {dist=new WeibullDistribution(1,0);Assert.fail("NotStrictlyPositiveException expected");}catch(NotStrictlyPositiveException e){}}
@Test public void testMoments(){final double tol=1e-9;WeibullDistribution dist;dist=new WeibullDistribution(2.5,3.5);Assert.assertEquals(dist.getNumericalMean(),3.5 * FastMath.exp(Gamma.logGamma(1 + (1 / 2.5))),tol);Assert.assertEquals(dist.getNumericalVariance(),(3.5 * 3.5)* FastMath.exp(Gamma.logGamma(1 + (2 / 2.5)))- (dist.getNumericalMean()* dist.getNumericalMean()),tol);dist=new WeibullDistribution(10.4,2.222);Assert.assertEquals(dist.getNumericalMean(),2.222 * FastMath.exp(Gamma.logGamma(1 + (1 / 10.4))),tol);Assert.assertEquals(dist.getNumericalVariance(),(2.222 * 2.222)* FastMath.exp(Gamma.logGamma(1 + (2 / 10.4)))- (dist.getNumericalMean()* dist.getNumericalMean()),tol);}
@Test public void testSampling(){}
/** * Verifies that cumulative probability density calculations match expected values using default test instance data*/@Test public void testCumulativeProbabilities()throws Exception {verifyCumulativeProbabilities();}
/** * Verifies that inverse cumulative probability density calculations match expected values using default test instance data*/@Test public void testInverseCumulativeProbabilities()throws Exception {verifyInverseCumulativeProbabilities();}
/** * Verifies that density calculations return expected values for default test instance data*/@Test public void testDensities()throws Exception {verifyDensities();}
/** * Verifies that probability computations are consistent*/@Test public void testConsistency()throws Exception {for (int i=1;i < cumulativeTestPoints.length;i++){TestUtils.assertEquals(0d,distribution.cumulativeProbability(cumulativeTestPoints[i],cumulativeTestPoints[i]),tolerance);double upper=FastMath.max(cumulativeTestPoints[i],cumulativeTestPoints[i - 1]);double lower=FastMath.min(cumulativeTestPoints[i],cumulativeTestPoints[i - 1]);double diff=distribution.cumulativeProbability(upper)- distribution.cumulativeProbability(lower);double direct=distribution.cumulativeProbability(lower,upper);TestUtils.assertEquals("Inconsistent cumulative probabilities for (" + lower + ","+ upper+ ")",diff,direct,tolerance);}}
/** * Verifies that illegal arguments are correctly handled*/@Test public void testIllegalArguments()throws Exception {try {distribution.cumulativeProbability(1,0);Assert.fail("Expecting MathIllegalArgumentException for bad cumulativeProbability interval");}catch(MathIllegalArgumentException ex){}try {distribution.inverseCumulativeProbability(-1);Assert.fail("Expecting MathIllegalArgumentException for p = -1");}catch(MathIllegalArgumentException ex){}try {distribution.inverseCumulativeProbability(2);Assert.fail("Expecting MathIllegalArgumentException for p = 2");}catch(MathIllegalArgumentException ex){}}
/** * Test of integrator for the sine function.*/@Test public void testSinFunction(){UnivariateFunction f=new SinFunction();UnivariateRealIntegrator integrator=new TrapezoidIntegrator();double min,max,expected,result,tolerance;min=0;max=FastMath.PI;expected=2;tolerance=FastMath.abs(expected * integrator.getRelativeAccuracy());result=integrator.integrate(10000,f,min,max);Assert.assertTrue(integrator.getEvaluations()< 2500);Assert.assertTrue(integrator.getIterations()< 15);Assert.assertEquals(expected,result,tolerance);min=-FastMath.PI / 3;max=0;expected=-0.5;tolerance=FastMath.abs(expected * integrator.getRelativeAccuracy());result=integrator.integrate(10000,f,min,max);Assert.assertTrue(integrator.getEvaluations()< 2500);Assert.assertTrue(integrator.getIterations()< 15);Assert.assertEquals(expected,result,tolerance);}
/** * Test of integrator for the quintic function.*/@Test public void testQuinticFunction(){UnivariateFunction f=new QuinticFunction();UnivariateRealIntegrator integrator=new TrapezoidIntegrator();double min,max,expected,result,tolerance;min=0;max=1;expected=-1.0 / 48;tolerance=FastMath.abs(expected * integrator.getRelativeAccuracy());result=integrator.integrate(10000,f,min,max);Assert.assertTrue(integrator.getEvaluations()< 5000);Assert.assertTrue(integrator.getIterations()< 15);Assert.assertEquals(expected,result,tolerance);min=0;max=0.5;expected=11.0 / 768;tolerance=FastMath.abs(expected * integrator.getRelativeAccuracy());result=integrator.integrate(10000,f,min,max);Assert.assertTrue(integrator.getEvaluations()< 2500);Assert.assertTrue(integrator.getIterations()< 15);Assert.assertEquals(expected,result,tolerance);min=-1;max=4;expected=2048 / 3.0 - 78 + 1.0 / 48;tolerance=FastMath.abs(expected * integrator.getRelativeAccuracy());result=integrator.integrate(10000,f,min,max);Assert.assertTrue(integrator.getEvaluations()< 5000);Assert.assertTrue(integrator.getIterations()< 15);Assert.assertEquals(expected,result,tolerance);}
/** * Test of parameters for the integrator.*/@Test public void testParameters()throws Exception {UnivariateFunction f=new SinFunction();try {new TrapezoidIntegrator().integrate(1000,f,1,-1);Assert.fail("Expecting NumberIsTooLargeException - bad interval");}catch(NumberIsTooLargeException ex){}try {new TrapezoidIntegrator(5,4);Assert.fail("Expecting NumberIsTooSmallException - bad iteration limits");}catch(NumberIsTooSmallException ex){}try {new TrapezoidIntegrator(10,99);Assert.fail("Expecting NumberIsTooLargeException - bad iteration limits");}catch(NumberIsTooLargeException ex){}}
@Test public void testTrivial(){LinearProblem problem=new LinearProblem(new double[][]{{2}},new double[]{3});DifferentiableMultivariateVectorialOptimizer underlyingOptimizer=new GaussNewtonOptimizer(true,new SimpleVectorialValueChecker(1.0e-6,1.0e-6));JDKRandomGenerator g=new JDKRandomGenerator();g.setSeed(16069223052l);RandomVectorGenerator generator=new UncorrelatedRandomVectorGenerator(1,new GaussianRandomGenerator(g));MultiStartDifferentiableMultivariateVectorialOptimizer optimizer=new MultiStartDifferentiableMultivariateVectorialOptimizer(underlyingOptimizer,10,generator);try {optimizer.getOptima();Assert.fail("an exception should have been thrown");}catch(MathIllegalStateException ise){}VectorialPointValuePair optimum=optimizer.optimize(100,problem,problem.target,new double[]{1},new double[]{0});Assert.assertEquals(1.5,optimum.getPoint()[0],1.0e-10);Assert.assertEquals(3.0,optimum.getValue()[0],1.0e-10);VectorialPointValuePair[]optima=optimizer.getOptima();Assert.assertEquals(10,optima.length);for (int i=0;i < optima.length;++i){Assert.assertEquals(1.5,optima[i].getPoint()[0],1.0e-10);Assert.assertEquals(3.0,optima[i].getValue()[0],1.0e-10);}Assert.assertTrue(optimizer.getEvaluations()> 20);Assert.assertTrue(optimizer.getEvaluations()< 50);Assert.assertEquals(100,optimizer.getMaxEvaluations());}
@Test(expected=TestException.class)public void testNoOptimum(){DifferentiableMultivariateVectorialOptimizer underlyingOptimizer=new GaussNewtonOptimizer(true,new SimpleVectorialValueChecker(1.0e-6,1.0e-6));JDKRandomGenerator g=new JDKRandomGenerator();g.setSeed(12373523445l);RandomVectorGenerator generator=new UncorrelatedRandomVectorGenerator(1,new GaussianRandomGenerator(g));MultiStartDifferentiableMultivariateVectorialOptimizer optimizer=new MultiStartDifferentiableMultivariateVectorialOptimizer(underlyingOptimizer,10,generator);optimizer.optimize(100,new DifferentiableMultivariateVectorFunction(){public MultivariateMatrixFunction jacobian(){return null;}public double[]value(double[]point){throw new TestException();}},new double[]{2},new double[]{1},new double[]{0});}
@Test public void testInsert(){int[]array={16,13,15,14,2,0,12,9,8,5,11,18,19,17,4,7,1,3,6,10};AVLTree<Integer> tree=buildTree(array);Assert.assertEquals(array.length,tree.size());for (int i=0;i < array.length;++i){Assert.assertEquals(array[i],value(tree.getNotSmaller(new Integer(array[i]))));}checkOrder(tree);}
@Test public void testDelete1(){int[][][]arrays={{{16,13,15,14,2,0,12,9,8,5,11,18,19,17,4,7,1,3,6,10},{11,10,9,12,16,15,13,18,5,0,3,2,14,6,19,17,8,4,7,1}},{{16,13,15,14,2,0,12,9,8,5,11,18,19,17,4,7,1,3,6,10},{0,17,14,15,16,18,6}},{{6,2,7,8,1,4,3,5},{8}},{{6,2,7,8,1,4,5},{8}},{{3,7,2,1,5,8,4},{1}},{{3,7,2,1,5,8,6},{1}}};for (int i=0;i < arrays.length;++i){AVLTree<Integer> tree=buildTree(arrays[i][0]);Assert.assertTrue(!tree.delete(new Integer(-2000)));for (int j=0;j < arrays[i][1].length;++j){Assert.assertTrue(tree.delete(tree.getNotSmaller(new Integer(arrays[i][1][j])).getElement()));Assert.assertEquals(arrays[i][0].length - j - 1,tree.size());}}}
@Test public void testNavigation(){int[]array={1,2,3,4,5,6,7,8,9,10};AVLTree<Integer> tree=buildTree(array);AVLTree<Integer>.Node node=tree.getSmallest();Assert.assertEquals(array[0],value(node));for (int i=0;i < array.length;++i){Assert.assertEquals(array[i],value(node));node=node.getNext();}Assert.assertNull(node);node=tree.getLargest();Assert.assertEquals(array[array.length - 1],value(node));for (int i=array.length - 1;i >= 0;--i){Assert.assertEquals(array[i],value(node));node=node.getPrevious();}Assert.assertNull(node);checkOrder(tree);}
@Test public void testSearch(){int[]array={2,4,6,8,10,12,14};AVLTree<Integer> tree=buildTree(array);Assert.assertNull(tree.getNotLarger(new Integer(array[0]- 1)));Assert.assertNull(tree.getNotSmaller(new Integer(array[array.length - 1]+ 1)));for (int i=0;i < array.length;++i){Assert.assertEquals(array[i],value(tree.getNotSmaller(new Integer(array[i]- 1))));Assert.assertEquals(array[i],value(tree.getNotLarger(new Integer(array[i]+ 1))));}checkOrder(tree);}
@Test public void testRepetition(){int[]array={1,1,3,3,4,5,6,7,7,7,7,7};AVLTree<Integer> tree=buildTree(array);Assert.assertEquals(array.length,tree.size());AVLTree<Integer>.Node node=tree.getNotSmaller(new Integer(3));Assert.assertEquals(3,value(node));Assert.assertEquals(1,value(node.getPrevious()));Assert.assertEquals(3,value(node.getNext()));Assert.assertEquals(4,value(node.getNext().getNext()));node=tree.getNotLarger(new Integer(2));Assert.assertEquals(1,value(node));Assert.assertEquals(1,value(node.getPrevious()));Assert.assertEquals(3,value(node.getNext()));Assert.assertNull(node.getPrevious().getPrevious());AVLTree<Integer>.Node otherNode=tree.getNotSmaller(new Integer(1));Assert.assertTrue(node != otherNode);Assert.assertEquals(1,value(otherNode));Assert.assertNull(otherNode.getPrevious());node=tree.getNotLarger(new Integer(10));Assert.assertEquals(7,value(node));Assert.assertNull(node.getNext());node=node.getPrevious();Assert.assertEquals(7,value(node));node=node.getPrevious();Assert.assertEquals(7,value(node));node=node.getPrevious();Assert.assertEquals(7,value(node));node=node.getPrevious();Assert.assertEquals(7,value(node));node=node.getPrevious();Assert.assertEquals(6,value(node));checkOrder(tree);}
/** * Test of polynomial for the linear function.*/@Test public void testLinearFunction(){PolynomialFunctionNewtonForm p;double coefficients[],z,expected,result,tolerance=1E-12;double a[]={2.0,1.5};double c[]={4.0};p=new PolynomialFunctionNewtonForm(a,c);z=2.0;expected=-1.0;result=p.value(z);Assert.assertEquals(expected,result,tolerance);z=4.5;expected=2.75;result=p.value(z);Assert.assertEquals(expected,result,tolerance);z=6.0;expected=5.0;result=p.value(z);Assert.assertEquals(expected,result,tolerance);Assert.assertEquals(1,p.degree());coefficients=p.getCoefficients();Assert.assertEquals(2,coefficients.length);Assert.assertEquals(-4.0,coefficients[0],tolerance);Assert.assertEquals(1.5,coefficients[1],tolerance);}
/** * Test of polynomial for the quadratic function.*/@Test public void testQuadraticFunction(){PolynomialFunctionNewtonForm p;double coefficients[],z,expected,result,tolerance=1E-12;double a[]={4.0,3.0,2.0};double c[]={1.0,-2.0};p=new PolynomialFunctionNewtonForm(a,c);z=1.0;expected=4.0;result=p.value(z);Assert.assertEquals(expected,result,tolerance);z=2.5;expected=22.0;result=p.value(z);Assert.assertEquals(expected,result,tolerance);z=-2.0;expected=-5.0;result=p.value(z);Assert.assertEquals(expected,result,tolerance);Assert.assertEquals(2,p.degree());coefficients=p.getCoefficients();Assert.assertEquals(3,coefficients.length);Assert.assertEquals(-3.0,coefficients[0],tolerance);Assert.assertEquals(5.0,coefficients[1],tolerance);Assert.assertEquals(2.0,coefficients[2],tolerance);}
/** * Test of polynomial for the quintic function.*/@Test public void testQuinticFunction(){PolynomialFunctionNewtonForm p;double coefficients[],z,expected,result,tolerance=1E-12;double a[]={0.0,6.0,-6.0,-6.0,1.0,1.0};double c[]={0.0,0.0,1.0,-1.0,2.0};p=new PolynomialFunctionNewtonForm(a,c);z=0.0;expected=0.0;result=p.value(z);Assert.assertEquals(expected,result,tolerance);z=-2.0;expected=0.0;result=p.value(z);Assert.assertEquals(expected,result,tolerance);z=4.0;expected=360.0;result=p.value(z);Assert.assertEquals(expected,result,tolerance);Assert.assertEquals(5,p.degree());coefficients=p.getCoefficients();Assert.assertEquals(6,coefficients.length);Assert.assertEquals(0.0,coefficients[0],tolerance);Assert.assertEquals(6.0,coefficients[1],tolerance);Assert.assertEquals(1.0,coefficients[2],tolerance);Assert.assertEquals(-7.0,coefficients[3],tolerance);Assert.assertEquals(-1.0,coefficients[4],tolerance);Assert.assertEquals(1.0,coefficients[5],tolerance);}
/** * Test of parameters for the polynomial.*/@Test public void testParameters()throws Exception {try {double a[]={1.0};double c[]={2.0};new PolynomialFunctionNewtonForm(a,c);Assert.fail("Expecting MathIllegalArgumentException - bad input array length");}catch(MathIllegalArgumentException ex){}try {double a[]={1.0,2.0,3.0,4.0};double c[]={4.0,3.0,2.0,1.0};new PolynomialFunctionNewtonForm(a,c);Assert.fail("Expecting MathIllegalArgumentException - mismatch input arrays");}catch(MathIllegalArgumentException ex){}}
@Test public void testMapFunctions()throws FractionConversionException {SparseFieldVector<Fraction> v1=new SparseFieldVector<Fraction>(field,vec1);FieldVector<Fraction> v_mapAdd=v1.mapAdd(new Fraction(2));Fraction[]result_mapAdd={new Fraction(3),new Fraction(4),new Fraction(5)};Assert.assertArrayEquals("compare vectors",result_mapAdd,v_mapAdd.getData());FieldVector<Fraction> v_mapAddToSelf=v1.copy();v_mapAddToSelf.mapAddToSelf(new Fraction(2));Fraction[]result_mapAddToSelf={new Fraction(3),new Fraction(4),new Fraction(5)};Assert.assertArrayEquals("compare vectors",result_mapAddToSelf,v_mapAddToSelf.getData());FieldVector<Fraction> v_mapSubtract=v1.mapSubtract(new Fraction(2));Fraction[]result_mapSubtract={new Fraction(-1),new Fraction(0),new Fraction(1)};Assert.assertArrayEquals("compare vectors",result_mapSubtract,v_mapSubtract.getData());FieldVector<Fraction> v_mapSubtractToSelf=v1.copy();v_mapSubtractToSelf.mapSubtractToSelf(new Fraction(2));Fraction[]result_mapSubtractToSelf={new Fraction(-1),new Fraction(0),new Fraction(1)};Assert.assertArrayEquals("compare vectors",result_mapSubtractToSelf,v_mapSubtractToSelf.getData());FieldVector<Fraction> v_mapMultiply=v1.mapMultiply(new Fraction(2));Fraction[]result_mapMultiply={new Fraction(2),new Fraction(4),new Fraction(6)};Assert.assertArrayEquals("compare vectors",result_mapMultiply,v_mapMultiply.getData());FieldVector<Fraction> v_mapMultiplyToSelf=v1.copy();v_mapMultiplyToSelf.mapMultiplyToSelf(new Fraction(2));Fraction[]result_mapMultiplyToSelf={new Fraction(2),new Fraction(4),new Fraction(6)};Assert.assertArrayEquals("compare vectors",result_mapMultiplyToSelf,v_mapMultiplyToSelf.getData());FieldVector<Fraction> v_mapDivide=v1.mapDivide(new Fraction(2));Fraction[]result_mapDivide={new Fraction(.5d),new Fraction(1),new Fraction(1.5d)};Assert.assertArrayEquals("compare vectors",result_mapDivide,v_mapDivide.getData());FieldVector<Fraction> v_mapDivideToSelf=v1.copy();v_mapDivideToSelf.mapDivideToSelf(new Fraction(2));Fraction[]result_mapDivideToSelf={new Fraction(.5d),new Fraction(1),new Fraction(1.5d)};Assert.assertArrayEquals("compare vectors",result_mapDivideToSelf,v_mapDivideToSelf.getData());FieldVector<Fraction> v_mapInv=v1.mapInv();Fraction[]result_mapInv={new Fraction(1),new Fraction(0.5d),new Fraction(3.333333333333333e-01d)};Assert.assertArrayEquals("compare vectors",result_mapInv,v_mapInv.getData());FieldVector<Fraction> v_mapInvToSelf=v1.copy();v_mapInvToSelf.mapInvToSelf();Fraction[]result_mapInvToSelf={new Fraction(1),new Fraction(0.5d),new Fraction(3.333333333333333e-01d)};Assert.assertArrayEquals("compare vectors",result_mapInvToSelf,v_mapInvToSelf.getData());}
@Test public void testBasicFunctions()throws FractionConversionException {SparseFieldVector<Fraction> v1=new SparseFieldVector<Fraction>(field,vec1);SparseFieldVector<Fraction> v2=new SparseFieldVector<Fraction>(field,vec2);FieldVector<Fraction> v2_t=new ArrayFieldVectorTest.FieldVectorTestImpl<Fraction>(vec2);FieldVector<Fraction> v_add=v1.add(v2);Fraction[]result_add={new Fraction(5),new Fraction(7),new Fraction(9)};Assert.assertArrayEquals("compare vect",v_add.getData(),result_add);FieldVector<Fraction> vt2=new ArrayFieldVectorTest.FieldVectorTestImpl<Fraction>(vec2);FieldVector<Fraction> v_add_i=v1.add(vt2);Fraction[]result_add_i={new Fraction(5),new Fraction(7),new Fraction(9)};Assert.assertArrayEquals("compare vect",v_add_i.getData(),result_add_i);SparseFieldVector<Fraction> v_subtract=v1.subtract(v2);Fraction[]result_subtract={new Fraction(-3),new Fraction(-3),new Fraction(-3)};assertClose("compare vect",v_subtract.getData(),result_subtract,normTolerance);FieldVector<Fraction> v_subtract_i=v1.subtract(vt2);Fraction[]result_subtract_i={new Fraction(-3),new Fraction(-3),new Fraction(-3)};assertClose("compare vect",v_subtract_i.getData(),result_subtract_i,normTolerance);FieldVector<Fraction> v_ebeMultiply=v1.ebeMultiply(v2);Fraction[]result_ebeMultiply={new Fraction(4),new Fraction(10),new Fraction(18)};assertClose("compare vect",v_ebeMultiply.getData(),result_ebeMultiply,normTolerance);FieldVector<Fraction> v_ebeMultiply_2=v1.ebeMultiply(v2_t);Fraction[]result_ebeMultiply_2={new Fraction(4),new Fraction(10),new Fraction(18)};assertClose("compare vect",v_ebeMultiply_2.getData(),result_ebeMultiply_2,normTolerance);FieldVector<Fraction> v_ebeDivide=v1.ebeDivide(v2);Fraction[]result_ebeDivide={new Fraction(0.25d),new Fraction(0.4d),new Fraction(0.5d)};assertClose("compare vect",v_ebeDivide.getData(),result_ebeDivide,normTolerance);FieldVector<Fraction> v_ebeDivide_2=v1.ebeDivide(v2_t);Fraction[]result_ebeDivide_2={new Fraction(0.25d),new Fraction(0.4d),new Fraction(0.5d)};assertClose("compare vect",v_ebeDivide_2.getData(),result_ebeDivide_2,normTolerance);Fraction dot=v1.dotProduct(v2);Assert.assertEquals("compare val ",new Fraction(32),dot);Fraction dot_2=v1.dotProduct(v2_t);Assert.assertEquals("compare val ",new Fraction(32),dot_2);FieldMatrix<Fraction> m_outerProduct=v1.outerProduct(v2);Assert.assertEquals("compare val ",new Fraction(4),m_outerProduct.getEntry(0,0));FieldMatrix<Fraction> m_outerProduct_2=v1.outerProduct(v2_t);Assert.assertEquals("compare val ",new Fraction(4),m_outerProduct_2.getEntry(0,0));}
@Test public void testOuterProduct(){final SparseFieldVector<Fraction> u=new SparseFieldVector<Fraction>(FractionField.getInstance(),new Fraction[]{new Fraction(1),new Fraction(2),new Fraction(-3)});final SparseFieldVector<Fraction> v=new SparseFieldVector<Fraction>(FractionField.getInstance(),new Fraction[]{new Fraction(4),new Fraction(-2)});final FieldMatrix<Fraction> uv=u.outerProduct(v);final double tol=Math.ulp(1d);Assert.assertEquals(new Fraction(4).doubleValue(),uv.getEntry(0,0).doubleValue(),tol);Assert.assertEquals(new Fraction(-2).doubleValue(),uv.getEntry(0,1).doubleValue(),tol);Assert.assertEquals(new Fraction(8).doubleValue(),uv.getEntry(1,0).doubleValue(),tol);Assert.assertEquals(new Fraction(-4).doubleValue(),uv.getEntry(1,1).doubleValue(),tol);Assert.assertEquals(new Fraction(-12).doubleValue(),uv.getEntry(2,0).doubleValue(),tol);Assert.assertEquals(new Fraction(6).doubleValue(),uv.getEntry(2,1).doubleValue(),tol);}
@Test public void testMisc(){SparseFieldVector<Fraction> v1=new SparseFieldVector<Fraction>(field,vec1);String out1=v1.toString();Assert.assertTrue("some output ",out1.length()!= 0);try {v1.checkVectorDimensions(2);Assert.fail("MathIllegalArgumentException expected");}catch(MathIllegalArgumentException ex){}}
@Test public void testPredicates(){SparseFieldVector<Fraction> v=new SparseFieldVector<Fraction>(field,new Fraction[]{new Fraction(0),new Fraction(1),new Fraction(2)});v.setEntry(0,field.getZero());Assert.assertEquals(v,new SparseFieldVector<Fraction>(field,new Fraction[]{new Fraction(0),new Fraction(1),new Fraction(2)}));Assert.assertNotSame(v,new SparseFieldVector<Fraction>(field,new Fraction[]{new Fraction(0),new Fraction(1),new Fraction(2),new Fraction(3)}));}
/** * Test preconditions.*/@Test public void testPreconditions(){double[]xval=new double[]{3,4,5,6.5};double[]yval=new double[]{-4,-3,-1,2.5};double[]zval=new double[]{-12,-8,-5.5,-3,0,2.5};double[][][]fval=new double[xval.length][yval.length][zval.length];TrivariateRealGridInterpolator interpolator=new TricubicSplineInterpolator();@SuppressWarnings("unused")TrivariateRealFunction p=interpolator.interpolate(xval,yval,zval,fval);double[]wxval=new double[]{3,2,5,6.5};try {p=interpolator.interpolate(wxval,yval,zval,fval);Assert.fail("an exception should have been thrown");}catch(MathIllegalArgumentException e){}double[]wyval=new double[]{-4,-3,-1,-1};try {p=interpolator.interpolate(xval,wyval,zval,fval);Assert.fail("an exception should have been thrown");}catch(MathIllegalArgumentException e){}double[]wzval=new double[]{-12,-8,-5.5,-3,-4,2.5};try {p=interpolator.interpolate(xval,yval,wzval,fval);Assert.fail("an exception should have been thrown");}catch(MathIllegalArgumentException e){}double[][][]wfval=new double[xval.length][yval.length + 1][zval.length];try {p=interpolator.interpolate(xval,yval,zval,wfval);Assert.fail("an exception should have been thrown");}catch(DimensionMismatchException e){}wfval=new double[xval.length - 1][yval.length][zval.length];try {p=interpolator.interpolate(xval,yval,zval,wfval);Assert.fail("an exception should have been thrown");}catch(DimensionMismatchException e){}wfval=new double[xval.length][yval.length][zval.length - 1];try {p=interpolator.interpolate(xval,yval,zval,wfval);Assert.fail("an exception should have been thrown");}catch(DimensionMismatchException e){}}
/** * Test of interpolator for a plane. <p> f(x,y,z)= 2 x - 3 y - z + 5*/@Test public void testPlane(){TrivariateRealFunction f=new TrivariateRealFunction(){public double value(double x,double y,double z){return 2 * x - 3 * y - z + 5;}};TrivariateRealGridInterpolator interpolator=new TricubicSplineInterpolator();double[]xval=new double[]{3,4,5,6.5};double[]yval=new double[]{-4,-3,-1,2,2.5};double[]zval=new double[]{-12,-8,-5.5,-3,0,2.5};double[][][]fval=new double[xval.length][yval.length][zval.length];for (int i=0;i < xval.length;i++){for (int j=0;j < yval.length;j++){for (int k=0;k < zval.length;k++){fval[i][j][k]=f.value(xval[i],yval[j],zval[k]);}}}TrivariateRealFunction p=interpolator.interpolate(xval,yval,zval,fval);double x,y,z;double expected,result;x=4;y=-3;z=0;expected=f.value(x,y,z);result=p.value(x,y,z);Assert.assertEquals("On sample point",expected,result,1e-15);x=4.5;y=-1.5;z=-4.25;expected=f.value(x,y,z);result=p.value(x,y,z);Assert.assertEquals("half-way between sample points (middle of the patch)",expected,result,0.3);x=3.5;y=-3.5;z=-10;expected=f.value(x,y,z);result=p.value(x,y,z);Assert.assertEquals("half-way between sample points (border of the patch)",expected,result,0.3);}
/** * Test of interpolator for a sine wave. <p> <p> f(x,y,z)= a cos [&omega;z - k<sub>y</sub> x - k<sub>y</sub> y]</p> with A = 0.2,&omega;= 0.5,k<sub>x</sub> = 2,k<sub>y</sub> = 1.*/@Test public void testWave(){double[]xval=new double[]{3,4,5,6.5};double[]yval=new double[]{-4,-3,-1,2,2.5};double[]zval=new double[]{-12,-8,-5.5,-3,0,4};final double a=0.2;final double omega=0.5;final double kx=2;final double ky=1;TrivariateRealFunction f=new TrivariateRealFunction(){public double value(double x,double y,double z){return a * FastMath.cos(omega * z - kx * x - ky * y);}};double[][][]fval=new double[xval.length][yval.length][zval.length];for (int i=0;i < xval.length;i++){for (int j=0;j < yval.length;j++){for (int k=0;k < zval.length;k++){fval[i][j][k]=f.value(xval[i],yval[j],zval[k]);}}}TrivariateRealGridInterpolator interpolator=new TricubicSplineInterpolator();TrivariateRealFunction p=interpolator.interpolate(xval,yval,zval,fval);double x,y,z;double expected,result;x=4;y=-3;z=0;expected=f.value(x,y,z);result=p.value(x,y,z);Assert.assertEquals("On sample point",expected,result,1e-12);x=4.5;y=-1.5;z=-4.25;expected=f.value(x,y,z);result=p.value(x,y,z);Assert.assertEquals("Half-way between sample points (middle of the patch)",expected,result,0.1);x=3.5;y=-3.5;z=-10;expected=f.value(x,y,z);result=p.value(x,y,z);Assert.assertEquals("Half-way between sample points (border of the patch)",expected,result,0.1);}
@Test public void testConstructor(){PolynomialSplineFunction spline=new PolynomialSplineFunction(knots,polynomials);Assert.assertTrue(Arrays.equals(knots,spline.getKnots()));Assert.assertEquals(1d,spline.getPolynomials()[0].getCoefficients()[2],0);Assert.assertEquals(3,spline.getN());try {new PolynomialSplineFunction(new double[]{0},polynomials);Assert.fail("Expecting MathIllegalArgumentException");}catch(MathIllegalArgumentException ex){}try {new PolynomialSplineFunction(new double[]{0,1,2,3,4},polynomials);Assert.fail("Expecting MathIllegalArgumentException");}catch(MathIllegalArgumentException ex){}try {new PolynomialSplineFunction(new double[]{0,1,3,2},polynomials);Assert.fail("Expecting MathIllegalArgumentException");}catch(MathIllegalArgumentException ex){}}
@Test public void testValues()throws Exception {PolynomialSplineFunction spline=new PolynomialSplineFunction(knots,polynomials);UnivariateFunction dSpline=spline.derivative();double x=-1;int index=0;for (int i=0;i < 10;i++){x+=0.25;index=findKnot(knots,x);Assert.assertEquals("spline function evaluation failed for x=" + x,polynomials[index].value(x - knots[index]),spline.value(x),tolerance);Assert.assertEquals("spline derivative evaluation failed for x=" + x,dp.value(x - knots[index]),dSpline.value(x),tolerance);}for (int i=0;i < 3;i++){Assert.assertEquals("spline function evaluation failed for knot=" + knots[i],polynomials[i].value(0),spline.value(knots[i]),tolerance);Assert.assertEquals("spline function evaluation failed for knot=" + knots[i],dp.value(0),dSpline.value(knots[i]),tolerance);}try {x=spline.value(-1.5);Assert.fail("Expecting OutOfRangeException");}catch(OutOfRangeException ex){}try {x=spline.value(2.5);Assert.fail("Expecting OutOfRangeException");}catch(OutOfRangeException ex){}}
@Test(expected=NotStrictlyPositiveException.class)public void testPreconditions(){new Gaussian(1,2,-1);}
@Test public void testSomeValues(){final UnivariateFunction f=new Gaussian();Assert.assertEquals(1 / FastMath.sqrt(2 * Math.PI),f.value(0),EPS);}
@Test public void testLargeArguments(){final UnivariateFunction f=new Gaussian();Assert.assertEquals(0,f.value(Double.NEGATIVE_INFINITY),0);Assert.assertEquals(0,f.value(-Double.MAX_VALUE),0);Assert.assertEquals(0,f.value(-1e2),0);Assert.assertEquals(0,f.value(1e2),0);Assert.assertEquals(0,f.value(Double.MAX_VALUE),0);Assert.assertEquals(0,f.value(Double.POSITIVE_INFINITY),0);}
@Test public void testDerivative(){final Gaussian f=new Gaussian();final UnivariateFunction dfdx=f.derivative();Assert.assertEquals(0,dfdx.value(0),0);}
@Test public void testDerivativeLargeArguments(){final Gaussian f=new Gaussian(0,1e-50);final UnivariateFunction dfdx=f.derivative();Assert.assertEquals(0,dfdx.value(Double.NEGATIVE_INFINITY),0);Assert.assertEquals(0,dfdx.value(-Double.MAX_VALUE),0);Assert.assertEquals(0,dfdx.value(-1e50),0);Assert.assertEquals(0,dfdx.value(-1e2),0);Assert.assertEquals(0,dfdx.value(1e2),0);Assert.assertEquals(0,dfdx.value(1e50),0);Assert.assertEquals(0,dfdx.value(Double.MAX_VALUE),0);Assert.assertEquals(0,dfdx.value(Double.POSITIVE_INFINITY),0);}
@Test public void testDerivativeNaN(){final Gaussian f=new Gaussian(0,1e-50);final UnivariateFunction dfdx=f.derivative();Assert.assertTrue(Double.isNaN(dfdx.value(Double.NaN)));}
@Test(expected=NullArgumentException.class)public void testParametricUsage1(){final Gaussian.Parametric g=new Gaussian.Parametric();g.value(0,null);}
@Test(expected=DimensionMismatchException.class)public void testParametricUsage2(){final Gaussian.Parametric g=new Gaussian.Parametric();g.value(0,new double[]{0});}
@Test(expected=NotStrictlyPositiveException.class)public void testParametricUsage3(){final Gaussian.Parametric g=new Gaussian.Parametric();g.value(0,new double[]{0,1,0});}
@Test(expected=NullArgumentException.class)public void testParametricUsage4(){final Gaussian.Parametric g=new Gaussian.Parametric();g.gradient(0,null);}
@Test(expected=DimensionMismatchException.class)public void testParametricUsage5(){final Gaussian.Parametric g=new Gaussian.Parametric();g.gradient(0,new double[]{0});}
@Test(expected=NotStrictlyPositiveException.class)public void testParametricUsage6(){final Gaussian.Parametric g=new Gaussian.Parametric();g.gradient(0,new double[]{0,1,0});}
@Test public void testParametricValue(){final double norm=2;final double mean=3;final double sigma=4;final Gaussian f=new Gaussian(norm,mean,sigma);final Gaussian.Parametric g=new Gaussian.Parametric();Assert.assertEquals(f.value(-1),g.value(-1,new double[]{norm,mean,sigma}),0);Assert.assertEquals(f.value(0),g.value(0,new double[]{norm,mean,sigma}),0);Assert.assertEquals(f.value(2),g.value(2,new double[]{norm,mean,sigma}),0);}
@Test public void testParametricGradient(){final double norm=2;final double mean=3;final double sigma=4;final Gaussian.Parametric f=new Gaussian.Parametric();final double x=1;final double[]grad=f.gradient(1,new double[]{norm,mean,sigma});final double diff=x - mean;final double n=FastMath.exp(-diff * diff / (2 * sigma * sigma));Assert.assertEquals(n,grad[0],EPS);final double m=norm * n * diff / (sigma * sigma);Assert.assertEquals(m,grad[1],EPS);final double s=m * diff / sigma;Assert.assertEquals(s,grad[2],EPS);}
@Test public void testConstructor1(){final Incrementor i=new Incrementor();Assert.assertEquals(0,i.getMaximalCount());Assert.assertEquals(0,i.getCount());}
@Test public void testConstructor2(){final Incrementor i=new Incrementor(10);Assert.assertEquals(10,i.getMaximalCount());Assert.assertEquals(0,i.getCount());}
@Test public void testCanIncrement1(){final Incrementor i=new Incrementor(3);Assert.assertTrue(i.canIncrement());i.incrementCount();Assert.assertTrue(i.canIncrement());i.incrementCount();Assert.assertTrue(i.canIncrement());i.incrementCount();Assert.assertFalse(i.canIncrement());}
@Test public void testCanIncrement2(){final Incrementor i=new Incrementor(3);while (i.canIncrement()){i.incrementCount();}try {i.incrementCount();Assert.fail("MaxCountExceededException expected");}catch(MaxCountExceededException e){}}
@Test public void testAccessor(){final Incrementor i=new Incrementor();i.setMaximalCount(10);Assert.assertEquals(10,i.getMaximalCount());Assert.assertEquals(0,i.getCount());}
@Test public void testBelowMaxCount(){final Incrementor i=new Incrementor();i.setMaximalCount(3);i.incrementCount();i.incrementCount();i.incrementCount();Assert.assertEquals(3,i.getCount());}
@Test(expected=MaxCountExceededException.class)public void testAboveMaxCount(){final Incrementor i=new Incrementor();i.setMaximalCount(3);i.incrementCount();i.incrementCount();i.incrementCount();i.incrementCount();}
@Test(expected=TooManyEvaluationsException.class)public void testAlternateException(){final Incrementor.MaxCountExceededCallback cb=new Incrementor.MaxCountExceededCallback(){/** * {@inheritDoc}*/public void trigger(int max){throw new TooManyEvaluationsException(max);}};final Incrementor i=new Incrementor(0,cb);i.incrementCount();}
@Test public void testReset(){final Incrementor i=new Incrementor();i.setMaximalCount(3);i.incrementCount();i.incrementCount();i.incrementCount();Assert.assertEquals(3,i.getCount());i.resetCount();Assert.assertEquals(0,i.getCount());}
@Test public void testBulkIncrement(){final Incrementor i=new Incrementor();i.setMaximalCount(3);i.incrementCount(2);Assert.assertEquals(2,i.getCount());i.incrementCount(1);Assert.assertEquals(3,i.getCount());}
@Test public void testCircleFitting(){Circle circle=new Circle();circle.addPoint(30.0,68.0);circle.addPoint(50.0,-6.0);circle.addPoint(110.0,-20.0);circle.addPoint(35.0,15.0);circle.addPoint(45.0,97.0);NonLinearConjugateGradientOptimizer underlying=new NonLinearConjugateGradientOptimizer(ConjugateGradientFormula.POLAK_RIBIERE,new SimpleScalarValueChecker(1.0e-10,1.0e-10));JDKRandomGenerator g=new JDKRandomGenerator();g.setSeed(753289573253l);RandomVectorGenerator generator=new UncorrelatedRandomVectorGenerator(new double[]{50.0,50.0},new double[]{10.0,10.0},new GaussianRandomGenerator(g));MultiStartDifferentiableMultivariateRealOptimizer optimizer=new MultiStartDifferentiableMultivariateRealOptimizer(underlying,10,generator);RealPointValuePair optimum=optimizer.optimize(200,circle,GoalType.MINIMIZE,new double[]{98.680,47.345});Assert.assertEquals(200,optimizer.getMaxEvaluations());RealPointValuePair[]optima=optimizer.getOptima();for(RealPointValuePair o : optima){Point2D.Double center=new Point2D.Double(o.getPointRef()[0],o.getPointRef()[1]);Assert.assertEquals(69.960161753,circle.getRadius(center),1.0e-8);Assert.assertEquals(96.075902096,center.x,1.0e-8);Assert.assertEquals(48.135167894,center.y,1.0e-8);}Assert.assertTrue(optimizer.getEvaluations()> 70);Assert.assertTrue(optimizer.getEvaluations()< 90);Assert.assertEquals(3.1267527,optimum.getValue(),1.0e-8);}
/** * test dimensions */@Test public void testDimensions(){CholeskyDecomposition llt=new CholeskyDecomposition(MatrixUtils.createRealMatrix(testData));Assert.assertEquals(testData.length,llt.getL().getRowDimension());Assert.assertEquals(testData.length,llt.getL().getColumnDimension());Assert.assertEquals(testData.length,llt.getLT().getRowDimension());Assert.assertEquals(testData.length,llt.getLT().getColumnDimension());}
/** * test non-square matrix */@Test(expected=NonSquareMatrixException.class)public void testNonSquare(){new CholeskyDecomposition(MatrixUtils.createRealMatrix(new double[3][2]));}
/** * test non-symmetric matrix */@Test(expected=NonSymmetricMatrixException.class)public void testNotSymmetricMatrixException(){double[][]changed=testData.clone();changed[0][changed[0].length - 1]+=1.0e-5;new CholeskyDecomposition(MatrixUtils.createRealMatrix(changed));}
/** * test non positive definite matrix */@Test(expected=NonPositiveDefiniteMatrixException.class)public void testNotPositiveDefinite(){new CholeskyDecomposition(MatrixUtils.createRealMatrix(new double[][]{{14,11,13,15,24},{11,34,13,8,25},{13,13,14,15,21},{15,8,15,18,23},{24,25,21,23,45}}));}
@Test(expected=NonPositiveDefiniteMatrixException.class)public void testMath274(){new CholeskyDecomposition(MatrixUtils.createRealMatrix(new double[][]{{0.40434286,-0.09376327,0.30328980,0.04909388},{-0.09376327,0.10400408,0.07137959,0.04762857},{0.30328980,0.07137959,0.30458776,0.04882449},{0.04909388,0.04762857,0.04882449,0.07543265}}));}
/** * test A = LLT */@Test public void testAEqualLLT(){RealMatrix matrix=MatrixUtils.createRealMatrix(testData);CholeskyDecomposition llt=new CholeskyDecomposition(matrix);RealMatrix l=llt.getL();RealMatrix lt=llt.getLT();double norm=l.multiply(lt).subtract(matrix).getNorm();Assert.assertEquals(0,norm,1.0e-15);}
/** * test that L is lower triangular */@Test public void testLLowerTriangular(){RealMatrix matrix=MatrixUtils.createRealMatrix(testData);RealMatrix l=new CholeskyDecomposition(matrix).getL();for (int i=0;i < l.getRowDimension();i++){for (int j=i + 1;j < l.getColumnDimension();j++){Assert.assertEquals(0.0,l.getEntry(i,j),0.0);}}}
/** * test that LT is transpose of L */@Test public void testLTTransposed(){RealMatrix matrix=MatrixUtils.createRealMatrix(testData);CholeskyDecomposition llt=new CholeskyDecomposition(matrix);RealMatrix l=llt.getL();RealMatrix lt=llt.getLT();double norm=l.subtract(lt.transpose()).getNorm();Assert.assertEquals(0,norm,1.0e-15);}
/** * test matrices values */@Test public void testMatricesValues(){RealMatrix lRef=MatrixUtils.createRealMatrix(new double[][]{{1,0,0,0,0},{2,3,0,0,0},{4,5,6,0,0},{7,8,9,10,0},{11,12,13,14,15}});CholeskyDecomposition llt=new CholeskyDecomposition(MatrixUtils.createRealMatrix(testData));RealMatrix l=llt.getL();Assert.assertEquals(0,l.subtract(lRef).getNorm(),1.0e-13);RealMatrix lt=llt.getLT();Assert.assertEquals(0,lt.subtract(lRef.transpose()).getNorm(),1.0e-13);Assert.assertTrue(l == llt.getL());Assert.assertTrue(lt == llt.getLT());}
/** * Test of solver for the sine function.*/@Test public void testSinFunction(){UnivariateFunction f=new SinFunction();UnivariateRealSolver solver=new MullerSolver2();double min,max,expected,result,tolerance;min=3.0;max=4.0;expected=FastMath.PI;tolerance=FastMath.max(solver.getAbsoluteAccuracy(),FastMath.abs(expected * solver.getRelativeAccuracy()));result=solver.solve(100,f,min,max);Assert.assertEquals(expected,result,tolerance);min=-1.0;max=1.5;expected=0.0;tolerance=FastMath.max(solver.getAbsoluteAccuracy(),FastMath.abs(expected * solver.getRelativeAccuracy()));result=solver.solve(100,f,min,max);Assert.assertEquals(expected,result,tolerance);}
/** * Test of solver for the quintic function.*/@Test public void testQuinticFunction(){UnivariateFunction f=new QuinticFunction();UnivariateRealSolver solver=new MullerSolver2();double min,max,expected,result,tolerance;min=-0.4;max=0.2;expected=0.0;tolerance=FastMath.max(solver.getAbsoluteAccuracy(),FastMath.abs(expected * solver.getRelativeAccuracy()));result=solver.solve(100,f,min,max);Assert.assertEquals(expected,result,tolerance);min=0.75;max=1.5;expected=1.0;tolerance=FastMath.max(solver.getAbsoluteAccuracy(),FastMath.abs(expected * solver.getRelativeAccuracy()));result=solver.solve(100,f,min,max);Assert.assertEquals(expected,result,tolerance);min=-0.9;max=-0.2;expected=-0.5;tolerance=FastMath.max(solver.getAbsoluteAccuracy(),FastMath.abs(expected * solver.getRelativeAccuracy()));result=solver.solve(100,f,min,max);Assert.assertEquals(expected,result,tolerance);}
/** * Test of solver for the exponential function. <p> It takes 25 to 50 iterations for the last two tests to converge.*/@Test public void testExpm1Function(){UnivariateFunction f=new Expm1Function();UnivariateRealSolver solver=new MullerSolver2();double min,max,expected,result,tolerance;min=-1.0;max=2.0;expected=0.0;tolerance=FastMath.max(solver.getAbsoluteAccuracy(),FastMath.abs(expected * solver.getRelativeAccuracy()));result=solver.solve(100,f,min,max);Assert.assertEquals(expected,result,tolerance);min=-20.0;max=10.0;expected=0.0;tolerance=FastMath.max(solver.getAbsoluteAccuracy(),FastMath.abs(expected * solver.getRelativeAccuracy()));result=solver.solve(100,f,min,max);Assert.assertEquals(expected,result,tolerance);min=-50.0;max=100.0;expected=0.0;tolerance=FastMath.max(solver.getAbsoluteAccuracy(),FastMath.abs(expected * solver.getRelativeAccuracy()));result=solver.solve(100,f,min,max);Assert.assertEquals(expected,result,tolerance);}
/** * Test of parameters for the solver.*/@Test public void testParameters()throws Exception {UnivariateFunction f=new SinFunction();UnivariateRealSolver solver=new MullerSolver2();try {solver.solve(100,f,1,-1);Assert.fail("Expecting NumberIsTooLargeException - bad interval");}catch(NumberIsTooLargeException ex){}try {solver.solve(100,f,2,3);Assert.fail("Expecting NoBracketingException - no bracketing");}catch(NoBracketingException ex){}}
@Test public void testConstructors(){float defaultExpansionFactor=2.0f;float defaultContractionCriteria=2.5f;int defaultMode=ResizableDoubleArray.MULTIPLICATIVE_MODE;ResizableDoubleArray testDa=new ResizableDoubleArray(2);Assert.assertEquals(0,testDa.getNumElements());Assert.assertEquals(2,testDa.getInternalLength());Assert.assertEquals(defaultExpansionFactor,testDa.getExpansionFactor(),0);Assert.assertEquals(defaultContractionCriteria,testDa.getContractionCriteria(),0);Assert.assertEquals(defaultMode,testDa.getExpansionMode());try {da=new ResizableDoubleArray(-1);Assert.fail("Expecting IllegalArgumentException");}catch(IllegalArgumentException ex){}testDa=new ResizableDoubleArray((double[])null);Assert.assertEquals(0,testDa.getNumElements());double[]initialArray=new double[]{0,1,2};testDa=new ResizableDoubleArray(initialArray);Assert.assertEquals(3,testDa.getNumElements());testDa=new ResizableDoubleArray(2,2.0f);Assert.assertEquals(0,testDa.getNumElements());Assert.assertEquals(2,testDa.getInternalLength());Assert.assertEquals(defaultExpansionFactor,testDa.getExpansionFactor(),0);Assert.assertEquals(defaultContractionCriteria,testDa.getContractionCriteria(),0);Assert.assertEquals(defaultMode,testDa.getExpansionMode());try {da=new ResizableDoubleArray(2,0.5f);Assert.fail("Expecting IllegalArgumentException");}catch(IllegalArgumentException ex){}testDa=new ResizableDoubleArray(2,3.0f);Assert.assertEquals(3.0f,testDa.getExpansionFactor(),0);Assert.assertEquals(3.5f,testDa.getContractionCriteria(),0);testDa=new ResizableDoubleArray(2,2.0f,3.0f);Assert.assertEquals(0,testDa.getNumElements());Assert.assertEquals(2,testDa.getInternalLength());Assert.assertEquals(defaultExpansionFactor,testDa.getExpansionFactor(),0);Assert.assertEquals(3.0f,testDa.getContractionCriteria(),0);Assert.assertEquals(defaultMode,testDa.getExpansionMode());try {da=new ResizableDoubleArray(2,2.0f,1.5f);Assert.fail("Expecting IllegalArgumentException");}catch(IllegalArgumentException ex){}testDa=new ResizableDoubleArray(2,2.0f,3.0f,ResizableDoubleArray.ADDITIVE_MODE);Assert.assertEquals(0,testDa.getNumElements());Assert.assertEquals(2,testDa.getInternalLength());Assert.assertEquals(defaultExpansionFactor,testDa.getExpansionFactor(),0);Assert.assertEquals(3.0f,testDa.getContractionCriteria(),0);Assert.assertEquals(ResizableDoubleArray.ADDITIVE_MODE,testDa.getExpansionMode());try {da=new ResizableDoubleArray(2,2.0f,2.5f,-1);Assert.fail("Expecting IllegalArgumentException");}catch(IllegalArgumentException ex){}testDa=new ResizableDoubleArray(2,2.0f,3.0f,ResizableDoubleArray.ADDITIVE_MODE);testDa.addElement(2.0);testDa.addElement(3.2);ResizableDoubleArray copyDa=new ResizableDoubleArray(testDa);Assert.assertEquals(copyDa,testDa);Assert.assertEquals(testDa,copyDa);}
@Test public void testSetElementArbitraryExpansion(){da.addElement(2.0);da.addElement(4.0);da.addElement(6.0);da.setElement(1,3.0);da.setElement(1000,3.4);Assert.assertEquals("The number of elements should now be 1001,it isn't",da.getNumElements(),1001);Assert.assertEquals("Uninitialized Elements are default value of 0.0,index 766 wasn't",0.0,da.getElement(760),Double.MIN_VALUE);Assert.assertEquals("The 1000th index should be 3.4,it isn't",3.4,da.getElement(1000),Double.MIN_VALUE);Assert.assertEquals("The 0th index should be 2.0,it isn't",2.0,da.getElement(0),Double.MIN_VALUE);da.clear();da.addElement(2.0);da.addElement(4.0);da.addElement(6.0);Assert.assertEquals(4,((ResizableDoubleArray)da).getInternalLength());Assert.assertEquals(3,da.getNumElements());da.setElement(3,7.0);Assert.assertEquals(4,((ResizableDoubleArray)da).getInternalLength());Assert.assertEquals(4,da.getNumElements());da.setElement(10,10.0);Assert.assertEquals(11,((ResizableDoubleArray)da).getInternalLength());Assert.assertEquals(11,da.getNumElements());da.setElement(9,10.0);Assert.assertEquals(11,((ResizableDoubleArray)da).getInternalLength());Assert.assertEquals(11,da.getNumElements());try {da.setElement(-2,3);Assert.fail("Expecting ArrayIndexOutOfBoundsException for negative index");}catch(ArrayIndexOutOfBoundsException ex){}ResizableDoubleArray testDa=new ResizableDoubleArray(2,2.0f,3.0f,ResizableDoubleArray.ADDITIVE_MODE);Assert.assertEquals(2,testDa.getInternalLength());testDa.addElement(1d);testDa.addElement(1d);Assert.assertEquals(2,testDa.getInternalLength());testDa.addElement(1d);Assert.assertEquals(4,testDa.getInternalLength());}
@Override @Test public void testAdd1000(){super.testAdd1000();Assert.assertEquals("Internal Storage length should be 1024 if we started out with initial capacity of " + "16 and an expansion factor of 2.0",1024,((ResizableDoubleArray)da).getInternalLength());}
@Test public void testAddElements(){ResizableDoubleArray testDa=new ResizableDoubleArray();testDa.addElements(new double[]{4,5,6});Assert.assertEquals(3,testDa.getNumElements(),0);Assert.assertEquals(4,testDa.getElement(0),0);Assert.assertEquals(5,testDa.getElement(1),0);Assert.assertEquals(6,testDa.getElement(2),0);testDa.addElements(new double[]{4,5,6});Assert.assertEquals(6,testDa.getNumElements());testDa=new ResizableDoubleArray(2,2.0f,2.5f,ResizableDoubleArray.ADDITIVE_MODE);Assert.assertEquals(2,testDa.getInternalLength());testDa.addElements(new double[]{1d});testDa.addElements(new double[]{2d});testDa.addElements(new double[]{3d});Assert.assertEquals(1d,testDa.getElement(0),0);Assert.assertEquals(2d,testDa.getElement(1),0);Assert.assertEquals(3d,testDa.getElement(2),0);Assert.assertEquals(4,testDa.getInternalLength());Assert.assertEquals(3,testDa.getNumElements());}
@Override @Test public void testAddElementRolling(){super.testAddElementRolling();da.clear();da.addElement(1);da.addElement(2);da.addElementRolling(3);Assert.assertEquals(3,da.getElement(1),0);da.addElementRolling(4);Assert.assertEquals(3,da.getElement(0),0);Assert.assertEquals(4,da.getElement(1),0);da.addElement(5);Assert.assertEquals(5,da.getElement(2),0);da.addElementRolling(6);Assert.assertEquals(4,da.getElement(0),0);Assert.assertEquals(5,da.getElement(1),0);Assert.assertEquals(6,da.getElement(2),0);ResizableDoubleArray testDa=new ResizableDoubleArray(2,2.0f,2.5f,ResizableDoubleArray.ADDITIVE_MODE);Assert.assertEquals(2,testDa.getInternalLength());testDa.addElement(1d);testDa.addElement(2d);testDa.addElement(3d);Assert.assertEquals(1d,testDa.getElement(0),0);Assert.assertEquals(2d,testDa.getElement(1),0);Assert.assertEquals(3d,testDa.getElement(2),0);Assert.assertEquals(4,testDa.getInternalLength());Assert.assertEquals(3,testDa.getNumElements());testDa.addElementRolling(4d);Assert.assertEquals(2d,testDa.getElement(0),0);Assert.assertEquals(3d,testDa.getElement(1),0);Assert.assertEquals(4d,testDa.getElement(2),0);Assert.assertEquals(4,testDa.getInternalLength());Assert.assertEquals(3,testDa.getNumElements());testDa.addElementRolling(5d);Assert.assertEquals(3d,testDa.getElement(0),0);Assert.assertEquals(4d,testDa.getElement(1),0);Assert.assertEquals(5d,testDa.getElement(2),0);Assert.assertEquals(4,testDa.getInternalLength());Assert.assertEquals(3,testDa.getNumElements());try {testDa.getElement(4);Assert.fail("Expecting ArrayIndexOutOfBoundsException");}catch(ArrayIndexOutOfBoundsException ex){}try {testDa.getElement(-1);Assert.fail("Expecting ArrayIndexOutOfBoundsException");}catch(ArrayIndexOutOfBoundsException ex){}}
@Test public void testSetNumberOfElements(){da.addElement(1.0);da.addElement(1.0);da.addElement(1.0);da.addElement(1.0);da.addElement(1.0);da.addElement(1.0);Assert.assertEquals("Number of elements should equal 6",da.getNumElements(),6);((ResizableDoubleArray)da).setNumElements(3);Assert.assertEquals("Number of elements should equal 3",da.getNumElements(),3);try {((ResizableDoubleArray)da).setNumElements(-3);Assert.fail("Setting number of elements to negative should've thrown an exception");}catch(IllegalArgumentException iae){}((ResizableDoubleArray)da).setNumElements(1024);Assert.assertEquals("Number of elements should now be 1024",da.getNumElements(),1024);Assert.assertEquals("Element 453 should be a default double",da.getElement(453),0.0,Double.MIN_VALUE);}
@Test public void testWithInitialCapacity(){ResizableDoubleArray eDA2=new ResizableDoubleArray(2);Assert.assertEquals("Initial number of elements should be 0",0,eDA2.getNumElements());RandomData randomData=new RandomDataImpl();int iterations=randomData.nextInt(100,1000);for (int i=0;i < iterations;i++){eDA2.addElement(i);}Assert.assertEquals("Number of elements should be equal to " + iterations,iterations,eDA2.getNumElements());eDA2.addElement(2.0);Assert.assertEquals("Number of elements should be equals to " + (iterations + 1),iterations + 1,eDA2.getNumElements());}
@Test public void testWithInitialCapacityAndExpansionFactor(){ResizableDoubleArray eDA3=new ResizableDoubleArray(3,3.0f,3.5f);Assert.assertEquals("Initial number of elements should be 0",0,eDA3.getNumElements());RandomData randomData=new RandomDataImpl();int iterations=randomData.nextInt(100,3000);for (int i=0;i < iterations;i++){eDA3.addElement(i);}Assert.assertEquals("Number of elements should be equal to " + iterations,iterations,eDA3.getNumElements());eDA3.addElement(2.0);Assert.assertEquals("Number of elements should be equals to " + (iterations + 1),iterations + 1,eDA3.getNumElements());Assert.assertEquals("Expansion factor should equal 3.0",3.0f,eDA3.getExpansionFactor(),Double.MIN_VALUE);}
@Test public void testDiscard(){da.addElement(2.0);da.addElement(2.0);da.addElement(2.0);da.addElement(2.0);da.addElement(2.0);da.addElement(2.0);da.addElement(2.0);da.addElement(2.0);da.addElement(2.0);da.addElement(2.0);da.addElement(2.0);Assert.assertEquals("Number of elements should be 11",11,da.getNumElements());((ResizableDoubleArray)da).discardFrontElements(5);Assert.assertEquals("Number of elements should be 6",6,da.getNumElements());da.addElement(2.0);da.addElement(2.0);da.addElement(2.0);da.addElement(2.0);Assert.assertEquals("Number of elements should be 10",10,da.getNumElements());((ResizableDoubleArray)da).discardMostRecentElements(2);Assert.assertEquals("Number of elements should be 8",8,da.getNumElements());try {((ResizableDoubleArray)da).discardFrontElements(-1);Assert.fail("Trying to discard a negative number of element is not allowed");}catch(Exception e){}try {((ResizableDoubleArray)da).discardMostRecentElements(-1);Assert.fail("Trying to discard a negative number of element is not allowed");}catch(Exception e){}try {((ResizableDoubleArray)da).discardFrontElements(10000);Assert.fail("You can't discard more elements than the array contains");}catch(Exception e){}try {((ResizableDoubleArray)da).discardMostRecentElements(10000);Assert.fail("You can't discard more elements than the array contains");}catch(Exception e){}}
@Test public void testSubstitute(){da.addElement(2.0);da.addElement(2.0);da.addElement(2.0);da.addElement(2.0);da.addElement(2.0);da.addElement(2.0);da.addElement(2.0);da.addElement(2.0);da.addElement(2.0);da.addElement(2.0);da.addElement(2.0);Assert.assertEquals("Number of elements should be 11",11,da.getNumElements());((ResizableDoubleArray)da).substituteMostRecentElement(24);Assert.assertEquals("Number of elements should be 11",11,da.getNumElements());try {((ResizableDoubleArray)da).discardMostRecentElements(10);}catch(Exception e){Assert.fail("Trying to discard a negative number of element is not allowed");}((ResizableDoubleArray)da).substituteMostRecentElement(24);Assert.assertEquals("Number of elements should be 1",1,da.getNumElements());}
@Test public void testMutators(){((ResizableDoubleArray)da).setContractionCriteria(10f);Assert.assertEquals(10f,((ResizableDoubleArray)da).getContractionCriteria(),0);((ResizableDoubleArray)da).setExpansionFactor(8f);Assert.assertEquals(8f,((ResizableDoubleArray)da).getExpansionFactor(),0);try {((ResizableDoubleArray)da).setExpansionFactor(11f);Assert.fail("Expecting IllegalArgumentException");}catch(IllegalArgumentException ex){}((ResizableDoubleArray)da).setExpansionMode(ResizableDoubleArray.ADDITIVE_MODE);Assert.assertEquals(ResizableDoubleArray.ADDITIVE_MODE,((ResizableDoubleArray)da).getExpansionMode());try {((ResizableDoubleArray)da).setExpansionMode(-1);Assert.fail("Expecting IllegalArgumentException");}catch(IllegalArgumentException ex){}}
@Test public void testEqualsAndHashCode()throws Exception {ResizableDoubleArray first=new ResizableDoubleArray();Double other=new Double(2);Assert.assertFalse(first.equals(other));other=null;Assert.assertFalse(first.equals(other));Assert.assertTrue(first.equals(first));ResizableDoubleArray second=new ResizableDoubleArray();verifyEquality(first,second);ResizableDoubleArray third=new ResizableDoubleArray(3,2.0f,2.0f);verifyInequality(third,first);ResizableDoubleArray fourth=new ResizableDoubleArray(3,2.0f,2.0f);ResizableDoubleArray fifth=new ResizableDoubleArray(2,2.0f,2.0f);verifyEquality(third,fourth);verifyInequality(third,fifth);third.addElement(4.1);third.addElement(4.2);third.addElement(4.3);fourth.addElement(4.1);fourth.addElement(4.2);fourth.addElement(4.3);verifyEquality(third,fourth);fourth.addElement(4.4);verifyInequality(third,fourth);third.addElement(4.4);verifyEquality(third,fourth);fourth.addElement(4.4);verifyInequality(third,fourth);third.addElement(4.4);verifyEquality(third,fourth);fourth.addElementRolling(4.5);third.addElementRolling(4.5);verifyEquality(third,fourth);third.discardFrontElements(1);verifyInequality(third,fourth);fourth.discardFrontElements(1);verifyEquality(third,fourth);third.discardMostRecentElements(2);fourth.discardMostRecentElements(2);verifyEquality(third,fourth);third.addElement(18);fourth.addElement(17);third.addElement(17);fourth.addElement(18);verifyInequality(third,fourth);ResizableDoubleArray.copy(fourth,fifth);verifyEquality(fourth,fifth);verifyEquality(fourth,new ResizableDoubleArray(fourth));verifyEquality(fourth,fourth.copy());}
/** * Test of transformer for the ad hoc data.*/@Test public void testAdHocData(){FastSineTransformer transformer=new FastSineTransformer();double result[],tolerance=1E-12;double x[]={0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0};double y[]={0.0,20.1093579685034,-9.65685424949238,5.98642305066196,-4.0,2.67271455167720,-1.65685424949238,0.795649469518633};result=transformer.transform(x);for (int i=0;i < result.length;i++){Assert.assertEquals(y[i],result[i],tolerance);}result=transformer.inversetransform(y);for (int i=0;i < result.length;i++){Assert.assertEquals(x[i],result[i],tolerance);}FastFourierTransformer.scaleArray(x,FastMath.sqrt(x.length / 2.0));result=transformer.transform2(y);for (int i=0;i < result.length;i++){Assert.assertEquals(x[i],result[i],tolerance);}result=transformer.inversetransform2(x);for (int i=0;i < result.length;i++){Assert.assertEquals(y[i],result[i],tolerance);}}
/** * Test of transformer for the sine function.*/@Test public void testSinFunction(){UnivariateFunction f=new SinFunction();FastSineTransformer transformer=new FastSineTransformer();double min,max,result[],tolerance=1E-12;int N=1 << 8;min=0.0;max=2.0 * FastMath.PI;result=transformer.transform(f,min,max,N);Assert.assertEquals(N >> 1,result[2],tolerance);for (int i=0;i < N;i+=(i == 1 ? 2 : 1)){Assert.assertEquals(0.0,result[i],tolerance);}min=-FastMath.PI;max=FastMath.PI;result=transformer.transform(f,min,max,N);Assert.assertEquals(-(N >> 1),result[2],tolerance);for (int i=0;i < N;i+=(i == 1 ? 2 : 1)){Assert.assertEquals(0.0,result[i],tolerance);}}
/** * Test of parameters for the transformer.*/@Test public void testParameters()throws Exception {UnivariateFunction f=new SinFunction();FastSineTransformer transformer=new FastSineTransformer();try {transformer.transform(f,1,-1,64);Assert.fail("Expecting IllegalArgumentException - bad interval");}catch(IllegalArgumentException ex){}try {transformer.transform(f,-1,1,0);Assert.fail("Expecting IllegalArgumentException - bad samples number");}catch(IllegalArgumentException ex){}try {transformer.transform(f,-1,1,100);Assert.fail("Expecting IllegalArgumentException - bad samples number");}catch(IllegalArgumentException ex){}}
@Test(expected=DimensionMismatchException.class)public void dimensionCheck(){TestProblem1 pb=new TestProblem1();FirstOrderIntegrator integ=new AdamsBashforthIntegrator(2,0.0,1.0,1.0e-10,1.0e-10);integ.integrate(pb,0.0,new double[pb.getDimension()+ 10],1.0,new double[pb.getDimension()+ 10]);}
@Test(expected=NumberIsTooSmallException.class)public void testMinStep(){TestProblem1 pb=new TestProblem1();double minStep=0.1 * (pb.getFinalTime()- pb.getInitialTime());double maxStep=pb.getFinalTime()- pb.getInitialTime();double[]vecAbsoluteTolerance={1.0e-15,1.0e-16};double[]vecRelativeTolerance={1.0e-15,1.0e-16};FirstOrderIntegrator integ=new AdamsBashforthIntegrator(4,minStep,maxStep,vecAbsoluteTolerance,vecRelativeTolerance);TestProblemHandler handler=new TestProblemHandler(pb,integ);integ.addStepHandler(handler);integ.integrate(pb,pb.getInitialTime(),pb.getInitialState(),pb.getFinalTime(),new double[pb.getDimension()]);}
@Test public void testIncreasingTolerance(){int previousCalls=Integer.MAX_VALUE;for (int i=-12;i < -5;++i){TestProblem1 pb=new TestProblem1();double minStep=0;double maxStep=pb.getFinalTime()- pb.getInitialTime();double scalAbsoluteTolerance=FastMath.pow(10.0,i);double scalRelativeTolerance=0.01 * scalAbsoluteTolerance;FirstOrderIntegrator integ=new AdamsBashforthIntegrator(4,minStep,maxStep,scalAbsoluteTolerance,scalRelativeTolerance);TestProblemHandler handler=new TestProblemHandler(pb,integ);integ.addStepHandler(handler);integ.integrate(pb,pb.getInitialTime(),pb.getInitialState(),pb.getFinalTime(),new double[pb.getDimension()]);Assert.assertTrue(handler.getMaximalValueError()> (50.0 * scalAbsoluteTolerance));Assert.assertTrue(handler.getMaximalValueError()< (300.0 * scalAbsoluteTolerance));Assert.assertEquals(0,handler.getMaximalTimeError(),1.0e-16);int calls=pb.getCalls();Assert.assertEquals(integ.getEvaluations(),calls);Assert.assertTrue(calls <= previousCalls);previousCalls=calls;}}
@Test(expected=MaxCountExceededException.class)public void exceedMaxEvaluations(){TestProblem1 pb=new TestProblem1();double range=pb.getFinalTime()- pb.getInitialTime();AdamsBashforthIntegrator integ=new AdamsBashforthIntegrator(2,0,range,1.0e-12,1.0e-12);TestProblemHandler handler=new TestProblemHandler(pb,integ);integ.addStepHandler(handler);integ.setMaxEvaluations(650);integ.integrate(pb,pb.getInitialTime(),pb.getInitialState(),pb.getFinalTime(),new double[pb.getDimension()]);}
@Test public void backward(){TestProblem5 pb=new TestProblem5();double range=FastMath.abs(pb.getFinalTime()- pb.getInitialTime());FirstOrderIntegrator integ=new AdamsBashforthIntegrator(4,0,range,1.0e-12,1.0e-12);TestProblemHandler handler=new TestProblemHandler(pb,integ);integ.addStepHandler(handler);integ.integrate(pb,pb.getInitialTime(),pb.getInitialState(),pb.getFinalTime(),new double[pb.getDimension()]);Assert.assertTrue(handler.getLastError()< 1.5e-8);Assert.assertTrue(handler.getMaximalValueError()< 1.5e-8);Assert.assertEquals(0,handler.getMaximalTimeError(),1.0e-16);Assert.assertEquals("Adams-Bashforth",integ.getName());}
@Test public void polynomial(){TestProblem6 pb=new TestProblem6();double range=FastMath.abs(pb.getFinalTime()- pb.getInitialTime());for (int nSteps=2;nSteps < 8;++nSteps){AdamsBashforthIntegrator integ=new AdamsBashforthIntegrator(nSteps,1.0e-6 * range,0.1 * range,1.0e-5,1.0e-5);TestProblemHandler handler=new TestProblemHandler(pb,integ);integ.addStepHandler(handler);integ.integrate(pb,pb.getInitialTime(),pb.getInitialState(),pb.getFinalTime(),new double[pb.getDimension()]);if (nSteps < 4){Assert.assertTrue(handler.getMaximalValueError()> 1.0e-03);}else {Assert.assertTrue(handler.getMaximalValueError()< 4.0e-12);}}}
@Test public void testInitialization(){LinearObjectiveFunction f=createFunction();Collection<LinearConstraint> constraints=createConstraints();SimplexTableau tableau=new SimplexTableau(f,constraints,GoalType.MAXIMIZE,false,1.0e-6);double[][]expectedInitialTableau={{-1,0,-1,-1,2,0,0,0,-4},{0,1,-15,-10,25,0,0,0,0},{0,0,1,0,-1,1,0,0,2},{0,0,0,1,-1,0,1,0,3},{0,0,1,1,-2,0,0,1,4}};assertMatrixEquals(expectedInitialTableau,tableau.getData());}
@Test public void testDropPhase1Objective(){LinearObjectiveFunction f=createFunction();Collection<LinearConstraint> constraints=createConstraints();SimplexTableau tableau=new SimplexTableau(f,constraints,GoalType.MAXIMIZE,false,1.0e-6);double[][]expectedTableau={{1,-15,-10,0,0,0,0},{0,1,0,1,0,0,2},{0,0,1,0,1,0,3},{0,1,1,0,0,1,4}};tableau.dropPhase1Objective();assertMatrixEquals(expectedTableau,tableau.getData());}
@Test public void testTableauWithNoArtificialVars(){LinearObjectiveFunction f=new LinearObjectiveFunction(new double[]{15,10},0);Collection<LinearConstraint> constraints=new ArrayList<LinearConstraint>();constraints.add(new LinearConstraint(new double[]{1,0},Relationship.LEQ,2));constraints.add(new LinearConstraint(new double[]{0,1},Relationship.LEQ,3));constraints.add(new LinearConstraint(new double[]{1,1},Relationship.LEQ,4));SimplexTableau tableau=new SimplexTableau(f,constraints,GoalType.MAXIMIZE,false,1.0e-6);double[][]initialTableau={{1,-15,-10,25,0,0,0,0},{0,1,0,-1,1,0,0,2},{0,0,1,-1,0,1,0,3},{0,1,1,-2,0,0,1,4}};assertMatrixEquals(initialTableau,tableau.getData());}
@Test public void testSerial(){LinearObjectiveFunction f=createFunction();Collection<LinearConstraint> constraints=createConstraints();SimplexTableau tableau=new SimplexTableau(f,constraints,GoalType.MAXIMIZE,false,1.0e-6);Assert.assertEquals(tableau,TestUtils.serializeAndRecover(tableau));}
/** * test dimensions */@Test public void testDimensions()throws ConvergenceException {checkDimension(MatrixUtils.createRealMatrix(testData3x3NonSingular));checkDimension(MatrixUtils.createRealMatrix(testData4x3));checkDimension(MatrixUtils.createRealMatrix(testData3x4));Random r=new Random(643895747384642l);int p=(5 * BlockRealMatrix.BLOCK_SIZE)/ 4;int q=(7 * BlockRealMatrix.BLOCK_SIZE)/ 4;checkDimension(createTestMatrix(r,p,q));checkDimension(createTestMatrix(r,q,p));}
/** * test A = QR */@Test public void testAEqualQR()throws ConvergenceException {checkAEqualQR(MatrixUtils.createRealMatrix(testData3x3NonSingular));checkAEqualQR(MatrixUtils.createRealMatrix(testData3x3Singular));checkAEqualQR(MatrixUtils.createRealMatrix(testData3x4));checkAEqualQR(MatrixUtils.createRealMatrix(testData4x3));Random r=new Random(643895747384642l);int p=(5 * BlockRealMatrix.BLOCK_SIZE)/ 4;int q=(7 * BlockRealMatrix.BLOCK_SIZE)/ 4;checkAEqualQR(createTestMatrix(r,p,q));checkAEqualQR(createTestMatrix(r,q,p));}
/** * test the orthogonality of Q */@Test public void testQOrthogonal()throws ConvergenceException {checkQOrthogonal(MatrixUtils.createRealMatrix(testData3x3NonSingular));checkQOrthogonal(MatrixUtils.createRealMatrix(testData3x3Singular));checkQOrthogonal(MatrixUtils.createRealMatrix(testData3x4));checkQOrthogonal(MatrixUtils.createRealMatrix(testData4x3));Random r=new Random(643895747384642l);int p=(5 * BlockRealMatrix.BLOCK_SIZE)/ 4;int q=(7 * BlockRealMatrix.BLOCK_SIZE)/ 4;checkQOrthogonal(createTestMatrix(r,p,q));checkQOrthogonal(createTestMatrix(r,q,p));}
/** * test that R is upper triangular */@Test public void testRUpperTriangular()throws ConvergenceException {RealMatrix matrix=MatrixUtils.createRealMatrix(testData3x3NonSingular);checkUpperTriangular(new PivotingQRDecomposition(matrix).getR());matrix=MatrixUtils.createRealMatrix(testData3x3Singular);checkUpperTriangular(new PivotingQRDecomposition(matrix).getR());matrix=MatrixUtils.createRealMatrix(testData3x4);checkUpperTriangular(new PivotingQRDecomposition(matrix).getR());matrix=MatrixUtils.createRealMatrix(testData4x3);checkUpperTriangular(new PivotingQRDecomposition(matrix).getR());Random r=new Random(643895747384642l);int p=(5 * BlockRealMatrix.BLOCK_SIZE)/ 4;int q=(7 * BlockRealMatrix.BLOCK_SIZE)/ 4;matrix=createTestMatrix(r,p,q);checkUpperTriangular(new PivotingQRDecomposition(matrix).getR());matrix=createTestMatrix(r,p,q);checkUpperTriangular(new PivotingQRDecomposition(matrix).getR());}
/** * test that H is trapezoidal */@Test public void testHTrapezoidal()throws ConvergenceException {RealMatrix matrix=MatrixUtils.createRealMatrix(testData3x3NonSingular);checkTrapezoidal(new PivotingQRDecomposition(matrix).getH());matrix=MatrixUtils.createRealMatrix(testData3x3Singular);checkTrapezoidal(new PivotingQRDecomposition(matrix).getH());matrix=MatrixUtils.createRealMatrix(testData3x4);checkTrapezoidal(new PivotingQRDecomposition(matrix).getH());matrix=MatrixUtils.createRealMatrix(testData4x3);checkTrapezoidal(new PivotingQRDecomposition(matrix).getH());Random r=new Random(643895747384642l);int p=(5 * BlockRealMatrix.BLOCK_SIZE)/ 4;int q=(7 * BlockRealMatrix.BLOCK_SIZE)/ 4;matrix=createTestMatrix(r,p,q);checkTrapezoidal(new PivotingQRDecomposition(matrix).getH());matrix=createTestMatrix(r,p,q);checkTrapezoidal(new PivotingQRDecomposition(matrix).getH());}
/** * test matrices values */@Test public void testMatricesValues()throws ConvergenceException {PivotingQRDecomposition qr=new PivotingQRDecomposition(MatrixUtils.createRealMatrix(testData3x3NonSingular),false);RealMatrix qRef=MatrixUtils.createRealMatrix(new double[][]{{-12.0 / 14.0,69.0 / 175.0,-58.0 / 175.0},{-6.0 / 14.0,-158.0 / 175.0,6.0 / 175.0},{4.0 / 14.0,-30.0 / 175.0,-165.0 / 175.0}});RealMatrix rRef=MatrixUtils.createRealMatrix(new double[][]{{-14.0,-21.0,14.0},{0.0,-175.0,70.0},{0.0,0.0,35.0}});RealMatrix hRef=MatrixUtils.createRealMatrix(new double[][]{{26.0 / 14.0,0.0,0.0},{6.0 / 14.0,648.0 / 325.0,0.0},{-4.0 / 14.0,36.0 / 325.0,2.0}});RealMatrix q=qr.getQ();Assert.assertEquals(0,q.subtract(qRef).getNorm(),1.0e-13);RealMatrix qT=qr.getQT();Assert.assertEquals(0,qT.subtract(qRef.transpose()).getNorm(),1.0e-13);RealMatrix r=qr.getR();Assert.assertEquals(0,r.subtract(rRef).getNorm(),1.0e-13);RealMatrix h=qr.getH();Assert.assertEquals(0,h.subtract(hRef).getNorm(),1.0e-13);Assert.assertTrue(q == qr.getQ());Assert.assertTrue(r == qr.getR());Assert.assertTrue(h == qr.getH());}
@Test(expected=NotStrictlyPositiveException.class)public void testPreconditions1(){new Logistic(1,0,1,1,0,-1);}
@Test(expected=NotStrictlyPositiveException.class)public void testPreconditions2(){new Logistic(1,0,1,1,0,0);}
@Test public void testCompareSigmoid(){final UnivariateFunction sig=new Sigmoid();final UnivariateFunction sigL=new Logistic(1,0,1,1,0,1);final double min=-2;final double max=2;final int n=100;final double delta=(max - min)/ n;for (int i=0;i < n;i++){final double x=min + i * delta;Assert.assertEquals("x=" + x,sig.value(x),sigL.value(x),EPS);}}
@Test public void testSomeValues(){final double k=4;final double m=5;final double b=2;final double q=3;final double a=-1;final double n=2;final UnivariateFunction f=new Logistic(k,m,b,q,a,n);double x;x=m;Assert.assertEquals("x=" + x,a + (k - a)/ FastMath.sqrt(1 + q),f.value(x),EPS);x=Double.NEGATIVE_INFINITY;Assert.assertEquals("x=" + x,a,f.value(x),EPS);x=Double.POSITIVE_INFINITY;Assert.assertEquals("x=" + x,k,f.value(x),EPS);}
@Test public void testCompareDerivativeSigmoid(){final double k=3;final double a=2;final Logistic f=new Logistic(k,0,1,1,a,1);final Sigmoid g=new Sigmoid(a,k);final UnivariateFunction dfdx=f.derivative();final UnivariateFunction dgdx=g.derivative();final double min=-10;final double max=10;final double n=20;final double delta=(max - min)/ n;for (int i=0;i < n;i++){final double x=min + i * delta;Assert.assertEquals("x=" + x,dgdx.value(x),dfdx.value(x),EPS);}}
@Test(expected=NullArgumentException.class)public void testParametricUsage1(){final Logistic.Parametric g=new Logistic.Parametric();g.value(0,null);}
@Test(expected=DimensionMismatchException.class)public void testParametricUsage2(){final Logistic.Parametric g=new Logistic.Parametric();g.value(0,new double[]{0});}
@Test(expected=NullArgumentException.class)public void testParametricUsage3(){final Logistic.Parametric g=new Logistic.Parametric();g.gradient(0,null);}
@Test(expected=DimensionMismatchException.class)public void testParametricUsage4(){final Logistic.Parametric g=new Logistic.Parametric();g.gradient(0,new double[]{0});}
@Test(expected=NotStrictlyPositiveException.class)public void testParametricUsage5(){final Logistic.Parametric g=new Logistic.Parametric();g.value(0,new double[]{1,0,1,1,0,0});}
@Test(expected=NotStrictlyPositiveException.class)public void testParametricUsage6(){final Logistic.Parametric g=new Logistic.Parametric();g.gradient(0,new double[]{1,0,1,1,0,0});}
@Test public void testGradientComponent0Component4(){final double k=3;final double a=2;final Logistic.Parametric f=new Logistic.Parametric();final Sigmoid.Parametric g=new Sigmoid.Parametric();final double x=0.12345;final double[]gf=f.gradient(x,new double[]{k,0,1,1,a,1});final double[]gg=g.gradient(x,new double[]{a,k});Assert.assertEquals(gg[0],gf[4],EPS);Assert.assertEquals(gg[1],gf[0],EPS);}
@Test public void testGradientComponent5(){final double m=1.2;final double k=3.4;final double a=2.3;final double q=0.567;final double b=-FastMath.log(q);final double n=3.4;final Logistic.Parametric f=new Logistic.Parametric();final double x=m - 1;final double qExp1=2;final double[]gf=f.gradient(x,new double[]{k,m,b,q,a,n});Assert.assertEquals((k - a)* FastMath.log(qExp1)/ (n * n * FastMath.pow(qExp1,1 / n)),gf[5],EPS);}
@Test public void testGradientComponent1Component2Component3(){final double m=1.2;final double k=3.4;final double a=2.3;final double b=0.567;final double q=1 / FastMath.exp(b * m);final double n=3.4;final Logistic.Parametric f=new Logistic.Parametric();final double x=0;final double qExp1=2;final double[]gf=f.gradient(x,new double[]{k,m,b,q,a,n});final double factor=(a - k)/ (n * FastMath.pow(qExp1,1 / n + 1));Assert.assertEquals(factor * b,gf[1],EPS);Assert.assertEquals(factor * m,gf[2],EPS);Assert.assertEquals(factor / q,gf[3],EPS);}
@Test public void testCumulative(){double[]x=new double[]{-0.1,0.0,0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9,1.0,1.1};checkCumulative(0.1,0.1,x,new double[]{0.0000000000,0.0000000000,0.4063850939,0.4397091902,0.4628041861,0.4821200456,0.5000000000,0.5178799544,0.5371958139,0.5602908098,0.5936149061,1.0000000000,1.0000000000});checkCumulative(0.1,0.5,x,new double[]{0.0000000000,0.0000000000,0.7048336221,0.7593042194,0.7951765304,0.8234948385,0.8480017124,0.8706034370,0.8926585878,0.9156406404,0.9423662883,1.0000000000,1.0000000000});checkCumulative(0.1,1.0,x,new double[]{0.0000000000,0.0000000000,0.7943282347,0.8513399225,0.8865681506,0.9124435366,0.9330329915,0.9502002165,0.9649610951,0.9779327685,0.9895192582,1.0000000000,1.0000000000});checkCumulative(0.1,2.0,x,new double[]{0.0000000000,0.0000000000,0.8658177758,0.9194471163,0.9486279211,0.9671901487,0.9796846411,0.9882082252,0.9939099280,0.9974914239,0.9994144508,1.0000000000,1.0000000000});checkCumulative(0.1,4.0,x,new double[]{0.0000000000,0.0000000000,0.9234991121,0.9661958941,0.9842285085,0.9928444112,0.9970040660,0.9989112804,0.9996895625,0.9999440793,0.9999967829,1.0000000000,1.0000000000});checkCumulative(0.5,0.1,x,new double[]{0.00000000000,0.00000000000,0.05763371168,0.08435935962,0.10734141216,0.12939656302,0.15199828760,0.17650516146,0.20482346963,0.24069578055,0.29516637795,1.00000000000,1.00000000000});checkCumulative(0.5,0.5,x,new double[]{0.0000000000,0.0000000000,0.2048327647,0.2951672353,0.3690101196,0.4359057832,0.5000000000,0.5640942168,0.6309898804,0.7048327647,0.7951672353,1.0000000000,1.0000000000});checkCumulative(0.5,1.0,x,new double[]{0.0000000000,0.0000000000,0.3162277660,0.4472135955,0.5477225575,0.6324555320,0.7071067812,0.7745966692,0.8366600265,0.8944271910,0.9486832981,1.0000000000,1.0000000000});checkCumulative(0.5,2.0,x,new double[]{0.0000000000,0.0000000000,0.4585302607,0.6260990337,0.7394254526,0.8221921916,0.8838834765,0.9295160031,0.9621590305,0.9838699101,0.9961174630,1.0000000000,1.0000000000});checkCumulative(0.5,4.0,x,new double[]{0.0000000000,0.0000000000,0.6266250826,0.8049844719,0.8987784842,0.9502644369,0.9777960959,0.9914837366,0.9974556254,0.9995223859,0.9999714889,1.0000000000,1.0000000000});checkCumulative(1.0,0.1,x,new double[]{0.00000000000,0.00000000000,0.01048074179,0.02206723146,0.03503890488,0.04979978349,0.06696700846,0.08755646344,0.11343184943,0.14866007748,0.20567176528,1.00000000000,1.00000000000});checkCumulative(1.0,0.5,x,new double[]{0.00000000000,0.00000000000,0.05131670195,0.10557280900,0.16333997347,0.22540333076,0.29289321881,0.36754446797,0.45227744249,0.55278640450,0.68377223398,1.00000000000,1.00000000000});checkCumulative(1,1,x,new double[]{0.0,0.0,0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9,1.0,1.0});checkCumulative(1,2,x,new double[]{0.00,0.00,0.19,0.36,0.51,0.64,0.75,0.84,0.91,0.96,0.99,1.00,1.00});checkCumulative(1,4,x,new double[]{0.0000,0.0000,0.3439,0.5904,0.7599,0.8704,0.9375,0.9744,0.9919,0.9984,0.9999,1.0000,1.0000});checkCumulative(2.0,0.1,x,new double[]{0.0000000000000,0.0000000000000,0.0005855492117,0.0025085760862,0.0060900720266,0.0117917748341,0.0203153588864,0.0328098512512,0.0513720788952,0.0805528836776,0.1341822241505,1.0000000000000,1.0000000000000});checkCumulative(2,1,x,new double[]{0.00,0.00,0.01,0.04,0.09,0.16,0.25,0.36,0.49,0.64,0.81,1.00,1.00});checkCumulative(2.0,0.5,x,new double[]{0.000000000000,0.000000000000,0.003882537047,0.016130089900,0.037840969486,0.070483996910,0.116116523517,0.177807808356,0.260574547368,0.373900966300,0.541469739276,1.000000000000,1.000000000000});checkCumulative(2,2,x,new double[]{0.000,0.000,0.028,0.104,0.216,0.352,0.500,0.648,0.784,0.896,0.972,1.000,1.000});checkCumulative(2,4,x,new double[]{0.00000,0.00000,0.08146,0.26272,0.47178,0.66304,0.81250,0.91296,0.96922,0.99328,0.99954,1.00000,1.00000});checkCumulative(4.0,0.1,x,new double[]{0.000000000e+00,0.000000000e+00,3.217128269e-06,5.592070271e-05,3.104375474e-04,1.088719595e-03,2.995933981e-03,7.155588777e-03,1.577149153e-02,3.380410585e-02,7.650088789e-02,1.000000000e+00,1.000000000e+00});checkCumulative(4.0,0.5,x,new double[]{0.000000000e+00,0.000000000e+00,2.851114863e-05,4.776140576e-04,2.544374616e-03,8.516263371e-03,2.220390414e-02,4.973556312e-02,1.012215158e-01,1.950155281e-01,3.733749174e-01,1.000000000e+00,1.000000000e+00});checkCumulative(4,1,x,new double[]{0.0000,0.0000,0.0001,0.0016,0.0081,0.0256,0.0625,0.1296,0.2401,0.4096,0.6561,1.0000,1.0000});checkCumulative(4,2,x,new double[]{0.00000,0.00000,0.00046,0.00672,0.03078,0.08704,0.18750,0.33696,0.52822,0.73728,0.91854,1.00000,1.00000});checkCumulative(4,4,x,new double[]{0.000000,0.000000,0.002728,0.033344,0.126036,0.289792,0.500000,0.710208,0.873964,0.966656,0.997272,1.000000,1.000000});}
@Test public void testDensity(){double[]x=new double[]{1e-6,0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9};checkDensity(0.1,0.1,x,new double[]{12741.2357380649,0.4429889586665234,2.639378715e-01,2.066393611e-01,1.832401831e-01,1.766302780e-01,1.832404579e-01,2.066400696e-01,2.639396531e-01,4.429925026e-01});checkDensity(0.1,0.5,x,new double[]{2.218377102e+04,7.394524202e-01,4.203020268e-01,3.119435533e-01,2.600787829e-01,2.330648626e-01,2.211408259e-01,2.222728708e-01,2.414013907e-01,3.070567405e-01});checkDensity(0.1,1.0,x,new double[]{2.511886432e+04,7.943210858e-01,4.256680458e-01,2.955218303e-01,2.281103709e-01,1.866062624e-01,1.583664652e-01,1.378514078e-01,1.222414585e-01,1.099464743e-01});checkDensity(0.1,2.0,x,new double[]{2.763072312e+04,7.863770012e-01,3.745874120e-01,2.275514842e-01,1.505525939e-01,1.026332391e-01,6.968107049e-02,4.549081293e-02,2.689298641e-02,1.209399123e-02});checkDensity(0.1,4.0,x,new double[]{2.997927462e+04,6.911058917e-01,2.601128486e-01,1.209774010e-01,5.880564714e-02,2.783915474e-02,1.209657335e-02,4.442148268e-03,1.167143939e-03,1.312171805e-04});checkDensity(0.5,0.1,x,new double[]{88.3152184726,0.3070542841,0.2414007269,0.2222727015,0.2211409364,0.2330652355,0.2600795198,0.3119449793,0.4203052841,0.7394649088});checkDensity(0.5,0.5,x,new double[]{318.3100453389,1.0610282383,0.7957732234,0.6946084565,0.6497470636,0.6366197724,0.6497476051,0.6946097796,0.7957762075,1.0610376697});checkDensity(0.5,1.0,x,new double[]{500.0000000000,1.5811309244,1.1180311937,0.9128694077,0.7905684268,0.7071060741,0.6454966865,0.5976138778,0.5590166450,0.5270459839});checkDensity(0.5,2.0,x,new double[]{749.99925000000,2.134537420613655,1.34163575536,0.95851150881,0.71151039830,0.53032849490,0.38729704363,0.26892534859,0.16770415497,0.07905610701});checkDensity(0.5,4.0,x,new double[]{1.093746719e+03,2.52142232809988,1.252190241e+00,6.849343920e-01,3.735417140e-01,1.933481570e-01,9.036885833e-02,3.529621669e-02,9.782644546e-03,1.152878503e-03});checkDensity(1.0,0.1,x,new double[]{0.1000000900,0.1099466942,0.1222417336,0.1378517623,0.1583669403,0.1866069342,0.2281113974,0.2955236034,0.4256718768,0.7943353837});checkDensity(1.0,0.5,x,new double[]{0.5000002500,0.5270465695,0.5590173438,0.5976147315,0.6454977623,0.7071074883,0.7905704033,0.9128724506,1.1180367838,1.5811467358});checkDensity(1,1,x,new double[]{1,1,1,1,1,1,1,1,1,1});checkDensity(1,2,x,new double[]{1.999998,1.799998,1.599998,1.399998,1.199998,0.999998,0.799998,0.599998,0.399998,0.199998});checkDensity(1,4,x,new double[]{3.999988000012,2.915990280011,2.047992320010,1.371994120008,0.863995680007,0.499997000006,0.255998080005,0.107998920004,0.031999520002,0.003999880001});checkDensity(2.0,0.1,x,new double[]{1.100000990e-07,1.209425730e-02,2.689331586e-02,4.549123318e-02,6.968162794e-02,1.026340191e-01,1.505537732e-01,2.275534997e-01,3.745917198e-01,7.863929037e-01});checkDensity(2.0,0.5,x,new double[]{7.500003750e-07,7.905777599e-02,1.677060417e-01,2.689275256e-01,3.872996256e-01,5.303316769e-01,7.115145488e-01,9.585174425e-01,1.341645818e+00,2.134537420613655});checkDensity(2,1,x,new double[]{0.000002,0.200002,0.400002,0.600002,0.800002,1.000002,1.200002,1.400002,1.600002,1.800002});checkDensity(2,2,x,new double[]{5.9999940e-06,5.4000480e-01,9.6000360e-01,1.2600024e+00,1.4400012e+00,1.5000000e+00,1.4399988e+00,1.2599976e+00,9.5999640e-01,5.3999520e-01});checkDensity(2,4,x,new double[]{0.00001999994,1.45800971996,2.04800255997,2.05799803998,1.72799567999,1.24999500000,0.76799552000,0.37799676001,0.12799824001,0.01799948000});checkDensity(4.0,0.1,x,new double[]{1.193501074e-19,1.312253162e-04,1.167181580e-03,4.442248535e-03,1.209679109e-02,2.783958903e-02,5.880649983e-02,1.209791638e-01,2.601171405e-01,6.911229392e-01});checkDensity(4.0,0.5,x,new double[]{1.093750547e-18,1.152948959e-03,9.782950259e-03,3.529697305e-02,9.037036449e-02,1.933508639e-01,3.735463833e-01,6.849425461e-01,1.252205894e+00,2.52142232809988});checkDensity(4,1,x,new double[]{4.000000000e-18,4.000120001e-03,3.200048000e-02,1.080010800e-01,2.560019200e-01,5.000030000e-01,8.640043200e-01,1.372005880e+00,2.048007680e+00,2.916009720e+00});checkDensity(4,2,x,new double[]{1.999998000e-17,1.800052000e-02,1.280017600e-01,3.780032400e-01,7.680044800e-01,1.250005000e+00,1.728004320e+00,2.058001960e+00,2.047997440e+00,1.457990280e+00});checkDensity(4,4,x,new double[]{1.399995800e-16,1.020627216e-01,5.734464512e-01,1.296547409e+00,1.935364838e+00,2.187500000e+00,1.935355162e+00,1.296532591e+00,5.734335488e-01,1.020572784e-01});}
@Test public void testMoments(){final double tol=1e-9;BetaDistribution dist;dist=new BetaDistribution(1,1);Assert.assertEquals(dist.getNumericalMean(),0.5,tol);Assert.assertEquals(dist.getNumericalVariance(),1.0 / 12.0,tol);dist=new BetaDistribution(2,5);Assert.assertEquals(dist.getNumericalMean(),2.0 / 7.0,tol);Assert.assertEquals(dist.getNumericalVariance(),10.0 / (49.0 * 8.0),tol);}
@Test public void testSpecialValues(){double[]testArray={0d,Double.NaN,Double.NEGATIVE_INFINITY,Double.POSITIVE_INFINITY};Max max=new Max();Assert.assertTrue(Double.isNaN(max.getResult()));max.increment(testArray[0]);Assert.assertEquals(0d,max.getResult(),0);max.increment(testArray[1]);Assert.assertEquals(0d,max.getResult(),0);max.increment(testArray[2]);Assert.assertEquals(0d,max.getResult(),0);max.increment(testArray[3]);Assert.assertEquals(Double.POSITIVE_INFINITY,max.getResult(),0);Assert.assertEquals(Double.POSITIVE_INFINITY,max.evaluate(testArray),0);}
@Test public void testNaNs(){Max max=new Max();double nan=Double.NaN;Assert.assertEquals(3d,max.evaluate(new double[]{nan,2d,3d}),0);Assert.assertEquals(3d,max.evaluate(new double[]{1d,nan,3d}),0);Assert.assertEquals(2d,max.evaluate(new double[]{1d,2d,nan}),0);Assert.assertTrue(Double.isNaN(max.evaluate(new double[]{nan,nan,nan})));}
/** * Verifies that increment()and incrementAll work properly.*/@Test public void testIncrementation()throws Exception {StorelessUnivariateStatistic statistic=(StorelessUnivariateStatistic)getUnivariateStatistic();for (int i=0;i < testArray.length;i++){statistic.increment(testArray[i]);}Assert.assertEquals(expectedValue(),statistic.getResult(),getTolerance());Assert.assertEquals(testArray.length,statistic.getN());statistic.clear();statistic.incrementAll(testArray);Assert.assertEquals(expectedValue(),statistic.getResult(),getTolerance());Assert.assertEquals(testArray.length,statistic.getN());statistic.clear();checkClearValue(statistic);Assert.assertEquals(0,statistic.getN());}
@Test public void testSerialization()throws Exception {StorelessUnivariateStatistic statistic=(StorelessUnivariateStatistic)getUnivariateStatistic();TestUtils.checkSerializedEquality(statistic);statistic.clear();for (int i=0;i < testArray.length;i++){statistic.increment(testArray[i]);if (i % 5 == 0)statistic=(StorelessUnivariateStatistic)TestUtils.serializeAndRecover(statistic);}TestUtils.checkSerializedEquality(statistic);Assert.assertEquals(expectedValue(),statistic.getResult(),getTolerance());statistic.clear();checkClearValue(statistic);}
@Test public void testEqualsAndHashCode(){StorelessUnivariateStatistic statistic=(StorelessUnivariateStatistic)getUnivariateStatistic();StorelessUnivariateStatistic statistic2=null;Assert.assertTrue("non-null,compared to null",!statistic.equals(statistic2));Assert.assertTrue("reflexive,non-null",statistic.equals(statistic));int emptyHash=statistic.hashCode();statistic2=(StorelessUnivariateStatistic)getUnivariateStatistic();Assert.assertTrue("empty stats should be equal",statistic.equals(statistic2));Assert.assertEquals("empty stats should have the same hashcode",emptyHash,statistic2.hashCode());statistic.increment(1d);Assert.assertTrue("reflexive,non-empty",statistic.equals(statistic));Assert.assertTrue("non-empty,compared to empty",!statistic.equals(statistic2));Assert.assertTrue("non-empty,compared to empty",!statistic2.equals(statistic));Assert.assertTrue("non-empty stat should have different hashcode from empty stat",statistic.hashCode()!= emptyHash);statistic2.increment(1d);Assert.assertTrue("stats with same data should be equal",statistic.equals(statistic2));Assert.assertEquals("stats with same data should have the same hashcode",statistic.hashCode(),statistic2.hashCode());statistic.increment(Double.POSITIVE_INFINITY);Assert.assertTrue("stats with different n's should not be equal",!statistic2.equals(statistic));Assert.assertTrue("stats with different n's should have different hashcodes",statistic.hashCode()!= statistic2.hashCode());statistic2.increment(Double.POSITIVE_INFINITY);Assert.assertTrue("stats with same data should be equal",statistic.equals(statistic2));Assert.assertEquals("stats with same data should have the same hashcode",statistic.hashCode(),statistic2.hashCode());statistic.clear();statistic2.clear();Assert.assertTrue("cleared stats should be equal",statistic.equals(statistic2));Assert.assertEquals("cleared stats should have thashcode of empty stat",emptyHash,statistic2.hashCode());Assert.assertEquals("cleared stats should have thashcode of empty stat",emptyHash,statistic.hashCode());}
@Test public void testMomentSmallSamples(){UnivariateStatistic stat=getUnivariateStatistic();if (stat instanceof SecondMoment){SecondMoment moment=(SecondMoment)getUnivariateStatistic();Assert.assertTrue(Double.isNaN(moment.getResult()));moment.increment(1d);Assert.assertEquals(0d,moment.getResult(),0);}}
/** * Make sure that evaluate(double[])and inrementAll(double[]),getResult()give same results.*/@Test public void testConsistency(){StorelessUnivariateStatistic stat=(StorelessUnivariateStatistic)getUnivariateStatistic();stat.incrementAll(testArray);Assert.assertEquals(stat.getResult(),stat.evaluate(testArray),getTolerance());for (int i=0;i < smallSamples.length;i++){stat.clear();for (int j=0;j < smallSamples[i].length;j++){stat.increment(smallSamples[i][j]);}TestUtils.assertEquals(stat.getResult(),stat.evaluate(smallSamples[i]),getTolerance());}}
/** * Verifies that copied statistics remain equal to originals when incremented the same way.*/@Test public void testCopyConsistency(){StorelessUnivariateStatistic master=(StorelessUnivariateStatistic)getUnivariateStatistic();StorelessUnivariateStatistic replica=null;long index=FastMath.round((FastMath.random())* testArray.length);master.incrementAll(testArray,0,(int)index);replica=master.copy();Assert.assertTrue(replica.equals(master));Assert.assertTrue(master.equals(replica));master.incrementAll(testArray,(int)index,(int)(testArray.length - index));replica.incrementAll(testArray,(int)index,(int)(testArray.length - index));Assert.assertTrue(replica.equals(master));Assert.assertTrue(master.equals(replica));}
@Test public void testSerial(){StorelessUnivariateStatistic s=(StorelessUnivariateStatistic)getUnivariateStatistic();Assert.assertEquals(s,TestUtils.serializeAndRecover(s));}
@Test public void testEvaluation()throws Exception {Assert.assertEquals(expectedValue(),getUnivariateStatistic().evaluate(testArray),getTolerance());}
@Test public void testEvaluateArraySegment(){final UnivariateStatistic stat=getUnivariateStatistic();final double[]arrayZero=new double[5];System.arraycopy(testArray,0,arrayZero,0,5);Assert.assertEquals(stat.evaluate(arrayZero),stat.evaluate(testArray,0,5),0);final double[]arrayOne=new double[5];System.arraycopy(testArray,5,arrayOne,0,5);Assert.assertEquals(stat.evaluate(arrayOne),stat.evaluate(testArray,5,5),0);final double[]arrayEnd=new double[5];System.arraycopy(testArray,testArray.length - 5,arrayEnd,0,5);Assert.assertEquals(stat.evaluate(arrayEnd),stat.evaluate(testArray,testArray.length - 5,5),0);}
@Test public void testEvaluateArraySegmentWeighted(){UnivariateStatistic statistic=getUnivariateStatistic();if (!(statistic instanceof WeightedEvaluation)){return;}final WeightedEvaluation stat=(WeightedEvaluation)getUnivariateStatistic();final double[]arrayZero=new double[5];final double[]weightZero=new double[5];System.arraycopy(testArray,0,arrayZero,0,5);System.arraycopy(testWeightsArray,0,weightZero,0,5);Assert.assertEquals(stat.evaluate(arrayZero,weightZero),stat.evaluate(testArray,testWeightsArray,0,5),0);final double[]arrayOne=new double[5];final double[]weightOne=new double[5];System.arraycopy(testArray,5,arrayOne,0,5);System.arraycopy(testWeightsArray,5,weightOne,0,5);Assert.assertEquals(stat.evaluate(arrayOne,weightOne),stat.evaluate(testArray,testWeightsArray,5,5),0);final double[]arrayEnd=new double[5];final double[]weightEnd=new double[5];System.arraycopy(testArray,testArray.length - 5,arrayEnd,0,5);System.arraycopy(testWeightsArray,testArray.length - 5,weightEnd,0,5);Assert.assertEquals(stat.evaluate(arrayEnd,weightEnd),stat.evaluate(testArray,testWeightsArray,testArray.length - 5,5),0);}
@Test public void testCopy()throws Exception {UnivariateStatistic original=getUnivariateStatistic();UnivariateStatistic copy=original.copy();Assert.assertEquals(expectedValue(),copy.evaluate(testArray),getTolerance());}
/** * Tests consistency of weighted statistic computation. For statistics that support weighted evaluation,this test case compares the result of direct computation on an array with repeated values with a weighted computation on the corresponding (shorter)array with each value appearing only once but with a weight value equal to its multiplicity in the repeating array.*/@Test public void testWeightedConsistency()throws Exception {UnivariateStatistic statistic=getUnivariateStatistic();if (!(statistic instanceof WeightedEvaluation)){return;}final int len=10;final double mu=0;final double sigma=5;double[]values=new double[len];double[]weights=new double[len];RandomData randomData=new RandomDataImpl();int[]intWeights=new int[len];for (int i=0;i < len;i++){intWeights[i]=randomData.nextInt(1,5);weights[i]=intWeights[i];}List<Double> valuesList=new ArrayList<Double>();for (int i=0;i < len;i++){double value=randomData.nextGaussian(mu,sigma);values[i]=value;for (int j=0;j < intWeights[i];j++){valuesList.add(new Double(value));}}int sumWeights=valuesList.size();double[]repeatedValues=new double[sumWeights];for (int i=0;i < sumWeights;i++){repeatedValues[i]=valuesList.get(i);}WeightedEvaluation weightedStatistic=(WeightedEvaluation)statistic;TestUtils.assertRelativelyEquals(statistic.evaluate(repeatedValues),weightedStatistic.evaluate(values,weights,0,values.length),10E-14);Assert.assertEquals(weightedStatistic.evaluate(values,weights,0,values.length),weightedStatistic.evaluate(values,weights),Double.MIN_VALUE);}
/** * Shows that an always failing test will fail even if it is retried.*/@Test(expected=MathIllegalStateException.class)@Retry public void testRetryFailAlways(){throw new MathIllegalStateException();}
/** * Shows that a test that sometimes fail might succeed if it is retried. In this case the high number of retries makes it quite unlikely that the exception will be thrown by all of the calls.*/@Test @Retry(100)public void testRetryFailSometimes(){if (rng.nextBoolean()){throw new MathIllegalStateException();}}
@Test public void testMissedEndEvent(){final double t0=1878250320.0000029;final double tEvent=1878250379.9999986;final double[]k={1.0e-4,1.0e-5,1.0e-6};FirstOrderDifferentialEquations ode=new FirstOrderDifferentialEquations(){public int getDimension(){return k.length;}public void computeDerivatives(double t,double[]y,double[]yDot){for (int i=0;i < y.length;++i){yDot[i]=k[i]* y[i];}}};ClassicalRungeKuttaIntegrator integrator=new ClassicalRungeKuttaIntegrator(60.0);double[]y0=new double[k.length];for (int i=0;i < y0.length;++i){y0[i]=i + 1;}double[]y=new double[k.length];double finalT=integrator.integrate(ode,t0,y0,tEvent,y);Assert.assertEquals(tEvent,finalT,5.0e-6);for (int i=0;i < y.length;++i){Assert.assertEquals(y0[i]* FastMath.exp(k[i]* (finalT - t0)),y[i],1.0e-9);}integrator.addEventHandler(new EventHandler(){public void init(double t0,double[]y0,double t){}public void resetState(double t,double[]y){}public double g(double t,double[]y){return t - tEvent;}public Action eventOccurred(double t,double[]y,boolean increasing){Assert.assertEquals(tEvent,t,5.0e-6);return Action.CONTINUE;}},Double.POSITIVE_INFINITY,1.0e-20,100);finalT=integrator.integrate(ode,t0,y0,tEvent + 120,y);Assert.assertEquals(tEvent + 120,finalT,5.0e-6);for (int i=0;i < y.length;++i){Assert.assertEquals(y0[i]* FastMath.exp(k[i]* (finalT - t0)),y[i],1.0e-9);}}
@Test public void testSanityChecks(){try {TestProblem1 pb=new TestProblem1();new ClassicalRungeKuttaIntegrator(0.01).integrate(pb,0.0,new double[pb.getDimension()+ 10],1.0,new double[pb.getDimension()]);Assert.fail("an exception should have been thrown");}catch(DimensionMismatchException ie){}try {TestProblem1 pb=new TestProblem1();new ClassicalRungeKuttaIntegrator(0.01).integrate(pb,0.0,new double[pb.getDimension()],1.0,new double[pb.getDimension()+ 10]);Assert.fail("an exception should have been thrown");}catch(DimensionMismatchException ie){}try {TestProblem1 pb=new TestProblem1();new ClassicalRungeKuttaIntegrator(0.01).integrate(pb,0.0,new double[pb.getDimension()],0.0,new double[pb.getDimension()]);Assert.fail("an exception should have been thrown");}catch(NumberIsTooSmallException ie){}}
@Test public void testDecreasingSteps(){TestProblemAbstract[]problems=TestProblemFactory.getProblems();for (int k=0;k < problems.length;++k){double previousValueError=Double.NaN;double previousTimeError=Double.NaN;for (int i=4;i < 10;++i){TestProblemAbstract pb=problems[k].copy();double step=(pb.getFinalTime()- pb.getInitialTime())* FastMath.pow(2.0,-i);FirstOrderIntegrator integ=new ClassicalRungeKuttaIntegrator(step);TestProblemHandler handler=new TestProblemHandler(pb,integ);integ.addStepHandler(handler);EventHandler[]functions=pb.getEventsHandlers();for (int l=0;l < functions.length;++l){integ.addEventHandler(functions[l],Double.POSITIVE_INFINITY,1.0e-6 * step,1000);}Assert.assertEquals(functions.length,integ.getEventHandlers().size());double stopTime=integ.integrate(pb,pb.getInitialTime(),pb.getInitialState(),pb.getFinalTime(),new double[pb.getDimension()]);if (functions.length == 0){Assert.assertEquals(pb.getFinalTime(),stopTime,1.0e-10);}double error=handler.getMaximalValueError();if (i > 4){Assert.assertTrue(error < 1.01 * FastMath.abs(previousValueError));}previousValueError=error;double timeError=handler.getMaximalTimeError();if (i > 4){Assert.assertTrue(timeError <= FastMath.abs(previousTimeError));}previousTimeError=timeError;integ.clearEventHandlers();Assert.assertEquals(0,integ.getEventHandlers().size());}}}
@Test public void testSmallStep(){TestProblem1 pb=new TestProblem1();double step=(pb.getFinalTime()- pb.getInitialTime())* 0.001;FirstOrderIntegrator integ=new ClassicalRungeKuttaIntegrator(step);TestProblemHandler handler=new TestProblemHandler(pb,integ);integ.addStepHandler(handler);integ.integrate(pb,pb.getInitialTime(),pb.getInitialState(),pb.getFinalTime(),new double[pb.getDimension()]);Assert.assertTrue(handler.getLastError()< 2.0e-13);Assert.assertTrue(handler.getMaximalValueError()< 4.0e-12);Assert.assertEquals(0,handler.getMaximalTimeError(),1.0e-12);Assert.assertEquals("classical Runge-Kutta",integ.getName());}
@Test public void testBigStep(){TestProblem1 pb=new TestProblem1();double step=(pb.getFinalTime()- pb.getInitialTime())* 0.2;FirstOrderIntegrator integ=new ClassicalRungeKuttaIntegrator(step);TestProblemHandler handler=new TestProblemHandler(pb,integ);integ.addStepHandler(handler);integ.integrate(pb,pb.getInitialTime(),pb.getInitialState(),pb.getFinalTime(),new double[pb.getDimension()]);Assert.assertTrue(handler.getLastError()> 0.0004);Assert.assertTrue(handler.getMaximalValueError()> 0.005);Assert.assertEquals(0,handler.getMaximalTimeError(),1.0e-12);}
@Test public void testBackward(){TestProblem5 pb=new TestProblem5();double step=FastMath.abs(pb.getFinalTime()- pb.getInitialTime())* 0.001;FirstOrderIntegrator integ=new ClassicalRungeKuttaIntegrator(step);TestProblemHandler handler=new TestProblemHandler(pb,integ);integ.addStepHandler(handler);integ.integrate(pb,pb.getInitialTime(),pb.getInitialState(),pb.getFinalTime(),new double[pb.getDimension()]);Assert.assertTrue(handler.getLastError()< 5.0e-10);Assert.assertTrue(handler.getMaximalValueError()< 7.0e-10);Assert.assertEquals(0,handler.getMaximalTimeError(),1.0e-12);Assert.assertEquals("classical Runge-Kutta",integ.getName());}
@Test public void testKepler(){final TestProblem3 pb=new TestProblem3(0.9);double step=(pb.getFinalTime()- pb.getInitialTime())* 0.0003;FirstOrderIntegrator integ=new ClassicalRungeKuttaIntegrator(step);integ.addStepHandler(new KeplerHandler(pb));integ.integrate(pb,pb.getInitialTime(),pb.getInitialState(),pb.getFinalTime(),new double[pb.getDimension()]);}
@Test public void testStepSize(){final double step=1.23456;FirstOrderIntegrator integ=new ClassicalRungeKuttaIntegrator(step);integ.addStepHandler(new StepHandler(){public void handleStep(StepInterpolator interpolator,boolean isLast){if (!isLast){Assert.assertEquals(step,interpolator.getCurrentTime()- interpolator.getPreviousTime(),1.0e-12);}}public void init(double t0,double[]y0,double t){}});integ.integrate(new FirstOrderDifferentialEquations(){public void computeDerivatives(double t,double[]y,double[]dot){dot[0]=1.0;}public int getDimension(){return 1;}},0.0,new double[]{0.0},5.0,new double[1]);}
/** * Test of integrator for the sine function.*/@Test public void testSinFunction(){UnivariateFunction f=new SinFunction();UnivariateRealIntegrator integrator=new SimpsonIntegrator();double min,max,expected,result,tolerance;min=0;max=FastMath.PI;expected=2;tolerance=FastMath.abs(expected * integrator.getRelativeAccuracy());result=integrator.integrate(1000,f,min,max);Assert.assertTrue(integrator.getEvaluations()< 100);Assert.assertTrue(integrator.getIterations()< 10);Assert.assertEquals(expected,result,tolerance);min=-FastMath.PI / 3;max=0;expected=-0.5;tolerance=FastMath.abs(expected * integrator.getRelativeAccuracy());result=integrator.integrate(1000,f,min,max);Assert.assertTrue(integrator.getEvaluations()< 50);Assert.assertTrue(integrator.getIterations()< 10);Assert.assertEquals(expected,result,tolerance);}
/** * Test of integrator for the quintic function.*/@Test public void testQuinticFunction(){UnivariateFunction f=new QuinticFunction();UnivariateRealIntegrator integrator=new SimpsonIntegrator();double min,max,expected,result,tolerance;min=0;max=1;expected=-1.0 / 48;tolerance=FastMath.abs(expected * integrator.getRelativeAccuracy());result=integrator.integrate(1000,f,min,max);Assert.assertTrue(integrator.getEvaluations()< 150);Assert.assertTrue(integrator.getIterations()< 10);Assert.assertEquals(expected,result,tolerance);min=0;max=0.5;expected=11.0 / 768;tolerance=FastMath.abs(expected * integrator.getRelativeAccuracy());result=integrator.integrate(1000,f,min,max);Assert.assertTrue(integrator.getEvaluations()< 100);Assert.assertTrue(integrator.getIterations()< 10);Assert.assertEquals(expected,result,tolerance);min=-1;max=4;expected=2048 / 3.0 - 78 + 1.0 / 48;tolerance=FastMath.abs(expected * integrator.getRelativeAccuracy());result=integrator.integrate(1000,f,min,max);Assert.assertTrue(integrator.getEvaluations()< 150);Assert.assertTrue(integrator.getIterations()< 10);Assert.assertEquals(expected,result,tolerance);}
/** * Test of parameters for the integrator.*/@Test public void testParameters()throws Exception {UnivariateFunction f=new SinFunction();try {new SimpsonIntegrator().integrate(1000,f,1,-1);Assert.fail("Expecting NumberIsTooLargeException - bad interval");}catch(NumberIsTooLargeException ex){}try {new SimpsonIntegrator(5,4);Assert.fail("Expecting NumberIsTooSmallException - bad iteration limits");}catch(NumberIsTooSmallException ex){}try {new SimpsonIntegrator(10,99);Assert.fail("Expecting NumberIsTooLargeException - bad iteration limits");}catch(NumberIsTooLargeException ex){}}
@Test public void derivativesConsistency(){TestProblem3 pb=new TestProblem3(0.1);double minStep=0;double maxStep=pb.getFinalTime()- pb.getInitialTime();double scalAbsoluteTolerance=1.0e-8;double scalRelativeTolerance=scalAbsoluteTolerance;DormandPrince54Integrator integ=new DormandPrince54Integrator(minStep,maxStep,scalAbsoluteTolerance,scalRelativeTolerance);StepInterpolatorTestUtils.checkDerivativesConsistency(integ,pb,1.0e-10);}
@Test public void serialization()throws IOException,ClassNotFoundException {TestProblem3 pb=new TestProblem3(0.9);double minStep=0;double maxStep=pb.getFinalTime()- pb.getInitialTime();double scalAbsoluteTolerance=1.0e-8;double scalRelativeTolerance=scalAbsoluteTolerance;DormandPrince54Integrator integ=new DormandPrince54Integrator(minStep,maxStep,scalAbsoluteTolerance,scalRelativeTolerance);integ.addStepHandler(new ContinuousOutputModel());integ.integrate(pb,pb.getInitialTime(),pb.getInitialState(),pb.getFinalTime(),new double[pb.getDimension()]);ByteArrayOutputStream bos=new ByteArrayOutputStream();ObjectOutputStream oos=new ObjectOutputStream(bos);for(StepHandler handler : integ.getStepHandlers()){oos.writeObject(handler);}Assert.assertTrue(bos.size()> 135000);Assert.assertTrue(bos.size()< 145000);ByteArrayInputStream bis=new ByteArrayInputStream(bos.toByteArray());ObjectInputStream ois=new ObjectInputStream(bis);ContinuousOutputModel cm=(ContinuousOutputModel)ois.readObject();Random random=new Random(347588535632l);double maxError=0.0;for (int i=0;i < 1000;++i){double r=random.nextDouble();double time=r * pb.getInitialTime()+ (1.0 - r)* pb.getFinalTime();cm.setInterpolatedTime(time);double[]interpolatedY=cm.getInterpolatedState();double[]theoreticalY=pb.computeTheoreticalState(time);double dx=interpolatedY[0]- theoreticalY[0];double dy=interpolatedY[1]- theoreticalY[1];double error=dx * dx + dy * dy;if (error > maxError){maxError=error;}}Assert.assertTrue(maxError < 7.0e-10);}
@Test public void checkClone(){TestProblem3 pb=new TestProblem3(0.9);double minStep=0;double maxStep=pb.getFinalTime()- pb.getInitialTime();double scalAbsoluteTolerance=1.0e-8;double scalRelativeTolerance=scalAbsoluteTolerance;DormandPrince54Integrator integ=new DormandPrince54Integrator(minStep,maxStep,scalAbsoluteTolerance,scalRelativeTolerance);integ.addStepHandler(new StepHandler(){public void handleStep(StepInterpolator interpolator,boolean isLast){StepInterpolator cloned=interpolator.copy();double tA=cloned.getPreviousTime();double tB=cloned.getCurrentTime();double halfStep=FastMath.abs(tB - tA)/ 2;Assert.assertEquals(interpolator.getPreviousTime(),tA,1.0e-12);Assert.assertEquals(interpolator.getCurrentTime(),tB,1.0e-12);for (int i=0;i < 10;++i){double t=(i * tB + (9 - i)* tA)/ 9;interpolator.setInterpolatedTime(t);Assert.assertTrue(FastMath.abs(cloned.getInterpolatedTime()- t)> (halfStep / 10));cloned.setInterpolatedTime(t);Assert.assertEquals(t,cloned.getInterpolatedTime(),1.0e-12);double[]referenceState=interpolator.getInterpolatedState();double[]cloneState=cloned.getInterpolatedState();for (int j=0;j < referenceState.length;++j){Assert.assertEquals(referenceState[j],cloneState[j],1.0e-12);}}}public void init(double t0,double[]y0,double t){}});integ.integrate(pb,pb.getInitialTime(),pb.getInitialState(),pb.getFinalTime(),new double[pb.getDimension()]);}
@Test public void testOnOnePoint(){double[]xval={0.5};double[]yval={0.7};double[]res=new LoessInterpolator().smooth(xval,yval);Assert.assertEquals(1,res.length);Assert.assertEquals(0.7,res[0],0.0);}
@Test public void testOnTwoPoints(){double[]xval={0.5,0.6};double[]yval={0.7,0.8};double[]res=new LoessInterpolator().smooth(xval,yval);Assert.assertEquals(2,res.length);Assert.assertEquals(0.7,res[0],0.0);Assert.assertEquals(0.8,res[1],0.0);}
@Test public void testOnStraightLine(){double[]xval={1,2,3,4,5};double[]yval={2,4,6,8,10};LoessInterpolator li=new LoessInterpolator(0.6,2,1e-12);double[]res=li.smooth(xval,yval);Assert.assertEquals(5,res.length);for (int i=0;i < 5;++i){Assert.assertEquals(yval[i],res[i],1e-8);}}
@Test public void testOnDistortedSine(){int numPoints=100;double[]xval=new double[numPoints];double[]yval=new double[numPoints];double xnoise=0.1;double ynoise=0.2;generateSineData(xval,yval,xnoise,ynoise);LoessInterpolator li=new LoessInterpolator(0.3,4,1e-12);double[]res=li.smooth(xval,yval);double noisyResidualSum=0;double fitResidualSum=0;for (int i=0;i < numPoints;++i){double expected=FastMath.sin(xval[i]);double noisy=yval[i];double fit=res[i];noisyResidualSum+=FastMath.pow(noisy - expected,2);fitResidualSum+=FastMath.pow(fit - expected,2);}Assert.assertTrue(fitResidualSum < noisyResidualSum);}
@Test public void testIncreasingBandwidthIncreasesSmoothness(){int numPoints=100;double[]xval=new double[numPoints];double[]yval=new double[numPoints];double xnoise=0.1;double ynoise=0.1;generateSineData(xval,yval,xnoise,ynoise);double[]bandwidths={0.1,0.5,1.0};double[]variances=new double[bandwidths.length];for (int i=0;i < bandwidths.length;i++){double bw=bandwidths[i];LoessInterpolator li=new LoessInterpolator(bw,4,1e-12);double[]res=li.smooth(xval,yval);for (int j=1;j < res.length;++j){variances[i]+=FastMath.pow(res[j]- res[j - 1],2);}}for (int i=1;i < variances.length;++i){Assert.assertTrue(variances[i]< variances[i - 1]);}}
@Test public void testIncreasingRobustnessItersIncreasesSmoothnessWithOutliers(){int numPoints=100;double[]xval=new double[numPoints];double[]yval=new double[numPoints];double xnoise=0.1;double ynoise=0.1;generateSineData(xval,yval,xnoise,ynoise);yval[numPoints / 3]*=100;yval[2 * numPoints / 3]*=-100;double[]variances=new double[4];for (int i=0;i < 4;i++){LoessInterpolator li=new LoessInterpolator(0.3,i,1e-12);double[]res=li.smooth(xval,yval);for (int j=1;j < res.length;++j){variances[i]+=FastMath.abs(res[j]- res[j - 1]);}}for (int i=1;i < variances.length;++i){Assert.assertTrue(variances[i]< variances[i - 1]);}}
@Test(expected=DimensionMismatchException.class)public void testUnequalSizeArguments(){new LoessInterpolator().smooth(new double[]{1,2,3},new double[]{1,2,3,4});}
@Test(expected=NoDataException.class)public void testEmptyData(){new LoessInterpolator().smooth(new double[]{},new double[]{});}
@Test(expected=NonMonotonicSequenceException.class)public void testNonStrictlyIncreasing1(){new LoessInterpolator().smooth(new double[]{4,3,1,2},new double[]{3,4,5,6});}
@Test(expected=NonMonotonicSequenceException.class)public void testNonStrictlyIncreasing2(){new LoessInterpolator().smooth(new double[]{1,2,2,3},new double[]{3,4,5,6});}
@Test(expected=NotFiniteNumberException.class)public void testNotAllFiniteReal1(){new LoessInterpolator().smooth(new double[]{1,2,Double.NaN},new double[]{3,4,5});}
@Test(expected=NotFiniteNumberException.class)public void testNotAllFiniteReal2(){new LoessInterpolator().smooth(new double[]{1,2,Double.POSITIVE_INFINITY},new double[]{3,4,5});}
@Test(expected=NotFiniteNumberException.class)public void testNotAllFiniteReal3(){new LoessInterpolator().smooth(new double[]{1,2,Double.NEGATIVE_INFINITY},new double[]{3,4,5});}
@Test(expected=NotFiniteNumberException.class)public void testNotAllFiniteReal4(){new LoessInterpolator().smooth(new double[]{3,4,5},new double[]{1,2,Double.NaN});}
@Test(expected=NotFiniteNumberException.class)public void testNotAllFiniteReal5(){new LoessInterpolator().smooth(new double[]{3,4,5},new double[]{1,2,Double.POSITIVE_INFINITY});}
@Test(expected=NotFiniteNumberException.class)public void testNotAllFiniteReal6(){new LoessInterpolator().smooth(new double[]{3,4,5},new double[]{1,2,Double.NEGATIVE_INFINITY});}
@Test(expected=NumberIsTooSmallException.class)public void testInsufficientBandwidth(){LoessInterpolator li=new LoessInterpolator(0.1,3,1e-12);li.smooth(new double[]{1,2,3,4,5,6,7,8,9,10,11,12},new double[]{1,2,3,4,5,6,7,8,9,10,11,12});}
@Test(expected=OutOfRangeException.class)public void testCompletelyIncorrectBandwidth1(){new LoessInterpolator(-0.2,3,1e-12);}
@Test(expected=OutOfRangeException.class)public void testCompletelyIncorrectBandwidth2(){new LoessInterpolator(1.1,3,1e-12);}
@Test public void testMath296withoutWeights(){double[]xval={0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9,1.0,1.1,1.2,1.3,1.4,1.5,1.6,1.7,1.8,1.9,2.0};double[]yval={0.47,0.48,0.55,0.56,-0.08,-0.04,-0.07,-0.07,-0.56,-0.46,-0.56,-0.52,-3.03,-3.08,-3.09,-3.04,3.54,3.46,3.36,3.35};double[]yref={0.461,0.499,0.541,0.308,0.175,-0.042,-0.072,-0.196,-0.311,-0.446,-0.557,-1.497,-2.133,-3.08,-3.09,-0.621,0.982,3.449,3.389,3.336};LoessInterpolator li=new LoessInterpolator(0.3,4,1e-12);double[]res=li.smooth(xval,yval);Assert.assertEquals(xval.length,res.length);for (int i=0;i < res.length;++i){Assert.assertEquals(yref[i],res[i],0.02);}}
@Test public void testMessageChain(){final ExceptionContext c=new ExceptionContext(new Exception("oops"));final String sep=" | ";final String m1="column index (0)";c.addMessage(LocalizedFormats.COLUMN_INDEX,0);final String m2="got 1x2 but expected 3x4";c.addMessage(LocalizedFormats.DIMENSIONS_MISMATCH_2x2,1,2,3,4);final String m3="It didn't work out";c.addMessage(LocalizedFormats.SIMPLE_MESSAGE,m3);Assert.assertEquals(c.getMessage(Locale.US,sep),m1 + sep + m2+ sep+ m3);}
@Test public void testNoArgAddMessage(){final ExceptionContext c=new ExceptionContext(new Exception("hello"));c.addMessage(LocalizedFormats.SIMPLE_MESSAGE);Assert.assertEquals(c.getMessage(),"{0}");}
@Test public void testContext(){final ExceptionContext c=new ExceptionContext(new Exception("bye"));final String[]keys={"Key 1","Key 2"};final Object[]values={"Value 1",Integer.valueOf(2)};for (int i=0;i < keys.length;i++){c.setValue(keys[i],values[i]);}Assert.assertTrue(c.getKeys().containsAll(Arrays.asList(keys)));for (int i=0;i < keys.length;i++){Assert.assertEquals(values[i],c.getValue(keys[i]));}Assert.assertNull(c.getValue("xyz"));}
@Test public void testSerialize()throws IOException,ClassNotFoundException {final ExceptionContext cOut=new ExceptionContext(new Exception("Apache"));cOut.addMessage(LocalizedFormats.COLUMN_INDEX,0);cOut.setValue("Key 1",Integer.valueOf(0));ByteArrayOutputStream bos=new ByteArrayOutputStream();ObjectOutputStream oos=new ObjectOutputStream(bos);oos.writeObject(cOut);ByteArrayInputStream bis=new ByteArrayInputStream(bos.toByteArray());ObjectInputStream ois=new ObjectInputStream(bis);ExceptionContext cIn=(ExceptionContext)ois.readObject();Assert.assertTrue(cOut.getMessage().equals(cIn.getMessage()));for(String key : cIn.getKeys()){Assert.assertTrue(cOut.getValue(key).equals(cIn.getValue(key)));}}
@Test public void testSerializeUnserializable()throws Exception {final ExceptionContext cOut=new ExceptionContext(new Exception("Apache Commons Math"));cOut.addMessage(LocalizedFormats.SIMPLE_MESSAGE,"OK");cOut.addMessage(LocalizedFormats.SIMPLE_MESSAGE,new Unserializable());String key="Key 1";cOut.setValue(key,new Unserializable());{ByteArrayOutputStream bos=new ByteArrayOutputStream();ObjectOutputStream oos=new ObjectOutputStream(bos);oos.writeObject(cOut);ByteArrayInputStream bis=new ByteArrayInputStream(bos.toByteArray());ObjectInputStream ois=new ObjectInputStream(bis);ExceptionContext cIn=(ExceptionContext)ois.readObject();String nsObjStr=(String)cIn.getValue(key);Assert.assertTrue(nsObjStr.matches(".*could not be serialized.*"));}}
/** * test freq counts */@Test public void testCounts(){Assert.assertEquals("total count",0,f.getSumFreq());f.addValue(oneL);f.addValue(twoL);f.addValue(1);f.addValue(oneI);Assert.assertEquals("one frequency count",3,f.getCount(1));Assert.assertEquals("two frequency count",1,f.getCount(2));Assert.assertEquals("three frequency count",0,f.getCount(3));Assert.assertEquals("total count",4,f.getSumFreq());Assert.assertEquals("zero cumulative frequency",0,f.getCumFreq(0));Assert.assertEquals("one cumulative frequency",3,f.getCumFreq(1));Assert.assertEquals("two cumulative frequency",4,f.getCumFreq(2));Assert.assertEquals("Integer argument cum freq",4,f.getCumFreq(Integer.valueOf(2)));Assert.assertEquals("five cumulative frequency",4,f.getCumFreq(5));Assert.assertEquals("foo cumulative frequency",0,f.getCumFreq("foo"));f.clear();Assert.assertEquals("total count",0,f.getSumFreq());f.addValue("one");f.addValue("One");f.addValue("oNe");f.addValue("Z");Assert.assertEquals("one cumulative frequency",1,f.getCount("one"));Assert.assertEquals("Z cumulative pct",0.5,f.getCumPct("Z"),tolerance);Assert.assertEquals("z cumulative pct",1.0,f.getCumPct("z"),tolerance);Assert.assertEquals("Ot cumulative pct",0.25,f.getCumPct("Ot"),tolerance);f.clear();f=null;Frequency f=new Frequency();f.addValue(1);f.addValue(Integer.valueOf(1));f.addValue(Long.valueOf(1));f.addValue(2);f.addValue(Integer.valueOf(-1));Assert.assertEquals("1 count",3,f.getCount(1));Assert.assertEquals("1 count",3,f.getCount(Integer.valueOf(1)));Assert.assertEquals("0 cum pct",0.2,f.getCumPct(0),tolerance);Assert.assertEquals("1 pct",0.6,f.getPct(Integer.valueOf(1)),tolerance);Assert.assertEquals("-2 cum pct",0,f.getCumPct(-2),tolerance);Assert.assertEquals("10 cum pct",1,f.getCumPct(10),tolerance);f=null;f=new Frequency(String.CASE_INSENSITIVE_ORDER);f.addValue("one");f.addValue("One");f.addValue("oNe");f.addValue("Z");Assert.assertEquals("one count",3,f.getCount("one"));Assert.assertEquals("Z cumulative pct -- case insensitive",1,f.getCumPct("Z"),tolerance);Assert.assertEquals("z cumulative pct -- case insensitive",1,f.getCumPct("z"),tolerance);f=null;f=new Frequency();Assert.assertEquals(0L,f.getCount('a'));Assert.assertEquals(0L,f.getCumFreq('b'));TestUtils.assertEquals(Double.NaN,f.getPct('a'),0.0);TestUtils.assertEquals(Double.NaN,f.getCumPct('b'),0.0);f.addValue('a');f.addValue('b');f.addValue('c');f.addValue('d');Assert.assertEquals(1L,f.getCount('a'));Assert.assertEquals(2L,f.getCumFreq('b'));Assert.assertEquals(0.25,f.getPct('a'),0.0);Assert.assertEquals(0.5,f.getCumPct('b'),0.0);Assert.assertEquals(1.0,f.getCumPct('e'),0.0);}
/** * test pcts */@Test public void testPcts(){f.addValue(oneL);f.addValue(twoL);f.addValue(oneI);f.addValue(twoI);f.addValue(threeL);f.addValue(threeL);f.addValue(3);f.addValue(threeI);Assert.assertEquals("one pct",0.25,f.getPct(1),tolerance);Assert.assertEquals("two pct",0.25,f.getPct(Long.valueOf(2)),tolerance);Assert.assertEquals("three pct",0.5,f.getPct(threeL),tolerance);Assert.assertEquals("five pct",0,f.getPct(5),tolerance);Assert.assertEquals("foo pct",0,f.getPct("foo"),tolerance);Assert.assertEquals("one cum pct",0.25,f.getCumPct(1),tolerance);Assert.assertEquals("two cum pct",0.50,f.getCumPct(Long.valueOf(2)),tolerance);Assert.assertEquals("Integer argument",0.50,f.getCumPct(Integer.valueOf(2)),tolerance);Assert.assertEquals("three cum pct",1.0,f.getCumPct(threeL),tolerance);Assert.assertEquals("five cum pct",1.0,f.getCumPct(5),tolerance);Assert.assertEquals("zero cum pct",0.0,f.getCumPct(0),tolerance);Assert.assertEquals("foo cum pct",0,f.getCumPct("foo"),tolerance);}
/** * test adding incomparable values */@Test public void testAdd(){char aChar='a';char bChar='b';String aString="a";f.addValue(aChar);f.addValue(bChar);try {f.addValue(aString);Assert.fail("Expecting IllegalArgumentException");}catch(IllegalArgumentException ex){}try {f.addValue(2);Assert.fail("Expecting IllegalArgumentException");}catch(IllegalArgumentException ex){}Assert.assertEquals("a pct",0.5,f.getPct(aChar),tolerance);Assert.assertEquals("b cum pct",1.0,f.getCumPct(bChar),tolerance);Assert.assertEquals("a string pct",0.0,f.getPct(aString),tolerance);Assert.assertEquals("a string cum pct",0.0,f.getCumPct(aString),tolerance);f=new Frequency();f.addValue("One");try {f.addValue(new Integer("One"));Assert.fail("Expecting IllegalArgumentException");}catch(IllegalArgumentException ex){}}
/** * test empty table */@Test public void testEmptyTable(){Assert.assertEquals("freq sum,empty table",0,f.getSumFreq());Assert.assertEquals("count,empty table",0,f.getCount(0));Assert.assertEquals("count,empty table",0,f.getCount(Integer.valueOf(0)));Assert.assertEquals("cum freq,empty table",0,f.getCumFreq(0));Assert.assertEquals("cum freq,empty table",0,f.getCumFreq("x"));Assert.assertTrue("pct,empty table",Double.isNaN(f.getPct(0)));Assert.assertTrue("pct,empty table",Double.isNaN(f.getPct(Integer.valueOf(0))));Assert.assertTrue("cum pct,empty table",Double.isNaN(f.getCumPct(0)));Assert.assertTrue("cum pct,empty table",Double.isNaN(f.getCumPct(Integer.valueOf(0))));}
/** * Tests toString()*/@Test public void testToString()throws Exception {f.addValue(oneL);f.addValue(twoL);f.addValue(oneI);f.addValue(twoI);String s=f.toString();Assert.assertNotNull(s);BufferedReader reader=new BufferedReader(new StringReader(s));String line=reader.readLine();Assert.assertNotNull(line);line=reader.readLine();Assert.assertNotNull(line);line=reader.readLine();Assert.assertNotNull(line);line=reader.readLine();Assert.assertNull(line);}
@Test public void testIntegerValues(){Comparable<?> obj1=null;obj1=Integer.valueOf(1);Integer int1=Integer.valueOf(1);f.addValue(obj1);f.addValue(int1);f.addValue(2);f.addValue(Long.valueOf(2));Assert.assertEquals("Integer 1 count",2,f.getCount(1));Assert.assertEquals("Integer 1 count",2,f.getCount(Integer.valueOf(1)));Assert.assertEquals("Integer 1 count",2,f.getCount(Long.valueOf(1)));Assert.assertEquals("Integer 1 cumPct",0.5,f.getCumPct(1),tolerance);Assert.assertEquals("Integer 1 cumPct",0.5,f.getCumPct(Long.valueOf(1)),tolerance);Assert.assertEquals("Integer 1 cumPct",0.5,f.getCumPct(Integer.valueOf(1)),tolerance);Iterator<?> it=f.valuesIterator();while (it.hasNext()){Assert.assertTrue(it.next()instanceof Long);}}
@Test public void testSerial(){f.addValue(oneL);f.addValue(twoL);f.addValue(oneI);f.addValue(twoI);Assert.assertEquals(f,TestUtils.serializeAndRecover(f));}
@Test public void testGetUniqueCount(){Assert.assertEquals(0,f.getUniqueCount());f.addValue(oneL);Assert.assertEquals(1,f.getUniqueCount());f.addValue(oneL);Assert.assertEquals(1,f.getUniqueCount());f.addValue(twoI);Assert.assertEquals(2,f.getUniqueCount());}
@Test(expected=NumberIsTooLargeException.class)public void testMath679(){new OpenMapRealMatrix(3,Integer.MAX_VALUE);}
@Test(expected=DimensionMismatchException.class)public void dimensionCheck(){TestProblem1 pb=new TestProblem1();FirstOrderIntegrator integ=new AdamsMoultonIntegrator(2,0.0,1.0,1.0e-10,1.0e-10);integ.integrate(pb,0.0,new double[pb.getDimension()+ 10],1.0,new double[pb.getDimension()+ 10]);}
@Test(expected=NumberIsTooSmallException.class)public void testMinStep(){TestProblem1 pb=new TestProblem1();double minStep=0.1 * (pb.getFinalTime()- pb.getInitialTime());double maxStep=pb.getFinalTime()- pb.getInitialTime();double[]vecAbsoluteTolerance={1.0e-15,1.0e-16};double[]vecRelativeTolerance={1.0e-15,1.0e-16};FirstOrderIntegrator integ=new AdamsMoultonIntegrator(4,minStep,maxStep,vecAbsoluteTolerance,vecRelativeTolerance);TestProblemHandler handler=new TestProblemHandler(pb,integ);integ.addStepHandler(handler);integ.integrate(pb,pb.getInitialTime(),pb.getInitialState(),pb.getFinalTime(),new double[pb.getDimension()]);}
@Test public void testIncreasingTolerance(){int previousCalls=Integer.MAX_VALUE;for (int i=-12;i < -2;++i){TestProblem1 pb=new TestProblem1();double minStep=0;double maxStep=pb.getFinalTime()- pb.getInitialTime();double scalAbsoluteTolerance=FastMath.pow(10.0,i);double scalRelativeTolerance=0.01 * scalAbsoluteTolerance;FirstOrderIntegrator integ=new AdamsMoultonIntegrator(4,minStep,maxStep,scalAbsoluteTolerance,scalRelativeTolerance);TestProblemHandler handler=new TestProblemHandler(pb,integ);integ.addStepHandler(handler);integ.integrate(pb,pb.getInitialTime(),pb.getInitialState(),pb.getFinalTime(),new double[pb.getDimension()]);Assert.assertTrue(handler.getMaximalValueError()> (0.5 * scalAbsoluteTolerance));Assert.assertTrue(handler.getMaximalValueError()< (11.0 * scalAbsoluteTolerance));Assert.assertEquals(0,handler.getMaximalTimeError(),1.0e-16);int calls=pb.getCalls();Assert.assertEquals(integ.getEvaluations(),calls);Assert.assertTrue(calls <= previousCalls);previousCalls=calls;}}
@Test(expected=MaxCountExceededException.class)public void exceedMaxEvaluations(){TestProblem1 pb=new TestProblem1();double range=pb.getFinalTime()- pb.getInitialTime();AdamsMoultonIntegrator integ=new AdamsMoultonIntegrator(2,0,range,1.0e-12,1.0e-12);TestProblemHandler handler=new TestProblemHandler(pb,integ);integ.addStepHandler(handler);integ.setMaxEvaluations(650);integ.integrate(pb,pb.getInitialTime(),pb.getInitialState(),pb.getFinalTime(),new double[pb.getDimension()]);}
@Test public void backward(){TestProblem5 pb=new TestProblem5();double range=FastMath.abs(pb.getFinalTime()- pb.getInitialTime());FirstOrderIntegrator integ=new AdamsMoultonIntegrator(4,0,range,1.0e-12,1.0e-12);TestProblemHandler handler=new TestProblemHandler(pb,integ);integ.addStepHandler(handler);integ.integrate(pb,pb.getInitialTime(),pb.getInitialState(),pb.getFinalTime(),new double[pb.getDimension()]);Assert.assertTrue(handler.getLastError()< 1.0e-9);Assert.assertTrue(handler.getMaximalValueError()< 1.0e-9);Assert.assertEquals(0,handler.getMaximalTimeError(),1.0e-16);Assert.assertEquals("Adams-Moulton",integ.getName());}
@Test public void polynomial(){TestProblem6 pb=new TestProblem6();double range=FastMath.abs(pb.getFinalTime()- pb.getInitialTime());for (int nSteps=2;nSteps < 8;++nSteps){AdamsMoultonIntegrator integ=new AdamsMoultonIntegrator(nSteps,1.0e-6 * range,0.1 * range,1.0e-5,1.0e-5);TestProblemHandler handler=new TestProblemHandler(pb,integ);integ.addStepHandler(handler);integ.integrate(pb,pb.getInitialTime(),pb.getInitialState(),pb.getFinalTime(),new double[pb.getDimension()]);if (nSteps < 4){Assert.assertTrue(handler.getMaximalValueError()> 7.0e-04);}else {Assert.assertTrue(handler.getMaximalValueError()< 3.0e-13);}}}
@Test public void testMath303(){LevenbergMarquardtOptimizer optimizer=new LevenbergMarquardtOptimizer();CurveFitter fitter=new CurveFitter(optimizer);fitter.addObservedPoint(2.805d,0.6934785852953367d);fitter.addObservedPoint(2.74333333333333d,0.6306772025518496d);fitter.addObservedPoint(1.655d,0.9474675497289684);fitter.addObservedPoint(1.725d,0.9013594835804194d);ParametricUnivariateFunction sif=new SimpleInverseFunction();double[]initialguess1=new double[1];initialguess1[0]=1.0d;Assert.assertEquals(1,fitter.fit(sif,initialguess1).length);double[]initialguess2=new double[2];initialguess2[0]=1.0d;initialguess2[1]=.5d;Assert.assertEquals(2,fitter.fit(sif,initialguess2).length);}
@Test public void testMath304(){LevenbergMarquardtOptimizer optimizer=new LevenbergMarquardtOptimizer();CurveFitter fitter=new CurveFitter(optimizer);fitter.addObservedPoint(2.805d,0.6934785852953367d);fitter.addObservedPoint(2.74333333333333d,0.6306772025518496d);fitter.addObservedPoint(1.655d,0.9474675497289684);fitter.addObservedPoint(1.725d,0.9013594835804194d);ParametricUnivariateFunction sif=new SimpleInverseFunction();double[]initialguess1=new double[1];initialguess1[0]=1.0d;Assert.assertEquals(1.6357215104109237,fitter.fit(sif,initialguess1)[0],1.0e-14);double[]initialguess2=new double[1];initialguess2[0]=10.0d;Assert.assertEquals(1.6357215104109237,fitter.fit(sif,initialguess1)[0],1.0e-14);}
@Test public void testMath372(){LevenbergMarquardtOptimizer optimizer=new LevenbergMarquardtOptimizer();CurveFitter curveFitter=new CurveFitter(optimizer);curveFitter.addObservedPoint(15,4443);curveFitter.addObservedPoint(31,8493);curveFitter.addObservedPoint(62,17586);curveFitter.addObservedPoint(125,30582);curveFitter.addObservedPoint(250,45087);curveFitter.addObservedPoint(500,50683);ParametricUnivariateFunction f=new ParametricUnivariateFunction(){public double value(double x,double... parameters){double a=parameters[0];double b=parameters[1];double c=parameters[2];double d=parameters[3];return d + ((a - d)/ (1 + FastMath.pow(x / c,b)));}public double[]gradient(double x,double... parameters){double a=parameters[0];double b=parameters[1];double c=parameters[2];double d=parameters[3];double[]gradients=new double[4];double den=1 + FastMath.pow(x / c,b);gradients[0]=1 / den;gradients[1]=-((a - d)* FastMath.pow(x / c,b)* FastMath.log(x / c))/ (den * den);gradients[2]=(b * FastMath.pow(x / c,b - 1)* (x / (c * c))* (a - d))/ (den * den);gradients[3]=1 - (1 / den);return gradients;}};double[]initialGuess=new double[]{1500,0.95,65,35000};double[]estimatedParameters=curveFitter.fit(f,initialGuess);Assert.assertEquals(2411.00,estimatedParameters[0],500.00);Assert.assertEquals(1.62,estimatedParameters[1],0.04);Assert.assertEquals(111.22,estimatedParameters[2],0.30);Assert.assertEquals(55347.47,estimatedParameters[3],300.00);Assert.assertTrue(optimizer.getRMS()< 600.0);}
@Test public void testZero(){Assert.assertEquals(BigReal.ZERO,BigRealField.getInstance().getZero());}
@Test public void testOne(){Assert.assertEquals(BigReal.ONE,BigRealField.getInstance().getOne());}
@Test public void testSerial(){BigRealField field=BigRealField.getInstance();Assert.assertTrue(field == TestUtils.serializeAndRecover(field));}
@Test(expected=NumberIsTooLargeException.class)public void testInitOutOfBounds(){double[]startPoint=point(DIM,3);double[][]boundaries=boundaries(DIM,-1,2);doTest(new Rosen(),startPoint,boundaries,GoalType.MINIMIZE,1e-13,1e-6,2000,null);}
@Test(expected=DimensionMismatchException.class)public void testBoundariesDimensionMismatch(){double[]startPoint=point(DIM,0.5);double[][]boundaries=boundaries(DIM + 1,-1,2);doTest(new Rosen(),startPoint,boundaries,GoalType.MINIMIZE,1e-13,1e-6,2000,null);}
@Test(expected=NumberIsTooSmallException.class)public void testProblemDimensionTooSmall(){double[]startPoint=point(1,0.5);doTest(new Rosen(),startPoint,null,GoalType.MINIMIZE,1e-13,1e-6,2000,null);}
@Test(expected=TooManyEvaluationsException.class)public void testMaxEvaluations(){final int lowMaxEval=2;double[]startPoint=point(DIM,0.1);double[][]boundaries=null;doTest(new Rosen(),startPoint,boundaries,GoalType.MINIMIZE,1e-13,1e-6,lowMaxEval,null);}
@Test public void testRosen(){double[]startPoint=point(DIM,0.1);double[][]boundaries=null;RealPointValuePair expected=new RealPointValuePair(point(DIM,1.0),0.0);doTest(new Rosen(),startPoint,boundaries,GoalType.MINIMIZE,1e-13,1e-6,2000,expected);}
@Test public void testMaximize(){double[]startPoint=point(DIM,1.0);double[][]boundaries=null;RealPointValuePair expected=new RealPointValuePair(point(DIM,0.0),1.0);doTest(new MinusElli(),startPoint,boundaries,GoalType.MAXIMIZE,2e-10,5e-6,1000,expected);boundaries=boundaries(DIM,-0.3,0.3);startPoint=point(DIM,0.1);doTest(new MinusElli(),startPoint,boundaries,GoalType.MAXIMIZE,2e-10,5e-6,1000,expected);}
@Test public void testEllipse(){double[]startPoint=point(DIM,1.0);double[][]boundaries=null;RealPointValuePair expected=new RealPointValuePair(point(DIM,0.0),0.0);doTest(new Elli(),startPoint,boundaries,GoalType.MINIMIZE,1e-13,1e-6,1000,expected);}
@Test public void testElliRotated(){double[]startPoint=point(DIM,1.0);double[][]boundaries=null;RealPointValuePair expected=new RealPointValuePair(point(DIM,0.0),0.0);doTest(new ElliRotated(),startPoint,boundaries,GoalType.MINIMIZE,1e-12,1e-6,10000,expected);}
@Test public void testCigar(){double[]startPoint=point(DIM,1.0);double[][]boundaries=null;RealPointValuePair expected=new RealPointValuePair(point(DIM,0.0),0.0);doTest(new Cigar(),startPoint,boundaries,GoalType.MINIMIZE,1e-13,1e-6,100,expected);}
@Test public void testTwoAxes(){double[]startPoint=point(DIM,1.0);double[][]boundaries=null;RealPointValuePair expected=new RealPointValuePair(point(DIM,0.0),0.0);doTest(new TwoAxes(),startPoint,boundaries,GoalType.MINIMIZE,2 * 1e-13,1e-6,100,expected);}
@Test public void testCigTab(){double[]startPoint=point(DIM,1.0);double[][]boundaries=null;RealPointValuePair expected=new RealPointValuePair(point(DIM,0.0),0.0);doTest(new CigTab(),startPoint,boundaries,GoalType.MINIMIZE,1e-13,5e-5,100,expected);}
@Test public void testSphere(){double[]startPoint=point(DIM,1.0);double[][]boundaries=null;RealPointValuePair expected=new RealPointValuePair(point(DIM,0.0),0.0);doTest(new Sphere(),startPoint,boundaries,GoalType.MINIMIZE,1e-13,1e-6,100,expected);}
@Test public void testTablet(){double[]startPoint=point(DIM,1.0);double[][]boundaries=null;RealPointValuePair expected=new RealPointValuePair(point(DIM,0.0),0.0);doTest(new Tablet(),startPoint,boundaries,GoalType.MINIMIZE,1e-13,1e-6,100,expected);}
@Test public void testDiffPow(){}
@Test public void testSsDiffPow(){double[]startPoint=point(DIM / 2,1.0);double[][]boundaries=null;RealPointValuePair expected=new RealPointValuePair(point(DIM / 2,0.0),0.0);doTest(new SsDiffPow(),startPoint,boundaries,GoalType.MINIMIZE,1e-2,1.3e-1,50000,expected);}
@Test public void testAckley(){}
@Test public void testRastrigin(){double[]startPoint=point(DIM,1.0);double[][]boundaries=null;RealPointValuePair expected=new RealPointValuePair(point(DIM,0.0),0.0);doTest(new Rastrigin(),startPoint,boundaries,GoalType.MINIMIZE,1e-13,1e-6,1000,expected);}
@Test public void testConstrainedRosen(){double[]startPoint=point(DIM,0.1);double[][]boundaries=boundaries(DIM,-1,2);RealPointValuePair expected=new RealPointValuePair(point(DIM,1.0),0.0);doTest(new Rosen(),startPoint,boundaries,GoalType.MINIMIZE,1e-13,1e-6,2000,expected);}
/** * Test of transformer for the ad hoc data.*/@Test public void testAdHocData(){FastCosineTransformer transformer=new FastCosineTransformer();double result[],tolerance=1E-12;double x[]={0.0,1.0,4.0,9.0,16.0,25.0,36.0,49.0,64.0};double y[]={172.0,-105.096569476353,27.3137084989848,-12.9593152353742,8.0,-5.78585076868676,4.68629150101524,-4.15826451958632,4.0};result=transformer.transform(x);for (int i=0;i < result.length;i++){Assert.assertEquals(y[i],result[i],tolerance);}result=transformer.inversetransform(y);for (int i=0;i < result.length;i++){Assert.assertEquals(x[i],result[i],tolerance);}FastFourierTransformer.scaleArray(x,FastMath.sqrt(0.5 * (x.length - 1)));result=transformer.transform2(y);for (int i=0;i < result.length;i++){Assert.assertEquals(x[i],result[i],tolerance);}result=transformer.inversetransform2(x);for (int i=0;i < result.length;i++){Assert.assertEquals(y[i],result[i],tolerance);}}
/** * Test of transformer for the sine function.*/@Test public void testSinFunction(){UnivariateFunction f=new SinFunction();FastCosineTransformer transformer=new FastCosineTransformer();double min,max,result[],tolerance=1E-12;int N=9;double expected[]={0.0,3.26197262739567,0.0,-2.17958042710327,0.0,-0.648846697642915,0.0,-0.433545502649478,0.0};min=0.0;max=2.0 * FastMath.PI * N / (N - 1);result=transformer.transform(f,min,max,N);for (int i=0;i < N;i++){Assert.assertEquals(expected[i],result[i],tolerance);}min=-FastMath.PI;max=FastMath.PI * (N + 1)/ (N - 1);result=transformer.transform(f,min,max,N);for (int i=0;i < N;i++){Assert.assertEquals(-expected[i],result[i],tolerance);}}
/** * Test of parameters for the transformer.*/@Test public void testParameters()throws Exception {UnivariateFunction f=new SinFunction();FastCosineTransformer transformer=new FastCosineTransformer();try {transformer.transform(f,1,-1,65);Assert.fail("Expecting IllegalArgumentException - bad interval");}catch(IllegalArgumentException ex){}try {transformer.transform(f,-1,1,1);Assert.fail("Expecting IllegalArgumentException - bad samples number");}catch(IllegalArgumentException ex){}try {transformer.transform(f,-1,1,64);Assert.fail("Expecting IllegalArgumentException - bad samples number");}catch(IllegalArgumentException ex){}}
/** * test stats */@Test public void testStats(){List<Object> externalList=new ArrayList<Object>();DescriptiveStatistics u=new ListUnivariateImpl(externalList);Assert.assertEquals("total count",0,u.getN(),tolerance);u.addValue(one);u.addValue(two);u.addValue(two);u.addValue(three);Assert.assertEquals("N",n,u.getN(),tolerance);Assert.assertEquals("sum",sum,u.getSum(),tolerance);Assert.assertEquals("sumsq",sumSq,u.getSumsq(),tolerance);Assert.assertEquals("var",var,u.getVariance(),tolerance);Assert.assertEquals("std",std,u.getStandardDeviation(),tolerance);Assert.assertEquals("mean",mean,u.getMean(),tolerance);Assert.assertEquals("min",min,u.getMin(),tolerance);Assert.assertEquals("max",max,u.getMax(),tolerance);u.clear();Assert.assertEquals("total count",0,u.getN(),tolerance);}
@Test public void testN0andN1Conditions()throws Exception {List<Object> list=new ArrayList<Object>();DescriptiveStatistics u=new ListUnivariateImpl(list);Assert.assertTrue("Mean of n = 0 set should be NaN",Double.isNaN(u.getMean()));Assert.assertTrue("Standard Deviation of n = 0 set should be NaN",Double.isNaN(u.getStandardDeviation()));Assert.assertTrue("Variance of n = 0 set should be NaN",Double.isNaN(u.getVariance()));list.add(Double.valueOf(one));Assert.assertTrue("Mean of n = 1 set should be value of single item n1",u.getMean()== one);Assert.assertTrue("StdDev of n = 1 set should be zero,instead it is: " + u.getStandardDeviation(),u.getStandardDeviation()== 0);Assert.assertTrue("Variance of n = 1 set should be zero",u.getVariance()== 0);}
@Test public void testSkewAndKurtosis(){DescriptiveStatistics u=new DescriptiveStatistics();double[]testArray={12.5,12,11.8,14.2,14.9,14.5,21,8.2,10.3,11.3,14.1,9.9,12.2,12,12.1,11,19.8,11,10,8.8,9,12.3};for (int i=0;i < testArray.length;i++){u.addValue(testArray[i]);}Assert.assertEquals("mean",12.40455,u.getMean(),0.0001);Assert.assertEquals("variance",10.00236,u.getVariance(),0.0001);Assert.assertEquals("skewness",1.437424,u.getSkewness(),0.0001);Assert.assertEquals("kurtosis",2.37719,u.getKurtosis(),0.0001);}
@Test public void testProductAndGeometricMean()throws Exception {ListUnivariateImpl u=new ListUnivariateImpl(new ArrayList<Object>());u.setWindowSize(10);u.addValue(1.0);u.addValue(2.0);u.addValue(3.0);u.addValue(4.0);Assert.assertEquals("Geometric mean not expected",2.213364,u.getGeometricMean(),0.00001);for (int i=0;i < 10;i++){u.addValue(i + 2);}Assert.assertEquals("Geometric mean not expected",5.755931,u.getGeometricMean(),0.00001);}
/** * test stats */@Test public void testSerialization(){DescriptiveStatistics u=new ListUnivariateImpl();Assert.assertEquals("total count",0,u.getN(),tolerance);u.addValue(one);u.addValue(two);DescriptiveStatistics u2=(DescriptiveStatistics)TestUtils.serializeAndRecover(u);u2.addValue(two);u2.addValue(three);Assert.assertEquals("N",n,u2.getN(),tolerance);Assert.assertEquals("sum",sum,u2.getSum(),tolerance);Assert.assertEquals("sumsq",sumSq,u2.getSumsq(),tolerance);Assert.assertEquals("var",var,u2.getVariance(),tolerance);Assert.assertEquals("std",std,u2.getStandardDeviation(),tolerance);Assert.assertEquals("mean",mean,u2.getMean(),tolerance);Assert.assertEquals("min",min,u2.getMin(),tolerance);Assert.assertEquals("max",max,u2.getMax(),tolerance);u2.clear();Assert.assertEquals("total count",0,u2.getN(),tolerance);}
/** */@Test public void testSinZero(){DifferentiableUnivariateFunction f=new SinFunction();double result;NewtonSolver solver=new NewtonSolver();result=solver.solve(100,f,3,4);Assert.assertEquals(result,FastMath.PI,solver.getAbsoluteAccuracy());result=solver.solve(100,f,1,4);Assert.assertEquals(result,FastMath.PI,solver.getAbsoluteAccuracy());Assert.assertTrue(solver.getEvaluations()> 0);}
/** */@Test public void testQuinticZero(){DifferentiableUnivariateFunction f=new QuinticFunction();double result;NewtonSolver solver=new NewtonSolver();result=solver.solve(100,f,-0.2,0.2);Assert.assertEquals(result,0,solver.getAbsoluteAccuracy());result=solver.solve(100,f,-0.1,0.3);Assert.assertEquals(result,0,solver.getAbsoluteAccuracy());result=solver.solve(100,f,-0.3,0.45);Assert.assertEquals(result,0,solver.getAbsoluteAccuracy());result=solver.solve(100,f,0.3,0.7);Assert.assertEquals(result,0.5,solver.getAbsoluteAccuracy());result=solver.solve(100,f,0.2,0.6);Assert.assertEquals(result,0.5,solver.getAbsoluteAccuracy());result=solver.solve(100,f,0.05,0.95);Assert.assertEquals(result,0.5,solver.getAbsoluteAccuracy());result=solver.solve(100,f,0.85,1.25);Assert.assertEquals(result,1.0,solver.getAbsoluteAccuracy());result=solver.solve(100,f,0.8,1.2);Assert.assertEquals(result,1.0,solver.getAbsoluteAccuracy());result=solver.solve(100,f,0.85,1.75);Assert.assertEquals(result,1.0,solver.getAbsoluteAccuracy());result=solver.solve(100,f,0.55,1.45);Assert.assertEquals(result,1.0,solver.getAbsoluteAccuracy());result=solver.solve(100,f,0.85,5);Assert.assertEquals(result,1.0,solver.getAbsoluteAccuracy());}
@Test public void testEqualsIncludingNaN(){double[]testArray={Double.NaN,Double.POSITIVE_INFINITY,Double.NEGATIVE_INFINITY,1d,0d};for (int i=0;i < testArray.length;i++){for (int j=0;j < testArray.length;j++){if (i == j){Assert.assertTrue(Precision.equalsIncludingNaN(testArray[i],testArray[j]));Assert.assertTrue(Precision.equalsIncludingNaN(testArray[j],testArray[i]));}else {Assert.assertTrue(!Precision.equalsIncludingNaN(testArray[i],testArray[j]));Assert.assertTrue(!Precision.equalsIncludingNaN(testArray[j],testArray[i]));}}}}
@Test public void testEqualsWithAllowedDelta(){Assert.assertTrue(Precision.equals(153.0000,153.0000,.0625));Assert.assertTrue(Precision.equals(153.0000,153.0625,.0625));Assert.assertTrue(Precision.equals(152.9375,153.0000,.0625));Assert.assertFalse(Precision.equals(153.0000,153.0625,.0624));Assert.assertFalse(Precision.equals(152.9374,153.0000,.0625));Assert.assertFalse(Precision.equals(Double.NaN,Double.NaN,1.0));Assert.assertTrue(Precision.equals(Double.POSITIVE_INFINITY,Double.POSITIVE_INFINITY,1.0));Assert.assertTrue(Precision.equals(Double.NEGATIVE_INFINITY,Double.NEGATIVE_INFINITY,1.0));Assert.assertFalse(Precision.equals(Double.NEGATIVE_INFINITY,Double.POSITIVE_INFINITY,1.0));}
@Test public void testMath475(){final double a=1.7976931348623182E16;final double b=FastMath.nextUp(a);double diff=FastMath.abs(a - b);Assert.assertTrue(Precision.equals(a,b,0.5 * diff));final double c=FastMath.nextUp(b);diff=FastMath.abs(a - c);Assert.assertTrue(Precision.equals(a,c,diff));Assert.assertFalse(Precision.equals(a,c,(1 - 1e-16)* diff));}
@Test public void testEqualsIncludingNaNWithAllowedDelta(){Assert.assertTrue(Precision.equalsIncludingNaN(153.0000,153.0000,.0625));Assert.assertTrue(Precision.equalsIncludingNaN(153.0000,153.0625,.0625));Assert.assertTrue(Precision.equalsIncludingNaN(152.9375,153.0000,.0625));Assert.assertTrue(Precision.equalsIncludingNaN(Double.NaN,Double.NaN,1.0));Assert.assertTrue(Precision.equalsIncludingNaN(Double.POSITIVE_INFINITY,Double.POSITIVE_INFINITY,1.0));Assert.assertTrue(Precision.equalsIncludingNaN(Double.NEGATIVE_INFINITY,Double.NEGATIVE_INFINITY,1.0));Assert.assertFalse(Precision.equalsIncludingNaN(Double.NEGATIVE_INFINITY,Double.POSITIVE_INFINITY,1.0));Assert.assertFalse(Precision.equalsIncludingNaN(153.0000,153.0625,.0624));Assert.assertFalse(Precision.equalsIncludingNaN(152.9374,153.0000,.0625));}
@Test public void testFloatEqualsWithAllowedUlps(){Assert.assertTrue("+0.0f == -0.0f",Precision.equals(0.0f,-0.0f));Assert.assertTrue("+0.0f == -0.0f (1 ulp)",Precision.equals(0.0f,-0.0f,1));float oneFloat=1.0f;Assert.assertTrue("1.0f == 1.0f + 1 ulp",Precision.equals(oneFloat,Float.intBitsToFloat(1 + Float.floatToIntBits(oneFloat))));Assert.assertTrue("1.0f == 1.0f + 1 ulp (1 ulp)",Precision.equals(oneFloat,Float.intBitsToFloat(1 + Float.floatToIntBits(oneFloat)),1));Assert.assertFalse("1.0f != 1.0f + 2 ulp (1 ulp)",Precision.equals(oneFloat,Float.intBitsToFloat(2 + Float.floatToIntBits(oneFloat)),1));Assert.assertTrue(Precision.equals(153.0f,153.0f,1));Assert.assertTrue(Precision.equals(Float.POSITIVE_INFINITY,Float.POSITIVE_INFINITY,1));Assert.assertTrue(Precision.equals(Double.MAX_VALUE,Float.POSITIVE_INFINITY,1));Assert.assertTrue(Precision.equals(Float.NEGATIVE_INFINITY,Float.NEGATIVE_INFINITY,1));Assert.assertTrue(Precision.equals(-Float.MAX_VALUE,Float.NEGATIVE_INFINITY,1));Assert.assertFalse(Precision.equals(Float.NaN,Float.NaN,1));Assert.assertFalse(Precision.equals(Float.NaN,Float.NaN,0));Assert.assertFalse(Precision.equals(Float.NaN,0,0));Assert.assertFalse(Precision.equals(Float.NaN,Float.POSITIVE_INFINITY,0));Assert.assertFalse(Precision.equals(Float.NaN,Float.NEGATIVE_INFINITY,0));Assert.assertFalse(Precision.equals(Float.NEGATIVE_INFINITY,Float.POSITIVE_INFINITY,100000));}
@Test public void testEqualsWithAllowedUlps(){Assert.assertTrue(Precision.equals(0.0,-0.0,1));Assert.assertTrue(Precision.equals(1.0,1 + FastMath.ulp(1d),1));Assert.assertFalse(Precision.equals(1.0,1 + 2 * FastMath.ulp(1d),1));final double nUp1=FastMath.nextAfter(1d,Double.POSITIVE_INFINITY);final double nnUp1=FastMath.nextAfter(nUp1,Double.POSITIVE_INFINITY);Assert.assertTrue(Precision.equals(1.0,nUp1,1));Assert.assertTrue(Precision.equals(nUp1,nnUp1,1));Assert.assertFalse(Precision.equals(1.0,nnUp1,1));Assert.assertTrue(Precision.equals(0.0,FastMath.ulp(0d),1));Assert.assertTrue(Precision.equals(0.0,-FastMath.ulp(0d),1));Assert.assertTrue(Precision.equals(153.0,153.0,1));Assert.assertTrue(Precision.equals(153.0,153.00000000000003,1));Assert.assertFalse(Precision.equals(153.0,153.00000000000006,1));Assert.assertTrue(Precision.equals(153.0,152.99999999999997,1));Assert.assertFalse(Precision.equals(153,152.99999999999994,1));Assert.assertTrue(Precision.equals(-128.0,-127.99999999999999,1));Assert.assertFalse(Precision.equals(-128.0,-127.99999999999997,1));Assert.assertTrue(Precision.equals(-128.0,-128.00000000000003,1));Assert.assertFalse(Precision.equals(-128.0,-128.00000000000006,1));Assert.assertTrue(Precision.equals(Double.POSITIVE_INFINITY,Double.POSITIVE_INFINITY,1));Assert.assertTrue(Precision.equals(Double.MAX_VALUE,Double.POSITIVE_INFINITY,1));Assert.assertTrue(Precision.equals(Double.NEGATIVE_INFINITY,Double.NEGATIVE_INFINITY,1));Assert.assertTrue(Precision.equals(-Double.MAX_VALUE,Double.NEGATIVE_INFINITY,1));Assert.assertFalse(Precision.equals(Double.NaN,Double.NaN,1));Assert.assertFalse(Precision.equals(Double.NaN,Double.NaN,0));Assert.assertFalse(Precision.equals(Double.NaN,0,0));Assert.assertFalse(Precision.equals(Double.NaN,Double.POSITIVE_INFINITY,0));Assert.assertFalse(Precision.equals(Double.NaN,Double.NEGATIVE_INFINITY,0));Assert.assertFalse(Precision.equals(Double.NEGATIVE_INFINITY,Double.POSITIVE_INFINITY,100000));}
@Test public void testEqualsIncludingNaNWithAllowedUlps(){Assert.assertTrue(Precision.equalsIncludingNaN(0.0,-0.0,1));Assert.assertTrue(Precision.equalsIncludingNaN(1.0,1 + FastMath.ulp(1d),1));Assert.assertFalse(Precision.equalsIncludingNaN(1.0,1 + 2 * FastMath.ulp(1d),1));final double nUp1=FastMath.nextAfter(1d,Double.POSITIVE_INFINITY);final double nnUp1=FastMath.nextAfter(nUp1,Double.POSITIVE_INFINITY);Assert.assertTrue(Precision.equalsIncludingNaN(1.0,nUp1,1));Assert.assertTrue(Precision.equalsIncludingNaN(nUp1,nnUp1,1));Assert.assertFalse(Precision.equalsIncludingNaN(1.0,nnUp1,1));Assert.assertTrue(Precision.equalsIncludingNaN(0.0,FastMath.ulp(0d),1));Assert.assertTrue(Precision.equalsIncludingNaN(0.0,-FastMath.ulp(0d),1));Assert.assertTrue(Precision.equalsIncludingNaN(153.0,153.0,1));Assert.assertTrue(Precision.equalsIncludingNaN(153.0,153.00000000000003,1));Assert.assertFalse(Precision.equalsIncludingNaN(153.0,153.00000000000006,1));Assert.assertTrue(Precision.equalsIncludingNaN(153.0,152.99999999999997,1));Assert.assertFalse(Precision.equalsIncludingNaN(153,152.99999999999994,1));Assert.assertTrue(Precision.equalsIncludingNaN(-128.0,-127.99999999999999,1));Assert.assertFalse(Precision.equalsIncludingNaN(-128.0,-127.99999999999997,1));Assert.assertTrue(Precision.equalsIncludingNaN(-128.0,-128.00000000000003,1));Assert.assertFalse(Precision.equalsIncludingNaN(-128.0,-128.00000000000006,1));Assert.assertTrue(Precision.equalsIncludingNaN(Double.POSITIVE_INFINITY,Double.POSITIVE_INFINITY,1));Assert.assertTrue(Precision.equalsIncludingNaN(Double.MAX_VALUE,Double.POSITIVE_INFINITY,1));Assert.assertTrue(Precision.equalsIncludingNaN(Double.NEGATIVE_INFINITY,Double.NEGATIVE_INFINITY,1));Assert.assertTrue(Precision.equalsIncludingNaN(-Double.MAX_VALUE,Double.NEGATIVE_INFINITY,1));Assert.assertTrue(Precision.equalsIncludingNaN(Double.NaN,Double.NaN,1));Assert.assertFalse(Precision.equalsIncludingNaN(Double.NEGATIVE_INFINITY,Double.POSITIVE_INFINITY,100000));}
@Test public void testCompareToEpsilon(){Assert.assertEquals(0,Precision.compareTo(152.33,152.32,.011));Assert.assertTrue(Precision.compareTo(152.308,152.32,.011)< 0);Assert.assertTrue(Precision.compareTo(152.33,152.318,.011)> 0);Assert.assertEquals(0,Precision.compareTo(Double.MIN_VALUE,+0.0,Double.MIN_VALUE));Assert.assertEquals(0,Precision.compareTo(Double.MIN_VALUE,-0.0,Double.MIN_VALUE));}
@Test public void testCompareToMaxUlps(){double a=152.32;double delta=FastMath.ulp(a);for (int i=0;i <= 10;++i){if (i <= 5){Assert.assertEquals(0,Precision.compareTo(a,a + i * delta,5));Assert.assertEquals(0,Precision.compareTo(a,a - i * delta,5));}else {Assert.assertEquals(-1,Precision.compareTo(a,a + i * delta,5));Assert.assertEquals(+1,Precision.compareTo(a,a - i * delta,5));}}Assert.assertEquals(0,Precision.compareTo(-0.0,0.0,0));Assert.assertEquals(-1,Precision.compareTo(-Double.MIN_VALUE,-0.0,0));Assert.assertEquals(0,Precision.compareTo(-Double.MIN_VALUE,-0.0,1));Assert.assertEquals(-1,Precision.compareTo(-Double.MIN_VALUE,+0.0,0));Assert.assertEquals(0,Precision.compareTo(-Double.MIN_VALUE,+0.0,1));Assert.assertEquals(+1,Precision.compareTo(Double.MIN_VALUE,-0.0,0));Assert.assertEquals(0,Precision.compareTo(Double.MIN_VALUE,-0.0,1));Assert.assertEquals(+1,Precision.compareTo(Double.MIN_VALUE,+0.0,0));Assert.assertEquals(0,Precision.compareTo(Double.MIN_VALUE,+0.0,1));Assert.assertEquals(-1,Precision.compareTo(-Double.MIN_VALUE,Double.MIN_VALUE,0));Assert.assertEquals(-1,Precision.compareTo(-Double.MIN_VALUE,Double.MIN_VALUE,1));Assert.assertEquals(0,Precision.compareTo(-Double.MIN_VALUE,Double.MIN_VALUE,2));Assert.assertEquals(0,Precision.compareTo(Double.MAX_VALUE,Double.POSITIVE_INFINITY,1));Assert.assertEquals(-1,Precision.compareTo(Double.MAX_VALUE,Double.POSITIVE_INFINITY,0));Assert.assertEquals(+1,Precision.compareTo(Double.MAX_VALUE,Double.NaN,Integer.MAX_VALUE));Assert.assertEquals(+1,Precision.compareTo(Double.NaN,Double.MAX_VALUE,Integer.MAX_VALUE));}
@Test public void testRoundDouble(){double x=1.234567890;Assert.assertEquals(1.23,Precision.round(x,2),0.0);Assert.assertEquals(1.235,Precision.round(x,3),0.0);Assert.assertEquals(1.2346,Precision.round(x,4),0.0);Assert.assertEquals(39.25,Precision.round(39.245,2),0.0);Assert.assertEquals(39.24,Precision.round(39.245,2,BigDecimal.ROUND_DOWN),0.0);double xx=39.0;xx=xx + 245d / 1000d;Assert.assertEquals(39.25,Precision.round(xx,2),0.0);Assert.assertEquals(30.1d,Precision.round(30.095d,2),0.0d);Assert.assertEquals(30.1d,Precision.round(30.095d,1),0.0d);Assert.assertEquals(33.1d,Precision.round(33.095d,1),0.0d);Assert.assertEquals(33.1d,Precision.round(33.095d,2),0.0d);Assert.assertEquals(50.09d,Precision.round(50.085d,2),0.0d);Assert.assertEquals(50.19d,Precision.round(50.185d,2),0.0d);Assert.assertEquals(50.01d,Precision.round(50.005d,2),0.0d);Assert.assertEquals(30.01d,Precision.round(30.005d,2),0.0d);Assert.assertEquals(30.65d,Precision.round(30.645d,2),0.0d);Assert.assertEquals(1.24,Precision.round(x,2,BigDecimal.ROUND_CEILING),0.0);Assert.assertEquals(1.235,Precision.round(x,3,BigDecimal.ROUND_CEILING),0.0);Assert.assertEquals(1.2346,Precision.round(x,4,BigDecimal.ROUND_CEILING),0.0);Assert.assertEquals(-1.23,Precision.round(-x,2,BigDecimal.ROUND_CEILING),0.0);Assert.assertEquals(-1.234,Precision.round(-x,3,BigDecimal.ROUND_CEILING),0.0);Assert.assertEquals(-1.2345,Precision.round(-x,4,BigDecimal.ROUND_CEILING),0.0);Assert.assertEquals(1.23,Precision.round(x,2,BigDecimal.ROUND_DOWN),0.0);Assert.assertEquals(1.234,Precision.round(x,3,BigDecimal.ROUND_DOWN),0.0);Assert.assertEquals(1.2345,Precision.round(x,4,BigDecimal.ROUND_DOWN),0.0);Assert.assertEquals(-1.23,Precision.round(-x,2,BigDecimal.ROUND_DOWN),0.0);Assert.assertEquals(-1.234,Precision.round(-x,3,BigDecimal.ROUND_DOWN),0.0);Assert.assertEquals(-1.2345,Precision.round(-x,4,BigDecimal.ROUND_DOWN),0.0);Assert.assertEquals(1.23,Precision.round(x,2,BigDecimal.ROUND_FLOOR),0.0);Assert.assertEquals(1.234,Precision.round(x,3,BigDecimal.ROUND_FLOOR),0.0);Assert.assertEquals(1.2345,Precision.round(x,4,BigDecimal.ROUND_FLOOR),0.0);Assert.assertEquals(-1.24,Precision.round(-x,2,BigDecimal.ROUND_FLOOR),0.0);Assert.assertEquals(-1.235,Precision.round(-x,3,BigDecimal.ROUND_FLOOR),0.0);Assert.assertEquals(-1.2346,Precision.round(-x,4,BigDecimal.ROUND_FLOOR),0.0);Assert.assertEquals(1.23,Precision.round(x,2,BigDecimal.ROUND_HALF_DOWN),0.0);Assert.assertEquals(1.235,Precision.round(x,3,BigDecimal.ROUND_HALF_DOWN),0.0);Assert.assertEquals(1.2346,Precision.round(x,4,BigDecimal.ROUND_HALF_DOWN),0.0);Assert.assertEquals(-1.23,Precision.round(-x,2,BigDecimal.ROUND_HALF_DOWN),0.0);Assert.assertEquals(-1.235,Precision.round(-x,3,BigDecimal.ROUND_HALF_DOWN),0.0);Assert.assertEquals(-1.2346,Precision.round(-x,4,BigDecimal.ROUND_HALF_DOWN),0.0);Assert.assertEquals(1.234,Precision.round(1.2345,3,BigDecimal.ROUND_HALF_DOWN),0.0);Assert.assertEquals(-1.234,Precision.round(-1.2345,3,BigDecimal.ROUND_HALF_DOWN),0.0);Assert.assertEquals(1.23,Precision.round(x,2,BigDecimal.ROUND_HALF_EVEN),0.0);Assert.assertEquals(1.235,Precision.round(x,3,BigDecimal.ROUND_HALF_EVEN),0.0);Assert.assertEquals(1.2346,Precision.round(x,4,BigDecimal.ROUND_HALF_EVEN),0.0);Assert.assertEquals(-1.23,Precision.round(-x,2,BigDecimal.ROUND_HALF_EVEN),0.0);Assert.assertEquals(-1.235,Precision.round(-x,3,BigDecimal.ROUND_HALF_EVEN),0.0);Assert.assertEquals(-1.2346,Precision.round(-x,4,BigDecimal.ROUND_HALF_EVEN),0.0);Assert.assertEquals(1.234,Precision.round(1.2345,3,BigDecimal.ROUND_HALF_EVEN),0.0);Assert.assertEquals(-1.234,Precision.round(-1.2345,3,BigDecimal.ROUND_HALF_EVEN),0.0);Assert.assertEquals(1.236,Precision.round(1.2355,3,BigDecimal.ROUND_HALF_EVEN),0.0);Assert.assertEquals(-1.236,Precision.round(-1.2355,3,BigDecimal.ROUND_HALF_EVEN),0.0);Assert.assertEquals(1.23,Precision.round(x,2,BigDecimal.ROUND_HALF_UP),0.0);Assert.assertEquals(1.235,Precision.round(x,3,BigDecimal.ROUND_HALF_UP),0.0);Assert.assertEquals(1.2346,Precision.round(x,4,BigDecimal.ROUND_HALF_UP),0.0);Assert.assertEquals(-1.23,Precision.round(-x,2,BigDecimal.ROUND_HALF_UP),0.0);Assert.assertEquals(-1.235,Precision.round(-x,3,BigDecimal.ROUND_HALF_UP),0.0);Assert.assertEquals(-1.2346,Precision.round(-x,4,BigDecimal.ROUND_HALF_UP),0.0);Assert.assertEquals(1.235,Precision.round(1.2345,3,BigDecimal.ROUND_HALF_UP),0.0);Assert.assertEquals(-1.235,Precision.round(-1.2345,3,BigDecimal.ROUND_HALF_UP),0.0);Assert.assertEquals(-1.23,Precision.round(-1.23,2,BigDecimal.ROUND_UNNECESSARY),0.0);Assert.assertEquals(1.23,Precision.round(1.23,2,BigDecimal.ROUND_UNNECESSARY),0.0);try {Precision.round(1.234,2,BigDecimal.ROUND_UNNECESSARY);Assert.fail();}catch(ArithmeticException ex){}Assert.assertEquals(1.24,Precision.round(x,2,BigDecimal.ROUND_UP),0.0);Assert.assertEquals(1.235,Precision.round(x,3,BigDecimal.ROUND_UP),0.0);Assert.assertEquals(1.2346,Precision.round(x,4,BigDecimal.ROUND_UP),0.0);Assert.assertEquals(-1.24,Precision.round(-x,2,BigDecimal.ROUND_UP),0.0);Assert.assertEquals(-1.235,Precision.round(-x,3,BigDecimal.ROUND_UP),0.0);Assert.assertEquals(-1.2346,Precision.round(-x,4,BigDecimal.ROUND_UP),0.0);try {Precision.round(1.234,2,1923);Assert.fail();}catch(IllegalArgumentException ex){}Assert.assertEquals(39.25,Precision.round(39.245,2,BigDecimal.ROUND_HALF_UP),0.0);TestUtils.assertEquals(Double.NaN,Precision.round(Double.NaN,2),0.0);Assert.assertEquals(0.0,Precision.round(0.0,2),0.0);Assert.assertEquals(Double.POSITIVE_INFINITY,Precision.round(Double.POSITIVE_INFINITY,2),0.0);Assert.assertEquals(Double.NEGATIVE_INFINITY,Precision.round(Double.NEGATIVE_INFINITY,2),0.0);}
@Test public void testRoundFloat(){float x=1.234567890f;Assert.assertEquals(1.23f,Precision.round(x,2),0.0);Assert.assertEquals(1.235f,Precision.round(x,3),0.0);Assert.assertEquals(1.2346f,Precision.round(x,4),0.0);Assert.assertEquals(30.1f,Precision.round(30.095f,2),0.0f);Assert.assertEquals(30.1f,Precision.round(30.095f,1),0.0f);Assert.assertEquals(50.09f,Precision.round(50.085f,2),0.0f);Assert.assertEquals(50.19f,Precision.round(50.185f,2),0.0f);Assert.assertEquals(50.01f,Precision.round(50.005f,2),0.0f);Assert.assertEquals(30.01f,Precision.round(30.005f,2),0.0f);Assert.assertEquals(30.65f,Precision.round(30.645f,2),0.0f);Assert.assertEquals(1.24f,Precision.round(x,2,BigDecimal.ROUND_CEILING),0.0);Assert.assertEquals(1.235f,Precision.round(x,3,BigDecimal.ROUND_CEILING),0.0);Assert.assertEquals(1.2346f,Precision.round(x,4,BigDecimal.ROUND_CEILING),0.0);Assert.assertEquals(-1.23f,Precision.round(-x,2,BigDecimal.ROUND_CEILING),0.0);Assert.assertEquals(-1.234f,Precision.round(-x,3,BigDecimal.ROUND_CEILING),0.0);Assert.assertEquals(-1.2345f,Precision.round(-x,4,BigDecimal.ROUND_CEILING),0.0);Assert.assertEquals(1.23f,Precision.round(x,2,BigDecimal.ROUND_DOWN),0.0);Assert.assertEquals(1.234f,Precision.round(x,3,BigDecimal.ROUND_DOWN),0.0);Assert.assertEquals(1.2345f,Precision.round(x,4,BigDecimal.ROUND_DOWN),0.0);Assert.assertEquals(-1.23f,Precision.round(-x,2,BigDecimal.ROUND_DOWN),0.0);Assert.assertEquals(-1.234f,Precision.round(-x,3,BigDecimal.ROUND_DOWN),0.0);Assert.assertEquals(-1.2345f,Precision.round(-x,4,BigDecimal.ROUND_DOWN),0.0);Assert.assertEquals(1.23f,Precision.round(x,2,BigDecimal.ROUND_FLOOR),0.0);Assert.assertEquals(1.234f,Precision.round(x,3,BigDecimal.ROUND_FLOOR),0.0);Assert.assertEquals(1.2345f,Precision.round(x,4,BigDecimal.ROUND_FLOOR),0.0);Assert.assertEquals(-1.24f,Precision.round(-x,2,BigDecimal.ROUND_FLOOR),0.0);Assert.assertEquals(-1.235f,Precision.round(-x,3,BigDecimal.ROUND_FLOOR),0.0);Assert.assertEquals(-1.2346f,Precision.round(-x,4,BigDecimal.ROUND_FLOOR),0.0);Assert.assertEquals(1.23f,Precision.round(x,2,BigDecimal.ROUND_HALF_DOWN),0.0);Assert.assertEquals(1.235f,Precision.round(x,3,BigDecimal.ROUND_HALF_DOWN),0.0);Assert.assertEquals(1.2346f,Precision.round(x,4,BigDecimal.ROUND_HALF_DOWN),0.0);Assert.assertEquals(-1.23f,Precision.round(-x,2,BigDecimal.ROUND_HALF_DOWN),0.0);Assert.assertEquals(-1.235f,Precision.round(-x,3,BigDecimal.ROUND_HALF_DOWN),0.0);Assert.assertEquals(-1.2346f,Precision.round(-x,4,BigDecimal.ROUND_HALF_DOWN),0.0);Assert.assertEquals(1.234f,Precision.round(1.2345f,3,BigDecimal.ROUND_HALF_DOWN),0.0);Assert.assertEquals(-1.234f,Precision.round(-1.2345f,3,BigDecimal.ROUND_HALF_DOWN),0.0);Assert.assertEquals(1.23f,Precision.round(x,2,BigDecimal.ROUND_HALF_EVEN),0.0);Assert.assertEquals(1.235f,Precision.round(x,3,BigDecimal.ROUND_HALF_EVEN),0.0);Assert.assertEquals(1.2346f,Precision.round(x,4,BigDecimal.ROUND_HALF_EVEN),0.0);Assert.assertEquals(-1.23f,Precision.round(-x,2,BigDecimal.ROUND_HALF_EVEN),0.0);Assert.assertEquals(-1.235f,Precision.round(-x,3,BigDecimal.ROUND_HALF_EVEN),0.0);Assert.assertEquals(-1.2346f,Precision.round(-x,4,BigDecimal.ROUND_HALF_EVEN),0.0);Assert.assertEquals(1.234f,Precision.round(1.2345f,3,BigDecimal.ROUND_HALF_EVEN),0.0);Assert.assertEquals(-1.234f,Precision.round(-1.2345f,3,BigDecimal.ROUND_HALF_EVEN),0.0);Assert.assertEquals(1.236f,Precision.round(1.2355f,3,BigDecimal.ROUND_HALF_EVEN),0.0);Assert.assertEquals(-1.236f,Precision.round(-1.2355f,3,BigDecimal.ROUND_HALF_EVEN),0.0);Assert.assertEquals(1.23f,Precision.round(x,2,BigDecimal.ROUND_HALF_UP),0.0);Assert.assertEquals(1.235f,Precision.round(x,3,BigDecimal.ROUND_HALF_UP),0.0);Assert.assertEquals(1.2346f,Precision.round(x,4,BigDecimal.ROUND_HALF_UP),0.0);Assert.assertEquals(-1.23f,Precision.round(-x,2,BigDecimal.ROUND_HALF_UP),0.0);Assert.assertEquals(-1.235f,Precision.round(-x,3,BigDecimal.ROUND_HALF_UP),0.0);Assert.assertEquals(-1.2346f,Precision.round(-x,4,BigDecimal.ROUND_HALF_UP),0.0);Assert.assertEquals(1.235f,Precision.round(1.2345f,3,BigDecimal.ROUND_HALF_UP),0.0);Assert.assertEquals(-1.235f,Precision.round(-1.2345f,3,BigDecimal.ROUND_HALF_UP),0.0);Assert.assertEquals(-1.23f,Precision.round(-1.23f,2,BigDecimal.ROUND_UNNECESSARY),0.0);Assert.assertEquals(1.23f,Precision.round(1.23f,2,BigDecimal.ROUND_UNNECESSARY),0.0);try {Precision.round(1.234f,2,BigDecimal.ROUND_UNNECESSARY);Assert.fail();}catch(MathArithmeticException ex){}Assert.assertEquals(1.24f,Precision.round(x,2,BigDecimal.ROUND_UP),0.0);Assert.assertEquals(1.235f,Precision.round(x,3,BigDecimal.ROUND_UP),0.0);Assert.assertEquals(1.2346f,Precision.round(x,4,BigDecimal.ROUND_UP),0.0);Assert.assertEquals(-1.24f,Precision.round(-x,2,BigDecimal.ROUND_UP),0.0);Assert.assertEquals(-1.235f,Precision.round(-x,3,BigDecimal.ROUND_UP),0.0);Assert.assertEquals(-1.2346f,Precision.round(-x,4,BigDecimal.ROUND_UP),0.0);try {Precision.round(1.234f,2,1923);Assert.fail();}catch(MathIllegalArgumentException ex){}TestUtils.assertEquals(Float.NaN,Precision.round(Float.NaN,2),0.0f);Assert.assertEquals(0.0f,Precision.round(0.0f,2),0.0f);Assert.assertEquals(Float.POSITIVE_INFINITY,Precision.round(Float.POSITIVE_INFINITY,2),0.0f);Assert.assertEquals(Float.NEGATIVE_INFINITY,Precision.round(Float.NEGATIVE_INFINITY,2),0.0f);}
@Test public void testRepresentableDelta(){int totalCount=0;int nonRepresentableCount=0;final double x=100;final int numTrials=10000;for (int i=0;i < numTrials;i++){final double originalDelta=Math.random();final double delta=Precision.representableDelta(x,originalDelta);if (delta != originalDelta){++nonRepresentableCount;}}Assert.assertTrue(nonRepresentableCount / (double)numTrials > 0.9);}
@Test public void testSinFunction(){UnivariateFunction f=new SinFunction();UnivariateRealIntegratorImpl integrator=new LegendreGaussIntegrator(5,1.0e-14,1.0e-10,2,15);double min,max,expected,result,tolerance;min=0;max=FastMath.PI;expected=2;tolerance=FastMath.max(integrator.getAbsoluteAccuracy(),FastMath.abs(expected * integrator.getRelativeAccuracy()));result=integrator.integrate(10000,f,min,max);Assert.assertEquals(expected,result,tolerance);min=-FastMath.PI / 3;max=0;expected=-0.5;tolerance=FastMath.max(integrator.getAbsoluteAccuracy(),FastMath.abs(expected * integrator.getRelativeAccuracy()));result=integrator.integrate(10000,f,min,max);Assert.assertEquals(expected,result,tolerance);}
@Test public void testQuinticFunction(){UnivariateFunction f=new QuinticFunction();UnivariateRealIntegrator integrator=new LegendreGaussIntegrator(3,UnivariateRealIntegratorImpl.DEFAULT_RELATIVE_ACCURACY,UnivariateRealIntegratorImpl.DEFAULT_ABSOLUTE_ACCURACY,UnivariateRealIntegratorImpl.DEFAULT_MIN_ITERATIONS_COUNT,64);double min,max,expected,result;min=0;max=1;expected=-1.0 / 48;result=integrator.integrate(10000,f,min,max);Assert.assertEquals(expected,result,1.0e-16);min=0;max=0.5;expected=11.0 / 768;result=integrator.integrate(10000,f,min,max);Assert.assertEquals(expected,result,1.0e-16);min=-1;max=4;expected=2048 / 3.0 - 78 + 1.0 / 48;result=integrator.integrate(10000,f,min,max);Assert.assertEquals(expected,result,1.0e-16);}
@Test public void testExactIntegration(){Random random=new Random(86343623467878363l);for (int n=2;n < 6;++n){LegendreGaussIntegrator integrator=new LegendreGaussIntegrator(n,UnivariateRealIntegratorImpl.DEFAULT_RELATIVE_ACCURACY,UnivariateRealIntegratorImpl.DEFAULT_ABSOLUTE_ACCURACY,UnivariateRealIntegratorImpl.DEFAULT_MIN_ITERATIONS_COUNT,64);for (int degree=0;degree <= 2 * n - 1;++degree){for (int i=0;i < 10;++i){double[]coeff=new double[degree + 1];for (int k=0;k < coeff.length;++k){coeff[k]=2 * random.nextDouble()- 1;}PolynomialFunction p=new PolynomialFunction(coeff);double result=integrator.integrate(10000,p,-5.0,15.0);double reference=exactIntegration(p,-5.0,15.0);Assert.assertEquals(n + " " + degree+ " "+ i,reference,result,1.0e-12 * (1.0 + FastMath.abs(reference)));}}}}
@Test public void testIssue464(){final double value=0.2;UnivariateFunction f=new UnivariateFunction(){public double value(double x){return (x >= 0 && x <= 5)? value : 0.0;}};LegendreGaussIntegrator gauss=new LegendreGaussIntegrator(5,3,100);double maxX=0.32462367623786328;Assert.assertEquals(maxX * value,gauss.integrate(Integer.MAX_VALUE,f,-10,maxX),1.0e-7);Assert.assertTrue(gauss.getEvaluations()> 37000000);Assert.assertTrue(gauss.getIterations()< 30);try {gauss.integrate(1000,f,-10,maxX);Assert.fail("expected TooManyEvaluationsException");}catch(TooManyEvaluationsException tmee){Assert.assertEquals(1000,tmee.getMax());}double sum1=gauss.integrate(1000,f,-10,0);int eval1=gauss.getEvaluations();double sum2=gauss.integrate(1000,f,0,maxX);int eval2=gauss.getEvaluations();Assert.assertEquals(maxX * value,sum1 + sum2,1.0e-7);Assert.assertTrue(eval1 + eval2 < 200);}
@Test public void testContains(){Line l=new Line(new Vector2D(0,1),new Vector2D(1,2));Assert.assertTrue(l.contains(new Vector2D(0,1)));Assert.assertTrue(l.contains(new Vector2D(1,2)));Assert.assertTrue(l.contains(new Vector2D(7,8)));Assert.assertTrue(!l.contains(new Vector2D(8,7)));}
@Test public void testAbscissa(){Line l=new Line(new Vector2D(2,1),new Vector2D(-2,-2));Assert.assertEquals(0.0,(l.toSubSpace(new Vector2D(-3,4))).getX(),1.0e-10);Assert.assertEquals(0.0,(l.toSubSpace(new Vector2D(3,-4))).getX(),1.0e-10);Assert.assertEquals(-5.0,(l.toSubSpace(new Vector2D(7,-1))).getX(),1.0e-10);Assert.assertEquals(5.0,(l.toSubSpace(new Vector2D(-1,-7))).getX(),1.0e-10);}
@Test public void testOffset(){Line l=new Line(new Vector2D(2,1),new Vector2D(-2,-2));Assert.assertEquals(-5.0,l.getOffset(new Vector2D(5,-3)),1.0e-10);Assert.assertEquals(+5.0,l.getOffset(new Vector2D(-5,2)),1.0e-10);}
@Test public void testPointAt(){Line l=new Line(new Vector2D(2,1),new Vector2D(-2,-2));for (double a=-2.0;a < 2.0;a+=0.2){Vector1D pA=new Vector1D(a);Vector2D point=l.toSpace(pA);Assert.assertEquals(a,(l.toSubSpace(point)).getX(),1.0e-10);Assert.assertEquals(0.0,l.getOffset(point),1.0e-10);for (double o=-2.0;o < 2.0;o+=0.2){point=l.getPointAt(pA,o);Assert.assertEquals(a,(l.toSubSpace(point)).getX(),1.0e-10);Assert.assertEquals(o,l.getOffset(point),1.0e-10);}}}
@Test public void testOriginOffset(){Line l1=new Line(new Vector2D(0,1),new Vector2D(1,2));Assert.assertEquals(FastMath.sqrt(0.5),l1.getOriginOffset(),1.0e-10);Line l2=new Line(new Vector2D(1,2),new Vector2D(0,1));Assert.assertEquals(-FastMath.sqrt(0.5),l2.getOriginOffset(),1.0e-10);}
@Test public void testParallel(){Line l1=new Line(new Vector2D(0,1),new Vector2D(1,2));Line l2=new Line(new Vector2D(2,2),new Vector2D(3,3));Assert.assertTrue(l1.isParallelTo(l2));Line l3=new Line(new Vector2D(1,0),new Vector2D(0.5,-0.5));Assert.assertTrue(l1.isParallelTo(l3));Line l4=new Line(new Vector2D(1,0),new Vector2D(0.5,-0.51));Assert.assertTrue(!l1.isParallelTo(l4));}
@Test public void testTransform(){Line l1=new Line(new Vector2D(1.0,1.0),new Vector2D(4.0,1.0));Transform<Euclidean2D,Euclidean1D> t1=Line.getTransform(new AffineTransform(0.0,0.5,-1.0,0.0,1.0,1.5));Assert.assertEquals(0.5 * FastMath.PI,((Line)t1.apply(l1)).getAngle(),1.0e-10);Line l2=new Line(new Vector2D(0.0,0.0),new Vector2D(1.0,1.0));Transform<Euclidean2D,Euclidean1D> t2=Line.getTransform(new AffineTransform(0.0,0.5,-1.0,0.0,1.0,1.5));Assert.assertEquals(FastMath.atan2(1.0,-2.0),((Line)t2.apply(l2)).getAngle(),1.0e-10);}
@Test public void testIntersection(){Line l1=new Line(new Vector2D(0,1),new Vector2D(1,2));Line l2=new Line(new Vector2D(-1,2),new Vector2D(2,1));Vector2D p=l1.intersection(l2);Assert.assertEquals(0.5,p.getX(),1.0e-10);Assert.assertEquals(1.5,p.getY(),1.0e-10);}
@Test public void testMath713NegativeVariable(){LinearObjectiveFunction f=new LinearObjectiveFunction(new double[]{1.0,1.0},0.0d);ArrayList<LinearConstraint> constraints=new ArrayList<LinearConstraint>();constraints.add(new LinearConstraint(new double[]{1,0},Relationship.EQ,1));double epsilon=1e-6;SimplexSolver solver=new SimplexSolver();RealPointValuePair solution=solver.optimize(f,constraints,GoalType.MINIMIZE,true);Assert.assertTrue(Precision.compareTo(solution.getPoint()[0],0.0d,epsilon)>= 0);Assert.assertTrue(Precision.compareTo(solution.getPoint()[1],0.0d,epsilon)>= 0);}
@Test public void testMath434NegativeVariable(){LinearObjectiveFunction f=new LinearObjectiveFunction(new double[]{0.0,0.0,1.0},0.0d);ArrayList<LinearConstraint> constraints=new ArrayList<LinearConstraint>();constraints.add(new LinearConstraint(new double[]{1,1,0},Relationship.EQ,5));constraints.add(new LinearConstraint(new double[]{0,0,1},Relationship.GEQ,-10));double epsilon=1e-6;SimplexSolver solver=new SimplexSolver();RealPointValuePair solution=solver.optimize(f,constraints,GoalType.MINIMIZE,false);Assert.assertEquals(5.0,solution.getPoint()[0]+ solution.getPoint()[1],epsilon);Assert.assertEquals(-10.0,solution.getPoint()[2],epsilon);Assert.assertEquals(-10.0,solution.getValue(),epsilon);}
@Test(expected=NoFeasibleSolutionException.class)public void testMath434UnfeasibleSolution(){double epsilon=1e-6;LinearObjectiveFunction f=new LinearObjectiveFunction(new double[]{1.0,0.0},0.0);ArrayList<LinearConstraint> constraints=new ArrayList<LinearConstraint>();constraints.add(new LinearConstraint(new double[]{epsilon / 2,0.5},Relationship.EQ,0));constraints.add(new LinearConstraint(new double[]{1e-3,0.1},Relationship.EQ,10));SimplexSolver solver=new SimplexSolver();solver.optimize(f,constraints,GoalType.MINIMIZE,true);}
@Test public void testMath434PivotRowSelection(){LinearObjectiveFunction f=new LinearObjectiveFunction(new double[]{1.0},0.0);double epsilon=1e-6;ArrayList<LinearConstraint> constraints=new ArrayList<LinearConstraint>();constraints.add(new LinearConstraint(new double[]{200},Relationship.GEQ,1));constraints.add(new LinearConstraint(new double[]{100},Relationship.GEQ,0.499900001));SimplexSolver solver=new SimplexSolver();RealPointValuePair solution=solver.optimize(f,constraints,GoalType.MINIMIZE,false);Assert.assertTrue(Precision.compareTo(solution.getPoint()[0]* 200.d,1.d,epsilon)>= 0);Assert.assertEquals(0.0050,solution.getValue(),epsilon);}
@Test public void testMath434PivotRowSelection2(){LinearObjectiveFunction f=new LinearObjectiveFunction(new double[]{0.0d,1.0d,1.0d,0.0d,0.0d,0.0d,0.0d},0.0d);ArrayList<LinearConstraint> constraints=new ArrayList<LinearConstraint>();constraints.add(new LinearConstraint(new double[]{1.0d,-0.1d,0.0d,0.0d,0.0d,0.0d,0.0d},Relationship.EQ,-0.1d));constraints.add(new LinearConstraint(new double[]{1.0d,0.0d,0.0d,0.0d,0.0d,0.0d,0.0d},Relationship.GEQ,-1e-18d));constraints.add(new LinearConstraint(new double[]{0.0d,1.0d,0.0d,0.0d,0.0d,0.0d,0.0d},Relationship.GEQ,0.0d));constraints.add(new LinearConstraint(new double[]{0.0d,0.0d,0.0d,1.0d,0.0d,-0.0128588d,1e-5d},Relationship.EQ,0.0d));constraints.add(new LinearConstraint(new double[]{0.0d,0.0d,0.0d,0.0d,1.0d,1e-5d,-0.0128586d},Relationship.EQ,1e-10d));constraints.add(new LinearConstraint(new double[]{0.0d,0.0d,1.0d,-1.0d,0.0d,0.0d,0.0d},Relationship.GEQ,0.0d));constraints.add(new LinearConstraint(new double[]{0.0d,0.0d,1.0d,1.0d,0.0d,0.0d,0.0d},Relationship.GEQ,0.0d));constraints.add(new LinearConstraint(new double[]{0.0d,0.0d,1.0d,0.0d,-1.0d,0.0d,0.0d},Relationship.GEQ,0.0d));constraints.add(new LinearConstraint(new double[]{0.0d,0.0d,1.0d,0.0d,1.0d,0.0d,0.0d},Relationship.GEQ,0.0d));double epsilon=1e-7;SimplexSolver simplex=new SimplexSolver();RealPointValuePair solution=simplex.optimize(f,constraints,GoalType.MINIMIZE,false);Assert.assertTrue(Precision.compareTo(solution.getPoint()[0],-1e-18d,epsilon)>= 0);Assert.assertEquals(1.0d,solution.getPoint()[1],epsilon);Assert.assertEquals(0.0d,solution.getPoint()[2],epsilon);Assert.assertEquals(1.0d,solution.getValue(),epsilon);}
@Test public void testMath272(){LinearObjectiveFunction f=new LinearObjectiveFunction(new double[]{2,2,1},0);Collection<LinearConstraint> constraints=new ArrayList<LinearConstraint>();constraints.add(new LinearConstraint(new double[]{1,1,0},Relationship.GEQ,1));constraints.add(new LinearConstraint(new double[]{1,0,1},Relationship.GEQ,1));constraints.add(new LinearConstraint(new double[]{0,1,0},Relationship.GEQ,1));SimplexSolver solver=new SimplexSolver();RealPointValuePair solution=solver.optimize(f,constraints,GoalType.MINIMIZE,true);Assert.assertEquals(0.0,solution.getPoint()[0],.0000001);Assert.assertEquals(1.0,solution.getPoint()[1],.0000001);Assert.assertEquals(1.0,solution.getPoint()[2],.0000001);Assert.assertEquals(3.0,solution.getValue(),.0000001);}
@Test public void testMath286(){LinearObjectiveFunction f=new LinearObjectiveFunction(new double[]{0.8,0.2,0.7,0.3,0.6,0.4},0);Collection<LinearConstraint> constraints=new ArrayList<LinearConstraint>();constraints.add(new LinearConstraint(new double[]{1,0,1,0,1,0},Relationship.EQ,23.0));constraints.add(new LinearConstraint(new double[]{0,1,0,1,0,1},Relationship.EQ,23.0));constraints.add(new LinearConstraint(new double[]{1,0,0,0,0,0},Relationship.GEQ,10.0));constraints.add(new LinearConstraint(new double[]{0,0,1,0,0,0},Relationship.GEQ,8.0));constraints.add(new LinearConstraint(new double[]{0,0,0,0,1,0},Relationship.GEQ,5.0));SimplexSolver solver=new SimplexSolver();RealPointValuePair solution=solver.optimize(f,constraints,GoalType.MAXIMIZE,true);Assert.assertEquals(25.8,solution.getValue(),.0000001);Assert.assertEquals(23.0,solution.getPoint()[0]+ solution.getPoint()[2]+ solution.getPoint()[4],0.0000001);Assert.assertEquals(23.0,solution.getPoint()[1]+ solution.getPoint()[3]+ solution.getPoint()[5],0.0000001);Assert.assertTrue(solution.getPoint()[0]>= 10.0 - 0.0000001);Assert.assertTrue(solution.getPoint()[2]>= 8.0 - 0.0000001);Assert.assertTrue(solution.getPoint()[4]>= 5.0 - 0.0000001);}
@Test public void testDegeneracy(){LinearObjectiveFunction f=new LinearObjectiveFunction(new double[]{0.8,0.7},0);Collection<LinearConstraint> constraints=new ArrayList<LinearConstraint>();constraints.add(new LinearConstraint(new double[]{1,1},Relationship.LEQ,18.0));constraints.add(new LinearConstraint(new double[]{1,0},Relationship.GEQ,10.0));constraints.add(new LinearConstraint(new double[]{0,1},Relationship.GEQ,8.0));SimplexSolver solver=new SimplexSolver();RealPointValuePair solution=solver.optimize(f,constraints,GoalType.MAXIMIZE,true);Assert.assertEquals(13.6,solution.getValue(),.0000001);}
@Test public void testMath288(){LinearObjectiveFunction f=new LinearObjectiveFunction(new double[]{7,3,0,0},0);Collection<LinearConstraint> constraints=new ArrayList<LinearConstraint>();constraints.add(new LinearConstraint(new double[]{3,0,-5,0},Relationship.LEQ,0.0));constraints.add(new LinearConstraint(new double[]{2,0,0,-5},Relationship.LEQ,0.0));constraints.add(new LinearConstraint(new double[]{0,3,0,-5},Relationship.LEQ,0.0));constraints.add(new LinearConstraint(new double[]{1,0,0,0},Relationship.LEQ,1.0));constraints.add(new LinearConstraint(new double[]{0,1,0,0},Relationship.LEQ,1.0));SimplexSolver solver=new SimplexSolver();RealPointValuePair solution=solver.optimize(f,constraints,GoalType.MAXIMIZE,true);Assert.assertEquals(10.0,solution.getValue(),.0000001);}
@Test public void testMath290GEQ(){LinearObjectiveFunction f=new LinearObjectiveFunction(new double[]{1,5},0);Collection<LinearConstraint> constraints=new ArrayList<LinearConstraint>();constraints.add(new LinearConstraint(new double[]{2,0},Relationship.GEQ,-1.0));SimplexSolver solver=new SimplexSolver();RealPointValuePair solution=solver.optimize(f,constraints,GoalType.MINIMIZE,true);Assert.assertEquals(0,solution.getValue(),.0000001);Assert.assertEquals(0,solution.getPoint()[0],.0000001);Assert.assertEquals(0,solution.getPoint()[1],.0000001);}
@Test(expected=NoFeasibleSolutionException.class)public void testMath290LEQ(){LinearObjectiveFunction f=new LinearObjectiveFunction(new double[]{1,5},0);Collection<LinearConstraint> constraints=new ArrayList<LinearConstraint>();constraints.add(new LinearConstraint(new double[]{2,0},Relationship.LEQ,-1.0));SimplexSolver solver=new SimplexSolver();solver.optimize(f,constraints,GoalType.MINIMIZE,true);}
@Test public void testMath293(){LinearObjectiveFunction f=new LinearObjectiveFunction(new double[]{0.8,0.2,0.7,0.3,0.4,0.6},0);Collection<LinearConstraint> constraints=new ArrayList<LinearConstraint>();constraints.add(new LinearConstraint(new double[]{1,0,1,0,1,0},Relationship.EQ,30.0));constraints.add(new LinearConstraint(new double[]{0,1,0,1,0,1},Relationship.EQ,30.0));constraints.add(new LinearConstraint(new double[]{0.8,0.2,0.0,0.0,0.0,0.0},Relationship.GEQ,10.0));constraints.add(new LinearConstraint(new double[]{0.0,0.0,0.7,0.3,0.0,0.0},Relationship.GEQ,10.0));constraints.add(new LinearConstraint(new double[]{0.0,0.0,0.0,0.0,0.4,0.6},Relationship.GEQ,10.0));SimplexSolver solver=new SimplexSolver();RealPointValuePair solution1=solver.optimize(f,constraints,GoalType.MAXIMIZE,true);Assert.assertEquals(15.7143,solution1.getPoint()[0],.0001);Assert.assertEquals(0.0,solution1.getPoint()[1],.0001);Assert.assertEquals(14.2857,solution1.getPoint()[2],.0001);Assert.assertEquals(0.0,solution1.getPoint()[3],.0001);Assert.assertEquals(0.0,solution1.getPoint()[4],.0001);Assert.assertEquals(30.0,solution1.getPoint()[5],.0001);Assert.assertEquals(40.57143,solution1.getValue(),.0001);double valA=0.8 * solution1.getPoint()[0]+ 0.2 * solution1.getPoint()[1];double valB=0.7 * solution1.getPoint()[2]+ 0.3 * solution1.getPoint()[3];double valC=0.4 * solution1.getPoint()[4]+ 0.6 * solution1.getPoint()[5];f=new LinearObjectiveFunction(new double[]{0.8,0.2,0.7,0.3,0.4,0.6},0);constraints=new ArrayList<LinearConstraint>();constraints.add(new LinearConstraint(new double[]{1,0,1,0,1,0},Relationship.EQ,30.0));constraints.add(new LinearConstraint(new double[]{0,1,0,1,0,1},Relationship.EQ,30.0));constraints.add(new LinearConstraint(new double[]{0.8,0.2,0.0,0.0,0.0,0.0},Relationship.GEQ,valA));constraints.add(new LinearConstraint(new double[]{0.0,0.0,0.7,0.3,0.0,0.0},Relationship.GEQ,valB));constraints.add(new LinearConstraint(new double[]{0.0,0.0,0.0,0.0,0.4,0.6},Relationship.GEQ,valC));RealPointValuePair solution2=solver.optimize(f,constraints,GoalType.MAXIMIZE,true);Assert.assertEquals(40.57143,solution2.getValue(),.0001);}
@Test public void testSimplexSolver(){LinearObjectiveFunction f=new LinearObjectiveFunction(new double[]{15,10},7);Collection<LinearConstraint> constraints=new ArrayList<LinearConstraint>();constraints.add(new LinearConstraint(new double[]{1,0},Relationship.LEQ,2));constraints.add(new LinearConstraint(new double[]{0,1},Relationship.LEQ,3));constraints.add(new LinearConstraint(new double[]{1,1},Relationship.EQ,4));SimplexSolver solver=new SimplexSolver();RealPointValuePair solution=solver.optimize(f,constraints,GoalType.MAXIMIZE,false);Assert.assertEquals(2.0,solution.getPoint()[0],0.0);Assert.assertEquals(2.0,solution.getPoint()[1],0.0);Assert.assertEquals(57.0,solution.getValue(),0.0);}
@Test public void testSingleVariableAndConstraint(){LinearObjectiveFunction f=new LinearObjectiveFunction(new double[]{3},0);Collection<LinearConstraint> constraints=new ArrayList<LinearConstraint>();constraints.add(new LinearConstraint(new double[]{1},Relationship.LEQ,10));SimplexSolver solver=new SimplexSolver();RealPointValuePair solution=solver.optimize(f,constraints,GoalType.MAXIMIZE,false);Assert.assertEquals(10.0,solution.getPoint()[0],0.0);Assert.assertEquals(30.0,solution.getValue(),0.0);}
/** * With no artificial variables needed (no equals and no greater than constraints)we can go straight to Phase 2.*/@Test public void testModelWithNoArtificialVars(){LinearObjectiveFunction f=new LinearObjectiveFunction(new double[]{15,10},0);Collection<LinearConstraint> constraints=new ArrayList<LinearConstraint>();constraints.add(new LinearConstraint(new double[]{1,0},Relationship.LEQ,2));constraints.add(new LinearConstraint(new double[]{0,1},Relationship.LEQ,3));constraints.add(new LinearConstraint(new double[]{1,1},Relationship.LEQ,4));SimplexSolver solver=new SimplexSolver();RealPointValuePair solution=solver.optimize(f,constraints,GoalType.MAXIMIZE,false);Assert.assertEquals(2.0,solution.getPoint()[0],0.0);Assert.assertEquals(2.0,solution.getPoint()[1],0.0);Assert.assertEquals(50.0,solution.getValue(),0.0);}
@Test public void testMinimization(){LinearObjectiveFunction f=new LinearObjectiveFunction(new double[]{-2,1},-5);Collection<LinearConstraint> constraints=new ArrayList<LinearConstraint>();constraints.add(new LinearConstraint(new double[]{1,2},Relationship.LEQ,6));constraints.add(new LinearConstraint(new double[]{3,2},Relationship.LEQ,12));constraints.add(new LinearConstraint(new double[]{0,1},Relationship.GEQ,0));SimplexSolver solver=new SimplexSolver();RealPointValuePair solution=solver.optimize(f,constraints,GoalType.MINIMIZE,false);Assert.assertEquals(4.0,solution.getPoint()[0],0.0);Assert.assertEquals(0.0,solution.getPoint()[1],0.0);Assert.assertEquals(-13.0,solution.getValue(),0.0);}
@Test public void testSolutionWithNegativeDecisionVariable(){LinearObjectiveFunction f=new LinearObjectiveFunction(new double[]{-2,1},0);Collection<LinearConstraint> constraints=new ArrayList<LinearConstraint>();constraints.add(new LinearConstraint(new double[]{1,1},Relationship.GEQ,6));constraints.add(new LinearConstraint(new double[]{1,2},Relationship.LEQ,14));SimplexSolver solver=new SimplexSolver();RealPointValuePair solution=solver.optimize(f,constraints,GoalType.MAXIMIZE,false);Assert.assertEquals(-2.0,solution.getPoint()[0],0.0);Assert.assertEquals(8.0,solution.getPoint()[1],0.0);Assert.assertEquals(12.0,solution.getValue(),0.0);}
@Test(expected=NoFeasibleSolutionException.class)public void testInfeasibleSolution(){LinearObjectiveFunction f=new LinearObjectiveFunction(new double[]{15},0);Collection<LinearConstraint> constraints=new ArrayList<LinearConstraint>();constraints.add(new LinearConstraint(new double[]{1},Relationship.LEQ,1));constraints.add(new LinearConstraint(new double[]{1},Relationship.GEQ,3));SimplexSolver solver=new SimplexSolver();solver.optimize(f,constraints,GoalType.MAXIMIZE,false);}
@Test(expected=UnboundedSolutionException.class)public void testUnboundedSolution(){LinearObjectiveFunction f=new LinearObjectiveFunction(new double[]{15,10},0);Collection<LinearConstraint> constraints=new ArrayList<LinearConstraint>();constraints.add(new LinearConstraint(new double[]{1,0},Relationship.EQ,2));SimplexSolver solver=new SimplexSolver();solver.optimize(f,constraints,GoalType.MAXIMIZE,false);}
@Test public void testRestrictVariablesToNonNegative(){LinearObjectiveFunction f=new LinearObjectiveFunction(new double[]{409,523,70,204,339},0);Collection<LinearConstraint> constraints=new ArrayList<LinearConstraint>();constraints.add(new LinearConstraint(new double[]{43,56,345,56,5},Relationship.LEQ,4567456));constraints.add(new LinearConstraint(new double[]{12,45,7,56,23},Relationship.LEQ,56454));constraints.add(new LinearConstraint(new double[]{8,768,0,34,7456},Relationship.LEQ,1923421));constraints.add(new LinearConstraint(new double[]{12342,2342,34,678,2342},Relationship.GEQ,4356));constraints.add(new LinearConstraint(new double[]{45,678,76,52,23},Relationship.EQ,456356));SimplexSolver solver=new SimplexSolver();RealPointValuePair solution=solver.optimize(f,constraints,GoalType.MAXIMIZE,true);Assert.assertEquals(2902.92783505155,solution.getPoint()[0],.0000001);Assert.assertEquals(480.419243986254,solution.getPoint()[1],.0000001);Assert.assertEquals(0.0,solution.getPoint()[2],.0000001);Assert.assertEquals(0.0,solution.getPoint()[3],.0000001);Assert.assertEquals(0.0,solution.getPoint()[4],.0000001);Assert.assertEquals(1438556.7491409,solution.getValue(),.0000001);}
@Test public void testEpsilon(){LinearObjectiveFunction f=new LinearObjectiveFunction(new double[]{10,5,1},0);Collection<LinearConstraint> constraints=new ArrayList<LinearConstraint>();constraints.add(new LinearConstraint(new double[]{9,8,0},Relationship.EQ,17));constraints.add(new LinearConstraint(new double[]{0,7,8},Relationship.LEQ,7));constraints.add(new LinearConstraint(new double[]{10,0,2},Relationship.LEQ,10));SimplexSolver solver=new SimplexSolver();RealPointValuePair solution=solver.optimize(f,constraints,GoalType.MAXIMIZE,false);Assert.assertEquals(1.0,solution.getPoint()[0],0.0);Assert.assertEquals(1.0,solution.getPoint()[1],0.0);Assert.assertEquals(0.0,solution.getPoint()[2],0.0);Assert.assertEquals(15.0,solution.getValue(),0.0);}
@Test public void testTrivialModel(){LinearObjectiveFunction f=new LinearObjectiveFunction(new double[]{1,1},0);Collection<LinearConstraint> constraints=new ArrayList<LinearConstraint>();constraints.add(new LinearConstraint(new double[]{1,1},Relationship.EQ,0));SimplexSolver solver=new SimplexSolver();RealPointValuePair solution=solver.optimize(f,constraints,GoalType.MAXIMIZE,true);Assert.assertEquals(0,solution.getValue(),.0000001);}
@Test public void testLargeModel(){double[]objective=new double[]{1,1,1,1,1,1,1,1,1,1,1,1,12,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,12,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,12,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,12,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,12,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,12,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1};LinearObjectiveFunction f=new LinearObjectiveFunction(objective,0);Collection<LinearConstraint> constraints=new ArrayList<LinearConstraint>();constraints.add(equationFromString(objective.length,"x0 + x1 + x2 + x3 - x12 = 0"));constraints.add(equationFromString(objective.length,"x4 + x5 + x6 + x7 + x8 + x9 + x10 + x11 - x13 = 0"));constraints.add(equationFromString(objective.length,"x4 + x5 + x6 + x7 + x8 + x9 + x10 + x11 >= 49"));constraints.add(equationFromString(objective.length,"x0 + x1 + x2 + x3 >= 42"));constraints.add(equationFromString(objective.length,"x14 + x15 + x16 + x17 - x26 = 0"));constraints.add(equationFromString(objective.length,"x18 + x19 + x20 + x21 + x22 + x23 + x24 + x25 - x27 = 0"));constraints.add(equationFromString(objective.length,"x14 + x15 + x16 + x17 - x12 = 0"));constraints.add(equationFromString(objective.length,"x18 + x19 + x20 + x21 + x22 + x23 + x24 + x25 - x13 = 0"));constraints.add(equationFromString(objective.length,"x28 + x29 + x30 + x31 - x40 = 0"));constraints.add(equationFromString(objective.length,"x32 + x33 + x34 + x35 + x36 + x37 + x38 + x39 - x41 = 0"));constraints.add(equationFromString(objective.length,"x32 + x33 + x34 + x35 + x36 + x37 + x38 + x39 >= 49"));constraints.add(equationFromString(objective.length,"x28 + x29 + x30 + x31 >= 42"));constraints.add(equationFromString(objective.length,"x42 + x43 + x44 + x45 - x54 = 0"));constraints.add(equationFromString(objective.length,"x46 + x47 + x48 + x49 + x50 + x51 + x52 + x53 - x55 = 0"));constraints.add(equationFromString(objective.length,"x42 + x43 + x44 + x45 - x40 = 0"));constraints.add(equationFromString(objective.length,"x46 + x47 + x48 + x49 + x50 + x51 + x52 + x53 - x41 = 0"));constraints.add(equationFromString(objective.length,"x56 + x57 + x58 + x59 - x68 = 0"));constraints.add(equationFromString(objective.length,"x60 + x61 + x62 + x63 + x64 + x65 + x66 + x67 - x69 = 0"));constraints.add(equationFromString(objective.length,"x60 + x61 + x62 + x63 + x64 + x65 + x66 + x67 >= 51"));constraints.add(equationFromString(objective.length,"x56 + x57 + x58 + x59 >= 44"));constraints.add(equationFromString(objective.length,"x70 + x71 + x72 + x73 - x82 = 0"));constraints.add(equationFromString(objective.length,"x74 + x75 + x76 + x77 + x78 + x79 + x80 + x81 - x83 = 0"));constraints.add(equationFromString(objective.length,"x70 + x71 + x72 + x73 - x68 = 0"));constraints.add(equationFromString(objective.length,"x74 + x75 + x76 + x77 + x78 + x79 + x80 + x81 - x69 = 0"));constraints.add(equationFromString(objective.length,"x84 + x85 + x86 + x87 - x96 = 0"));constraints.add(equationFromString(objective.length,"x88 + x89 + x90 + x91 + x92 + x93 + x94 + x95 - x97 = 0"));constraints.add(equationFromString(objective.length,"x88 + x89 + x90 + x91 + x92 + x93 + x94 + x95 >= 51"));constraints.add(equationFromString(objective.length,"x84 + x85 + x86 + x87 >= 44"));constraints.add(equationFromString(objective.length,"x98 + x99 + x100 + x101 - x110 = 0"));constraints.add(equationFromString(objective.length,"x102 + x103 + x104 + x105 + x106 + x107 + x108 + x109 - x111 = 0"));constraints.add(equationFromString(objective.length,"x98 + x99 + x100 + x101 - x96 = 0"));constraints.add(equationFromString(objective.length,"x102 + x103 + x104 + x105 + x106 + x107 + x108 + x109 - x97 = 0"));constraints.add(equationFromString(objective.length,"x112 + x113 + x114 + x115 - x124 = 0"));constraints.add(equationFromString(objective.length,"x116 + x117 + x118 + x119 + x120 + x121 + x122 + x123 - x125 = 0"));constraints.add(equationFromString(objective.length,"x116 + x117 + x118 + x119 + x120 + x121 + x122 + x123 >= 49"));constraints.add(equationFromString(objective.length,"x112 + x113 + x114 + x115 >= 42"));constraints.add(equationFromString(objective.length,"x126 + x127 + x128 + x129 - x138 = 0"));constraints.add(equationFromString(objective.length,"x130 + x131 + x132 + x133 + x134 + x135 + x136 + x137 - x139 = 0"));constraints.add(equationFromString(objective.length,"x126 + x127 + x128 + x129 - x124 = 0"));constraints.add(equationFromString(objective.length,"x130 + x131 + x132 + x133 + x134 + x135 + x136 + x137 - x125 = 0"));constraints.add(equationFromString(objective.length,"x140 + x141 + x142 + x143 - x152 = 0"));constraints.add(equationFromString(objective.length,"x144 + x145 + x146 + x147 + x148 + x149 + x150 + x151 - x153 = 0"));constraints.add(equationFromString(objective.length,"x144 + x145 + x146 + x147 + x148 + x149 + x150 + x151 >= 59"));constraints.add(equationFromString(objective.length,"x140 + x141 + x142 + x143 >= 42"));constraints.add(equationFromString(objective.length,"x154 + x155 + x156 + x157 - x166 = 0"));constraints.add(equationFromString(objective.length,"x158 + x159 + x160 + x161 + x162 + x163 + x164 + x165 - x167 = 0"));constraints.add(equationFromString(objective.length,"x154 + x155 + x156 + x157 - x152 = 0"));constraints.add(equationFromString(objective.length,"x158 + x159 + x160 + x161 + x162 + x163 + x164 + x165 - x153 = 0"));constraints.add(equationFromString(objective.length,"x83 + x82 - x168 = 0"));constraints.add(equationFromString(objective.length,"x111 + x110 - x169 = 0"));constraints.add(equationFromString(objective.length,"x170 - x182 = 0"));constraints.add(equationFromString(objective.length,"x171 - x183 = 0"));constraints.add(equationFromString(objective.length,"x172 - x184 = 0"));constraints.add(equationFromString(objective.length,"x173 - x185 = 0"));constraints.add(equationFromString(objective.length,"x174 - x186 = 0"));constraints.add(equationFromString(objective.length,"x175 + x176 - x187 = 0"));constraints.add(equationFromString(objective.length,"x177 - x188 = 0"));constraints.add(equationFromString(objective.length,"x178 - x189 = 0"));constraints.add(equationFromString(objective.length,"x179 - x190 = 0"));constraints.add(equationFromString(objective.length,"x180 - x191 = 0"));constraints.add(equationFromString(objective.length,"x181 - x192 = 0"));constraints.add(equationFromString(objective.length,"x170 - x26 = 0"));constraints.add(equationFromString(objective.length,"x171 - x27 = 0"));constraints.add(equationFromString(objective.length,"x172 - x54 = 0"));constraints.add(equationFromString(objective.length,"x173 - x55 = 0"));constraints.add(equationFromString(objective.length,"x174 - x168 = 0"));constraints.add(equationFromString(objective.length,"x177 - x169 = 0"));constraints.add(equationFromString(objective.length,"x178 - x138 = 0"));constraints.add(equationFromString(objective.length,"x179 - x139 = 0"));constraints.add(equationFromString(objective.length,"x180 - x166 = 0"));constraints.add(equationFromString(objective.length,"x181 - x167 = 0"));constraints.add(equationFromString(objective.length,"x193 - x205 = 0"));constraints.add(equationFromString(objective.length,"x194 - x206 = 0"));constraints.add(equationFromString(objective.length,"x195 - x207 = 0"));constraints.add(equationFromString(objective.length,"x196 - x208 = 0"));constraints.add(equationFromString(objective.length,"x197 - x209 = 0"));constraints.add(equationFromString(objective.length,"x198 + x199 - x210 = 0"));constraints.add(equationFromString(objective.length,"x200 - x211 = 0"));constraints.add(equationFromString(objective.length,"x201 - x212 = 0"));constraints.add(equationFromString(objective.length,"x202 - x213 = 0"));constraints.add(equationFromString(objective.length,"x203 - x214 = 0"));constraints.add(equationFromString(objective.length,"x204 - x215 = 0"));constraints.add(equationFromString(objective.length,"x193 - x182 = 0"));constraints.add(equationFromString(objective.length,"x194 - x183 = 0"));constraints.add(equationFromString(objective.length,"x195 - x184 = 0"));constraints.add(equationFromString(objective.length,"x196 - x185 = 0"));constraints.add(equationFromString(objective.length,"x197 - x186 = 0"));constraints.add(equationFromString(objective.length,"x198 + x199 - x187 = 0"));constraints.add(equationFromString(objective.length,"x200 - x188 = 0"));constraints.add(equationFromString(objective.length,"x201 - x189 = 0"));constraints.add(equationFromString(objective.length,"x202 - x190 = 0"));constraints.add(equationFromString(objective.length,"x203 - x191 = 0"));constraints.add(equationFromString(objective.length,"x204 - x192 = 0"));SimplexSolver solver=new SimplexSolver();RealPointValuePair solution=solver.optimize(f,constraints,GoalType.MINIMIZE,true);Assert.assertEquals(7518.0,solution.getValue(),.0000001);}
@Test public void testWrongDerivative()throws Exception {HighamHall54Integrator integrator=new HighamHall54Integrator(0.0,1.0,1.0e-10,1.0e-10);FirstOrderDifferentialEquations equations=new FirstOrderDifferentialEquations(){public void computeDerivatives(double t,double[]y,double[]dot){if (t < -0.5){throw new LocalException(t);}else {throw new RuntimeException("oops");}}public int getDimension(){return 1;}};try {integrator.integrate(equations,-1.0,new double[1],0.0,new double[1]);Assert.fail("an exception should have been thrown");}catch(LocalException de){}try {integrator.integrate(equations,0.0,new double[1],1.0,new double[1]);Assert.fail("an exception should have been thrown");}catch(RuntimeException de){}}
@Test(expected=NumberIsTooSmallException.class)public void testMinStep(){TestProblem1 pb=new TestProblem1();double minStep=0.1 * (pb.getFinalTime()- pb.getInitialTime());double maxStep=pb.getFinalTime()- pb.getInitialTime();double[]vecAbsoluteTolerance={1.0e-15,1.0e-16};double[]vecRelativeTolerance={1.0e-15,1.0e-16};FirstOrderIntegrator integ=new HighamHall54Integrator(minStep,maxStep,vecAbsoluteTolerance,vecRelativeTolerance);TestProblemHandler handler=new TestProblemHandler(pb,integ);integ.addStepHandler(handler);integ.integrate(pb,pb.getInitialTime(),pb.getInitialState(),pb.getFinalTime(),new double[pb.getDimension()]);Assert.fail("an exception should have been thrown");}
@Test public void testIncreasingTolerance(){int previousCalls=Integer.MAX_VALUE;for (int i=-12;i < -2;++i){TestProblem1 pb=new TestProblem1();double minStep=0;double maxStep=pb.getFinalTime()- pb.getInitialTime();double scalAbsoluteTolerance=FastMath.pow(10.0,i);double scalRelativeTolerance=0.01 * scalAbsoluteTolerance;FirstOrderIntegrator integ=new HighamHall54Integrator(minStep,maxStep,scalAbsoluteTolerance,scalRelativeTolerance);TestProblemHandler handler=new TestProblemHandler(pb,integ);integ.addStepHandler(handler);integ.integrate(pb,pb.getInitialTime(),pb.getInitialState(),pb.getFinalTime(),new double[pb.getDimension()]);Assert.assertTrue(handler.getMaximalValueError()< (1.3 * scalAbsoluteTolerance));Assert.assertEquals(0,handler.getMaximalTimeError(),1.0e-12);int calls=pb.getCalls();Assert.assertEquals(integ.getEvaluations(),calls);Assert.assertTrue(calls <= previousCalls);previousCalls=calls;}}
@Test public void testBackward(){TestProblem5 pb=new TestProblem5();double minStep=0;double maxStep=pb.getFinalTime()- pb.getInitialTime();double scalAbsoluteTolerance=1.0e-8;double scalRelativeTolerance=0.01 * scalAbsoluteTolerance;FirstOrderIntegrator integ=new HighamHall54Integrator(minStep,maxStep,scalAbsoluteTolerance,scalRelativeTolerance);TestProblemHandler handler=new TestProblemHandler(pb,integ);integ.addStepHandler(handler);integ.integrate(pb,pb.getInitialTime(),pb.getInitialState(),pb.getFinalTime(),new double[pb.getDimension()]);Assert.assertTrue(handler.getLastError()< 5.0e-7);Assert.assertTrue(handler.getMaximalValueError()< 5.0e-7);Assert.assertEquals(0,handler.getMaximalTimeError(),1.0e-12);Assert.assertEquals("Higham-Hall 5(4)",integ.getName());}
@Test public void testEvents(){TestProblem4 pb=new TestProblem4();double minStep=0;double maxStep=pb.getFinalTime()- pb.getInitialTime();double scalAbsoluteTolerance=1.0e-8;double scalRelativeTolerance=0.01 * scalAbsoluteTolerance;FirstOrderIntegrator integ=new HighamHall54Integrator(minStep,maxStep,scalAbsoluteTolerance,scalRelativeTolerance);TestProblemHandler handler=new TestProblemHandler(pb,integ);integ.addStepHandler(handler);EventHandler[]functions=pb.getEventsHandlers();double convergence=1.0e-8 * maxStep;for (int l=0;l < functions.length;++l){integ.addEventHandler(functions[l],Double.POSITIVE_INFINITY,convergence,1000);}Assert.assertEquals(functions.length,integ.getEventHandlers().size());integ.integrate(pb,pb.getInitialTime(),pb.getInitialState(),pb.getFinalTime(),new double[pb.getDimension()]);Assert.assertTrue(handler.getMaximalValueError()< 1.0e-7);Assert.assertEquals(0,handler.getMaximalTimeError(),convergence);Assert.assertEquals(12.0,handler.getLastTime(),convergence);integ.clearEventHandlers();Assert.assertEquals(0,integ.getEventHandlers().size());}
@Test(expected=LocalException.class)public void testEventsErrors(){final TestProblem1 pb=new TestProblem1();double minStep=0;double maxStep=pb.getFinalTime()- pb.getInitialTime();double scalAbsoluteTolerance=1.0e-8;double scalRelativeTolerance=0.01 * scalAbsoluteTolerance;FirstOrderIntegrator integ=new HighamHall54Integrator(minStep,maxStep,scalAbsoluteTolerance,scalRelativeTolerance);TestProblemHandler handler=new TestProblemHandler(pb,integ);integ.addStepHandler(handler);integ.addEventHandler(new EventHandler(){public void init(double t0,double[]y0,double t){}public Action eventOccurred(double t,double[]y,boolean increasing){return Action.CONTINUE;}public double g(double t,double[]y){double middle=(pb.getInitialTime()+ pb.getFinalTime())/ 2;double offset=t - middle;if (offset > 0){throw new LocalException(t);}return offset;}public void resetState(double t,double[]y){}},Double.POSITIVE_INFINITY,1.0e-8 * maxStep,1000);integ.integrate(pb,pb.getInitialTime(),pb.getInitialState(),pb.getFinalTime(),new double[pb.getDimension()]);}
@Test public void testEventsNoConvergence()throws Exception {final TestProblem1 pb=new TestProblem1();double minStep=0;double maxStep=pb.getFinalTime()- pb.getInitialTime();double scalAbsoluteTolerance=1.0e-8;double scalRelativeTolerance=0.01 * scalAbsoluteTolerance;FirstOrderIntegrator integ=new HighamHall54Integrator(minStep,maxStep,scalAbsoluteTolerance,scalRelativeTolerance);TestProblemHandler handler=new TestProblemHandler(pb,integ);integ.addStepHandler(handler);integ.addEventHandler(new EventHandler(){public void init(double t0,double[]y0,double t){}public Action eventOccurred(double t,double[]y,boolean increasing){return Action.CONTINUE;}public double g(double t,double[]y){double middle=(pb.getInitialTime()+ pb.getFinalTime())/ 2;double offset=t - middle;return (offset > 0)? (offset + 0.5): (offset - 0.5);}public void resetState(double t,double[]y){}},Double.POSITIVE_INFINITY,1.0e-8 * maxStep,3);try {integ.integrate(pb,pb.getInitialTime(),pb.getInitialState(),pb.getFinalTime(),new double[pb.getDimension()]);Assert.fail("an exception should have been thrown");}catch(TooManyEvaluationsException tmee){}}
@Test public void testSanityChecks()throws Exception {final TestProblem3 pb=new TestProblem3(0.9);double minStep=0;double maxStep=pb.getFinalTime()- pb.getInitialTime();try {FirstOrderIntegrator integ=new HighamHall54Integrator(minStep,maxStep,new double[4],new double[4]);integ.integrate(pb,pb.getInitialTime(),new double[6],pb.getFinalTime(),new double[pb.getDimension()]);Assert.fail("an exception should have been thrown");}catch(DimensionMismatchException ie){}try {FirstOrderIntegrator integ=new HighamHall54Integrator(minStep,maxStep,new double[4],new double[4]);integ.integrate(pb,pb.getInitialTime(),pb.getInitialState(),pb.getFinalTime(),new double[6]);Assert.fail("an exception should have been thrown");}catch(DimensionMismatchException ie){}try {FirstOrderIntegrator integ=new HighamHall54Integrator(minStep,maxStep,new double[2],new double[4]);integ.integrate(pb,pb.getInitialTime(),pb.getInitialState(),pb.getFinalTime(),new double[pb.getDimension()]);Assert.fail("an exception should have been thrown");}catch(DimensionMismatchException ie){}try {FirstOrderIntegrator integ=new HighamHall54Integrator(minStep,maxStep,new double[4],new double[2]);integ.integrate(pb,pb.getInitialTime(),pb.getInitialState(),pb.getFinalTime(),new double[pb.getDimension()]);Assert.fail("an exception should have been thrown");}catch(DimensionMismatchException ie){}try {FirstOrderIntegrator integ=new HighamHall54Integrator(minStep,maxStep,new double[4],new double[4]);integ.integrate(pb,pb.getInitialTime(),pb.getInitialState(),pb.getInitialTime(),new double[pb.getDimension()]);Assert.fail("an exception should have been thrown");}catch(NumberIsTooSmallException ie){}}
@Test public void testKepler(){final TestProblem3 pb=new TestProblem3(0.9);double minStep=0;double maxStep=pb.getFinalTime()- pb.getInitialTime();double[]vecAbsoluteTolerance={1.0e-8,1.0e-8,1.0e-10,1.0e-10};double[]vecRelativeTolerance={1.0e-10,1.0e-10,1.0e-8,1.0e-8};FirstOrderIntegrator integ=new HighamHall54Integrator(minStep,maxStep,vecAbsoluteTolerance,vecRelativeTolerance);TestProblemHandler handler=new TestProblemHandler(pb,integ);integ.addStepHandler(handler);integ.integrate(pb,pb.getInitialTime(),pb.getInitialState(),pb.getFinalTime(),new double[pb.getDimension()]);Assert.assertEquals(0.0,handler.getMaximalValueError(),1.5e-4);Assert.assertEquals("Higham-Hall 5(4)",integ.getName());}
@Test public void testConstructor()throws Exception {assertFraction(0,1,new Fraction(0,1));assertFraction(0,1,new Fraction(0,2));assertFraction(0,1,new Fraction(0,-1));assertFraction(1,2,new Fraction(1,2));assertFraction(1,2,new Fraction(2,4));assertFraction(-1,2,new Fraction(-1,2));assertFraction(-1,2,new Fraction(1,-2));assertFraction(-1,2,new Fraction(-2,4));assertFraction(-1,2,new Fraction(2,-4));try {new Fraction(Integer.MIN_VALUE,-1);Assert.fail();}catch(MathArithmeticException ex){}try {new Fraction(1,Integer.MIN_VALUE);Assert.fail();}catch(MathArithmeticException ex){}assertFraction(0,1,new Fraction(0.00000000000001));assertFraction(2,5,new Fraction(0.40000000000001));assertFraction(15,1,new Fraction(15.0000000000001));}
@Test(expected=ConvergenceException.class)public void testGoldenRatio(){new Fraction((1 + FastMath.sqrt(5))/ 2,1.0e-12,25);}
@Test public void testDoubleConstructor()throws ConvergenceException {assertFraction(1,2,new Fraction((double)1 / (double)2));assertFraction(1,3,new Fraction((double)1 / (double)3));assertFraction(2,3,new Fraction((double)2 / (double)3));assertFraction(1,4,new Fraction((double)1 / (double)4));assertFraction(3,4,new Fraction((double)3 / (double)4));assertFraction(1,5,new Fraction((double)1 / (double)5));assertFraction(2,5,new Fraction((double)2 / (double)5));assertFraction(3,5,new Fraction((double)3 / (double)5));assertFraction(4,5,new Fraction((double)4 / (double)5));assertFraction(1,6,new Fraction((double)1 / (double)6));assertFraction(5,6,new Fraction((double)5 / (double)6));assertFraction(1,7,new Fraction((double)1 / (double)7));assertFraction(2,7,new Fraction((double)2 / (double)7));assertFraction(3,7,new Fraction((double)3 / (double)7));assertFraction(4,7,new Fraction((double)4 / (double)7));assertFraction(5,7,new Fraction((double)5 / (double)7));assertFraction(6,7,new Fraction((double)6 / (double)7));assertFraction(1,8,new Fraction((double)1 / (double)8));assertFraction(3,8,new Fraction((double)3 / (double)8));assertFraction(5,8,new Fraction((double)5 / (double)8));assertFraction(7,8,new Fraction((double)7 / (double)8));assertFraction(1,9,new Fraction((double)1 / (double)9));assertFraction(2,9,new Fraction((double)2 / (double)9));assertFraction(4,9,new Fraction((double)4 / (double)9));assertFraction(5,9,new Fraction((double)5 / (double)9));assertFraction(7,9,new Fraction((double)7 / (double)9));assertFraction(8,9,new Fraction((double)8 / (double)9));assertFraction(1,10,new Fraction((double)1 / (double)10));assertFraction(3,10,new Fraction((double)3 / (double)10));assertFraction(7,10,new Fraction((double)7 / (double)10));assertFraction(9,10,new Fraction((double)9 / (double)10));assertFraction(1,11,new Fraction((double)1 / (double)11));assertFraction(2,11,new Fraction((double)2 / (double)11));assertFraction(3,11,new Fraction((double)3 / (double)11));assertFraction(4,11,new Fraction((double)4 / (double)11));assertFraction(5,11,new Fraction((double)5 / (double)11));assertFraction(6,11,new Fraction((double)6 / (double)11));assertFraction(7,11,new Fraction((double)7 / (double)11));assertFraction(8,11,new Fraction((double)8 / (double)11));assertFraction(9,11,new Fraction((double)9 / (double)11));assertFraction(10,11,new Fraction((double)10 / (double)11));}
@Test public void testDigitLimitConstructor()throws ConvergenceException {assertFraction(2,5,new Fraction(0.4,9));assertFraction(2,5,new Fraction(0.4,99));assertFraction(2,5,new Fraction(0.4,999));assertFraction(3,5,new Fraction(0.6152,9));assertFraction(8,13,new Fraction(0.6152,99));assertFraction(510,829,new Fraction(0.6152,999));assertFraction(769,1250,new Fraction(0.6152,9999));}
@Test public void testIntegerOverflow(){checkIntegerOverflow(0.75000000001455192);checkIntegerOverflow(1.0e10);}
@Test public void testEpsilonLimitConstructor()throws ConvergenceException {assertFraction(2,5,new Fraction(0.4,1.0e-5,100));assertFraction(3,5,new Fraction(0.6152,0.02,100));assertFraction(8,13,new Fraction(0.6152,1.0e-3,100));assertFraction(251,408,new Fraction(0.6152,1.0e-4,100));assertFraction(251,408,new Fraction(0.6152,1.0e-5,100));assertFraction(510,829,new Fraction(0.6152,1.0e-6,100));assertFraction(769,1250,new Fraction(0.6152,1.0e-7,100));}
@Test public void testCompareTo(){Fraction first=new Fraction(1,2);Fraction second=new Fraction(1,3);Fraction third=new Fraction(1,2);Assert.assertEquals(0,first.compareTo(first));Assert.assertEquals(0,first.compareTo(third));Assert.assertEquals(1,first.compareTo(second));Assert.assertEquals(-1,second.compareTo(first));Fraction pi1=new Fraction(1068966896,340262731);Fraction pi2=new Fraction(411557987,131002976);Assert.assertEquals(-1,pi1.compareTo(pi2));Assert.assertEquals(1,pi2.compareTo(pi1));Assert.assertEquals(0.0,pi1.doubleValue()- pi2.doubleValue(),1.0e-20);}
@Test public void testDoubleValue(){Fraction first=new Fraction(1,2);Fraction second=new Fraction(1,3);Assert.assertEquals(0.5,first.doubleValue(),0.0);Assert.assertEquals(1.0 / 3.0,second.doubleValue(),0.0);}
@Test public void testFloatValue(){Fraction first=new Fraction(1,2);Fraction second=new Fraction(1,3);Assert.assertEquals(0.5f,first.floatValue(),0.0f);Assert.assertEquals((float)(1.0 / 3.0),second.floatValue(),0.0f);}
@Test public void testIntValue(){Fraction first=new Fraction(1,2);Fraction second=new Fraction(3,2);Assert.assertEquals(0,first.intValue());Assert.assertEquals(1,second.intValue());}
@Test public void testLongValue(){Fraction first=new Fraction(1,2);Fraction second=new Fraction(3,2);Assert.assertEquals(0L,first.longValue());Assert.assertEquals(1L,second.longValue());}
@Test public void testConstructorDouble()throws Exception {assertFraction(1,2,new Fraction(0.5));assertFraction(1,3,new Fraction(1.0 / 3.0));assertFraction(17,100,new Fraction(17.0 / 100.0));assertFraction(317,100,new Fraction(317.0 / 100.0));assertFraction(-1,2,new Fraction(-0.5));assertFraction(-1,3,new Fraction(-1.0 / 3.0));assertFraction(-17,100,new Fraction(17.0 / -100.0));assertFraction(-317,100,new Fraction(-317.0 / 100.0));}
@Test public void testAbs(){Fraction a=new Fraction(10,21);Fraction b=new Fraction(-10,21);Fraction c=new Fraction(10,-21);assertFraction(10,21,a.abs());assertFraction(10,21,b.abs());assertFraction(10,21,c.abs());}
@Test public void testPercentage(){Assert.assertEquals(50.0,new Fraction(1,2).percentageValue(),1.0e-15);}
@Test public void testReciprocal(){Fraction f=null;f=new Fraction(50,75);f=f.reciprocal();Assert.assertEquals(3,f.getNumerator());Assert.assertEquals(2,f.getDenominator());f=new Fraction(4,3);f=f.reciprocal();Assert.assertEquals(3,f.getNumerator());Assert.assertEquals(4,f.getDenominator());f=new Fraction(-15,47);f=f.reciprocal();Assert.assertEquals(-47,f.getNumerator());Assert.assertEquals(15,f.getDenominator());f=new Fraction(0,3);try {f=f.reciprocal();Assert.fail("expecting MathArithmeticException");}catch(MathArithmeticException ex){}f=new Fraction(Integer.MAX_VALUE,1);f=f.reciprocal();Assert.assertEquals(1,f.getNumerator());Assert.assertEquals(Integer.MAX_VALUE,f.getDenominator());}
@Test public void testNegate(){Fraction f=null;f=new Fraction(50,75);f=f.negate();Assert.assertEquals(-2,f.getNumerator());Assert.assertEquals(3,f.getDenominator());f=new Fraction(-50,75);f=f.negate();Assert.assertEquals(2,f.getNumerator());Assert.assertEquals(3,f.getDenominator());f=new Fraction(Integer.MAX_VALUE - 1,Integer.MAX_VALUE);f=f.negate();Assert.assertEquals(Integer.MIN_VALUE + 2,f.getNumerator());Assert.assertEquals(Integer.MAX_VALUE,f.getDenominator());f=new Fraction(Integer.MIN_VALUE,1);try {f=f.negate();Assert.fail("expecting MathArithmeticException");}catch(MathArithmeticException ex){}}
@Test public void testAdd(){Fraction a=new Fraction(1,2);Fraction b=new Fraction(2,3);assertFraction(1,1,a.add(a));assertFraction(7,6,a.add(b));assertFraction(7,6,b.add(a));assertFraction(4,3,b.add(b));Fraction f1=new Fraction(Integer.MAX_VALUE - 1,1);Fraction f2=Fraction.ONE;Fraction f=f1.add(f2);Assert.assertEquals(Integer.MAX_VALUE,f.getNumerator());Assert.assertEquals(1,f.getDenominator());f=f1.add(1);Assert.assertEquals(Integer.MAX_VALUE,f.getNumerator());Assert.assertEquals(1,f.getDenominator());f1=new Fraction(-1,13 * 13 * 2* 2);f2=new Fraction(-2,13 * 17 * 2);f=f1.add(f2);Assert.assertEquals(13 * 13 * 17* 2* 2,f.getDenominator());Assert.assertEquals(-17 - 2 * 13 * 2,f.getNumerator());try {f.add(null);Assert.fail("expecting MathIllegalArgumentException");}catch(MathIllegalArgumentException ex){}f1=new Fraction(1,32768 * 3);f2=new Fraction(1,59049);f=f1.add(f2);Assert.assertEquals(52451,f.getNumerator());Assert.assertEquals(1934917632,f.getDenominator());f1=new Fraction(Integer.MIN_VALUE,3);f2=new Fraction(1,3);f=f1.add(f2);Assert.assertEquals(Integer.MIN_VALUE + 1,f.getNumerator());Assert.assertEquals(3,f.getDenominator());f1=new Fraction(Integer.MAX_VALUE - 1,1);f2=Fraction.ONE;f=f1.add(f2);Assert.assertEquals(Integer.MAX_VALUE,f.getNumerator());Assert.assertEquals(1,f.getDenominator());try {f=f.add(Fraction.ONE);Assert.fail("expecting MathArithmeticException but got: " + f.toString());}catch(MathArithmeticException ex){}f1=new Fraction(Integer.MIN_VALUE,5);f2=new Fraction(-1,5);try {f=f1.add(f2);Assert.fail("expecting MathArithmeticException but got: " + f.toString());}catch(MathArithmeticException ex){}try {f=new Fraction(-Integer.MAX_VALUE,1);f=f.add(f);Assert.fail("expecting MathArithmeticException");}catch(MathArithmeticException ex){}try {f=new Fraction(-Integer.MAX_VALUE,1);f=f.add(f);Assert.fail("expecting MathArithmeticException");}catch(MathArithmeticException ex){}f1=new Fraction(3,327680);f2=new Fraction(2,59049);try {f=f1.add(f2);Assert.fail("expecting MathArithmeticException but got: " + f.toString());}catch(MathArithmeticException ex){}}
@Test public void testDivide(){Fraction a=new Fraction(1,2);Fraction b=new Fraction(2,3);assertFraction(1,1,a.divide(a));assertFraction(3,4,a.divide(b));assertFraction(4,3,b.divide(a));assertFraction(1,1,b.divide(b));Fraction f1=new Fraction(3,5);Fraction f2=Fraction.ZERO;try {f1.divide(f2);Assert.fail("expecting MathArithmeticException");}catch(MathArithmeticException ex){}f1=new Fraction(0,5);f2=new Fraction(2,7);Fraction f=f1.divide(f2);Assert.assertSame(Fraction.ZERO,f);f1=new Fraction(2,7);f2=Fraction.ONE;f=f1.divide(f2);Assert.assertEquals(2,f.getNumerator());Assert.assertEquals(7,f.getDenominator());f1=new Fraction(1,Integer.MAX_VALUE);f=f1.divide(f1);Assert.assertEquals(1,f.getNumerator());Assert.assertEquals(1,f.getDenominator());f1=new Fraction(Integer.MIN_VALUE,Integer.MAX_VALUE);f2=new Fraction(1,Integer.MAX_VALUE);f=f1.divide(f2);Assert.assertEquals(Integer.MIN_VALUE,f.getNumerator());Assert.assertEquals(1,f.getDenominator());try {f.divide(null);Assert.fail("MathIllegalArgumentException");}catch(MathIllegalArgumentException ex){}try {f1=new Fraction(1,Integer.MAX_VALUE);f=f1.divide(f1.reciprocal());Assert.fail("expecting MathArithmeticException");}catch(MathArithmeticException ex){}try {f1=new Fraction(1,-Integer.MAX_VALUE);f=f1.divide(f1.reciprocal());Assert.fail("expecting MathArithmeticException");}catch(MathArithmeticException ex){}f1=new Fraction(6,35);f=f1.divide(15);Assert.assertEquals(2,f.getNumerator());Assert.assertEquals(175,f.getDenominator());}
@Test public void testMultiply(){Fraction a=new Fraction(1,2);Fraction b=new Fraction(2,3);assertFraction(1,4,a.multiply(a));assertFraction(1,3,a.multiply(b));assertFraction(1,3,b.multiply(a));assertFraction(4,9,b.multiply(b));Fraction f1=new Fraction(Integer.MAX_VALUE,1);Fraction f2=new Fraction(Integer.MIN_VALUE,Integer.MAX_VALUE);Fraction f=f1.multiply(f2);Assert.assertEquals(Integer.MIN_VALUE,f.getNumerator());Assert.assertEquals(1,f.getDenominator());try {f.multiply(null);Assert.fail("expecting MathIllegalArgumentException");}catch(MathIllegalArgumentException ex){}f1=new Fraction(6,35);f=f1.multiply(15);Assert.assertEquals(18,f.getNumerator());Assert.assertEquals(7,f.getDenominator());}
@Test public void testSubtract(){Fraction a=new Fraction(1,2);Fraction b=new Fraction(2,3);assertFraction(0,1,a.subtract(a));assertFraction(-1,6,a.subtract(b));assertFraction(1,6,b.subtract(a));assertFraction(0,1,b.subtract(b));Fraction f=new Fraction(1,1);try {f.subtract(null);Assert.fail("expecting MathIllegalArgumentException");}catch(MathIllegalArgumentException ex){}Fraction f1=new Fraction(1,32768 * 3);Fraction f2=new Fraction(1,59049);f=f1.subtract(f2);Assert.assertEquals(-13085,f.getNumerator());Assert.assertEquals(1934917632,f.getDenominator());f1=new Fraction(Integer.MIN_VALUE,3);f2=new Fraction(1,3).negate();f=f1.subtract(f2);Assert.assertEquals(Integer.MIN_VALUE + 1,f.getNumerator());Assert.assertEquals(3,f.getDenominator());f1=new Fraction(Integer.MAX_VALUE,1);f2=Fraction.ONE;f=f1.subtract(f2);Assert.assertEquals(Integer.MAX_VALUE - 1,f.getNumerator());Assert.assertEquals(1,f.getDenominator());f=f1.subtract(1);Assert.assertEquals(Integer.MAX_VALUE - 1,f.getNumerator());Assert.assertEquals(1,f.getDenominator());try {f1=new Fraction(1,Integer.MAX_VALUE);f2=new Fraction(1,Integer.MAX_VALUE - 1);f=f1.subtract(f2);Assert.fail("expecting MathArithmeticException");}catch(MathArithmeticException ex){}f1=new Fraction(Integer.MIN_VALUE,5);f2=new Fraction(1,5);try {f=f1.subtract(f2);Assert.fail("expecting MathArithmeticException but got: " + f.toString());}catch(MathArithmeticException ex){}try {f=new Fraction(Integer.MIN_VALUE,1);f=f.subtract(Fraction.ONE);Assert.fail("expecting MathArithmeticException");}catch(MathArithmeticException ex){}try {f=new Fraction(Integer.MAX_VALUE,1);f=f.subtract(Fraction.ONE.negate());Assert.fail("expecting MathArithmeticException");}catch(MathArithmeticException ex){}f1=new Fraction(3,327680);f2=new Fraction(2,59049);try {f=f1.subtract(f2);Assert.fail("expecting MathArithmeticException but got: " + f.toString());}catch(MathArithmeticException ex){}}
@Test public void testEqualsAndHashCode(){Fraction zero=new Fraction(0,1);Fraction nullFraction=null;Assert.assertTrue(zero.equals(zero));Assert.assertFalse(zero.equals(nullFraction));Assert.assertFalse(zero.equals(Double.valueOf(0)));Fraction zero2=new Fraction(0,2);Assert.assertTrue(zero.equals(zero2));Assert.assertEquals(zero.hashCode(),zero2.hashCode());Fraction one=new Fraction(1,1);Assert.assertFalse((one.equals(zero)|| zero.equals(one)));}
@Test public void testGetReducedFraction(){Fraction threeFourths=new Fraction(3,4);Assert.assertTrue(threeFourths.equals(Fraction.getReducedFraction(6,8)));Assert.assertTrue(Fraction.ZERO.equals(Fraction.getReducedFraction(0,-1)));try {Fraction.getReducedFraction(1,0);Assert.fail("expecting MathArithmeticException");}catch(MathArithmeticException ex){}Assert.assertEquals(Fraction.getReducedFraction(2,Integer.MIN_VALUE).getNumerator(),-1);Assert.assertEquals(Fraction.getReducedFraction(1,-1).getNumerator(),-1);}
@Test public void testToString(){Assert.assertEquals("0",new Fraction(0,3).toString());Assert.assertEquals("3",new Fraction(6,2).toString());Assert.assertEquals("2 / 3",new Fraction(18,27).toString());}
@Test public void testSerial()throws FractionConversionException {Fraction[]fractions={new Fraction(3,4),Fraction.ONE,Fraction.ZERO,new Fraction(17),new Fraction(FastMath.PI,1000),new Fraction(-5,2)};for(Fraction fraction : fractions){Assert.assertEquals(fraction,TestUtils.serializeAndRecover(fraction));}}
@Test public void testSpecialValues(){Sum sum=new Sum();Assert.assertEquals(0,sum.getResult(),0);sum.increment(1);Assert.assertEquals(1,sum.getResult(),0);sum.increment(Double.POSITIVE_INFINITY);Assert.assertEquals(Double.POSITIVE_INFINITY,sum.getResult(),0);sum.increment(Double.NEGATIVE_INFINITY);Assert.assertTrue(Double.isNaN(sum.getResult()));sum.increment(1);Assert.assertTrue(Double.isNaN(sum.getResult()));}
@Test public void testWeightedSum(){Sum sum=new Sum();Assert.assertEquals(expectedWeightedValue(),sum.evaluate(testArray,testWeightsArray,0,testArray.length),getTolerance());Assert.assertEquals(expectedValue(),sum.evaluate(testArray,unitWeightsArray,0,testArray.length),getTolerance());}
@Test public void testWeightedConsistency(){}
/** * Verifies that increment()and incrementAll work properly.*/@Test public void testIncrementation()throws Exception {StorelessUnivariateStatistic statistic=(StorelessUnivariateStatistic)getUnivariateStatistic();for (int i=0;i < testArray.length;i++){statistic.increment(testArray[i]);}Assert.assertEquals(expectedValue(),statistic.getResult(),getTolerance());Assert.assertEquals(testArray.length,statistic.getN());statistic.clear();statistic.incrementAll(testArray);Assert.assertEquals(expectedValue(),statistic.getResult(),getTolerance());Assert.assertEquals(testArray.length,statistic.getN());statistic.clear();checkClearValue(statistic);Assert.assertEquals(0,statistic.getN());}
@Test public void testSerialization()throws Exception {StorelessUnivariateStatistic statistic=(StorelessUnivariateStatistic)getUnivariateStatistic();TestUtils.checkSerializedEquality(statistic);statistic.clear();for (int i=0;i < testArray.length;i++){statistic.increment(testArray[i]);if (i % 5 == 0)statistic=(StorelessUnivariateStatistic)TestUtils.serializeAndRecover(statistic);}TestUtils.checkSerializedEquality(statistic);Assert.assertEquals(expectedValue(),statistic.getResult(),getTolerance());statistic.clear();checkClearValue(statistic);}
@Test public void testEqualsAndHashCode(){StorelessUnivariateStatistic statistic=(StorelessUnivariateStatistic)getUnivariateStatistic();StorelessUnivariateStatistic statistic2=null;Assert.assertTrue("non-null,compared to null",!statistic.equals(statistic2));Assert.assertTrue("reflexive,non-null",statistic.equals(statistic));int emptyHash=statistic.hashCode();statistic2=(StorelessUnivariateStatistic)getUnivariateStatistic();Assert.assertTrue("empty stats should be equal",statistic.equals(statistic2));Assert.assertEquals("empty stats should have the same hashcode",emptyHash,statistic2.hashCode());statistic.increment(1d);Assert.assertTrue("reflexive,non-empty",statistic.equals(statistic));Assert.assertTrue("non-empty,compared to empty",!statistic.equals(statistic2));Assert.assertTrue("non-empty,compared to empty",!statistic2.equals(statistic));Assert.assertTrue("non-empty stat should have different hashcode from empty stat",statistic.hashCode()!= emptyHash);statistic2.increment(1d);Assert.assertTrue("stats with same data should be equal",statistic.equals(statistic2));Assert.assertEquals("stats with same data should have the same hashcode",statistic.hashCode(),statistic2.hashCode());statistic.increment(Double.POSITIVE_INFINITY);Assert.assertTrue("stats with different n's should not be equal",!statistic2.equals(statistic));Assert.assertTrue("stats with different n's should have different hashcodes",statistic.hashCode()!= statistic2.hashCode());statistic2.increment(Double.POSITIVE_INFINITY);Assert.assertTrue("stats with same data should be equal",statistic.equals(statistic2));Assert.assertEquals("stats with same data should have the same hashcode",statistic.hashCode(),statistic2.hashCode());statistic.clear();statistic2.clear();Assert.assertTrue("cleared stats should be equal",statistic.equals(statistic2));Assert.assertEquals("cleared stats should have thashcode of empty stat",emptyHash,statistic2.hashCode());Assert.assertEquals("cleared stats should have thashcode of empty stat",emptyHash,statistic.hashCode());}
@Test public void testMomentSmallSamples(){UnivariateStatistic stat=getUnivariateStatistic();if (stat instanceof SecondMoment){SecondMoment moment=(SecondMoment)getUnivariateStatistic();Assert.assertTrue(Double.isNaN(moment.getResult()));moment.increment(1d);Assert.assertEquals(0d,moment.getResult(),0);}}
/** * Make sure that evaluate(double[])and inrementAll(double[]),getResult()give same results.*/@Test public void testConsistency(){StorelessUnivariateStatistic stat=(StorelessUnivariateStatistic)getUnivariateStatistic();stat.incrementAll(testArray);Assert.assertEquals(stat.getResult(),stat.evaluate(testArray),getTolerance());for (int i=0;i < smallSamples.length;i++){stat.clear();for (int j=0;j < smallSamples[i].length;j++){stat.increment(smallSamples[i][j]);}TestUtils.assertEquals(stat.getResult(),stat.evaluate(smallSamples[i]),getTolerance());}}
/** * Verifies that copied statistics remain equal to originals when incremented the same way.*/@Test public void testCopyConsistency(){StorelessUnivariateStatistic master=(StorelessUnivariateStatistic)getUnivariateStatistic();StorelessUnivariateStatistic replica=null;long index=FastMath.round((FastMath.random())* testArray.length);master.incrementAll(testArray,0,(int)index);replica=master.copy();Assert.assertTrue(replica.equals(master));Assert.assertTrue(master.equals(replica));master.incrementAll(testArray,(int)index,(int)(testArray.length - index));replica.incrementAll(testArray,(int)index,(int)(testArray.length - index));Assert.assertTrue(replica.equals(master));Assert.assertTrue(master.equals(replica));}
@Test public void testSerial(){StorelessUnivariateStatistic s=(StorelessUnivariateStatistic)getUnivariateStatistic();Assert.assertEquals(s,TestUtils.serializeAndRecover(s));}
@Test public void testEvaluation()throws Exception {Assert.assertEquals(expectedValue(),getUnivariateStatistic().evaluate(testArray),getTolerance());}
@Test public void testEvaluateArraySegment(){final UnivariateStatistic stat=getUnivariateStatistic();final double[]arrayZero=new double[5];System.arraycopy(testArray,0,arrayZero,0,5);Assert.assertEquals(stat.evaluate(arrayZero),stat.evaluate(testArray,0,5),0);final double[]arrayOne=new double[5];System.arraycopy(testArray,5,arrayOne,0,5);Assert.assertEquals(stat.evaluate(arrayOne),stat.evaluate(testArray,5,5),0);final double[]arrayEnd=new double[5];System.arraycopy(testArray,testArray.length - 5,arrayEnd,0,5);Assert.assertEquals(stat.evaluate(arrayEnd),stat.evaluate(testArray,testArray.length - 5,5),0);}
@Test public void testEvaluateArraySegmentWeighted(){UnivariateStatistic statistic=getUnivariateStatistic();if (!(statistic instanceof WeightedEvaluation)){return;}final WeightedEvaluation stat=(WeightedEvaluation)getUnivariateStatistic();final double[]arrayZero=new double[5];final double[]weightZero=new double[5];System.arraycopy(testArray,0,arrayZero,0,5);System.arraycopy(testWeightsArray,0,weightZero,0,5);Assert.assertEquals(stat.evaluate(arrayZero,weightZero),stat.evaluate(testArray,testWeightsArray,0,5),0);final double[]arrayOne=new double[5];final double[]weightOne=new double[5];System.arraycopy(testArray,5,arrayOne,0,5);System.arraycopy(testWeightsArray,5,weightOne,0,5);Assert.assertEquals(stat.evaluate(arrayOne,weightOne),stat.evaluate(testArray,testWeightsArray,5,5),0);final double[]arrayEnd=new double[5];final double[]weightEnd=new double[5];System.arraycopy(testArray,testArray.length - 5,arrayEnd,0,5);System.arraycopy(testWeightsArray,testArray.length - 5,weightEnd,0,5);Assert.assertEquals(stat.evaluate(arrayEnd,weightEnd),stat.evaluate(testArray,testWeightsArray,testArray.length - 5,5),0);}
@Test public void testCopy()throws Exception {UnivariateStatistic original=getUnivariateStatistic();UnivariateStatistic copy=original.copy();Assert.assertEquals(expectedValue(),copy.evaluate(testArray),getTolerance());}
@Test public void testAccessors(){final NumberIsTooLargeException e=new NumberIsTooLargeException(1,0,true);Assert.assertEquals(1,e.getArgument());Assert.assertEquals(0,e.getMax());Assert.assertTrue(e.getBoundIsAllowed());}
@Test(expected=MatrixDimensionMismatchException.class)public void testTransitionMeasurementMatrixMismatch(){RealMatrix A=new Array2DRowRealMatrix(new double[]{1d});RealMatrix B=null;RealMatrix H=new Array2DRowRealMatrix(new double[]{1d,1d});RealMatrix Q=new Array2DRowRealMatrix(new double[]{0});RealMatrix R=new Array2DRowRealMatrix(new double[]{0});ProcessModel pm=new DefaultProcessModel(A,B,Q,new ArrayRealVector(new double[]{0}),null);MeasurementModel mm=new DefaultMeasurementModel(H,R);new KalmanFilter(pm,mm);Assert.fail("transition and measurement matrix should not be compatible");}
@Test(expected=MatrixDimensionMismatchException.class)public void testTransitionControlMatrixMismatch(){RealMatrix A=new Array2DRowRealMatrix(new double[]{1d});RealMatrix B=new Array2DRowRealMatrix(new double[]{1d,1d});RealMatrix H=new Array2DRowRealMatrix(new double[]{1d});RealMatrix Q=new Array2DRowRealMatrix(new double[]{0});RealMatrix R=new Array2DRowRealMatrix(new double[]{0});ProcessModel pm=new DefaultProcessModel(A,B,Q,new ArrayRealVector(new double[]{0}),null);MeasurementModel mm=new DefaultMeasurementModel(H,R);new KalmanFilter(pm,mm);Assert.fail("transition and control matrix should not be compatible");}
@Test public void testConstant(){double constantValue=10d;double measurementNoise=0.1d;double processNoise=1e-5d;RealMatrix A=new Array2DRowRealMatrix(new double[]{1d});RealMatrix B=null;RealMatrix H=new Array2DRowRealMatrix(new double[]{1d});RealVector x=new ArrayRealVector(new double[]{constantValue});RealMatrix Q=new Array2DRowRealMatrix(new double[]{processNoise});RealMatrix R=new Array2DRowRealMatrix(new double[]{measurementNoise});ProcessModel pm=new DefaultProcessModel(A,B,Q,new ArrayRealVector(new double[]{constantValue}),null);MeasurementModel mm=new DefaultMeasurementModel(H,R);KalmanFilter filter=new KalmanFilter(pm,mm);Assert.assertEquals(1,filter.getMeasurementDimension());Assert.assertEquals(1,filter.getStateDimension());assertMatrixEquals(Q.getData(),filter.getErrorCovariance());double[]expectedInitialState=new double[]{constantValue};assertVectorEquals(expectedInitialState,filter.getStateEstimation());RealVector pNoise=new ArrayRealVector(1);RealVector mNoise=new ArrayRealVector(1);RandomGenerator rand=new JDKRandomGenerator();for (int i=0;i < 60;i++){filter.predict();pNoise.setEntry(0,processNoise * rand.nextGaussian());x=A.operate(x).add(pNoise);mNoise.setEntry(0,measurementNoise * rand.nextGaussian());RealVector z=H.operate(x).add(mNoise);filter.correct(z);double diff=Math.abs(constantValue - filter.getStateEstimation()[0]);Assert.assertTrue(Precision.compareTo(diff,measurementNoise,1e-6)< 0);}Assert.assertTrue(Precision.compareTo(filter.getErrorCovariance()[0][0],0.02d,1e-6)< 0);}
@Test public void testConstantAcceleration(){double dt=0.1d;double measurementNoise=10d;double accelNoise=0.2d;RealMatrix A=new Array2DRowRealMatrix(new double[][]{{1,dt},{0,1}});RealMatrix B=new Array2DRowRealMatrix(new double[][]{{Math.pow(dt,2d)/ 2d},{dt}});RealMatrix H=new Array2DRowRealMatrix(new double[][]{{1d,0d}});RealVector x=new ArrayRealVector(new double[]{0,0});RealMatrix tmp=new Array2DRowRealMatrix(new double[][]{{Math.pow(dt,4d)/ 4d,Math.pow(dt,3d)/ 2d},{Math.pow(dt,3d)/ 2d,Math.pow(dt,2d)}});RealMatrix Q=tmp.scalarMultiply(Math.pow(accelNoise,2));RealMatrix P0=new Array2DRowRealMatrix(new double[][]{{1,1},{1,1}});RealMatrix R=new Array2DRowRealMatrix(new double[]{Math.pow(measurementNoise,2)});RealVector u=new ArrayRealVector(new double[]{0.1d});ProcessModel pm=new DefaultProcessModel(A,B,Q,x,P0);MeasurementModel mm=new DefaultMeasurementModel(H,R);KalmanFilter filter=new KalmanFilter(pm,mm);Assert.assertEquals(1,filter.getMeasurementDimension());Assert.assertEquals(2,filter.getStateDimension());assertMatrixEquals(P0.getData(),filter.getErrorCovariance());double[]expectedInitialState=new double[]{0.0,0.0};assertVectorEquals(expectedInitialState,filter.getStateEstimation());RandomGenerator rand=new JDKRandomGenerator();RealVector tmpPNoise=new ArrayRealVector(new double[]{Math.pow(dt,2d)/ 2d,dt});RealVector mNoise=new ArrayRealVector(1);for (int i=0;i < 60;i++){filter.predict(u);RealVector pNoise=tmpPNoise.mapMultiply(accelNoise * rand.nextGaussian());x=A.operate(x).add(B.operate(u)).add(pNoise);mNoise.setEntry(0,measurementNoise * rand.nextGaussian());RealVector z=H.operate(x).add(mNoise);filter.correct(z);double diff=Math.abs(x.getEntry(0)- filter.getStateEstimation()[0]);Assert.assertTrue(Precision.compareTo(diff,measurementNoise,1e-6)< 0);}Assert.assertTrue(Precision.compareTo(filter.getErrorCovariance()[1][1],0.1d,1e-6)< 0);}
@Test public void testRegularizedBetaNanPositivePositive(){testRegularizedBeta(Double.NaN,Double.NaN,1.0,1.0);}
@Test public void testRegularizedBetaPositiveNanPositive(){testRegularizedBeta(Double.NaN,0.5,Double.NaN,1.0);}
@Test public void testRegularizedBetaPositivePositiveNan(){testRegularizedBeta(Double.NaN,0.5,1.0,Double.NaN);}
@Test public void testRegularizedBetaNegativePositivePositive(){testRegularizedBeta(Double.NaN,-0.5,1.0,2.0);}
@Test public void testRegularizedBetaPositiveNegativePositive(){testRegularizedBeta(Double.NaN,0.5,-1.0,2.0);}
@Test public void testRegularizedBetaPositivePositiveNegative(){testRegularizedBeta(Double.NaN,0.5,1.0,-2.0);}
@Test public void testRegularizedBetaZeroPositivePositive(){testRegularizedBeta(0.0,0.0,1.0,2.0);}
@Test public void testRegularizedBetaPositiveZeroPositive(){testRegularizedBeta(Double.NaN,0.5,0.0,2.0);}
@Test public void testRegularizedBetaPositivePositiveZero(){testRegularizedBeta(Double.NaN,0.5,1.0,0.0);}
@Test public void testRegularizedBetaPositivePositivePositive(){testRegularizedBeta(0.75,0.5,1.0,2.0);}
@Test public void testLogBetaNanPositive(){testLogBeta(Double.NaN,Double.NaN,2.0);}
@Test public void testLogBetaPositiveNan(){testLogBeta(Double.NaN,1.0,Double.NaN);}
@Test public void testLogBetaNegativePositive(){testLogBeta(Double.NaN,-1.0,2.0);}
@Test public void testLogBetaPositiveNegative(){testLogBeta(Double.NaN,1.0,-2.0);}
@Test public void testLogBetaZeroPositive(){testLogBeta(Double.NaN,0.0,2.0);}
@Test public void testLogBetaPositiveZero(){testLogBeta(Double.NaN,1.0,0.0);}
@Test public void testLogBetaPositivePositive(){testLogBeta(-0.693147180559945,1.0,2.0);}
@Test public void testAnovaFValue()throws Exception {List<double[]> threeClasses=new ArrayList<double[]>();threeClasses.add(classA);threeClasses.add(classB);threeClasses.add(classC);Assert.assertEquals("ANOVA F-value",24.67361709460624,testStatistic.anovaFValue(threeClasses),1E-12);List<double[]> twoClasses=new ArrayList<double[]>();twoClasses.add(classA);twoClasses.add(classB);Assert.assertEquals("ANOVA F-value",0.0150579150579,testStatistic.anovaFValue(twoClasses),1E-12);List<double[]> emptyContents=new ArrayList<double[]>();emptyContents.add(emptyArray);emptyContents.add(classC);try {testStatistic.anovaFValue(emptyContents);Assert.fail("empty array for key classX,IllegalArgumentException expected");}catch(IllegalArgumentException ex){}List<double[]> tooFew=new ArrayList<double[]>();tooFew.add(classA);try {testStatistic.anovaFValue(tooFew);Assert.fail("less than two classes,IllegalArgumentException expected");}catch(IllegalArgumentException ex){}}
@Test public void testAnovaPValue()throws Exception {List<double[]> threeClasses=new ArrayList<double[]>();threeClasses.add(classA);threeClasses.add(classB);threeClasses.add(classC);Assert.assertEquals("ANOVA P-value",6.959446E-06,testStatistic.anovaPValue(threeClasses),1E-12);List<double[]> twoClasses=new ArrayList<double[]>();twoClasses.add(classA);twoClasses.add(classB);Assert.assertEquals("ANOVA P-value",0.904212960464,testStatistic.anovaPValue(twoClasses),1E-12);}
@Test public void testAnovaTest()throws Exception {List<double[]> threeClasses=new ArrayList<double[]>();threeClasses.add(classA);threeClasses.add(classB);threeClasses.add(classC);Assert.assertTrue("ANOVA Test P<0.01",testStatistic.anovaTest(threeClasses,0.01));List<double[]> twoClasses=new ArrayList<double[]>();twoClasses.add(classA);twoClasses.add(classB);Assert.assertFalse("ANOVA Test P>0.01",testStatistic.anovaTest(twoClasses,0.01));}
/** * Test Longley dataset against R.*/@Override @Test public void testLongly()throws Exception {RealMatrix matrix=createRealMatrix(longleyData,16,7);SpearmansCorrelation corrInstance=new SpearmansCorrelation(matrix);RealMatrix correlationMatrix=corrInstance.getCorrelationMatrix();double[]rData=new double[]{1,0.982352941176471,0.985294117647059,0.564705882352941,0.2264705882352941,0.976470588235294,0.976470588235294,0.982352941176471,1,0.997058823529412,0.664705882352941,0.2205882352941176,0.997058823529412,0.997058823529412,0.985294117647059,0.997058823529412,1,0.638235294117647,0.2235294117647059,0.9941176470588236,0.9941176470588236,0.564705882352941,0.664705882352941,0.638235294117647,1,-0.3411764705882353,0.685294117647059,0.685294117647059,0.2264705882352941,0.2205882352941176,0.2235294117647059,-0.3411764705882353,1,0.2264705882352941,0.2264705882352941,0.976470588235294,0.997058823529412,0.9941176470588236,0.685294117647059,0.2264705882352941,1,1,0.976470588235294,0.997058823529412,0.9941176470588236,0.685294117647059,0.2264705882352941,1,1};TestUtils.assertEquals("Spearman's correlation matrix",createRealMatrix(rData,7,7),correlationMatrix,10E-15);}
/** * Test R swiss fertility dataset.*/@Test public void testSwiss()throws Exception {RealMatrix matrix=createRealMatrix(swissData,47,5);SpearmansCorrelation corrInstance=new SpearmansCorrelation(matrix);RealMatrix correlationMatrix=corrInstance.getCorrelationMatrix();double[]rData=new double[]{1,0.2426642769364176,-0.660902996352354,-0.443257690360988,0.4136455623012432,0.2426642769364176,1,-0.598859938748963,-0.650463814145816,0.2886878090882852,-0.660902996352354,-0.598859938748963,1,0.674603831406147,-0.4750575257171745,-0.443257690360988,-0.650463814145816,0.674603831406147,1,-0.1444163088302244,0.4136455623012432,0.2886878090882852,-0.4750575257171745,-0.1444163088302244,1};TestUtils.assertEquals("Spearman's correlation matrix",createRealMatrix(rData,5,5),correlationMatrix,10E-15);}
/** * Constant column*/@Override @Test public void testConstant(){double[]noVariance=new double[]{1,1,1,1};double[]values=new double[]{1,2,3,4};Assert.assertTrue(Double.isNaN(new SpearmansCorrelation().correlation(noVariance,values)));}
/** * Insufficient data*/@Override @Test public void testInsufficientData(){double[]one=new double[]{1};double[]two=new double[]{2};try {new SpearmansCorrelation().correlation(one,two);Assert.fail("Expecting IllegalArgumentException");}catch(IllegalArgumentException ex){}RealMatrix matrix=new BlockRealMatrix(new double[][]{{0},{1}});try {new SpearmansCorrelation(matrix);Assert.fail("Expecting IllegalArgumentException");}catch(IllegalArgumentException ex){}}
@Override @Test public void testConsistency(){RealMatrix matrix=createRealMatrix(longleyData,16,7);SpearmansCorrelation corrInstance=new SpearmansCorrelation(matrix);double[][]data=matrix.getData();double[]x=matrix.getColumn(0);double[]y=matrix.getColumn(1);Assert.assertEquals(new SpearmansCorrelation().correlation(x,y),corrInstance.getCorrelationMatrix().getEntry(0,1),Double.MIN_VALUE);TestUtils.assertEquals("Correlation matrix",corrInstance.getCorrelationMatrix(),new SpearmansCorrelation().computeCorrelationMatrix(data),Double.MIN_VALUE);}
@Override @Test public void testStdErrorConsistency()throws Exception {}
@Override @Test public void testCovarianceConsistency()throws Exception {}
/** * Test R Swiss fertility dataset against R.*/@Test public void testSwissFertility()throws Exception {RealMatrix matrix=createRealMatrix(swissData,47,5);PearsonsCorrelation corrInstance=new PearsonsCorrelation(matrix);RealMatrix correlationMatrix=corrInstance.getCorrelationMatrix();double[]rData=new double[]{1.0000000000000000,0.3530791836199747,-0.6458827064572875,-0.6637888570350691,0.4636847006517939,0.3530791836199747,1.0000000000000000,-0.6865422086171366,-0.6395225189483201,0.4010950530487398,-0.6458827064572875,-0.6865422086171366,1.0000000000000000,0.6984152962884830,-0.5727418060641666,-0.6637888570350691,-0.6395225189483201,0.6984152962884830,1.0000000000000000,-0.1538589170909148,0.4636847006517939,0.4010950530487398,-0.5727418060641666,-0.1538589170909148,1.0000000000000000};TestUtils.assertEquals("correlation matrix",createRealMatrix(rData,5,5),correlationMatrix,10E-15);double[]rPvalues=new double[]{0.01491720061472623,9.45043734069043e-07,9.95151527133974e-08,3.658616965962355e-07,1.304590105694471e-06,4.811397236181847e-08,0.001028523190118147,0.005204433539191644,2.588307925380906e-05,0.301807756132683};RealMatrix rPMatrix=createLowerTriangularRealMatrix(rPvalues,5);fillUpper(rPMatrix,0d);TestUtils.assertEquals("correlation p values",rPMatrix,corrInstance.getCorrelationPValues(),10E-15);}
/** * Test p-value near 0. JIRA: MATH-371*/@Test public void testPValueNearZero()throws Exception {int dimension=120;double[][]data=new double[dimension][2];for (int i=0;i < dimension;i++){data[i][0]=i;data[i][1]=i + 1 / ((double)i + 1);}PearsonsCorrelation corrInstance=new PearsonsCorrelation(data);Assert.assertTrue(corrInstance.getCorrelationPValues().getEntry(0,1)> 0);}
@Test public void testAccessors(){final NumberIsTooSmallException e=new NumberIsTooSmallException(0,0,false);Assert.assertEquals(0,e.getArgument());Assert.assertEquals(0,e.getMin());Assert.assertFalse(e.getBoundIsAllowed());}
/** * Test Longley dataset against R. Data Source: J. Longley (1967)"An Appraisal of Least Squares Programs for the Electronic Computer from the Point of View of the User" Journal of the American Statistical Association,vol. 62. September,pp. 819-841. Data are from NIST: http://www.itl.nist.gov/div898/strd/lls/data/LINKS/DATA/Longley.dat*/@Test public void testLongly(){RealMatrix matrix=createRealMatrix(longleyData,16,7);RealMatrix covarianceMatrix=new Covariance(matrix).getCovarianceMatrix();double[]rData=new double[]{12333921.73333333246,3.679666000000000e+04,343330206.333333313,1649102.666666666744,1117681.066666666651,23461965.733333334,16240.93333333333248,36796.66000000000,1.164576250000000e+02,1063604.115416667,6258.666250000000,3490.253750000000,73503.000000000,50.92333333333334,343330206.33333331347,1.063604115416667e+06,9879353659.329166412,56124369.854166664183,30880428.345833335072,685240944.600000024,470977.90000000002328,1649102.66666666674,6.258666250000000e+03,56124369.854166664,873223.429166666698,-115378.762499999997,4462741.533333333,2973.03333333333330,1117681.06666666665,3.490253750000000e+03,30880428.345833335,-115378.762499999997,484304.095833333326,1764098.133333333,1382.43333333333339,23461965.73333333433,7.350300000000000e+04,685240944.600000024,4462741.533333333209,1764098.133333333302,48387348.933333330,32917.40000000000146,16240.93333333333,5.092333333333334e+01,470977.900000000,2973.033333333333,1382.433333333333,32917.40000000,22.66666666666667};TestUtils.assertEquals("covariance matrix",createRealMatrix(rData,7,7),covarianceMatrix,10E-9);}
/** * Test R Swiss fertility dataset against R. Data Source: R datasets package*/@Test public void testSwissFertility(){RealMatrix matrix=createRealMatrix(swissData,47,5);RealMatrix covarianceMatrix=new Covariance(matrix).getCovarianceMatrix();double[]rData=new double[]{156.0424976873265,100.1691489361702,-64.36692876965772,-79.7295097132285,241.5632030527289,100.169148936170251,515.7994172062905,-124.39283071230344,-139.6574005550416,379.9043755781684,-64.3669287696577,-124.3928307123034,63.64662349676226,53.5758556891767,-190.5606105457909,-79.7295097132285,-139.6574005550416,53.57585568917669,92.4560592044403,-61.6988297872340,241.5632030527289,379.9043755781684,-190.56061054579092,-61.6988297872340,1739.2945371877890};TestUtils.assertEquals("covariance matrix",createRealMatrix(rData,5,5),covarianceMatrix,10E-13);}
/** * Constant column*/@Test public void testConstant(){double[]noVariance=new double[]{1,1,1,1};double[]values=new double[]{1,2,3,4};Assert.assertEquals(0d,new Covariance().covariance(noVariance,values,true),Double.MIN_VALUE);Assert.assertEquals(0d,new Covariance().covariance(noVariance,noVariance,true),Double.MIN_VALUE);}
/** * Insufficient data*/@Test public void testInsufficientData(){double[]one=new double[]{1};double[]two=new double[]{2};try {new Covariance().covariance(one,two,false);Assert.fail("Expecting IllegalArgumentException");}catch(IllegalArgumentException ex){}RealMatrix matrix=new Array2DRowRealMatrix(new double[][]{{0},{1}});try {new Covariance(matrix);Assert.fail("Expecting IllegalArgumentException");}catch(IllegalArgumentException ex){}}
/** * Verify that diagonal entries are consistent with Variance computation and matrix matches column-by-column covariances*/@Test public void testConsistency(){final RealMatrix matrix=createRealMatrix(swissData,47,5);final RealMatrix covarianceMatrix=new Covariance(matrix).getCovarianceMatrix();Variance variance=new Variance();for (int i=0;i < 5;i++){Assert.assertEquals(variance.evaluate(matrix.getColumn(i)),covarianceMatrix.getEntry(i,i),10E-14);}Assert.assertEquals(covarianceMatrix.getEntry(2,3),new Covariance().covariance(matrix.getColumn(2),matrix.getColumn(3),true),10E-14);Assert.assertEquals(covarianceMatrix.getEntry(2,3),covarianceMatrix.getEntry(3,2),Double.MIN_VALUE);RealMatrix repeatedColumns=new Array2DRowRealMatrix(47,3);for (int i=0;i < 3;i++){repeatedColumns.setColumnMatrix(i,matrix.getColumnMatrix(0));}RealMatrix repeatedCovarianceMatrix=new Covariance(repeatedColumns).getCovarianceMatrix();double columnVariance=variance.evaluate(matrix.getColumn(0));for (int i=0;i < 3;i++){for (int j=0;j < 3;j++){Assert.assertEquals(columnVariance,repeatedCovarianceMatrix.getEntry(i,j),10E-14);}}double[][]data=matrix.getData();TestUtils.assertEquals("Covariances",covarianceMatrix,new Covariance().computeCovarianceMatrix(data),Double.MIN_VALUE);TestUtils.assertEquals("Covariances",covarianceMatrix,new Covariance().computeCovarianceMatrix(data,true),Double.MIN_VALUE);double[]x=data[0];double[]y=data[1];Assert.assertEquals(new Covariance().covariance(x,y),new Covariance().covariance(x,y,true),Double.MIN_VALUE);}
@Test(expected=MathIllegalArgumentException.class)public void testSolveNull(){UnivariateRealSolverUtils.solve(null,0.0,4.0);}
@Test(expected=MathIllegalArgumentException.class)public void testSolveBadEndpoints(){double root=UnivariateRealSolverUtils.solve(sin,4.0,-0.1,1e-6);System.out.println("root=" + root);}
@Test public void testSolveBadAccuracy(){try {UnivariateRealSolverUtils.solve(sin,0.0,4.0,0.0);}catch(MathIllegalArgumentException ex){}}
@Test public void testSolveSin(){double x=UnivariateRealSolverUtils.solve(sin,1.0,4.0);Assert.assertEquals(FastMath.PI,x,1.0e-4);}
@Test(expected=MathIllegalArgumentException.class)public void testSolveAccuracyNull(){double accuracy=1.0e-6;UnivariateRealSolverUtils.solve(null,0.0,4.0,accuracy);}
@Test public void testSolveAccuracySin(){double accuracy=1.0e-6;double x=UnivariateRealSolverUtils.solve(sin,1.0,4.0,accuracy);Assert.assertEquals(FastMath.PI,x,accuracy);}
@Test(expected=MathIllegalArgumentException.class)public void testSolveNoRoot(){UnivariateRealSolverUtils.solve(sin,1.0,1.5);}
@Test public void testBracketSin(){double[]result=UnivariateRealSolverUtils.bracket(sin,0.0,-2.0,2.0);Assert.assertTrue(sin.value(result[0])< 0);Assert.assertTrue(sin.value(result[1])> 0);}
@Test public void testBracketEndpointRoot(){double[]result=UnivariateRealSolverUtils.bracket(sin,1.5,0,2.0);Assert.assertEquals(0.0,sin.value(result[0]),1.0e-15);Assert.assertTrue(sin.value(result[1])> 0);}
@Test(expected=MathIllegalArgumentException.class)public void testNullFunction(){UnivariateRealSolverUtils.bracket(null,1.5,0,2.0);}
@Test(expected=MathIllegalArgumentException.class)public void testBadInitial(){UnivariateRealSolverUtils.bracket(sin,2.5,0,2.0);}
@Test(expected=MathIllegalArgumentException.class)public void testBadEndpoints(){UnivariateRealSolverUtils.bracket(sin,1.5,2.0,1.0);}
@Test(expected=MathIllegalArgumentException.class)public void testBadMaximumIterations(){UnivariateRealSolverUtils.bracket(sin,1.5,0,2.0,0);}
@Test public void testMisc(){UnivariateFunction f=new QuinticFunction();double result;result=UnivariateRealSolverUtils.solve(f,-0.2,0.2);Assert.assertEquals(result,0,1E-8);result=UnivariateRealSolverUtils.solve(f,-0.1,0.3);Assert.assertEquals(result,0,1E-8);result=UnivariateRealSolverUtils.solve(f,-0.3,0.45);Assert.assertEquals(result,0,1E-6);result=UnivariateRealSolverUtils.solve(f,0.3,0.7);Assert.assertEquals(result,0.5,1E-6);result=UnivariateRealSolverUtils.solve(f,0.2,0.6);Assert.assertEquals(result,0.5,1E-6);result=UnivariateRealSolverUtils.solve(f,0.05,0.95);Assert.assertEquals(result,0.5,1E-6);result=UnivariateRealSolverUtils.solve(f,0.85,1.25);Assert.assertEquals(result,1.0,1E-6);result=UnivariateRealSolverUtils.solve(f,0.8,1.2);Assert.assertEquals(result,1.0,1E-6);result=UnivariateRealSolverUtils.solve(f,0.85,1.75);Assert.assertEquals(result,1.0,1E-6);result=UnivariateRealSolverUtils.solve(f,0.55,1.45);Assert.assertEquals(result,1.0,1E-6);result=UnivariateRealSolverUtils.solve(f,0.85,5);Assert.assertEquals(result,1.0,1E-6);}
@Test public void testStartSimplexInsideRange(){final BiQuadratic biQuadratic=new BiQuadratic(2.0,2.5,1.0,3.0,2.0,3.0);final MultivariateFunctionMappingAdapter wrapped=new MultivariateFunctionMappingAdapter(biQuadratic,biQuadratic.getLower(),biQuadratic.getUpper());SimplexOptimizer optimizer=new SimplexOptimizer(1e-10,1e-30);optimizer.setSimplex(new NelderMeadSimplex(new double[][]{wrapped.boundedToUnbounded(new double[]{1.5,2.75}),wrapped.boundedToUnbounded(new double[]{1.5,2.95}),wrapped.boundedToUnbounded(new double[]{1.7,2.90})}));final RealPointValuePair optimum=optimizer.optimize(300,wrapped,GoalType.MINIMIZE,wrapped.boundedToUnbounded(new double[]{1.5,2.25}));final double[]bounded=wrapped.unboundedToBounded(optimum.getPoint());Assert.assertEquals(biQuadratic.getBoundedXOptimum(),bounded[0],2e-7);Assert.assertEquals(biQuadratic.getBoundedYOptimum(),bounded[1],2e-7);}
@Test public void testOptimumOutsideRange(){final BiQuadratic biQuadratic=new BiQuadratic(4.0,0.0,1.0,3.0,2.0,3.0);final MultivariateFunctionMappingAdapter wrapped=new MultivariateFunctionMappingAdapter(biQuadratic,biQuadratic.getLower(),biQuadratic.getUpper());SimplexOptimizer optimizer=new SimplexOptimizer(1e-10,1e-30);optimizer.setSimplex(new NelderMeadSimplex(new double[][]{wrapped.boundedToUnbounded(new double[]{1.5,2.75}),wrapped.boundedToUnbounded(new double[]{1.5,2.95}),wrapped.boundedToUnbounded(new double[]{1.7,2.90})}));final RealPointValuePair optimum=optimizer.optimize(100,wrapped,GoalType.MINIMIZE,wrapped.boundedToUnbounded(new double[]{1.5,2.25}));final double[]bounded=wrapped.unboundedToBounded(optimum.getPoint());Assert.assertEquals(biQuadratic.getBoundedXOptimum(),bounded[0],2e-7);Assert.assertEquals(biQuadratic.getBoundedYOptimum(),bounded[1],2e-7);}
@Test public void testUnbounded(){final BiQuadratic biQuadratic=new BiQuadratic(4.0,0.0,Double.NEGATIVE_INFINITY,Double.POSITIVE_INFINITY,Double.NEGATIVE_INFINITY,Double.POSITIVE_INFINITY);final MultivariateFunctionMappingAdapter wrapped=new MultivariateFunctionMappingAdapter(biQuadratic,biQuadratic.getLower(),biQuadratic.getUpper());SimplexOptimizer optimizer=new SimplexOptimizer(1e-10,1e-30);optimizer.setSimplex(new NelderMeadSimplex(new double[][]{wrapped.boundedToUnbounded(new double[]{1.5,2.75}),wrapped.boundedToUnbounded(new double[]{1.5,2.95}),wrapped.boundedToUnbounded(new double[]{1.7,2.90})}));final RealPointValuePair optimum=optimizer.optimize(300,wrapped,GoalType.MINIMIZE,wrapped.boundedToUnbounded(new double[]{1.5,2.25}));final double[]bounded=wrapped.unboundedToBounded(optimum.getPoint());Assert.assertEquals(biQuadratic.getBoundedXOptimum(),bounded[0],2e-7);Assert.assertEquals(biQuadratic.getBoundedYOptimum(),bounded[1],2e-7);}
@Test public void testHalfBounded(){final BiQuadratic biQuadratic=new BiQuadratic(4.0,4.0,1.0,Double.POSITIVE_INFINITY,Double.NEGATIVE_INFINITY,3.0);final MultivariateFunctionMappingAdapter wrapped=new MultivariateFunctionMappingAdapter(biQuadratic,biQuadratic.getLower(),biQuadratic.getUpper());SimplexOptimizer optimizer=new SimplexOptimizer(1e-13,1e-30);optimizer.setSimplex(new NelderMeadSimplex(new double[][]{wrapped.boundedToUnbounded(new double[]{1.5,2.75}),wrapped.boundedToUnbounded(new double[]{1.5,2.95}),wrapped.boundedToUnbounded(new double[]{1.7,2.90})}));final RealPointValuePair optimum=optimizer.optimize(200,wrapped,GoalType.MINIMIZE,wrapped.boundedToUnbounded(new double[]{1.5,2.25}));final double[]bounded=wrapped.unboundedToBounded(optimum.getPoint());Assert.assertEquals(biQuadratic.getBoundedXOptimum(),bounded[0],1e-7);Assert.assertEquals(biQuadratic.getBoundedYOptimum(),bounded[1],1e-7);}
/** * Basic.*/@Test public void testFit01(){GaussianFitter fitter=new GaussianFitter(new LevenbergMarquardtOptimizer());addDatasetToGaussianFitter(DATASET1,fitter);double[]parameters=fitter.fit();Assert.assertEquals(3496978.1837704973,parameters[0],1e-4);Assert.assertEquals(4.054933085999146,parameters[1],1e-4);Assert.assertEquals(0.015039355620304326,parameters[2],1e-4);}
/** * Zero points is not enough observed points.*/@Test(expected=MathIllegalArgumentException.class)public void testFit02(){GaussianFitter fitter=new GaussianFitter(new LevenbergMarquardtOptimizer());fitter.fit();}
/** * Two points is not enough observed points.*/@Test(expected=MathIllegalArgumentException.class)public void testFit03(){GaussianFitter fitter=new GaussianFitter(new LevenbergMarquardtOptimizer());addDatasetToGaussianFitter(new double[][]{{4.0254623,531026.0},{4.02804905,664002.0}},fitter);fitter.fit();}
/** * Poor data: right of peak not symmetric with left of peak.*/@Test public void testFit04(){GaussianFitter fitter=new GaussianFitter(new LevenbergMarquardtOptimizer());addDatasetToGaussianFitter(DATASET2,fitter);double[]parameters=fitter.fit();Assert.assertEquals(233003.2967252038,parameters[0],1e-4);Assert.assertEquals(-10.654887521095983,parameters[1],1e-4);Assert.assertEquals(4.335937353196641,parameters[2],1e-4);}
/** * Poor data: long tails.*/@Test public void testFit05(){GaussianFitter fitter=new GaussianFitter(new LevenbergMarquardtOptimizer());addDatasetToGaussianFitter(DATASET3,fitter);double[]parameters=fitter.fit();Assert.assertEquals(283863.81929180305,parameters[0],1e-4);Assert.assertEquals(-13.29641995105174,parameters[1],1e-4);Assert.assertEquals(1.7297330293549908,parameters[2],1e-4);}
/** * Poor data: right of peak is missing.*/@Test public void testFit06(){GaussianFitter fitter=new GaussianFitter(new LevenbergMarquardtOptimizer());addDatasetToGaussianFitter(DATASET4,fitter);double[]parameters=fitter.fit();Assert.assertEquals(285250.66754309234,parameters[0],1e-4);Assert.assertEquals(-13.528375695228455,parameters[1],1e-4);Assert.assertEquals(1.5204344894331614,parameters[2],1e-4);}
/** * Basic with smaller dataset.*/@Test public void testFit07(){GaussianFitter fitter=new GaussianFitter(new LevenbergMarquardtOptimizer());addDatasetToGaussianFitter(DATASET5,fitter);double[]parameters=fitter.fit();Assert.assertEquals(3514384.729342235,parameters[0],1e-4);Assert.assertEquals(4.054970307455625,parameters[1],1e-4);Assert.assertEquals(0.015029412832160017,parameters[2],1e-4);}
@Test public void testMath519(){final double[]data={1.1143831578403364E-29,4.95281403484594E-28,1.1171347211930288E-26,1.7044813962636277E-25,1.9784716574832164E-24,1.8630236407866774E-23,1.4820532905097742E-22,1.0241963854632831E-21,6.275077366673128E-21,3.461808994532493E-20,1.7407124684715706E-19,8.056687953553974E-19,3.460193945992071E-18,1.3883326374011525E-17,5.233894983671116E-17,1.8630791465263745E-16,6.288759227922111E-16,2.0204433920597856E-15,6.198768938576155E-15,1.821419346860626E-14,5.139176445538471E-14,1.3956427429045787E-13,3.655705706448139E-13,9.253753324779779E-13,2.267636001476696E-12,5.3880460095836855E-12,1.2431632654852931E-11};GaussianFitter fitter=new GaussianFitter(new LevenbergMarquardtOptimizer());for (int i=0;i < data.length;i++){fitter.addObservedPoint(i,data[i]);}final double[]p=fitter.fit();Assert.assertEquals(53.1572792,p[1],1e-7);Assert.assertEquals(5.75214622,p[2],1e-8);}
@Test(expected=OutOfRangeException.class)public void testInitOutofbounds(){double[]startPoint=point(DIM,3);double[]insigma=null;double[][]boundaries=boundaries(DIM,-1,2);RealPointValuePair expected=new RealPointValuePair(point(DIM,1.0),0.0);doTest(new Rosen(),startPoint,insigma,boundaries,GoalType.MINIMIZE,LAMBDA,true,0,1e-13,1e-13,1e-6,100000,expected);}
@Test(expected=MultiDimensionMismatchException.class)public void testBoundariesDimensionMismatch(){double[]startPoint=point(DIM,0.5);double[]insigma=null;double[][]boundaries=boundaries(DIM + 1,-1,2);RealPointValuePair expected=new RealPointValuePair(point(DIM,1.0),0.0);doTest(new Rosen(),startPoint,insigma,boundaries,GoalType.MINIMIZE,LAMBDA,true,0,1e-13,1e-13,1e-6,100000,expected);}
@Test(expected=NoDataException.class)public void testBoundariesNoData(){double[]startPoint=point(DIM,0.5);double[]insigma=null;double[][]boundaries=boundaries(DIM,-1,2);boundaries[1]=null;RealPointValuePair expected=new RealPointValuePair(point(DIM,1.0),0.0);doTest(new Rosen(),startPoint,insigma,boundaries,GoalType.MINIMIZE,LAMBDA,true,0,1e-13,1e-13,1e-6,100000,expected);}
@Test(expected=NotPositiveException.class)public void testInputSigmaNegative(){double[]startPoint=point(DIM,0.5);double[]insigma=point(DIM,-0.5);double[][]boundaries=null;RealPointValuePair expected=new RealPointValuePair(point(DIM,1.0),0.0);doTest(new Rosen(),startPoint,insigma,boundaries,GoalType.MINIMIZE,LAMBDA,true,0,1e-13,1e-13,1e-6,100000,expected);}
@Test(expected=OutOfRangeException.class)public void testInputSigmaOutOfRange(){double[]startPoint=point(DIM,0.5);double[]insigma=point(DIM,1.1);double[][]boundaries=boundaries(DIM,-0.5,0.5);RealPointValuePair expected=new RealPointValuePair(point(DIM,1.0),0.0);doTest(new Rosen(),startPoint,insigma,boundaries,GoalType.MINIMIZE,LAMBDA,true,0,1e-13,1e-13,1e-6,100000,expected);}
@Test(expected=MultiDimensionMismatchException.class)public void testInputSigmaDimensionMismatch(){double[]startPoint=point(DIM,0.5);double[]insigma=point(DIM + 1,-0.5);double[][]boundaries=null;RealPointValuePair expected=new RealPointValuePair(point(DIM,1.0),0.0);doTest(new Rosen(),startPoint,insigma,boundaries,GoalType.MINIMIZE,LAMBDA,true,0,1e-13,1e-13,1e-6,100000,expected);}
@Test @Retry(3)public void testRosen(){double[]startPoint=point(DIM,0.1);double[]insigma=point(DIM,0.1);double[][]boundaries=null;RealPointValuePair expected=new RealPointValuePair(point(DIM,1.0),0.0);doTest(new Rosen(),startPoint,insigma,boundaries,GoalType.MINIMIZE,LAMBDA,true,0,1e-13,1e-13,1e-6,100000,expected);doTest(new Rosen(),startPoint,insigma,boundaries,GoalType.MINIMIZE,LAMBDA,false,0,1e-13,1e-13,1e-6,100000,expected);}
@Test @Retry(3)public void testMaximize(){}
@Test public void testEllipse(){double[]startPoint=point(DIM,1.0);double[]insigma=point(DIM,0.1);double[][]boundaries=null;RealPointValuePair expected=new RealPointValuePair(point(DIM,0.0),0.0);doTest(new Elli(),startPoint,insigma,boundaries,GoalType.MINIMIZE,LAMBDA,true,0,1e-13,1e-13,1e-6,100000,expected);doTest(new Elli(),startPoint,insigma,boundaries,GoalType.MINIMIZE,LAMBDA,false,0,1e-13,1e-13,1e-6,100000,expected);}
@Test public void testElliRotated(){double[]startPoint=point(DIM,1.0);double[]insigma=point(DIM,0.1);double[][]boundaries=null;RealPointValuePair expected=new RealPointValuePair(point(DIM,0.0),0.0);doTest(new ElliRotated(),startPoint,insigma,boundaries,GoalType.MINIMIZE,LAMBDA,true,0,1e-13,1e-13,1e-6,100000,expected);doTest(new ElliRotated(),startPoint,insigma,boundaries,GoalType.MINIMIZE,LAMBDA,false,0,1e-13,1e-13,1e-6,100000,expected);}
@Test public void testCigar(){double[]startPoint=point(DIM,1.0);double[]insigma=point(DIM,0.1);double[][]boundaries=null;RealPointValuePair expected=new RealPointValuePair(point(DIM,0.0),0.0);doTest(new Cigar(),startPoint,insigma,boundaries,GoalType.MINIMIZE,LAMBDA,true,0,1e-13,1e-13,1e-6,200000,expected);doTest(new Cigar(),startPoint,insigma,boundaries,GoalType.MINIMIZE,LAMBDA,false,0,1e-13,1e-13,1e-6,100000,expected);}
@Test public void testTwoAxes(){double[]startPoint=point(DIM,1.0);double[]insigma=point(DIM,0.1);double[][]boundaries=null;RealPointValuePair expected=new RealPointValuePair(point(DIM,0.0),0.0);doTest(new TwoAxes(),startPoint,insigma,boundaries,GoalType.MINIMIZE,2 * LAMBDA,true,0,1e-13,1e-13,1e-6,200000,expected);doTest(new TwoAxes(),startPoint,insigma,boundaries,GoalType.MINIMIZE,2 * LAMBDA,false,0,1e-13,1e-8,1e-3,200000,expected);}
@Test public void testCigTab(){}
@Test public void testSphere(){double[]startPoint=point(DIM,1.0);double[]insigma=point(DIM,0.1);double[][]boundaries=null;RealPointValuePair expected=new RealPointValuePair(point(DIM,0.0),0.0);doTest(new Sphere(),startPoint,insigma,boundaries,GoalType.MINIMIZE,LAMBDA,true,0,1e-13,1e-13,1e-6,100000,expected);doTest(new Sphere(),startPoint,insigma,boundaries,GoalType.MINIMIZE,LAMBDA,false,0,1e-13,1e-13,1e-6,100000,expected);}
@Test public void testTablet(){double[]startPoint=point(DIM,1.0);double[]insigma=point(DIM,0.1);double[][]boundaries=null;RealPointValuePair expected=new RealPointValuePair(point(DIM,0.0),0.0);doTest(new Tablet(),startPoint,insigma,boundaries,GoalType.MINIMIZE,LAMBDA,true,0,1e-13,1e-13,1e-6,100000,expected);doTest(new Tablet(),startPoint,insigma,boundaries,GoalType.MINIMIZE,LAMBDA,false,0,1e-13,1e-13,1e-6,100000,expected);}
@Test public void testDiffPow(){double[]startPoint=point(DIM,1.0);double[]insigma=point(DIM,0.1);double[][]boundaries=null;RealPointValuePair expected=new RealPointValuePair(point(DIM,0.0),0.0);doTest(new DiffPow(),startPoint,insigma,boundaries,GoalType.MINIMIZE,10,true,0,1e-13,1e-8,1e-1,100000,expected);doTest(new DiffPow(),startPoint,insigma,boundaries,GoalType.MINIMIZE,10,false,0,1e-13,1e-8,2e-1,100000,expected);}
@Test public void testSsDiffPow(){double[]startPoint=point(DIM,1.0);double[]insigma=point(DIM,0.1);double[][]boundaries=null;RealPointValuePair expected=new RealPointValuePair(point(DIM,0.0),0.0);doTest(new SsDiffPow(),startPoint,insigma,boundaries,GoalType.MINIMIZE,10,true,0,1e-13,1e-4,1e-1,200000,expected);doTest(new SsDiffPow(),startPoint,insigma,boundaries,GoalType.MINIMIZE,10,false,0,1e-13,1e-4,1e-1,200000,expected);}
@Test public void testAckley(){double[]startPoint=point(DIM,1.0);double[]insigma=point(DIM,1.0);double[][]boundaries=null;RealPointValuePair expected=new RealPointValuePair(point(DIM,0.0),0.0);doTest(new Ackley(),startPoint,insigma,boundaries,GoalType.MINIMIZE,2 * LAMBDA,true,0,1e-13,1e-9,1e-5,100000,expected);doTest(new Ackley(),startPoint,insigma,boundaries,GoalType.MINIMIZE,2 * LAMBDA,false,0,1e-13,1e-9,1e-5,100000,expected);}
@Test public void testRastrigin(){double[]startPoint=point(DIM,0.1);double[]insigma=point(DIM,0.1);double[][]boundaries=null;RealPointValuePair expected=new RealPointValuePair(point(DIM,0.0),0.0);doTest(new Rastrigin(),startPoint,insigma,boundaries,GoalType.MINIMIZE,(int)(200 * Math.sqrt(DIM)),true,0,1e-13,1e-13,1e-6,200000,expected);doTest(new Rastrigin(),startPoint,insigma,boundaries,GoalType.MINIMIZE,(int)(200 * Math.sqrt(DIM)),false,0,1e-13,1e-13,1e-6,200000,expected);}
@Test public void testConstrainedRosen(){double[]startPoint=point(DIM,0.1);double[]insigma=point(DIM,0.1);double[][]boundaries=boundaries(DIM,-1,2);RealPointValuePair expected=new RealPointValuePair(point(DIM,1.0),0.0);doTest(new Rosen(),startPoint,insigma,boundaries,GoalType.MINIMIZE,2 * LAMBDA,true,0,1e-13,1e-13,1e-6,100000,expected);doTest(new Rosen(),startPoint,insigma,boundaries,GoalType.MINIMIZE,2 * LAMBDA,false,0,1e-13,1e-13,1e-6,100000,expected);}
@Test public void testDiagonalRosen(){}
@Test public void testInsufficientData(){double[]nothing=null;SemiVariance sv=new SemiVariance();try {sv.evaluate(nothing);Assert.fail("null is not a valid data array.");}catch(MathIllegalArgumentException iae){}try {sv.setVarianceDirection(SemiVariance.UPSIDE_VARIANCE);sv.evaluate(nothing);Assert.fail("null is not a valid data array.");}catch(MathIllegalArgumentException iae){}nothing=new double[]{};Assert.assertTrue(Double.isNaN(sv.evaluate(nothing)));}
@Test public void testSingleDown(){SemiVariance sv=new SemiVariance();double[]values={50.0d};double singletest=sv.evaluate(values);Assert.assertEquals(0.0d,singletest,0);}
@Test public void testSingleUp(){SemiVariance sv=new SemiVariance(SemiVariance.UPSIDE_VARIANCE);double[]values={50.0d};double singletest=sv.evaluate(values);Assert.assertEquals(0.0d,singletest,0);}
@Test public void testSample(){final double[]values={-2.0d,2.0d,4.0d,-2.0d,22.0d,11.0d,3.0d,14.0d,5.0d};final int length=values.length;final double mean=StatUtils.mean(values);final SemiVariance sv=new SemiVariance();final double downsideSemiVariance=sv.evaluate(values);Assert.assertEquals(TestUtils.sumSquareDev(new double[]{-2d,2d,4d,-2d,3d,5d},mean)/ (length - 1),downsideSemiVariance,1E-14);sv.setVarianceDirection(SemiVariance.UPSIDE_VARIANCE);final double upsideSemiVariance=sv.evaluate(values);Assert.assertEquals(TestUtils.sumSquareDev(new double[]{22d,11d,14d},mean)/ (length - 1),upsideSemiVariance,1E-14);Assert.assertEquals(StatUtils.variance(values),downsideSemiVariance + upsideSemiVariance,10e-12);}
@Test public void testPopulation(){double[]values={-2.0d,2.0d,4.0d,-2.0d,22.0d,11.0d,3.0d,14.0d,5.0d};SemiVariance sv=new SemiVariance(false);double singletest=sv.evaluate(values);Assert.assertEquals(19.556d,singletest,0.01d);sv.setVarianceDirection(SemiVariance.UPSIDE_VARIANCE);singletest=sv.evaluate(values);Assert.assertEquals(36.222d,singletest,0.01d);}
@Test public void testNonMeanCutoffs(){double[]values={-2.0d,2.0d,4.0d,-2.0d,22.0d,11.0d,3.0d,14.0d,5.0d};SemiVariance sv=new SemiVariance(false);double singletest=sv.evaluate(values,1.0d,SemiVariance.DOWNSIDE_VARIANCE,false,0,values.length);Assert.assertEquals(TestUtils.sumSquareDev(new double[]{-2d,-2d},1.0d)/ values.length,singletest,0.01d);singletest=sv.evaluate(values,3.0d,SemiVariance.UPSIDE_VARIANCE,false,0,values.length);Assert.assertEquals(TestUtils.sumSquareDev(new double[]{4d,22d,11d,14d,5d},3.0d)/ values.length,singletest,0.01d);}
/** * Check that the lower + upper semivariance against the mean sum to the variance.*/@Test public void testVarianceDecompMeanCutoff(){double[]values={-2.0d,2.0d,4.0d,-2.0d,22.0d,11.0d,3.0d,14.0d,5.0d};double variance=StatUtils.variance(values);SemiVariance sv=new SemiVariance(true);sv.setVarianceDirection(SemiVariance.DOWNSIDE_VARIANCE);final double lower=sv.evaluate(values);sv.setVarianceDirection(SemiVariance.UPSIDE_VARIANCE);final double upper=sv.evaluate(values);Assert.assertEquals(variance,lower + upper,10e-12);}
/** * Check that upper and lower semivariances against a cutoff sum to the sum of squared deviations of the full set of values against the cutoff divided by df = length - 1 (assuming bias-corrected).*/@Test public void testVarianceDecompNonMeanCutoff(){double[]values={-2.0d,2.0d,4.0d,-2.0d,22.0d,11.0d,3.0d,14.0d,5.0d};double target=0;double totalSumOfSquares=TestUtils.sumSquareDev(values,target);SemiVariance sv=new SemiVariance(true);sv.setVarianceDirection(SemiVariance.DOWNSIDE_VARIANCE);double lower=sv.evaluate(values,target);sv.setVarianceDirection(SemiVariance.UPSIDE_VARIANCE);double upper=sv.evaluate(values,target);Assert.assertEquals(totalSumOfSquares / (values.length - 1),lower + upper,10e-12);}
@Test public void testNoVariance(){final double[]values={100d,100d,100d,100d};SemiVariance sv=new SemiVariance();Assert.assertEquals(0,sv.evaluate(values),10E-12);Assert.assertEquals(0,sv.evaluate(values,100d),10E-12);Assert.assertEquals(0,sv.evaluate(values,100d,SemiVariance.UPSIDE_VARIANCE,false,0,values.length),10E-12);}
@Test public void testSomeValues(){final UnivariateFunction f=new Sigmoid();Assert.assertEquals(0.5,f.value(0),EPS);Assert.assertEquals(0,f.value(Double.NEGATIVE_INFINITY),EPS);Assert.assertEquals(1,f.value(Double.POSITIVE_INFINITY),EPS);}
@Test public void testDerivative(){final Sigmoid f=new Sigmoid();final UnivariateFunction dfdx=f.derivative();Assert.assertEquals(0.25,dfdx.value(0),0);}
@Test public void testDerivativeLargeArguments(){final Sigmoid f=new Sigmoid(1,2);final UnivariateFunction dfdx=f.derivative();Assert.assertEquals(0,dfdx.value(Double.NEGATIVE_INFINITY),0);Assert.assertEquals(0,dfdx.value(-Double.MAX_VALUE),0);Assert.assertEquals(0,dfdx.value(-1e50),0);Assert.assertEquals(0,dfdx.value(-1e3),0);Assert.assertEquals(0,dfdx.value(1e3),0);Assert.assertEquals(0,dfdx.value(1e50),0);Assert.assertEquals(0,dfdx.value(Double.MAX_VALUE),0);Assert.assertEquals(0,dfdx.value(Double.POSITIVE_INFINITY),0);}
@Test(expected=NullArgumentException.class)public void testParametricUsage1(){final Sigmoid.Parametric g=new Sigmoid.Parametric();g.value(0,null);}
@Test(expected=DimensionMismatchException.class)public void testParametricUsage2(){final Sigmoid.Parametric g=new Sigmoid.Parametric();g.value(0,new double[]{0});}
@Test(expected=NullArgumentException.class)public void testParametricUsage3(){final Sigmoid.Parametric g=new Sigmoid.Parametric();g.gradient(0,null);}
@Test(expected=DimensionMismatchException.class)public void testParametricUsage4(){final Sigmoid.Parametric g=new Sigmoid.Parametric();g.gradient(0,new double[]{0});}
@Test public void testParametricValue(){final double lo=2;final double hi=3;final Sigmoid f=new Sigmoid(lo,hi);final Sigmoid.Parametric g=new Sigmoid.Parametric();Assert.assertEquals(f.value(-1),g.value(-1,new double[]{lo,hi}),0);Assert.assertEquals(f.value(0),g.value(0,new double[]{lo,hi}),0);Assert.assertEquals(f.value(2),g.value(2,new double[]{lo,hi}),0);}
/** * Test Longley dataset against R.*/@Test public void testLongly()throws Exception {RealMatrix matrix=createRealMatrix(longleyData,16,7);PearsonsCorrelation corrInstance=new PearsonsCorrelation(matrix);RealMatrix correlationMatrix=corrInstance.getCorrelationMatrix();double[]rData=new double[]{1.000000000000000,0.9708985250610560,0.9835516111796693,0.5024980838759942,0.4573073999764817,0.960390571594376,0.9713294591921188,0.970898525061056,1.0000000000000000,0.9915891780247822,0.6206333925590966,0.4647441876006747,0.979163432977498,0.9911491900672053,0.983551611179669,0.9915891780247822,1.0000000000000000,0.6042609398895580,0.4464367918926265,0.991090069458478,0.9952734837647849,0.502498083875994,0.6206333925590966,0.6042609398895580,1.0000000000000000,-0.1774206295018783,0.686551516365312,0.6682566045621746,0.457307399976482,0.4647441876006747,0.4464367918926265,-0.1774206295018783,1.0000000000000000,0.364416267189032,0.4172451498349454,0.960390571594376,0.9791634329774981,0.9910900694584777,0.6865515163653120,0.3644162671890320,1.000000000000000,0.9939528462329257,0.971329459192119,0.9911491900672053,0.9952734837647849,0.6682566045621746,0.4172451498349454,0.993952846232926,1.0000000000000000};TestUtils.assertEquals("correlation matrix",createRealMatrix(rData,7,7),correlationMatrix,10E-15);double[]rPvalues=new double[]{4.38904690369668e-10,8.36353208910623e-12,7.8159700933611e-14,0.0472894097790304,0.01030636128354301,0.01316878049026582,0.0749178049642416,0.06971758330341182,0.0830166169296545,0.510948586323452,3.693245043123738e-09,4.327782576751815e-11,1.167954621905665e-13,0.00331028281967516,0.1652293725106684,3.95834476307755e-10,1.114663916723657e-13,1.332267629550188e-15,0.00466039138541463,0.1078477071581498,7.771561172376096e-15};RealMatrix rPMatrix=createLowerTriangularRealMatrix(rPvalues,7);fillUpper(rPMatrix,0d);TestUtils.assertEquals("correlation p values",rPMatrix,corrInstance.getCorrelationPValues(),10E-15);}
/** * Test R Swiss fertility dataset against R.*/@Test public void testSwissFertility()throws Exception {RealMatrix matrix=createRealMatrix(swissData,47,5);PearsonsCorrelation corrInstance=new PearsonsCorrelation(matrix);RealMatrix correlationMatrix=corrInstance.getCorrelationMatrix();double[]rData=new double[]{1.0000000000000000,0.3530791836199747,-0.6458827064572875,-0.6637888570350691,0.4636847006517939,0.3530791836199747,1.0000000000000000,-0.6865422086171366,-0.6395225189483201,0.4010950530487398,-0.6458827064572875,-0.6865422086171366,1.0000000000000000,0.6984152962884830,-0.5727418060641666,-0.6637888570350691,-0.6395225189483201,0.6984152962884830,1.0000000000000000,-0.1538589170909148,0.4636847006517939,0.4010950530487398,-0.5727418060641666,-0.1538589170909148,1.0000000000000000};TestUtils.assertEquals("correlation matrix",createRealMatrix(rData,5,5),correlationMatrix,10E-15);double[]rPvalues=new double[]{0.01491720061472623,9.45043734069043e-07,9.95151527133974e-08,3.658616965962355e-07,1.304590105694471e-06,4.811397236181847e-08,0.001028523190118147,0.005204433539191644,2.588307925380906e-05,0.301807756132683};RealMatrix rPMatrix=createLowerTriangularRealMatrix(rPvalues,5);fillUpper(rPMatrix,0d);TestUtils.assertEquals("correlation p values",rPMatrix,corrInstance.getCorrelationPValues(),10E-15);}
/** * Test p-value near 0. JIRA: MATH-371*/@Test public void testPValueNearZero()throws Exception {int dimension=120;double[][]data=new double[dimension][2];for (int i=0;i < dimension;i++){data[i][0]=i;data[i][1]=i + 1 / ((double)i + 1);}PearsonsCorrelation corrInstance=new PearsonsCorrelation(data);Assert.assertTrue(corrInstance.getCorrelationPValues().getEntry(0,1)> 0);}
/** * Constant column*/@Test public void testConstant(){double[]noVariance=new double[]{1,1,1,1};double[]values=new double[]{1,2,3,4};Assert.assertTrue(Double.isNaN(new PearsonsCorrelation().correlation(noVariance,values)));}
/** * Insufficient data*/@Test public void testInsufficientData(){double[]one=new double[]{1};double[]two=new double[]{2};try {new PearsonsCorrelation().correlation(one,two);Assert.fail("Expecting IllegalArgumentException");}catch(IllegalArgumentException ex){}RealMatrix matrix=new BlockRealMatrix(new double[][]{{0},{1}});try {new PearsonsCorrelation(matrix);Assert.fail("Expecting IllegalArgumentException");}catch(IllegalArgumentException ex){}}
/** * Verify that direct t-tests using standard error estimates are consistent with reported p-values*/@Test public void testStdErrorConsistency()throws Exception {TDistribution tDistribution=new TDistribution(45);RealMatrix matrix=createRealMatrix(swissData,47,5);PearsonsCorrelation corrInstance=new PearsonsCorrelation(matrix);RealMatrix rValues=corrInstance.getCorrelationMatrix();RealMatrix pValues=corrInstance.getCorrelationPValues();RealMatrix stdErrors=corrInstance.getCorrelationStandardErrors();for (int i=0;i < 5;i++){for (int j=0;j < i;j++){double t=FastMath.abs(rValues.getEntry(i,j))/ stdErrors.getEntry(i,j);double p=2 * (1 - tDistribution.cumulativeProbability(t));Assert.assertEquals(p,pValues.getEntry(i,j),10E-15);}}}
/** * Verify that creating correlation from covariance gives same results as direct computation from the original matrix*/@Test public void testCovarianceConsistency()throws Exception {RealMatrix matrix=createRealMatrix(longleyData,16,7);PearsonsCorrelation corrInstance=new PearsonsCorrelation(matrix);Covariance covInstance=new Covariance(matrix);PearsonsCorrelation corrFromCovInstance=new PearsonsCorrelation(covInstance);TestUtils.assertEquals("correlation values",corrInstance.getCorrelationMatrix(),corrFromCovInstance.getCorrelationMatrix(),10E-15);TestUtils.assertEquals("p values",corrInstance.getCorrelationPValues(),corrFromCovInstance.getCorrelationPValues(),10E-15);TestUtils.assertEquals("standard errors",corrInstance.getCorrelationStandardErrors(),corrFromCovInstance.getCorrelationStandardErrors(),10E-15);PearsonsCorrelation corrFromCovInstance2=new PearsonsCorrelation(covInstance.getCovarianceMatrix(),16);TestUtils.assertEquals("correlation values",corrInstance.getCorrelationMatrix(),corrFromCovInstance2.getCorrelationMatrix(),10E-15);TestUtils.assertEquals("p values",corrInstance.getCorrelationPValues(),corrFromCovInstance2.getCorrelationPValues(),10E-15);TestUtils.assertEquals("standard errors",corrInstance.getCorrelationStandardErrors(),corrFromCovInstance2.getCorrelationStandardErrors(),10E-15);}
@Test public void testConsistency(){RealMatrix matrix=createRealMatrix(longleyData,16,7);PearsonsCorrelation corrInstance=new PearsonsCorrelation(matrix);double[][]data=matrix.getData();double[]x=matrix.getColumn(0);double[]y=matrix.getColumn(1);Assert.assertEquals(new PearsonsCorrelation().correlation(x,y),corrInstance.getCorrelationMatrix().getEntry(0,1),Double.MIN_VALUE);TestUtils.assertEquals("Correlation matrix",corrInstance.getCorrelationMatrix(),new PearsonsCorrelation().computeCorrelationMatrix(data),Double.MIN_VALUE);}
@Test public void testSinZero(){UnivariateFunction f=new SinFunction();double result;UnivariateRealSolver solver=getSolver();result=solver.solve(100,f,3,4);Assert.assertEquals(result,FastMath.PI,solver.getAbsoluteAccuracy());Assert.assertTrue(solver.getEvaluations()<= 6);result=solver.solve(100,f,1,4);Assert.assertEquals(result,FastMath.PI,solver.getAbsoluteAccuracy());Assert.assertTrue(solver.getEvaluations()<= 7);}
@Test public void testQuinticZero(){UnivariateFunction f=new QuinticFunction();double result;UnivariateRealSolver solver=getSolver();double atol=solver.getAbsoluteAccuracy();int[]counts=getQuinticEvalCounts();double[][]testsData={{-0.2,0.2,0.0},{-0.1,0.3,0.0},{-0.3,0.45,0.0},{0.3,0.7,0.5},{0.2,0.6,0.5},{0.05,0.95,0.5},{0.85,1.25,1.0},{0.8,1.2,1.0},{0.85,1.75,1.0},{0.55,1.45,1.0},{0.85,5.0,1.0}};int maxIter=500;for (int i=0;i < testsData.length;i++){if (counts[i]== -1)continue;double[]testData=testsData[i];result=solver.solve(maxIter,f,testData[0],testData[1]);Assert.assertEquals(result,testData[2],atol);Assert.assertTrue(solver.getEvaluations()<= counts[i]+ 1);}}
@Test public void testRootEndpoints(){UnivariateFunction f=new XMinus5Function();UnivariateRealSolver solver=getSolver();double result=solver.solve(100,f,5.0,6.0);Assert.assertEquals(5.0,result,0.0);result=solver.solve(100,f,4.0,5.0);Assert.assertEquals(5.0,result,0.0);result=solver.solve(100,f,5.0,6.0,5.5);Assert.assertEquals(5.0,result,0.0);result=solver.solve(100,f,4.0,5.0,4.5);Assert.assertEquals(5.0,result,0.0);}
@Test public void testBadEndpoints(){UnivariateFunction f=new SinFunction();UnivariateRealSolver solver=getSolver();try {solver.solve(100,f,1,-1);Assert.fail("Expecting NumberIsTooLargeException - bad interval");}catch(NumberIsTooLargeException ex){}try {solver.solve(100,f,1,1.5);Assert.fail("Expecting NoBracketingException - non-bracketing");}catch(NoBracketingException ex){}try {solver.solve(100,f,1,1.5,1.2);Assert.fail("Expecting NoBracketingException - non-bracketing");}catch(NoBracketingException ex){}}
@Test public void testSolutionLeftSide(){UnivariateFunction f=new SinFunction();UnivariateRealSolver solver=getSolver();double left=-1.5;double right=0.05;for (int i=0;i < 10;i++){double solution=getSolution(solver,100,f,left,right,AllowedSolution.LEFT_SIDE);if (!Double.isNaN(solution)){Assert.assertTrue(solution <= 0.0);}left-=0.1;right+=0.3;}}
@Test public void testSolutionRightSide(){UnivariateFunction f=new SinFunction();UnivariateRealSolver solver=getSolver();double left=-1.5;double right=0.05;for (int i=0;i < 10;i++){double solution=getSolution(solver,100,f,left,right,AllowedSolution.RIGHT_SIDE);if (!Double.isNaN(solution)){Assert.assertTrue(solution >= 0.0);}left-=0.1;right+=0.3;}}
@Test public void testSolutionBelowSide(){UnivariateFunction f=new SinFunction();UnivariateRealSolver solver=getSolver();double left=-1.5;double right=0.05;for (int i=0;i < 10;i++){double solution=getSolution(solver,100,f,left,right,AllowedSolution.BELOW_SIDE);if (!Double.isNaN(solution)){Assert.assertTrue(f.value(solution)<= 0.0);}left-=0.1;right+=0.3;}}
@Test public void testSolutionAboveSide(){UnivariateFunction f=new SinFunction();UnivariateRealSolver solver=getSolver();double left=-1.5;double right=0.05;for (int i=0;i < 10;i++){double solution=getSolution(solver,100,f,left,right,AllowedSolution.ABOVE_SIDE);if (!Double.isNaN(solution)){Assert.assertTrue(f.value(solution)>= 0.0);}left-=0.1;right+=0.3;}}
@Test public void testSetterInjection(){DescriptiveStatistics stats=createDescriptiveStatistics();stats.addValue(1);stats.addValue(3);Assert.assertEquals(2,stats.getMean(),1E-10);stats.setMeanImpl(new deepMean());Assert.assertEquals(42,stats.getMean(),1E-10);}
@Test public void testCopy(){DescriptiveStatistics stats=createDescriptiveStatistics();stats.addValue(1);stats.addValue(3);DescriptiveStatistics copy=new DescriptiveStatistics(stats);Assert.assertEquals(2,copy.getMean(),1E-10);stats.setMeanImpl(new deepMean());copy=stats.copy();Assert.assertEquals(42,copy.getMean(),1E-10);}
@Test public void testWindowSize(){DescriptiveStatistics stats=createDescriptiveStatistics();stats.setWindowSize(300);for (int i=0;i < 100;++i){stats.addValue(i + 1);}int refSum=(100 * 101)/ 2;Assert.assertEquals(refSum / 100.0,stats.getMean(),1E-10);Assert.assertEquals(300,stats.getWindowSize());try {stats.setWindowSize(-3);Assert.fail("an exception should have been thrown");}catch(IllegalArgumentException iae){}Assert.assertEquals(300,stats.getWindowSize());stats.setWindowSize(50);Assert.assertEquals(50,stats.getWindowSize());int refSum2=refSum - (50 * 51)/ 2;Assert.assertEquals(refSum2 / 50.0,stats.getMean(),1E-10);}
@Test public void testGetValues(){DescriptiveStatistics stats=createDescriptiveStatistics();for (int i=100;i > 0;--i){stats.addValue(i);}int refSum=(100 * 101)/ 2;Assert.assertEquals(refSum / 100.0,stats.getMean(),1E-10);double[]v=stats.getValues();for (int i=0;i < v.length;++i){Assert.assertEquals(100.0 - i,v[i],1.0e-10);}double[]s=stats.getSortedValues();for (int i=0;i < s.length;++i){Assert.assertEquals(i + 1.0,s[i],1.0e-10);}Assert.assertEquals(12.0,stats.getElement(88),1.0e-10);}
@Test public void testToString(){DescriptiveStatistics stats=createDescriptiveStatistics();stats.addValue(1);stats.addValue(2);stats.addValue(3);Locale d=Locale.getDefault();Locale.setDefault(Locale.US);Assert.assertEquals("DescriptiveStatistics:\n" + "n: 3\n" + "min: 1.0\n"+ "max: 3.0\n"+ "mean: 2.0\n"+ "std dev: 1.0\n"+ "median: 2.0\n"+ "skewness: 0.0\n"+ "kurtosis: NaN\n",stats.toString());Locale.setDefault(d);}
@Test public void testShuffledStatistics(){DescriptiveStatistics reference=createDescriptiveStatistics();DescriptiveStatistics shuffled=createDescriptiveStatistics();UnivariateStatistic tmp=shuffled.getGeometricMeanImpl();shuffled.setGeometricMeanImpl(shuffled.getMeanImpl());shuffled.setMeanImpl(shuffled.getKurtosisImpl());shuffled.setKurtosisImpl(shuffled.getSkewnessImpl());shuffled.setSkewnessImpl(shuffled.getVarianceImpl());shuffled.setVarianceImpl(shuffled.getMaxImpl());shuffled.setMaxImpl(shuffled.getMinImpl());shuffled.setMinImpl(shuffled.getSumImpl());shuffled.setSumImpl(shuffled.getSumsqImpl());shuffled.setSumsqImpl(tmp);for (int i=100;i > 0;--i){reference.addValue(i);shuffled.addValue(i);}Assert.assertEquals(reference.getMean(),shuffled.getGeometricMean(),1.0e-10);Assert.assertEquals(reference.getKurtosis(),shuffled.getMean(),1.0e-10);Assert.assertEquals(reference.getSkewness(),shuffled.getKurtosis(),1.0e-10);Assert.assertEquals(reference.getVariance(),shuffled.getSkewness(),1.0e-10);Assert.assertEquals(reference.getMax(),shuffled.getVariance(),1.0e-10);Assert.assertEquals(reference.getMin(),shuffled.getMax(),1.0e-10);Assert.assertEquals(reference.getSum(),shuffled.getMin(),1.0e-10);Assert.assertEquals(reference.getSumsq(),shuffled.getSum(),1.0e-10);Assert.assertEquals(reference.getGeometricMean(),shuffled.getSumsq(),1.0e-10);}
@Test public void testPercentileSetter()throws Exception {DescriptiveStatistics stats=createDescriptiveStatistics();stats.addValue(1);stats.addValue(2);stats.addValue(3);Assert.assertEquals(2,stats.getPercentile(50.0),1E-10);stats.setPercentileImpl(new goodPercentile());Assert.assertEquals(2,stats.getPercentile(50.0),1E-10);stats.setPercentileImpl(new subPercentile());Assert.assertEquals(10.0,stats.getPercentile(10.0),1E-10);try {stats.setPercentileImpl(new badPercentile());Assert.fail("Expecting IllegalArgumentException");}catch(IllegalArgumentException ex){}}
@Test public void test20090720(){DescriptiveStatistics descriptiveStatistics=new DescriptiveStatistics(100);for (int i=0;i < 161;i++){descriptiveStatistics.addValue(1.2);}descriptiveStatistics.clear();descriptiveStatistics.addValue(1.2);Assert.assertEquals(1,descriptiveStatistics.getN());}
@Test public void testRemoval(){final DescriptiveStatistics dstat=createDescriptiveStatistics();checkremoval(dstat,1,6.0,0.0,Double.NaN);checkremoval(dstat,3,5.0,3.0,4.5);checkremoval(dstat,6,3.5,2.5,3.0);checkremoval(dstat,9,3.5,2.5,3.0);checkremoval(dstat,DescriptiveStatistics.INFINITE_WINDOW,3.5,2.5,3.0);}
@Test public void testSummaryConsistency(){final DescriptiveStatistics dstats=new DescriptiveStatistics();final SummaryStatistics sstats=new SummaryStatistics();final int windowSize=5;dstats.setWindowSize(windowSize);final double tol=1E-12;for (int i=0;i < 20;i++){dstats.addValue(i);sstats.clear();double[]values=dstats.getValues();for (int j=0;j < values.length;j++){sstats.addValue(values[j]);}TestUtils.assertEquals(dstats.getMean(),sstats.getMean(),tol);TestUtils.assertEquals(new Mean().evaluate(values),dstats.getMean(),tol);TestUtils.assertEquals(dstats.getMax(),sstats.getMax(),tol);TestUtils.assertEquals(new Max().evaluate(values),dstats.getMax(),tol);TestUtils.assertEquals(dstats.getGeometricMean(),sstats.getGeometricMean(),tol);TestUtils.assertEquals(new GeometricMean().evaluate(values),dstats.getGeometricMean(),tol);TestUtils.assertEquals(dstats.getMin(),sstats.getMin(),tol);TestUtils.assertEquals(new Min().evaluate(values),dstats.getMin(),tol);TestUtils.assertEquals(dstats.getStandardDeviation(),sstats.getStandardDeviation(),tol);TestUtils.assertEquals(dstats.getVariance(),sstats.getVariance(),tol);TestUtils.assertEquals(new Variance().evaluate(values),dstats.getVariance(),tol);TestUtils.assertEquals(dstats.getSum(),sstats.getSum(),tol);TestUtils.assertEquals(new Sum().evaluate(values),dstats.getSum(),tol);TestUtils.assertEquals(dstats.getSumsq(),sstats.getSumsq(),tol);TestUtils.assertEquals(new SumOfSquares().evaluate(values),dstats.getSumsq(),tol);TestUtils.assertEquals(dstats.getPopulationVariance(),sstats.getPopulationVariance(),tol);TestUtils.assertEquals(new Variance(false).evaluate(values),dstats.getPopulationVariance(),tol);}}
/** * Test of interpolator for the sine function. <p> |sin^(n)(zeta)| <= 1.0,zeta in [0,2*PI]*/@Test public void testSinFunction(){UnivariateFunction f=new SinFunction();UnivariateRealInterpolator interpolator=new NevilleInterpolator();double x[],y[],z,expected,result,tolerance;int n=6;double min=0.0,max=2 * FastMath.PI;x=new double[n];y=new double[n];for (int i=0;i < n;i++){x[i]=min + i * (max - min)/ n;y[i]=f.value(x[i]);}double derivativebound=1.0;UnivariateFunction p=interpolator.interpolate(x,y);z=FastMath.PI / 4;expected=f.value(z);result=p.value(z);tolerance=FastMath.abs(derivativebound * partialerror(x,z));Assert.assertEquals(expected,result,tolerance);z=FastMath.PI * 1.5;expected=f.value(z);result=p.value(z);tolerance=FastMath.abs(derivativebound * partialerror(x,z));Assert.assertEquals(expected,result,tolerance);}
/** * Test of interpolator for the exponential function. <p> |expm1^(n)(zeta)| <= e,zeta in [-1,1]*/@Test public void testExpm1Function(){UnivariateFunction f=new Expm1Function();UnivariateRealInterpolator interpolator=new NevilleInterpolator();double x[],y[],z,expected,result,tolerance;int n=5;double min=-1.0,max=1.0;x=new double[n];y=new double[n];for (int i=0;i < n;i++){x[i]=min + i * (max - min)/ n;y[i]=f.value(x[i]);}double derivativebound=FastMath.E;UnivariateFunction p=interpolator.interpolate(x,y);z=0.0;expected=f.value(z);result=p.value(z);tolerance=FastMath.abs(derivativebound * partialerror(x,z));Assert.assertEquals(expected,result,tolerance);z=0.5;expected=f.value(z);result=p.value(z);tolerance=FastMath.abs(derivativebound * partialerror(x,z));Assert.assertEquals(expected,result,tolerance);z=-0.5;expected=f.value(z);result=p.value(z);tolerance=FastMath.abs(derivativebound * partialerror(x,z));Assert.assertEquals(expected,result,tolerance);}
/** * Test of parameters for the interpolator.*/@Test public void testParameters()throws Exception {UnivariateRealInterpolator interpolator=new NevilleInterpolator();try {double x[]={1.0,2.0,2.0,4.0};double y[]={0.0,4.0,4.0,2.5};UnivariateFunction p=interpolator.interpolate(x,y);p.value(0.0);Assert.fail("Expecting NonMonotonicSequenceException - bad abscissas array");}catch(NonMonotonicSequenceException ex){}}
@Test public void testStartSimplexInsideRange(){final BiQuadratic biQuadratic=new BiQuadratic(2.0,2.5,1.0,3.0,2.0,3.0);final MultivariateFunctionPenaltyAdapter wrapped=new MultivariateFunctionPenaltyAdapter(biQuadratic,biQuadratic.getLower(),biQuadratic.getUpper(),1000.0,new double[]{100.0,100.0});SimplexOptimizer optimizer=new SimplexOptimizer(1e-10,1e-30);optimizer.setSimplex(new NelderMeadSimplex(new double[]{1.0,0.5}));final RealPointValuePair optimum=optimizer.optimize(300,wrapped,GoalType.MINIMIZE,new double[]{1.5,2.25});Assert.assertEquals(biQuadratic.getBoundedXOptimum(),optimum.getPoint()[0],2e-7);Assert.assertEquals(biQuadratic.getBoundedYOptimum(),optimum.getPoint()[1],2e-7);}
@Test public void testStartSimplexOutsideRange(){final BiQuadratic biQuadratic=new BiQuadratic(2.0,2.5,1.0,3.0,2.0,3.0);final MultivariateFunctionPenaltyAdapter wrapped=new MultivariateFunctionPenaltyAdapter(biQuadratic,biQuadratic.getLower(),biQuadratic.getUpper(),1000.0,new double[]{100.0,100.0});SimplexOptimizer optimizer=new SimplexOptimizer(1e-10,1e-30);optimizer.setSimplex(new NelderMeadSimplex(new double[]{1.0,0.5}));final RealPointValuePair optimum=optimizer.optimize(300,wrapped,GoalType.MINIMIZE,new double[]{-1.5,4.0});Assert.assertEquals(biQuadratic.getBoundedXOptimum(),optimum.getPoint()[0],2e-7);Assert.assertEquals(biQuadratic.getBoundedYOptimum(),optimum.getPoint()[1],2e-7);}
@Test public void testOptimumOutsideRange(){final BiQuadratic biQuadratic=new BiQuadratic(4.0,0.0,1.0,3.0,2.0,3.0);final MultivariateFunctionPenaltyAdapter wrapped=new MultivariateFunctionPenaltyAdapter(biQuadratic,biQuadratic.getLower(),biQuadratic.getUpper(),1000.0,new double[]{100.0,100.0});SimplexOptimizer optimizer=new SimplexOptimizer(new SimpleRealPointChecker(1.0e-11,1.0e-20));optimizer.setSimplex(new NelderMeadSimplex(new double[]{1.0,0.5}));final RealPointValuePair optimum=optimizer.optimize(600,wrapped,GoalType.MINIMIZE,new double[]{-1.5,4.0});Assert.assertEquals(biQuadratic.getBoundedXOptimum(),optimum.getPoint()[0],2e-7);Assert.assertEquals(biQuadratic.getBoundedYOptimum(),optimum.getPoint()[1],2e-7);}
@Test public void testUnbounded(){final BiQuadratic biQuadratic=new BiQuadratic(4.0,0.0,Double.NEGATIVE_INFINITY,Double.POSITIVE_INFINITY,Double.NEGATIVE_INFINITY,Double.POSITIVE_INFINITY);final MultivariateFunctionPenaltyAdapter wrapped=new MultivariateFunctionPenaltyAdapter(biQuadratic,biQuadratic.getLower(),biQuadratic.getUpper(),1000.0,new double[]{100.0,100.0});SimplexOptimizer optimizer=new SimplexOptimizer(1e-10,1e-30);optimizer.setSimplex(new NelderMeadSimplex(new double[]{1.0,0.5}));final RealPointValuePair optimum=optimizer.optimize(300,wrapped,GoalType.MINIMIZE,new double[]{-1.5,4.0});Assert.assertEquals(biQuadratic.getBoundedXOptimum(),optimum.getPoint()[0],2e-7);Assert.assertEquals(biQuadratic.getBoundedYOptimum(),optimum.getPoint()[1],2e-7);}
@Test public void testHalfBounded(){final BiQuadratic biQuadratic=new BiQuadratic(4.0,4.0,1.0,Double.POSITIVE_INFINITY,Double.NEGATIVE_INFINITY,3.0);final MultivariateFunctionPenaltyAdapter wrapped=new MultivariateFunctionPenaltyAdapter(biQuadratic,biQuadratic.getLower(),biQuadratic.getUpper(),1000.0,new double[]{100.0,100.0});SimplexOptimizer optimizer=new SimplexOptimizer(new SimpleRealPointChecker(1.0e-10,1.0e-20));optimizer.setSimplex(new NelderMeadSimplex(new double[]{1.0,0.5}));final RealPointValuePair optimum=optimizer.optimize(400,wrapped,GoalType.MINIMIZE,new double[]{-1.5,4.0});Assert.assertEquals(biQuadratic.getBoundedXOptimum(),optimum.getPoint()[0],2e-7);Assert.assertEquals(biQuadratic.getBoundedYOptimum(),optimum.getPoint()[1],2e-7);}
@Test public void testMap()throws Exception {double[]vec1Squared={1d,4d,9d,16d,25d};RealVector v=new TestVectorImpl(vec1.clone());RealVector w=v.map(new UnivariateFunction(){public double value(double x){return x * x;}});double[]d2=w.toArray();Assert.assertEquals(vec1Squared.length,d2.length);for (int i=0;i < vec1Squared.length;i++){Assert.assertEquals(vec1Squared[i],d2[i],0);}}
@Test public void testIterator()throws Exception {RealVector v=new TestVectorImpl(vec2.clone());Entry e;int i=0;for (Iterator<Entry> it=v.iterator();it.hasNext()&& (e=it.next())!= null;i++){Assert.assertEquals(vec2[i],e.getValue(),0);}}
@Test public void testSparseIterator()throws Exception {RealVector v=new TestVectorImpl(vec2.clone());Entry e;int i=0;double[]nonDefaultV2={-3d,2d,1d};for (Iterator<Entry> it=v.sparseIterator();it.hasNext()&& (e=it.next())!= null;i++){Assert.assertEquals(nonDefaultV2[i],e.getValue(),0);}double[]onlyOne={0d,1.0,0d};v=new TestVectorImpl(onlyOne);for (Iterator<Entry> it=v.sparseIterator();it.hasNext()&& (e=it.next())!= null;){Assert.assertEquals(onlyOne[1],e.getValue(),0);}}
@Test public void testClone()throws Exception {double[]d=new double[1000000];Random r=new Random(1234);for (int i=0;i < d.length;i++)d[i]=r.nextDouble();Assert.assertTrue(new ArrayRealVector(d).getNorm()> 0);double[]c=d.clone();c[0]=1;Assert.assertNotSame(c[0],d[0]);d[0]=1;Assert.assertEquals(new ArrayRealVector(d).getNorm(),new ArrayRealVector(c).getNorm(),0);}
@Test(expected=DimensionMismatchException.class)public void testCombinePrecondition(){final double a=1d;final double b=2d;double[]aux=new double[]{3d,4d,5d};final TestVectorImpl x=new TestVectorImpl(aux);aux=new double[]{6d,7d};final TestVectorImpl y=new TestVectorImpl(aux);x.combine(a,b,y);}
@Test public void testCombine(){final Random random=new Random(20110726);final int dim=10;final double a=(2 * random.nextDouble()- 1);final double b=(2 * random.nextDouble()- 1);final RealVector x=new TestVectorImpl(new double[dim]);final RealVector y=new TestVectorImpl(new double[dim]);final double[]expected=new double[dim];for (int i=0;i < dim;i++){final double xi=2 * random.nextDouble()- 1;final double yi=2 * random.nextDouble()- 1;x.setEntry(i,xi);y.setEntry(i,yi);expected[i]=a * xi + b * yi;}final RealVector z=x.combine(a,b,y);Assert.assertTrue(z != x);final double[]actual=z.toArray();for (int i=0;i < dim;i++){final double delta;if (expected[i]== 0d){delta=Math.ulp(1d);}else {delta=Math.ulp(expected[i]);}Assert.assertEquals("elements [" + i + "]differ",expected[i],actual[i],delta);}}
@Test(expected=DimensionMismatchException.class)public void testCombineToSelfPrecondition(){final double a=1d;final double b=2d;double[]aux=new double[]{3d,4d,5d};final TestVectorImpl x=new TestVectorImpl(aux);aux=new double[]{6d,7d};final TestVectorImpl y=new TestVectorImpl(aux);x.combineToSelf(a,b,y);}
@Test public void testCombineToSelf(){final Random random=new Random(20110726);final int dim=10;final double a=(2 * random.nextDouble()- 1);final double b=(2 * random.nextDouble()- 1);final RealVector x=new TestVectorImpl(new double[dim]);final RealVector y=new TestVectorImpl(new double[dim]);final double[]expected=new double[dim];for (int i=0;i < dim;i++){final double xi=2 * random.nextDouble()- 1;final double yi=2 * random.nextDouble()- 1;x.setEntry(i,xi);y.setEntry(i,yi);expected[i]=a * xi + b * yi;}Assert.assertSame(x,x.combineToSelf(a,b,y));final double[]actual=x.toArray();for (int i=0;i < dim;i++){final double delta;if (expected[i]== 0d){delta=Math.ulp(1d);}else {delta=Math.ulp(expected[i]);}Assert.assertEquals("elements [" + i + "]differ",expected[i],actual[i],delta);}}
@Test public void testAddToEntry(){final double[]v=new double[]{1,2,3};final RealVector x=new TestVectorImpl(v.clone());final double inc=7;for (int i=0;i < x.getDimension();i++){x.addToEntry(i,inc);}for (int i=0;i < x.getDimension();i++){Assert.assertEquals(v[i]+ inc,x.getEntry(i),0);}}
@Test public void testSinZero(){UnivariateFunction f=new SinFunction();double result;UnivariateRealSolver solver=getSolver();result=solver.solve(100,f,3,4);Assert.assertEquals(result,FastMath.PI,solver.getAbsoluteAccuracy());Assert.assertTrue(solver.getEvaluations()<= 6);result=solver.solve(100,f,1,4);Assert.assertEquals(result,FastMath.PI,solver.getAbsoluteAccuracy());Assert.assertTrue(solver.getEvaluations()<= 7);}
@Test public void testQuinticZero(){UnivariateFunction f=new QuinticFunction();double result;UnivariateRealSolver solver=getSolver();double atol=solver.getAbsoluteAccuracy();int[]counts=getQuinticEvalCounts();double[][]testsData={{-0.2,0.2,0.0},{-0.1,0.3,0.0},{-0.3,0.45,0.0},{0.3,0.7,0.5},{0.2,0.6,0.5},{0.05,0.95,0.5},{0.85,1.25,1.0},{0.8,1.2,1.0},{0.85,1.75,1.0},{0.55,1.45,1.0},{0.85,5.0,1.0}};int maxIter=500;for (int i=0;i < testsData.length;i++){if (counts[i]== -1)continue;double[]testData=testsData[i];result=solver.solve(maxIter,f,testData[0],testData[1]);Assert.assertEquals(result,testData[2],atol);Assert.assertTrue(solver.getEvaluations()<= counts[i]+ 1);}}
@Test public void testRootEndpoints(){UnivariateFunction f=new XMinus5Function();UnivariateRealSolver solver=getSolver();double result=solver.solve(100,f,5.0,6.0);Assert.assertEquals(5.0,result,0.0);result=solver.solve(100,f,4.0,5.0);Assert.assertEquals(5.0,result,0.0);result=solver.solve(100,f,5.0,6.0,5.5);Assert.assertEquals(5.0,result,0.0);result=solver.solve(100,f,4.0,5.0,4.5);Assert.assertEquals(5.0,result,0.0);}
@Test public void testBadEndpoints(){UnivariateFunction f=new SinFunction();UnivariateRealSolver solver=getSolver();try {solver.solve(100,f,1,-1);Assert.fail("Expecting NumberIsTooLargeException - bad interval");}catch(NumberIsTooLargeException ex){}try {solver.solve(100,f,1,1.5);Assert.fail("Expecting NoBracketingException - non-bracketing");}catch(NoBracketingException ex){}try {solver.solve(100,f,1,1.5,1.2);Assert.fail("Expecting NoBracketingException - non-bracketing");}catch(NoBracketingException ex){}}
@Test public void testSolutionLeftSide(){UnivariateFunction f=new SinFunction();UnivariateRealSolver solver=getSolver();double left=-1.5;double right=0.05;for (int i=0;i < 10;i++){double solution=getSolution(solver,100,f,left,right,AllowedSolution.LEFT_SIDE);if (!Double.isNaN(solution)){Assert.assertTrue(solution <= 0.0);}left-=0.1;right+=0.3;}}
@Test public void testSolutionRightSide(){UnivariateFunction f=new SinFunction();UnivariateRealSolver solver=getSolver();double left=-1.5;double right=0.05;for (int i=0;i < 10;i++){double solution=getSolution(solver,100,f,left,right,AllowedSolution.RIGHT_SIDE);if (!Double.isNaN(solution)){Assert.assertTrue(solution >= 0.0);}left-=0.1;right+=0.3;}}
@Test public void testSolutionBelowSide(){UnivariateFunction f=new SinFunction();UnivariateRealSolver solver=getSolver();double left=-1.5;double right=0.05;for (int i=0;i < 10;i++){double solution=getSolution(solver,100,f,left,right,AllowedSolution.BELOW_SIDE);if (!Double.isNaN(solution)){Assert.assertTrue(f.value(solution)<= 0.0);}left-=0.1;right+=0.3;}}
@Test public void testSolutionAboveSide(){UnivariateFunction f=new SinFunction();UnivariateRealSolver solver=getSolver();double left=-1.5;double right=0.05;for (int i=0;i < 10;i++){double solution=getSolution(solver,100,f,left,right,AllowedSolution.ABOVE_SIDE);if (!Double.isNaN(solution)){Assert.assertTrue(f.value(solution)>= 0.0);}left-=0.1;right+=0.3;}}
/** * Verifies that increment()and incrementAll work properly.*/@Test public void testIncrementation()throws Exception {StorelessUnivariateStatistic statistic=(StorelessUnivariateStatistic)getUnivariateStatistic();for (int i=0;i < testArray.length;i++){statistic.increment(testArray[i]);}Assert.assertEquals(expectedValue(),statistic.getResult(),getTolerance());Assert.assertEquals(testArray.length,statistic.getN());statistic.clear();statistic.incrementAll(testArray);Assert.assertEquals(expectedValue(),statistic.getResult(),getTolerance());Assert.assertEquals(testArray.length,statistic.getN());statistic.clear();checkClearValue(statistic);Assert.assertEquals(0,statistic.getN());}
@Test public void testSerialization()throws Exception {StorelessUnivariateStatistic statistic=(StorelessUnivariateStatistic)getUnivariateStatistic();TestUtils.checkSerializedEquality(statistic);statistic.clear();for (int i=0;i < testArray.length;i++){statistic.increment(testArray[i]);if (i % 5 == 0)statistic=(StorelessUnivariateStatistic)TestUtils.serializeAndRecover(statistic);}TestUtils.checkSerializedEquality(statistic);Assert.assertEquals(expectedValue(),statistic.getResult(),getTolerance());statistic.clear();checkClearValue(statistic);}
@Test public void testEqualsAndHashCode(){StorelessUnivariateStatistic statistic=(StorelessUnivariateStatistic)getUnivariateStatistic();StorelessUnivariateStatistic statistic2=null;Assert.assertTrue("non-null,compared to null",!statistic.equals(statistic2));Assert.assertTrue("reflexive,non-null",statistic.equals(statistic));int emptyHash=statistic.hashCode();statistic2=(StorelessUnivariateStatistic)getUnivariateStatistic();Assert.assertTrue("empty stats should be equal",statistic.equals(statistic2));Assert.assertEquals("empty stats should have the same hashcode",emptyHash,statistic2.hashCode());statistic.increment(1d);Assert.assertTrue("reflexive,non-empty",statistic.equals(statistic));Assert.assertTrue("non-empty,compared to empty",!statistic.equals(statistic2));Assert.assertTrue("non-empty,compared to empty",!statistic2.equals(statistic));Assert.assertTrue("non-empty stat should have different hashcode from empty stat",statistic.hashCode()!= emptyHash);statistic2.increment(1d);Assert.assertTrue("stats with same data should be equal",statistic.equals(statistic2));Assert.assertEquals("stats with same data should have the same hashcode",statistic.hashCode(),statistic2.hashCode());statistic.increment(Double.POSITIVE_INFINITY);Assert.assertTrue("stats with different n's should not be equal",!statistic2.equals(statistic));Assert.assertTrue("stats with different n's should have different hashcodes",statistic.hashCode()!= statistic2.hashCode());statistic2.increment(Double.POSITIVE_INFINITY);Assert.assertTrue("stats with same data should be equal",statistic.equals(statistic2));Assert.assertEquals("stats with same data should have the same hashcode",statistic.hashCode(),statistic2.hashCode());statistic.clear();statistic2.clear();Assert.assertTrue("cleared stats should be equal",statistic.equals(statistic2));Assert.assertEquals("cleared stats should have thashcode of empty stat",emptyHash,statistic2.hashCode());Assert.assertEquals("cleared stats should have thashcode of empty stat",emptyHash,statistic.hashCode());}
@Test public void testMomentSmallSamples(){UnivariateStatistic stat=getUnivariateStatistic();if (stat instanceof SecondMoment){SecondMoment moment=(SecondMoment)getUnivariateStatistic();Assert.assertTrue(Double.isNaN(moment.getResult()));moment.increment(1d);Assert.assertEquals(0d,moment.getResult(),0);}}
/** * Make sure that evaluate(double[])and inrementAll(double[]),getResult()give same results.*/@Test public void testConsistency(){StorelessUnivariateStatistic stat=(StorelessUnivariateStatistic)getUnivariateStatistic();stat.incrementAll(testArray);Assert.assertEquals(stat.getResult(),stat.evaluate(testArray),getTolerance());for (int i=0;i < smallSamples.length;i++){stat.clear();for (int j=0;j < smallSamples[i].length;j++){stat.increment(smallSamples[i][j]);}TestUtils.assertEquals(stat.getResult(),stat.evaluate(smallSamples[i]),getTolerance());}}
/** * Verifies that copied statistics remain equal to originals when incremented the same way.*/@Test public void testCopyConsistency(){StorelessUnivariateStatistic master=(StorelessUnivariateStatistic)getUnivariateStatistic();StorelessUnivariateStatistic replica=null;long index=FastMath.round((FastMath.random())* testArray.length);master.incrementAll(testArray,0,(int)index);replica=master.copy();Assert.assertTrue(replica.equals(master));Assert.assertTrue(master.equals(replica));master.incrementAll(testArray,(int)index,(int)(testArray.length - index));replica.incrementAll(testArray,(int)index,(int)(testArray.length - index));Assert.assertTrue(replica.equals(master));Assert.assertTrue(master.equals(replica));}
@Test public void testSerial(){StorelessUnivariateStatistic s=(StorelessUnivariateStatistic)getUnivariateStatistic();Assert.assertEquals(s,TestUtils.serializeAndRecover(s));}
@Test public void testEvaluation()throws Exception {Assert.assertEquals(expectedValue(),getUnivariateStatistic().evaluate(testArray),getTolerance());}
@Test public void testEvaluateArraySegment(){final UnivariateStatistic stat=getUnivariateStatistic();final double[]arrayZero=new double[5];System.arraycopy(testArray,0,arrayZero,0,5);Assert.assertEquals(stat.evaluate(arrayZero),stat.evaluate(testArray,0,5),0);final double[]arrayOne=new double[5];System.arraycopy(testArray,5,arrayOne,0,5);Assert.assertEquals(stat.evaluate(arrayOne),stat.evaluate(testArray,5,5),0);final double[]arrayEnd=new double[5];System.arraycopy(testArray,testArray.length - 5,arrayEnd,0,5);Assert.assertEquals(stat.evaluate(arrayEnd),stat.evaluate(testArray,testArray.length - 5,5),0);}
@Test public void testEvaluateArraySegmentWeighted(){UnivariateStatistic statistic=getUnivariateStatistic();if (!(statistic instanceof WeightedEvaluation)){return;}final WeightedEvaluation stat=(WeightedEvaluation)getUnivariateStatistic();final double[]arrayZero=new double[5];final double[]weightZero=new double[5];System.arraycopy(testArray,0,arrayZero,0,5);System.arraycopy(testWeightsArray,0,weightZero,0,5);Assert.assertEquals(stat.evaluate(arrayZero,weightZero),stat.evaluate(testArray,testWeightsArray,0,5),0);final double[]arrayOne=new double[5];final double[]weightOne=new double[5];System.arraycopy(testArray,5,arrayOne,0,5);System.arraycopy(testWeightsArray,5,weightOne,0,5);Assert.assertEquals(stat.evaluate(arrayOne,weightOne),stat.evaluate(testArray,testWeightsArray,5,5),0);final double[]arrayEnd=new double[5];final double[]weightEnd=new double[5];System.arraycopy(testArray,testArray.length - 5,arrayEnd,0,5);System.arraycopy(testWeightsArray,testArray.length - 5,weightEnd,0,5);Assert.assertEquals(stat.evaluate(arrayEnd,weightEnd),stat.evaluate(testArray,testWeightsArray,testArray.length - 5,5),0);}
@Test public void testCopy()throws Exception {UnivariateStatistic original=getUnivariateStatistic();UnivariateStatistic copy=original.copy();Assert.assertEquals(expectedValue(),copy.evaluate(testArray),getTolerance());}
/** * Tests consistency of weighted statistic computation. For statistics that support weighted evaluation,this test case compares the result of direct computation on an array with repeated values with a weighted computation on the corresponding (shorter)array with each value appearing only once but with a weight value equal to its multiplicity in the repeating array.*/@Test public void testWeightedConsistency()throws Exception {UnivariateStatistic statistic=getUnivariateStatistic();if (!(statistic instanceof WeightedEvaluation)){return;}final int len=10;final double mu=0;final double sigma=5;double[]values=new double[len];double[]weights=new double[len];RandomData randomData=new RandomDataImpl();int[]intWeights=new int[len];for (int i=0;i < len;i++){intWeights[i]=randomData.nextInt(1,5);weights[i]=intWeights[i];}List<Double> valuesList=new ArrayList<Double>();for (int i=0;i < len;i++){double value=randomData.nextGaussian(mu,sigma);values[i]=value;for (int j=0;j < intWeights[i];j++){valuesList.add(new Double(value));}}int sumWeights=valuesList.size();double[]repeatedValues=new double[sumWeights];for (int i=0;i < sumWeights;i++){repeatedValues[i]=valuesList.get(i);}WeightedEvaluation weightedStatistic=(WeightedEvaluation)statistic;TestUtils.assertRelativelyEquals(statistic.evaluate(repeatedValues),weightedStatistic.evaluate(values,weights,0,values.length),10E-14);Assert.assertEquals(weightedStatistic.evaluate(values,weights,0,values.length),weightedStatistic.evaluate(values,weights),Double.MIN_VALUE);}
@Test public void testInterpolateLinearDegenerateTwoSegment()throws Exception {double x[]={0.0,0.5,1.0};double y[]={0.0,0.5,1.0};UnivariateRealInterpolator i=new SplineInterpolator();UnivariateFunction f=i.interpolate(x,y);verifyInterpolation(f,x,y);verifyConsistency((PolynomialSplineFunction)f,x);PolynomialFunction polynomials[]=((PolynomialSplineFunction)f).getPolynomials();double target[]={y[0],1d};TestUtils.assertEquals(polynomials[0].getCoefficients(),target,coefficientTolerance);target=new double[]{y[1],1d};TestUtils.assertEquals(polynomials[1].getCoefficients(),target,coefficientTolerance);Assert.assertEquals(0.0,f.value(0.0),interpolationTolerance);Assert.assertEquals(0.4,f.value(0.4),interpolationTolerance);Assert.assertEquals(1.0,f.value(1.0),interpolationTolerance);}
@Test public void testInterpolateLinearDegenerateThreeSegment()throws Exception {double x[]={0.0,0.5,1.0,1.5};double y[]={0.0,0.5,1.0,1.5};UnivariateRealInterpolator i=new SplineInterpolator();UnivariateFunction f=i.interpolate(x,y);verifyInterpolation(f,x,y);PolynomialFunction polynomials[]=((PolynomialSplineFunction)f).getPolynomials();double target[]={y[0],1d};TestUtils.assertEquals(polynomials[0].getCoefficients(),target,coefficientTolerance);target=new double[]{y[1],1d};TestUtils.assertEquals(polynomials[1].getCoefficients(),target,coefficientTolerance);target=new double[]{y[2],1d};TestUtils.assertEquals(polynomials[2].getCoefficients(),target,coefficientTolerance);Assert.assertEquals(0,f.value(0),interpolationTolerance);Assert.assertEquals(1.4,f.value(1.4),interpolationTolerance);Assert.assertEquals(1.5,f.value(1.5),interpolationTolerance);}
@Test public void testInterpolateLinear()throws Exception {double x[]={0.0,0.5,1.0};double y[]={0.0,0.5,0.0};UnivariateRealInterpolator i=new SplineInterpolator();UnivariateFunction f=i.interpolate(x,y);verifyInterpolation(f,x,y);verifyConsistency((PolynomialSplineFunction)f,x);PolynomialFunction polynomials[]=((PolynomialSplineFunction)f).getPolynomials();double target[]={y[0],1.5d,0d,-2d};TestUtils.assertEquals(polynomials[0].getCoefficients(),target,coefficientTolerance);target=new double[]{y[1],0d,-3d,2d};TestUtils.assertEquals(polynomials[1].getCoefficients(),target,coefficientTolerance);}
@Test public void testInterpolateSin()throws Exception {double x[]={0.0,FastMath.PI / 6d,FastMath.PI / 2d,5d * FastMath.PI / 6d,FastMath.PI,7d * FastMath.PI / 6d,3d * FastMath.PI / 2d,11d * FastMath.PI / 6d,2.d * FastMath.PI};double y[]={0d,0.5d,1d,0.5d,0d,-0.5d,-1d,-0.5d,0d};UnivariateRealInterpolator i=new SplineInterpolator();UnivariateFunction f=i.interpolate(x,y);verifyInterpolation(f,x,y);verifyConsistency((PolynomialSplineFunction)f,x);PolynomialFunction polynomials[]=((PolynomialSplineFunction)f).getPolynomials();double target[]={y[0],1.002676d,0d,-0.17415829d};TestUtils.assertEquals(polynomials[0].getCoefficients(),target,coefficientTolerance);target=new double[]{y[1],8.594367e-01,-2.735672e-01,-0.08707914};TestUtils.assertEquals(polynomials[1].getCoefficients(),target,coefficientTolerance);target=new double[]{y[2],1.471804e-17,-5.471344e-01,0.08707914};TestUtils.assertEquals(polynomials[2].getCoefficients(),target,coefficientTolerance);target=new double[]{y[3],-8.594367e-01,-2.735672e-01,0.17415829};TestUtils.assertEquals(polynomials[3].getCoefficients(),target,coefficientTolerance);target=new double[]{y[4],-1.002676,6.548562e-17,0.17415829};TestUtils.assertEquals(polynomials[4].getCoefficients(),target,coefficientTolerance);target=new double[]{y[5],-8.594367e-01,2.735672e-01,0.08707914};TestUtils.assertEquals(polynomials[5].getCoefficients(),target,coefficientTolerance);target=new double[]{y[6],3.466465e-16,5.471344e-01,-0.08707914};TestUtils.assertEquals(polynomials[6].getCoefficients(),target,coefficientTolerance);target=new double[]{y[7],8.594367e-01,2.735672e-01,-0.17415829};TestUtils.assertEquals(polynomials[7].getCoefficients(),target,coefficientTolerance);Assert.assertEquals(FastMath.sqrt(2d)/ 2d,f.value(FastMath.PI / 4d),interpolationTolerance);Assert.assertEquals(FastMath.sqrt(2d)/ 2d,f.value(3d * FastMath.PI / 4d),interpolationTolerance);}
@Test public void testIllegalArguments(){UnivariateRealInterpolator i=new SplineInterpolator();try {double xval[]={0.0,1.0};double yval[]={0.0,1.0,2.0};i.interpolate(xval,yval);Assert.fail("Failed to detect data set array with different sizes.");}catch(DimensionMismatchException iae){}try {double xval[]={0.0,1.0,0.5};double yval[]={0.0,1.0,2.0};i.interpolate(xval,yval);Assert.fail("Failed to detect unsorted arguments.");}catch(NonMonotonicSequenceException iae){}try {double xval[]={0.0,1.0};double yval[]={0.0,1.0};i.interpolate(xval,yval);Assert.fail("Failed to detect unsorted arguments.");}catch(NumberIsTooSmallException iae){}}
/** * Verifies that increment()and incrementAll work properly.*/@Test public void testIncrementation()throws Exception {StorelessUnivariateStatistic statistic=(StorelessUnivariateStatistic)getUnivariateStatistic();for (int i=0;i < testArray.length;i++){statistic.increment(testArray[i]);}Assert.assertEquals(expectedValue(),statistic.getResult(),getTolerance());Assert.assertEquals(testArray.length,statistic.getN());statistic.clear();statistic.incrementAll(testArray);Assert.assertEquals(expectedValue(),statistic.getResult(),getTolerance());Assert.assertEquals(testArray.length,statistic.getN());statistic.clear();checkClearValue(statistic);Assert.assertEquals(0,statistic.getN());}
@Test public void testSerialization()throws Exception {StorelessUnivariateStatistic statistic=(StorelessUnivariateStatistic)getUnivariateStatistic();TestUtils.checkSerializedEquality(statistic);statistic.clear();for (int i=0;i < testArray.length;i++){statistic.increment(testArray[i]);if (i % 5 == 0)statistic=(StorelessUnivariateStatistic)TestUtils.serializeAndRecover(statistic);}TestUtils.checkSerializedEquality(statistic);Assert.assertEquals(expectedValue(),statistic.getResult(),getTolerance());statistic.clear();checkClearValue(statistic);}
@Test public void testEqualsAndHashCode(){StorelessUnivariateStatistic statistic=(StorelessUnivariateStatistic)getUnivariateStatistic();StorelessUnivariateStatistic statistic2=null;Assert.assertTrue("non-null,compared to null",!statistic.equals(statistic2));Assert.assertTrue("reflexive,non-null",statistic.equals(statistic));int emptyHash=statistic.hashCode();statistic2=(StorelessUnivariateStatistic)getUnivariateStatistic();Assert.assertTrue("empty stats should be equal",statistic.equals(statistic2));Assert.assertEquals("empty stats should have the same hashcode",emptyHash,statistic2.hashCode());statistic.increment(1d);Assert.assertTrue("reflexive,non-empty",statistic.equals(statistic));Assert.assertTrue("non-empty,compared to empty",!statistic.equals(statistic2));Assert.assertTrue("non-empty,compared to empty",!statistic2.equals(statistic));Assert.assertTrue("non-empty stat should have different hashcode from empty stat",statistic.hashCode()!= emptyHash);statistic2.increment(1d);Assert.assertTrue("stats with same data should be equal",statistic.equals(statistic2));Assert.assertEquals("stats with same data should have the same hashcode",statistic.hashCode(),statistic2.hashCode());statistic.increment(Double.POSITIVE_INFINITY);Assert.assertTrue("stats with different n's should not be equal",!statistic2.equals(statistic));Assert.assertTrue("stats with different n's should have different hashcodes",statistic.hashCode()!= statistic2.hashCode());statistic2.increment(Double.POSITIVE_INFINITY);Assert.assertTrue("stats with same data should be equal",statistic.equals(statistic2));Assert.assertEquals("stats with same data should have the same hashcode",statistic.hashCode(),statistic2.hashCode());statistic.clear();statistic2.clear();Assert.assertTrue("cleared stats should be equal",statistic.equals(statistic2));Assert.assertEquals("cleared stats should have thashcode of empty stat",emptyHash,statistic2.hashCode());Assert.assertEquals("cleared stats should have thashcode of empty stat",emptyHash,statistic.hashCode());}
@Test public void testMomentSmallSamples(){UnivariateStatistic stat=getUnivariateStatistic();if (stat instanceof SecondMoment){SecondMoment moment=(SecondMoment)getUnivariateStatistic();Assert.assertTrue(Double.isNaN(moment.getResult()));moment.increment(1d);Assert.assertEquals(0d,moment.getResult(),0);}}
/** * Make sure that evaluate(double[])and inrementAll(double[]),getResult()give same results.*/@Test public void testConsistency(){StorelessUnivariateStatistic stat=(StorelessUnivariateStatistic)getUnivariateStatistic();stat.incrementAll(testArray);Assert.assertEquals(stat.getResult(),stat.evaluate(testArray),getTolerance());for (int i=0;i < smallSamples.length;i++){stat.clear();for (int j=0;j < smallSamples[i].length;j++){stat.increment(smallSamples[i][j]);}TestUtils.assertEquals(stat.getResult(),stat.evaluate(smallSamples[i]),getTolerance());}}
/** * Verifies that copied statistics remain equal to originals when incremented the same way.*/@Test public void testCopyConsistency(){StorelessUnivariateStatistic master=(StorelessUnivariateStatistic)getUnivariateStatistic();StorelessUnivariateStatistic replica=null;long index=FastMath.round((FastMath.random())* testArray.length);master.incrementAll(testArray,0,(int)index);replica=master.copy();Assert.assertTrue(replica.equals(master));Assert.assertTrue(master.equals(replica));master.incrementAll(testArray,(int)index,(int)(testArray.length - index));replica.incrementAll(testArray,(int)index,(int)(testArray.length - index));Assert.assertTrue(replica.equals(master));Assert.assertTrue(master.equals(replica));}
@Test public void testSerial(){StorelessUnivariateStatistic s=(StorelessUnivariateStatistic)getUnivariateStatistic();Assert.assertEquals(s,TestUtils.serializeAndRecover(s));}
@Test public void testEvaluation()throws Exception {Assert.assertEquals(expectedValue(),getUnivariateStatistic().evaluate(testArray),getTolerance());}
@Test public void testEvaluateArraySegment(){final UnivariateStatistic stat=getUnivariateStatistic();final double[]arrayZero=new double[5];System.arraycopy(testArray,0,arrayZero,0,5);Assert.assertEquals(stat.evaluate(arrayZero),stat.evaluate(testArray,0,5),0);final double[]arrayOne=new double[5];System.arraycopy(testArray,5,arrayOne,0,5);Assert.assertEquals(stat.evaluate(arrayOne),stat.evaluate(testArray,5,5),0);final double[]arrayEnd=new double[5];System.arraycopy(testArray,testArray.length - 5,arrayEnd,0,5);Assert.assertEquals(stat.evaluate(arrayEnd),stat.evaluate(testArray,testArray.length - 5,5),0);}
@Test public void testEvaluateArraySegmentWeighted(){UnivariateStatistic statistic=getUnivariateStatistic();if (!(statistic instanceof WeightedEvaluation)){return;}final WeightedEvaluation stat=(WeightedEvaluation)getUnivariateStatistic();final double[]arrayZero=new double[5];final double[]weightZero=new double[5];System.arraycopy(testArray,0,arrayZero,0,5);System.arraycopy(testWeightsArray,0,weightZero,0,5);Assert.assertEquals(stat.evaluate(arrayZero,weightZero),stat.evaluate(testArray,testWeightsArray,0,5),0);final double[]arrayOne=new double[5];final double[]weightOne=new double[5];System.arraycopy(testArray,5,arrayOne,0,5);System.arraycopy(testWeightsArray,5,weightOne,0,5);Assert.assertEquals(stat.evaluate(arrayOne,weightOne),stat.evaluate(testArray,testWeightsArray,5,5),0);final double[]arrayEnd=new double[5];final double[]weightEnd=new double[5];System.arraycopy(testArray,testArray.length - 5,arrayEnd,0,5);System.arraycopy(testWeightsArray,testArray.length - 5,weightEnd,0,5);Assert.assertEquals(stat.evaluate(arrayEnd,weightEnd),stat.evaluate(testArray,testWeightsArray,testArray.length - 5,5),0);}
@Test public void testCopy()throws Exception {UnivariateStatistic original=getUnivariateStatistic();UnivariateStatistic copy=original.copy();Assert.assertEquals(expectedValue(),copy.evaluate(testArray),getTolerance());}
/** * Tests consistency of weighted statistic computation. For statistics that support weighted evaluation,this test case compares the result of direct computation on an array with repeated values with a weighted computation on the corresponding (shorter)array with each value appearing only once but with a weight value equal to its multiplicity in the repeating array.*/@Test public void testWeightedConsistency()throws Exception {UnivariateStatistic statistic=getUnivariateStatistic();if (!(statistic instanceof WeightedEvaluation)){return;}final int len=10;final double mu=0;final double sigma=5;double[]values=new double[len];double[]weights=new double[len];RandomData randomData=new RandomDataImpl();int[]intWeights=new int[len];for (int i=0;i < len;i++){intWeights[i]=randomData.nextInt(1,5);weights[i]=intWeights[i];}List<Double> valuesList=new ArrayList<Double>();for (int i=0;i < len;i++){double value=randomData.nextGaussian(mu,sigma);values[i]=value;for (int j=0;j < intWeights[i];j++){valuesList.add(new Double(value));}}int sumWeights=valuesList.size();double[]repeatedValues=new double[sumWeights];for (int i=0;i < sumWeights;i++){repeatedValues[i]=valuesList.get(i);}WeightedEvaluation weightedStatistic=(WeightedEvaluation)statistic;TestUtils.assertRelativelyEquals(statistic.evaluate(repeatedValues),weightedStatistic.evaluate(values,weights,0,values.length),10E-14);Assert.assertEquals(weightedStatistic.evaluate(values,weights,0,values.length),weightedStatistic.evaluate(values,weights),Double.MIN_VALUE);}
@Test public void derivativesConsistency(){TestProblem3 pb=new TestProblem3(0.9);double minStep=0;double maxStep=pb.getFinalTime()- pb.getInitialTime();double absTolerance=1.0e-8;double relTolerance=1.0e-8;GraggBulirschStoerIntegrator integ=new GraggBulirschStoerIntegrator(minStep,maxStep,absTolerance,relTolerance);StepInterpolatorTestUtils.checkDerivativesConsistency(integ,pb,1.0e-8);}
@Test public void serialization()throws IOException,ClassNotFoundException {TestProblem3 pb=new TestProblem3(0.9);double minStep=0;double maxStep=pb.getFinalTime()- pb.getInitialTime();double absTolerance=1.0e-8;double relTolerance=1.0e-8;GraggBulirschStoerIntegrator integ=new GraggBulirschStoerIntegrator(minStep,maxStep,absTolerance,relTolerance);integ.addStepHandler(new ContinuousOutputModel());integ.integrate(pb,pb.getInitialTime(),pb.getInitialState(),pb.getFinalTime(),new double[pb.getDimension()]);ByteArrayOutputStream bos=new ByteArrayOutputStream();ObjectOutputStream oos=new ObjectOutputStream(bos);for(StepHandler handler : integ.getStepHandlers()){oos.writeObject(handler);}Assert.assertTrue(bos.size()> 35000);Assert.assertTrue(bos.size()< 36000);ByteArrayInputStream bis=new ByteArrayInputStream(bos.toByteArray());ObjectInputStream ois=new ObjectInputStream(bis);ContinuousOutputModel cm=(ContinuousOutputModel)ois.readObject();Random random=new Random(347588535632l);double maxError=0.0;for (int i=0;i < 1000;++i){double r=random.nextDouble();double time=r * pb.getInitialTime()+ (1.0 - r)* pb.getFinalTime();cm.setInterpolatedTime(time);double[]interpolatedY=cm.getInterpolatedState();double[]theoreticalY=pb.computeTheoreticalState(time);double dx=interpolatedY[0]- theoreticalY[0];double dy=interpolatedY[1]- theoreticalY[1];double error=dx * dx + dy * dy;if (error > maxError){maxError=error;}}Assert.assertTrue(maxError < 5.0e-10);}
@Test public void checklone(){TestProblem3 pb=new TestProblem3(0.9);double minStep=0;double maxStep=pb.getFinalTime()- pb.getInitialTime();double scalAbsoluteTolerance=1.0e-8;double scalRelativeTolerance=scalAbsoluteTolerance;GraggBulirschStoerIntegrator integ=new GraggBulirschStoerIntegrator(minStep,maxStep,scalAbsoluteTolerance,scalRelativeTolerance);integ.addStepHandler(new StepHandler(){public void handleStep(StepInterpolator interpolator,boolean isLast){StepInterpolator cloned=interpolator.copy();double tA=cloned.getPreviousTime();double tB=cloned.getCurrentTime();double halfStep=FastMath.abs(tB - tA)/ 2;Assert.assertEquals(interpolator.getPreviousTime(),tA,1.0e-12);Assert.assertEquals(interpolator.getCurrentTime(),tB,1.0e-12);for (int i=0;i < 10;++i){double t=(i * tB + (9 - i)* tA)/ 9;interpolator.setInterpolatedTime(t);Assert.assertTrue(FastMath.abs(cloned.getInterpolatedTime()- t)> (halfStep / 10));cloned.setInterpolatedTime(t);Assert.assertEquals(t,cloned.getInterpolatedTime(),1.0e-12);double[]referenceState=interpolator.getInterpolatedState();double[]cloneState=cloned.getInterpolatedState();for (int j=0;j < referenceState.length;++j){Assert.assertEquals(referenceState[j],cloneState[j],1.0e-12);}}}public void init(double t0,double[]y0,double t){}});integ.integrate(pb,pb.getInitialTime(),pb.getInitialState(),pb.getFinalTime(),new double[pb.getDimension()]);}
@Test public void testEndPoints(){Vector2D p1=new Vector2D(-1,-7);Vector2D p2=new Vector2D(7,-1);Segment segment=new Segment(p1,p2,new Line(p1,p2));SubLine sub=new SubLine(segment);List<Segment> segments=sub.getSegments();Assert.assertEquals(1,segments.size());Assert.assertEquals(0.0,new Vector2D(-1,-7).distance(segments.get(0).getStart()),1.0e-10);Assert.assertEquals(0.0,new Vector2D(7,-1).distance(segments.get(0).getEnd()),1.0e-10);}
@Test public void testNoEndPoints(){SubLine wholeLine=new Line(new Vector2D(-1,7),new Vector2D(7,1)).wholeHyperplane();List<Segment> segments=wholeLine.getSegments();Assert.assertEquals(1,segments.size());Assert.assertTrue(Double.isInfinite(segments.get(0).getStart().getX())&& segments.get(0).getStart().getX()< 0);Assert.assertTrue(Double.isInfinite(segments.get(0).getStart().getY())&& segments.get(0).getStart().getY()> 0);Assert.assertTrue(Double.isInfinite(segments.get(0).getEnd().getX())&& segments.get(0).getEnd().getX()> 0);Assert.assertTrue(Double.isInfinite(segments.get(0).getEnd().getY())&& segments.get(0).getEnd().getY()< 0);}
@Test public void testNoSegments(){SubLine empty=new SubLine(new Line(new Vector2D(-1,-7),new Vector2D(7,-1)),new RegionFactory<Euclidean1D>().getComplement(new IntervalsSet()));List<Segment> segments=empty.getSegments();Assert.assertEquals(0,segments.size());}
@Test public void testSeveralSegments(){SubLine twoSubs=new SubLine(new Line(new Vector2D(-1,-7),new Vector2D(7,-1)),new RegionFactory<Euclidean1D>().union(new IntervalsSet(1,2),new IntervalsSet(3,4)));List<Segment> segments=twoSubs.getSegments();Assert.assertEquals(2,segments.size());}
@Test public void testHalfInfiniteNeg(){SubLine empty=new SubLine(new Line(new Vector2D(-1,-7),new Vector2D(7,-1)),new IntervalsSet(Double.NEGATIVE_INFINITY,0.0));List<Segment> segments=empty.getSegments();Assert.assertEquals(1,segments.size());Assert.assertTrue(Double.isInfinite(segments.get(0).getStart().getX())&& segments.get(0).getStart().getX()< 0);Assert.assertTrue(Double.isInfinite(segments.get(0).getStart().getY())&& segments.get(0).getStart().getY()< 0);Assert.assertEquals(0.0,new Vector2D(3,-4).distance(segments.get(0).getEnd()),1.0e-10);}
@Test public void testHalfInfinitePos(){SubLine empty=new SubLine(new Line(new Vector2D(-1,-7),new Vector2D(7,-1)),new IntervalsSet(0.0,Double.POSITIVE_INFINITY));List<Segment> segments=empty.getSegments();Assert.assertEquals(1,segments.size());Assert.assertEquals(0.0,new Vector2D(3,-4).distance(segments.get(0).getStart()),1.0e-10);Assert.assertTrue(Double.isInfinite(segments.get(0).getEnd().getX())&& segments.get(0).getEnd().getX()> 0);Assert.assertTrue(Double.isInfinite(segments.get(0).getEnd().getY())&& segments.get(0).getEnd().getY()> 0);}
@Test public void testIntersectionInsideInside(){SubLine sub1=new SubLine(new Vector2D(1,1),new Vector2D(3,1));SubLine sub2=new SubLine(new Vector2D(2,0),new Vector2D(2,2));Assert.assertEquals(0.0,new Vector2D(2,1).distance(sub1.intersection(sub2,true)),1.0e-12);Assert.assertEquals(0.0,new Vector2D(2,1).distance(sub1.intersection(sub2,false)),1.0e-12);}
@Test public void testIntersectionInsideBoundary(){SubLine sub1=new SubLine(new Vector2D(1,1),new Vector2D(3,1));SubLine sub2=new SubLine(new Vector2D(2,0),new Vector2D(2,1));Assert.assertEquals(0.0,new Vector2D(2,1).distance(sub1.intersection(sub2,true)),1.0e-12);Assert.assertNull(sub1.intersection(sub2,false));}
@Test public void testIntersectionInsideOutside(){SubLine sub1=new SubLine(new Vector2D(1,1),new Vector2D(3,1));SubLine sub2=new SubLine(new Vector2D(2,0),new Vector2D(2,0.5));Assert.assertNull(sub1.intersection(sub2,true));Assert.assertNull(sub1.intersection(sub2,false));}
@Test public void testIntersectionBoundaryBoundary(){SubLine sub1=new SubLine(new Vector2D(1,1),new Vector2D(2,1));SubLine sub2=new SubLine(new Vector2D(2,0),new Vector2D(2,1));Assert.assertEquals(0.0,new Vector2D(2,1).distance(sub1.intersection(sub2,true)),1.0e-12);Assert.assertNull(sub1.intersection(sub2,false));}
@Test public void testIntersectionBoundaryOutside(){SubLine sub1=new SubLine(new Vector2D(1,1),new Vector2D(2,1));SubLine sub2=new SubLine(new Vector2D(2,0),new Vector2D(2,0.5));Assert.assertNull(sub1.intersection(sub2,true));Assert.assertNull(sub1.intersection(sub2,false));}
@Test public void testIntersectionOutsideOutside(){SubLine sub1=new SubLine(new Vector2D(1,1),new Vector2D(1.5,1));SubLine sub2=new SubLine(new Vector2D(2,0),new Vector2D(2,0.5));Assert.assertNull(sub1.intersection(sub2,true));Assert.assertNull(sub1.intersection(sub2,false));}
/** * Test preconditions.*/@Test public void testPreconditions(){double[]xval=new double[]{3,4,5,6.5};double[]yval=new double[]{-4,-3,-1,2.5};double[][]zval=new double[xval.length][yval.length];BivariateRealGridInterpolator interpolator=new SmoothingPolynomialBicubicSplineInterpolator(0);@SuppressWarnings("unused")BivariateRealFunction p=interpolator.interpolate(xval,yval,zval);double[]wxval=new double[]{3,2,5,6.5};try {p=interpolator.interpolate(wxval,yval,zval);Assert.fail("an exception should have been thrown");}catch(MathIllegalArgumentException e){}double[]wyval=new double[]{-4,-3,-1,-1};try {p=interpolator.interpolate(xval,wyval,zval);Assert.fail("an exception should have been thrown");}catch(MathIllegalArgumentException e){}double[][]wzval=new double[xval.length][yval.length + 1];try {p=interpolator.interpolate(xval,yval,wzval);Assert.fail("an exception should have been thrown");}catch(DimensionMismatchException e){}wzval=new double[xval.length - 1][yval.length];try {p=interpolator.interpolate(xval,yval,wzval);Assert.fail("an exception should have been thrown");}catch(DimensionMismatchException e){}wzval=new double[xval.length][yval.length - 1];try {p=interpolator.interpolate(xval,yval,wzval);Assert.fail("an exception should have been thrown");}catch(DimensionMismatchException e){}}
/** * Test of interpolator for a plane. <p> z = 2 x - 3 y + 5*/@Test public void testPlane(){BivariateRealFunction f=new BivariateRealFunction(){public double value(double x,double y){return 2 * x - 3 * y + 5 + ((int)(FastMath.abs(5 * x + 3 * y))% 2 == 0 ? 1 : -1);}};BivariateRealGridInterpolator interpolator=new SmoothingPolynomialBicubicSplineInterpolator(1);double[]xval=new double[]{3,4,5,6.5};double[]yval=new double[]{-4,-3,-1,2,2.5};double[][]zval=new double[xval.length][yval.length];for (int i=0;i < xval.length;i++){for (int j=0;j < yval.length;j++){zval[i][j]=f.value(xval[i],yval[j]);}}BivariateRealFunction p=interpolator.interpolate(xval,yval,zval);double x,y;double expected,result;x=4;y=-3;expected=f.value(x,y);result=p.value(x,y);Assert.assertEquals("On sample point",expected,result,2);x=4.5;y=-1.5;expected=f.value(x,y);result=p.value(x,y);Assert.assertEquals("half-way between sample points (middle of the patch)",expected,result,2);x=3.5;y=-3.5;expected=f.value(x,y);result=p.value(x,y);Assert.assertEquals("half-way between sample points (border of the patch)",expected,result,2);}
/** * Test of interpolator for a paraboloid. <p> z = 2 x<sup>2</sup> - 3 y<sup>2</sup> + 4 x y - 5*/@Test public void testParaboloid(){BivariateRealFunction f=new BivariateRealFunction(){public double value(double x,double y){return 2 * x * x - 3 * y * y + 4 * x * y - 5 + ((int)(FastMath.abs(5 * x + 3 * y))% 2 == 0 ? 1 : -1);}};BivariateRealGridInterpolator interpolator=new SmoothingPolynomialBicubicSplineInterpolator(4);double[]xval=new double[]{3,4,5,6.5};double[]yval=new double[]{-4,-3,-2,-1,0.5,2.5};double[][]zval=new double[xval.length][yval.length];for (int i=0;i < xval.length;i++){for (int j=0;j < yval.length;j++){zval[i][j]=f.value(xval[i],yval[j]);}}BivariateRealFunction p=interpolator.interpolate(xval,yval,zval);double x,y;double expected,result;x=5;y=0.5;expected=f.value(x,y);result=p.value(x,y);Assert.assertEquals("On sample point",expected,result,2);x=4.5;y=-1.5;expected=f.value(x,y);result=p.value(x,y);Assert.assertEquals("half-way between sample points (middle of the patch)",expected,result,2);x=3.5;y=-3.5;expected=f.value(x,y);result=p.value(x,y);Assert.assertEquals("half-way between sample points (border of the patch)",expected,result,2);}
@Test public void testConstructors(){ArrayRealVector v0=new ArrayRealVector();Assert.assertEquals("testData len",0,v0.getDimension());ArrayRealVector v1=new ArrayRealVector(7);Assert.assertEquals("testData len",7,v1.getDimension());Assert.assertEquals("testData is 0.0 ",0.0,v1.getEntry(6),0);ArrayRealVector v2=new ArrayRealVector(5,1.23);Assert.assertEquals("testData len",5,v2.getDimension());Assert.assertEquals("testData is 1.23 ",1.23,v2.getEntry(4),0);ArrayRealVector v3=new ArrayRealVector(vec1);Assert.assertEquals("testData len",3,v3.getDimension());Assert.assertEquals("testData is 2.0 ",2.0,v3.getEntry(1),0);ArrayRealVector v3_bis=new ArrayRealVector(vec1,true);Assert.assertEquals("testData len",3,v3_bis.getDimension());Assert.assertEquals("testData is 2.0 ",2.0,v3_bis.getEntry(1),0);Assert.assertNotSame(v3_bis.getDataRef(),vec1);Assert.assertNotSame(v3_bis.toArray(),vec1);ArrayRealVector v3_ter=new ArrayRealVector(vec1,false);Assert.assertEquals("testData len",3,v3_ter.getDimension());Assert.assertEquals("testData is 2.0 ",2.0,v3_ter.getEntry(1),0);Assert.assertSame(v3_ter.getDataRef(),vec1);Assert.assertNotSame(v3_ter.toArray(),vec1);ArrayRealVector v4=new ArrayRealVector(vec4,3,2);Assert.assertEquals("testData len",2,v4.getDimension());Assert.assertEquals("testData is 4.0 ",4.0,v4.getEntry(0),0);try {new ArrayRealVector(vec4,8,3);Assert.fail("MathIllegalArgumentException expected");}catch(MathIllegalArgumentException ex){}RealVector v5_i=new ArrayRealVector(dvec1);Assert.assertEquals("testData len",9,v5_i.getDimension());Assert.assertEquals("testData is 9.0 ",9.0,v5_i.getEntry(8),0);ArrayRealVector v5=new ArrayRealVector(dvec1);Assert.assertEquals("testData len",9,v5.getDimension());Assert.assertEquals("testData is 9.0 ",9.0,v5.getEntry(8),0);ArrayRealVector v6=new ArrayRealVector(dvec1,3,2);Assert.assertEquals("testData len",2,v6.getDimension());Assert.assertEquals("testData is 4.0 ",4.0,v6.getEntry(0),0);try {new ArrayRealVector(dvec1,8,3);Assert.fail("MathIllegalArgumentException expected");}catch(MathIllegalArgumentException ex){}ArrayRealVector v7=new ArrayRealVector(v1);Assert.assertEquals("testData len",7,v7.getDimension());Assert.assertEquals("testData is 0.0 ",0.0,v7.getEntry(6),0);RealVectorTestImpl v7_i=new RealVectorTestImpl(vec1);ArrayRealVector v7_2=new ArrayRealVector(v7_i);Assert.assertEquals("testData len",3,v7_2.getDimension());Assert.assertEquals("testData is 0.0 ",2.0d,v7_2.getEntry(1),0);ArrayRealVector v8=new ArrayRealVector(v1,true);Assert.assertEquals("testData len",7,v8.getDimension());Assert.assertEquals("testData is 0.0 ",0.0,v8.getEntry(6),0);Assert.assertNotSame("testData not same object ",v1.data,v8.data);ArrayRealVector v8_2=new ArrayRealVector(v1,false);Assert.assertEquals("testData len",7,v8_2.getDimension());Assert.assertEquals("testData is 0.0 ",0.0,v8_2.getEntry(6),0);Assert.assertEquals("testData same object ",v1.data,v8_2.data);ArrayRealVector v9=new ArrayRealVector(v1,v3);Assert.assertEquals("testData len",10,v9.getDimension());Assert.assertEquals("testData is 1.0 ",1.0,v9.getEntry(7),0);ArrayRealVector v10=new ArrayRealVector(v2,new RealVectorTestImpl(vec3));Assert.assertEquals("testData len",8,v10.getDimension());Assert.assertEquals("testData is 1.23 ",1.23,v10.getEntry(4),0);Assert.assertEquals("testData is 7.0 ",7.0,v10.getEntry(5),0);ArrayRealVector v11=new ArrayRealVector(new RealVectorTestImpl(vec3),v2);Assert.assertEquals("testData len",8,v11.getDimension());Assert.assertEquals("testData is 9.0 ",9.0,v11.getEntry(2),0);Assert.assertEquals("testData is 1.23 ",1.23,v11.getEntry(3),0);ArrayRealVector v12=new ArrayRealVector(v2,vec3);Assert.assertEquals("testData len",8,v12.getDimension());Assert.assertEquals("testData is 1.23 ",1.23,v12.getEntry(4),0);Assert.assertEquals("testData is 7.0 ",7.0,v12.getEntry(5),0);ArrayRealVector v13=new ArrayRealVector(vec3,v2);Assert.assertEquals("testData len",8,v13.getDimension());Assert.assertEquals("testData is 9.0 ",9.0,v13.getEntry(2),0);Assert.assertEquals("testData is 1.23 ",1.23,v13.getEntry(3),0);ArrayRealVector v14=new ArrayRealVector(vec3,vec4);Assert.assertEquals("testData len",12,v14.getDimension());Assert.assertEquals("testData is 9.0 ",9.0,v14.getEntry(2),0);Assert.assertEquals("testData is 1.0 ",1.0,v14.getEntry(3),0);}
@Test public void testDataInOut(){ArrayRealVector v1=new ArrayRealVector(vec1);ArrayRealVector v2=new ArrayRealVector(vec2);ArrayRealVector v4=new ArrayRealVector(vec4);RealVectorTestImpl v2_t=new RealVectorTestImpl(vec2);RealVector v_append_1=v1.append(v2);Assert.assertEquals("testData len",6,v_append_1.getDimension());Assert.assertEquals("testData is 4.0 ",4.0,v_append_1.getEntry(3),0);RealVector v_append_2=v1.append(2.0);Assert.assertEquals("testData len",4,v_append_2.getDimension());Assert.assertEquals("testData is 2.0 ",2.0,v_append_2.getEntry(3),0);RealVector v_append_4=v1.append(v2_t);Assert.assertEquals("testData len",6,v_append_4.getDimension());Assert.assertEquals("testData is 4.0 ",4.0,v_append_4.getEntry(3),0);RealVector v_append_5=v1.append((RealVector)v2);Assert.assertEquals("testData len",6,v_append_5.getDimension());Assert.assertEquals("testData is 4.0 ",4.0,v_append_5.getEntry(3),0);RealVector v_copy=v1.copy();Assert.assertEquals("testData len",3,v_copy.getDimension());Assert.assertNotSame("testData not same object ",v1.data,v_copy.toArray());double[]a_double=v1.toArray();Assert.assertEquals("testData len",3,a_double.length);Assert.assertNotSame("testData not same object ",v1.data,a_double);RealVector vout5=v4.getSubVector(3,3);Assert.assertEquals("testData len",3,vout5.getDimension());Assert.assertEquals("testData is 4.0 ",5.0,vout5.getEntry(1),0);try {v4.getSubVector(3,7);Assert.fail("OutOfRangeException expected");}catch(OutOfRangeException ex){}ArrayRealVector v_set1=v1.copy();v_set1.setEntry(1,11.0);Assert.assertEquals("testData is 11.0 ",11.0,v_set1.getEntry(1),0);try {v_set1.setEntry(3,11.0);Assert.fail("OutOfRangeException expected");}catch(OutOfRangeException ex){}ArrayRealVector v_set3=v1.copy();v_set3.set(13.0);Assert.assertEquals("testData is 13.0 ",13.0,v_set3.getEntry(2),0);try {v_set3.getEntry(23);Assert.fail("ArrayIndexOutOfBoundsException expected");}catch(ArrayIndexOutOfBoundsException ex){}ArrayRealVector v_set4=v4.copy();v_set4.setSubVector(3,v2_t);Assert.assertEquals("testData is 1.0 ",4.0,v_set4.getEntry(3),0);Assert.assertEquals("testData is 7.0 ",7.0,v_set4.getEntry(6),0);try {v_set4.setSubVector(7,v2_t);Assert.fail("OutOfRangeException expected");}catch(OutOfRangeException ex){}ArrayRealVector vout10=v1.copy();ArrayRealVector vout10_2=v1.copy();Assert.assertEquals(vout10,vout10_2);vout10_2.setEntry(0,1.1);Assert.assertNotSame(vout10,vout10_2);}
@Test public void testMapFunctions(){ArrayRealVector v1=new ArrayRealVector(vec1);RealVector v_mapAdd=v1.mapAdd(2.0d);double[]result_mapAdd={3d,4d,5d};assertClose("compare vectors",result_mapAdd,v_mapAdd.toArray(),normTolerance);RealVector v_mapAddToSelf=v1.copy();v_mapAddToSelf.mapAddToSelf(2.0d);double[]result_mapAddToSelf={3d,4d,5d};assertClose("compare vectors",result_mapAddToSelf,v_mapAddToSelf.toArray(),normTolerance);RealVector v_mapSubtract=v1.mapSubtract(2.0d);double[]result_mapSubtract={-1d,0d,1d};assertClose("compare vectors",result_mapSubtract,v_mapSubtract.toArray(),normTolerance);RealVector v_mapSubtractToSelf=v1.copy();v_mapSubtractToSelf.mapSubtractToSelf(2.0d);double[]result_mapSubtractToSelf={-1d,0d,1d};assertClose("compare vectors",result_mapSubtractToSelf,v_mapSubtractToSelf.toArray(),normTolerance);RealVector v_mapMultiply=v1.mapMultiply(2.0d);double[]result_mapMultiply={2d,4d,6d};assertClose("compare vectors",result_mapMultiply,v_mapMultiply.toArray(),normTolerance);RealVector v_mapMultiplyToSelf=v1.copy();v_mapMultiplyToSelf.mapMultiplyToSelf(2.0d);double[]result_mapMultiplyToSelf={2d,4d,6d};assertClose("compare vectors",result_mapMultiplyToSelf,v_mapMultiplyToSelf.toArray(),normTolerance);RealVector v_mapDivide=v1.mapDivide(2.0d);double[]result_mapDivide={.5d,1d,1.5d};assertClose("compare vectors",result_mapDivide,v_mapDivide.toArray(),normTolerance);RealVector v_mapDivideToSelf=v1.copy();v_mapDivideToSelf.mapDivideToSelf(2.0d);double[]result_mapDivideToSelf={.5d,1d,1.5d};assertClose("compare vectors",result_mapDivideToSelf,v_mapDivideToSelf.toArray(),normTolerance);RealVector v_mapPow=v1.map(new Power(2));double[]result_mapPow={1d,4d,9d};assertClose("compare vectors",result_mapPow,v_mapPow.toArray(),normTolerance);RealVector v_mapPowToSelf=v1.copy();v_mapPowToSelf.mapToSelf(new Power(2));double[]result_mapPowToSelf={1d,4d,9d};assertClose("compare vectors",result_mapPowToSelf,v_mapPowToSelf.toArray(),normTolerance);RealVector v_mapExp=v1.map(new Exp());double[]result_mapExp={2.718281828459045e+00d,7.389056098930650e+00d,2.008553692318767e+01d};assertClose("compare vectors",result_mapExp,v_mapExp.toArray(),normTolerance);RealVector v_mapExpToSelf=v1.copy();v_mapExpToSelf.mapToSelf(new Exp());double[]result_mapExpToSelf={2.718281828459045e+00d,7.389056098930650e+00d,2.008553692318767e+01d};assertClose("compare vectors",result_mapExpToSelf,v_mapExpToSelf.toArray(),normTolerance);RealVector v_mapExpm1=v1.map(new Expm1());double[]result_mapExpm1={1.718281828459045d,6.38905609893065d,19.085536923187668d};assertClose("compare vectors",result_mapExpm1,v_mapExpm1.toArray(),normTolerance);RealVector v_mapExpm1ToSelf=v1.copy();v_mapExpm1ToSelf.mapToSelf(new Expm1());double[]result_mapExpm1ToSelf={1.718281828459045d,6.38905609893065d,19.085536923187668d};assertClose("compare vectors",result_mapExpm1ToSelf,v_mapExpm1ToSelf.toArray(),normTolerance);RealVector v_mapLog=v1.map(new Log());double[]result_mapLog={0d,6.931471805599453e-01d,1.098612288668110e+00d};assertClose("compare vectors",result_mapLog,v_mapLog.toArray(),normTolerance);RealVector v_mapLogToSelf=v1.copy();v_mapLogToSelf.mapToSelf(new Log());double[]result_mapLogToSelf={0d,6.931471805599453e-01d,1.098612288668110e+00d};assertClose("compare vectors",result_mapLogToSelf,v_mapLogToSelf.toArray(),normTolerance);RealVector v_mapLog10=v1.map(new Log10());double[]result_mapLog10={0d,3.010299956639812e-01d,4.771212547196624e-01d};assertClose("compare vectors",result_mapLog10,v_mapLog10.toArray(),normTolerance);RealVector v_mapLog10ToSelf=v1.copy();v_mapLog10ToSelf.mapToSelf(new Log10());double[]result_mapLog10ToSelf={0d,3.010299956639812e-01d,4.771212547196624e-01d};assertClose("compare vectors",result_mapLog10ToSelf,v_mapLog10ToSelf.toArray(),normTolerance);RealVector v_mapLog1p=v1.map(new Log1p());double[]result_mapLog1p={0.6931471805599453d,1.0986122886681096d,1.3862943611198906d};assertClose("compare vectors",result_mapLog1p,v_mapLog1p.toArray(),normTolerance);RealVector v_mapLog1pToSelf=v1.copy();v_mapLog1pToSelf.mapToSelf(new Log1p());double[]result_mapLog1pToSelf={0.6931471805599453d,1.0986122886681096d,1.3862943611198906d};assertClose("compare vectors",result_mapLog1pToSelf,v_mapLog1pToSelf.toArray(),normTolerance);RealVector v_mapCosh=v1.map(new Cosh());double[]result_mapCosh={1.543080634815244e+00d,3.762195691083631e+00d,1.006766199577777e+01d};assertClose("compare vectors",result_mapCosh,v_mapCosh.toArray(),normTolerance);RealVector v_mapCoshToSelf=v1.copy();v_mapCoshToSelf.mapToSelf(new Cosh());double[]result_mapCoshToSelf={1.543080634815244e+00d,3.762195691083631e+00d,1.006766199577777e+01d};assertClose("compare vectors",result_mapCoshToSelf,v_mapCoshToSelf.toArray(),normTolerance);RealVector v_mapSinh=v1.map(new Sinh());double[]result_mapSinh={1.175201193643801e+00d,3.626860407847019e+00d,1.001787492740990e+01d};assertClose("compare vectors",result_mapSinh,v_mapSinh.toArray(),normTolerance);RealVector v_mapSinhToSelf=v1.copy();v_mapSinhToSelf.mapToSelf(new Sinh());double[]result_mapSinhToSelf={1.175201193643801e+00d,3.626860407847019e+00d,1.001787492740990e+01d};assertClose("compare vectors",result_mapSinhToSelf,v_mapSinhToSelf.toArray(),normTolerance);RealVector v_mapTanh=v1.map(new Tanh());double[]result_mapTanh={7.615941559557649e-01d,9.640275800758169e-01d,9.950547536867305e-01d};assertClose("compare vectors",result_mapTanh,v_mapTanh.toArray(),normTolerance);RealVector v_mapTanhToSelf=v1.copy();v_mapTanhToSelf.mapToSelf(new Tanh());double[]result_mapTanhToSelf={7.615941559557649e-01d,9.640275800758169e-01d,9.950547536867305e-01d};assertClose("compare vectors",result_mapTanhToSelf,v_mapTanhToSelf.toArray(),normTolerance);RealVector v_mapCos=v1.map(new Cos());double[]result_mapCos={5.403023058681398e-01d,-4.161468365471424e-01d,-9.899924966004454e-01d};assertClose("compare vectors",result_mapCos,v_mapCos.toArray(),normTolerance);RealVector v_mapCosToSelf=v1.copy();v_mapCosToSelf.mapToSelf(new Cos());double[]result_mapCosToSelf={5.403023058681398e-01d,-4.161468365471424e-01d,-9.899924966004454e-01d};assertClose("compare vectors",result_mapCosToSelf,v_mapCosToSelf.toArray(),normTolerance);RealVector v_mapSin=v1.map(new Sin());double[]result_mapSin={8.414709848078965e-01d,9.092974268256817e-01d,1.411200080598672e-01d};assertClose("compare vectors",result_mapSin,v_mapSin.toArray(),normTolerance);RealVector v_mapSinToSelf=v1.copy();v_mapSinToSelf.mapToSelf(new Sin());double[]result_mapSinToSelf={8.414709848078965e-01d,9.092974268256817e-01d,1.411200080598672e-01d};assertClose("compare vectors",result_mapSinToSelf,v_mapSinToSelf.toArray(),normTolerance);RealVector v_mapTan=v1.map(new Tan());double[]result_mapTan={1.557407724654902e+00d,-2.185039863261519e+00d,-1.425465430742778e-01d};assertClose("compare vectors",result_mapTan,v_mapTan.toArray(),normTolerance);RealVector v_mapTanToSelf=v1.copy();v_mapTanToSelf.mapToSelf(new Tan());double[]result_mapTanToSelf={1.557407724654902e+00d,-2.185039863261519e+00d,-1.425465430742778e-01d};assertClose("compare vectors",result_mapTanToSelf,v_mapTanToSelf.toArray(),normTolerance);double[]vat_a={0d,0.5d,1.0d};ArrayRealVector vat=new ArrayRealVector(vat_a);RealVector v_mapAcos=vat.map(new Acos());double[]result_mapAcos={1.570796326794897e+00d,1.047197551196598e+00d,0.0d};assertClose("compare vectors",result_mapAcos,v_mapAcos.toArray(),normTolerance);RealVector v_mapAcosToSelf=vat.copy();v_mapAcosToSelf.mapToSelf(new Acos());double[]result_mapAcosToSelf={1.570796326794897e+00d,1.047197551196598e+00d,0.0d};assertClose("compare vectors",result_mapAcosToSelf,v_mapAcosToSelf.toArray(),normTolerance);RealVector v_mapAsin=vat.map(new Asin());double[]result_mapAsin={0.0d,5.235987755982989e-01d,1.570796326794897e+00d};assertClose("compare vectors",result_mapAsin,v_mapAsin.toArray(),normTolerance);RealVector v_mapAsinToSelf=vat.copy();v_mapAsinToSelf.mapToSelf(new Asin());double[]result_mapAsinToSelf={0.0d,5.235987755982989e-01d,1.570796326794897e+00d};assertClose("compare vectors",result_mapAsinToSelf,v_mapAsinToSelf.toArray(),normTolerance);RealVector v_mapAtan=vat.map(new Atan());double[]result_mapAtan={0.0d,4.636476090008061e-01d,7.853981633974483e-01d};assertClose("compare vectors",result_mapAtan,v_mapAtan.toArray(),normTolerance);RealVector v_mapAtanToSelf=vat.copy();v_mapAtanToSelf.mapToSelf(new Atan());double[]result_mapAtanToSelf={0.0d,4.636476090008061e-01d,7.853981633974483e-01d};assertClose("compare vectors",result_mapAtanToSelf,v_mapAtanToSelf.toArray(),normTolerance);RealVector v_mapInv=v1.map(new Inverse());double[]result_mapInv={1d,0.5d,3.333333333333333e-01d};assertClose("compare vectors",result_mapInv,v_mapInv.toArray(),normTolerance);RealVector v_mapInvToSelf=v1.copy();v_mapInvToSelf.mapToSelf(new Inverse());double[]result_mapInvToSelf={1d,0.5d,3.333333333333333e-01d};assertClose("compare vectors",result_mapInvToSelf,v_mapInvToSelf.toArray(),normTolerance);double[]abs_a={-1.0d,0.0d,1.0d};ArrayRealVector abs_v=new ArrayRealVector(abs_a);RealVector v_mapAbs=abs_v.map(new Abs());double[]result_mapAbs={1d,0d,1d};assertClose("compare vectors",result_mapAbs,v_mapAbs.toArray(),normTolerance);RealVector v_mapAbsToSelf=abs_v.copy();v_mapAbsToSelf.mapToSelf(new Abs());double[]result_mapAbsToSelf={1d,0d,1d};assertClose("compare vectors",result_mapAbsToSelf,v_mapAbsToSelf.toArray(),normTolerance);RealVector v_mapSqrt=v1.map(new Sqrt());double[]result_mapSqrt={1d,1.414213562373095e+00d,1.732050807568877e+00d};assertClose("compare vectors",result_mapSqrt,v_mapSqrt.toArray(),normTolerance);RealVector v_mapSqrtToSelf=v1.copy();v_mapSqrtToSelf.mapToSelf(new Sqrt());double[]result_mapSqrtToSelf={1d,1.414213562373095e+00d,1.732050807568877e+00d};assertClose("compare vectors",result_mapSqrtToSelf,v_mapSqrtToSelf.toArray(),normTolerance);double[]cbrt_a={-2.0d,0.0d,2.0d};ArrayRealVector cbrt_v=new ArrayRealVector(cbrt_a);RealVector v_mapCbrt=cbrt_v.map(new Cbrt());double[]result_mapCbrt={-1.2599210498948732d,0d,1.2599210498948732d};assertClose("compare vectors",result_mapCbrt,v_mapCbrt.toArray(),normTolerance);RealVector v_mapCbrtToSelf=cbrt_v.copy();v_mapCbrtToSelf.mapToSelf(new Cbrt());double[]result_mapCbrtToSelf={-1.2599210498948732d,0d,1.2599210498948732d};assertClose("compare vectors",result_mapCbrtToSelf,v_mapCbrtToSelf.toArray(),normTolerance);double[]ceil_a={-1.1d,0.9d,1.1d};ArrayRealVector ceil_v=new ArrayRealVector(ceil_a);RealVector v_mapCeil=ceil_v.map(new Ceil());double[]result_mapCeil={-1d,1d,2d};assertClose("compare vectors",result_mapCeil,v_mapCeil.toArray(),normTolerance);RealVector v_mapCeilToSelf=ceil_v.copy();v_mapCeilToSelf.mapToSelf(new Ceil());double[]result_mapCeilToSelf={-1d,1d,2d};assertClose("compare vectors",result_mapCeilToSelf,v_mapCeilToSelf.toArray(),normTolerance);RealVector v_mapFloor=ceil_v.map(new Floor());double[]result_mapFloor={-2d,0d,1d};assertClose("compare vectors",result_mapFloor,v_mapFloor.toArray(),normTolerance);RealVector v_mapFloorToSelf=ceil_v.copy();v_mapFloorToSelf.mapToSelf(new Floor());double[]result_mapFloorToSelf={-2d,0d,1d};assertClose("compare vectors",result_mapFloorToSelf,v_mapFloorToSelf.toArray(),normTolerance);RealVector v_mapRint=ceil_v.map(new Rint());double[]result_mapRint={-1d,1d,1d};assertClose("compare vectors",result_mapRint,v_mapRint.toArray(),normTolerance);RealVector v_mapRintToSelf=ceil_v.copy();v_mapRintToSelf.mapToSelf(new Rint());double[]result_mapRintToSelf={-1d,1d,1d};assertClose("compare vectors",result_mapRintToSelf,v_mapRintToSelf.toArray(),normTolerance);RealVector v_mapSignum=ceil_v.map(new Signum());double[]result_mapSignum={-1d,1d,1d};assertClose("compare vectors",result_mapSignum,v_mapSignum.toArray(),normTolerance);RealVector v_mapSignumToSelf=ceil_v.copy();v_mapSignumToSelf.mapToSelf(new Signum());double[]result_mapSignumToSelf={-1d,1d,1d};assertClose("compare vectors",result_mapSignumToSelf,v_mapSignumToSelf.toArray(),normTolerance);RealVector v_mapUlp=ceil_v.map(new Ulp());double[]result_mapUlp={2.220446049250313E-16d,1.1102230246251565E-16d,2.220446049250313E-16d};assertClose("compare vectors",result_mapUlp,v_mapUlp.toArray(),normTolerance);RealVector v_mapUlpToSelf=ceil_v.copy();v_mapUlpToSelf.mapToSelf(new Ulp());double[]result_mapUlpToSelf={2.220446049250313E-16d,1.1102230246251565E-16d,2.220446049250313E-16d};assertClose("compare vectors",result_mapUlpToSelf,v_mapUlpToSelf.toArray(),normTolerance);}
@Test public void testBasicFunctions(){ArrayRealVector v1=new ArrayRealVector(vec1);ArrayRealVector v2=new ArrayRealVector(vec2);ArrayRealVector v5=new ArrayRealVector(vec5);ArrayRealVector v_null=new ArrayRealVector(vec_null);RealVectorTestImpl v2_t=new RealVectorTestImpl(vec2);double d_getNorm=v5.getNorm();Assert.assertEquals("compare values  ",8.4261497731763586307,d_getNorm,normTolerance);double d_getL1Norm=v5.getL1Norm();Assert.assertEquals("compare values  ",17.0,d_getL1Norm,normTolerance);double d_getLInfNorm=v5.getLInfNorm();Assert.assertEquals("compare values  ",6.0,d_getLInfNorm,normTolerance);double dist=v1.getDistance(v2);Assert.assertEquals("compare values  ",v1.subtract(v2).getNorm(),dist,normTolerance);double dist_2=v1.getDistance(v2_t);Assert.assertEquals("compare values  ",v1.subtract(v2).getNorm(),dist_2,normTolerance);double dist_3=v1.getDistance(v2);Assert.assertEquals("compare values  ",v1.subtract(v2).getNorm(),dist_3,normTolerance);double d_getL1Distance=v1.getL1Distance(v2);Assert.assertEquals("compare values  ",9d,d_getL1Distance,normTolerance);double d_getL1Distance_2=v1.getL1Distance(v2_t);Assert.assertEquals("compare values  ",9d,d_getL1Distance_2,normTolerance);double d_getL1Distance_3=v1.getL1Distance(v2);Assert.assertEquals("compare values  ",9d,d_getL1Distance_3,normTolerance);double d_getLInfDistance=v1.getLInfDistance(v2);Assert.assertEquals("compare values  ",3d,d_getLInfDistance,normTolerance);double d_getLInfDistance_2=v1.getLInfDistance(v2_t);Assert.assertEquals("compare values  ",3d,d_getLInfDistance_2,normTolerance);double d_getLInfDistance_3=v1.getLInfDistance(v2);Assert.assertEquals("compare values  ",3d,d_getLInfDistance_3,normTolerance);ArrayRealVector v_add=v1.add(v2);double[]result_add={5d,7d,9d};assertClose("compare vect",v_add.toArray(),result_add,normTolerance);RealVectorTestImpl vt2=new RealVectorTestImpl(vec2);RealVector v_add_i=v1.add(vt2);double[]result_add_i={5d,7d,9d};assertClose("compare vect",v_add_i.toArray(),result_add_i,normTolerance);ArrayRealVector v_subtract=v1.subtract(v2);double[]result_subtract={-3d,-3d,-3d};assertClose("compare vect",v_subtract.toArray(),result_subtract,normTolerance);RealVector v_subtract_i=v1.subtract(vt2);double[]result_subtract_i={-3d,-3d,-3d};assertClose("compare vect",v_subtract_i.toArray(),result_subtract_i,normTolerance);ArrayRealVector v_ebeMultiply=v1.ebeMultiply(v2);double[]result_ebeMultiply={4d,10d,18d};assertClose("compare vect",v_ebeMultiply.toArray(),result_ebeMultiply,normTolerance);RealVector v_ebeMultiply_2=v1.ebeMultiply(v2_t);double[]result_ebeMultiply_2={4d,10d,18d};assertClose("compare vect",v_ebeMultiply_2.toArray(),result_ebeMultiply_2,normTolerance);RealVector v_ebeMultiply_3=v1.ebeMultiply(v2);double[]result_ebeMultiply_3={4d,10d,18d};assertClose("compare vect",v_ebeMultiply_3.toArray(),result_ebeMultiply_3,normTolerance);ArrayRealVector v_ebeDivide=v1.ebeDivide(v2);double[]result_ebeDivide={0.25d,0.4d,0.5d};assertClose("compare vect",v_ebeDivide.toArray(),result_ebeDivide,normTolerance);RealVector v_ebeDivide_2=v1.ebeDivide(v2_t);double[]result_ebeDivide_2={0.25d,0.4d,0.5d};assertClose("compare vect",v_ebeDivide_2.toArray(),result_ebeDivide_2,normTolerance);RealVector v_ebeDivide_3=v1.ebeDivide(v2);double[]result_ebeDivide_3={0.25d,0.4d,0.5d};assertClose("compare vect",v_ebeDivide_3.toArray(),result_ebeDivide_3,normTolerance);double dot=v1.dotProduct(v2);Assert.assertEquals("compare val ",32d,dot,normTolerance);double dot_2=v1.dotProduct(v2_t);Assert.assertEquals("compare val ",32d,dot_2,normTolerance);RealMatrix m_outerProduct=v1.outerProduct(v2);Assert.assertEquals("compare val ",4d,m_outerProduct.getEntry(0,0),normTolerance);RealMatrix m_outerProduct_2=v1.outerProduct(v2_t);Assert.assertEquals("compare val ",4d,m_outerProduct_2.getEntry(0,0),normTolerance);RealMatrix m_outerProduct_3=v1.outerProduct(v2);Assert.assertEquals("compare val ",4d,m_outerProduct_3.getEntry(0,0),normTolerance);RealVector v_unitVector=v1.unitVector();RealVector v_unitVector_2=v1.mapDivide(v1.getNorm());assertClose("compare vect",v_unitVector.toArray(),v_unitVector_2.toArray(),normTolerance);try {v_null.unitVector();Assert.fail("Expecting MathArithmeticException");}catch(MathArithmeticException ex){}ArrayRealVector v_unitize=v1.copy();v_unitize.unitize();assertClose("compare vect",v_unitVector_2.toArray(),v_unitize.toArray(),normTolerance);try {v_null.unitize();Assert.fail("Expecting MathArithmeticException");}catch(MathArithmeticException ex){}RealVector v_projection=v1.projection(v2);double[]result_projection={1.662337662337662,2.0779220779220777,2.493506493506493};assertClose("compare vect",v_projection.toArray(),result_projection,normTolerance);RealVector v_projection_2=v1.projection(v2_t);double[]result_projection_2={1.662337662337662,2.0779220779220777,2.493506493506493};assertClose("compare vect",v_projection_2.toArray(),result_projection_2,normTolerance);}
@Test public void testMisc(){ArrayRealVector v1=new ArrayRealVector(vec1);ArrayRealVector v4=new ArrayRealVector(vec4);RealVector v4_2=new ArrayRealVector(vec4);String out1=v1.toString();Assert.assertTrue("some output ",out1.length()!= 0);try {v1.checkVectorDimensions(2);Assert.fail("MathIllegalArgumentException expected");}catch(MathIllegalArgumentException ex){}try {v1.checkVectorDimensions(v4);Assert.fail("MathIllegalArgumentException expected");}catch(MathIllegalArgumentException ex){}try {v1.checkVectorDimensions(v4_2);Assert.fail("MathIllegalArgumentException expected");}catch(MathIllegalArgumentException ex){}}
@Test public void testPredicates(){ArrayRealVector v=new ArrayRealVector(new double[]{0,1,2});Assert.assertFalse(v.isNaN());v.setEntry(1,Double.NaN);Assert.assertTrue(v.isNaN());Assert.assertFalse(v.isInfinite());v.setEntry(0,Double.POSITIVE_INFINITY);Assert.assertFalse(v.isInfinite());v.setEntry(1,1);Assert.assertTrue(v.isInfinite());v.setEntry(0,1);Assert.assertFalse(v.isInfinite());v.setEntry(0,0);Assert.assertEquals(v,new ArrayRealVector(new double[]{0,1,2}));Assert.assertNotSame(v,new ArrayRealVector(new double[]{0,1,2 + FastMath.ulp(2)}));Assert.assertNotSame(v,new ArrayRealVector(new double[]{0,1,2,3}));Assert.assertEquals(new ArrayRealVector(new double[]{Double.NaN,1,2}).hashCode(),new ArrayRealVector(new double[]{0,Double.NaN,2}).hashCode());Assert.assertTrue(new ArrayRealVector(new double[]{Double.NaN,1,2}).hashCode()!= new ArrayRealVector(new double[]{0,1,2}).hashCode());Assert.assertTrue(v.equals(v));Assert.assertTrue(v.equals(v.copy()));Assert.assertFalse(v.equals(null));Assert.assertFalse(v.equals(v.getDataRef()));Assert.assertFalse(v.equals(v.getSubVector(0,v.getDimension()- 1)));Assert.assertTrue(v.equals(v.getSubVector(0,v.getDimension())));}
@Test public void testSerial(){ArrayRealVector v=new ArrayRealVector(new double[]{0,1,2});Assert.assertEquals(v,TestUtils.serializeAndRecover(v));}
@Test public void testZeroVectors(){Assert.assertEquals(0,new ArrayRealVector(new double[0]).getDimension());Assert.assertEquals(0,new ArrayRealVector(new double[0],true).getDimension());Assert.assertEquals(0,new ArrayRealVector(new double[0],false).getDimension());}
@Test public void testMinMax(){ArrayRealVector v1=new ArrayRealVector(new double[]{0,-6,4,12,7});Assert.assertEquals(1,v1.getMinIndex());Assert.assertEquals(-6,v1.getMinValue(),1.0e-12);Assert.assertEquals(3,v1.getMaxIndex());Assert.assertEquals(12,v1.getMaxValue(),1.0e-12);ArrayRealVector v2=new ArrayRealVector(new double[]{Double.NaN,3,Double.NaN,-2});Assert.assertEquals(3,v2.getMinIndex());Assert.assertEquals(-2,v2.getMinValue(),1.0e-12);Assert.assertEquals(1,v2.getMaxIndex());Assert.assertEquals(3,v2.getMaxValue(),1.0e-12);ArrayRealVector v3=new ArrayRealVector(new double[]{Double.NaN,Double.NaN});Assert.assertEquals(-1,v3.getMinIndex());Assert.assertTrue(Double.isNaN(v3.getMinValue()));Assert.assertEquals(-1,v3.getMaxIndex());Assert.assertTrue(Double.isNaN(v3.getMaxValue()));ArrayRealVector v4=new ArrayRealVector(new double[0]);Assert.assertEquals(-1,v4.getMinIndex());Assert.assertTrue(Double.isNaN(v4.getMinValue()));Assert.assertEquals(-1,v4.getMaxIndex());Assert.assertTrue(Double.isNaN(v4.getMaxValue()));}
@Test public void testCosine(){final ArrayRealVector v=new ArrayRealVector(new double[]{1,0,0});double[]wData=new double[]{1,1,0};RealVector w=new ArrayRealVector(wData);Assert.assertEquals(FastMath.sqrt(2)/ 2,v.cosine(w),normTolerance);wData=new double[]{1,0,0};w=new ArrayRealVector(wData);Assert.assertEquals(1,v.cosine(w),normTolerance);wData=new double[]{0,1,0};w=new ArrayRealVector(wData);Assert.assertEquals(0,v.cosine(w),0);wData=new double[]{-1,0,0};w=new ArrayRealVector(wData);Assert.assertEquals(-1,v.cosine(w),normTolerance);}
@Test(expected=MathArithmeticException.class)public void testCosinePrecondition1(){final ArrayRealVector v=new ArrayRealVector(new double[]{0,0,0});final ArrayRealVector w=new ArrayRealVector(new double[]{1,0,0});v.cosine(w);}
@Test(expected=MathArithmeticException.class)public void testCosinePrecondition2(){final ArrayRealVector v=new ArrayRealVector(new double[]{0,0,0});final ArrayRealVector w=new ArrayRealVector(new double[]{1,0,0});w.cosine(v);}
@Test(expected=DimensionMismatchException.class)public void testCosinePrecondition3(){final ArrayRealVector v=new ArrayRealVector(new double[]{1,2,3});final ArrayRealVector w=new ArrayRealVector(new double[]{1,2,3,4});v.cosine(w);}
@Test public void testOuterProduct(){final ArrayRealVector u=new ArrayRealVector(new double[]{1,2,-3});final ArrayRealVector v=new ArrayRealVector(new double[]{4,-2});final RealMatrix uv=u.outerProduct(v);final double tol=Math.ulp(1d);Assert.assertEquals(4,uv.getEntry(0,0),tol);Assert.assertEquals(-2,uv.getEntry(0,1),tol);Assert.assertEquals(8,uv.getEntry(1,0),tol);Assert.assertEquals(-4,uv.getEntry(1,1),tol);Assert.assertEquals(-12,uv.getEntry(2,0),tol);Assert.assertEquals(6,uv.getEntry(2,1),tol);}
@Test(expected=DimensionMismatchException.class)public void testCombinePreconditionSameType(){final double a=1d;final double b=2d;double[]aux=new double[]{3d,4d,5d};final RealVector x=new ArrayRealVector(aux,false);aux=new double[]{6d,7d};final RealVector y=new ArrayRealVector(aux,false);x.combine(a,b,y);}
@Test public void testCombineSameType(){final Random random=new Random(20110726);final int dim=10;final double a=(2 * random.nextDouble()- 1);final double b=(2 * random.nextDouble()- 1);final RealVector x=new ArrayRealVector(dim);final RealVector y=new ArrayRealVector(dim);final double[]expected=new double[dim];for (int i=0;i < dim;i++){final double xi=2 * random.nextDouble()- 1;final double yi=2 * random.nextDouble()- 1;x.setEntry(i,xi);y.setEntry(i,yi);expected[i]=a * xi + b * yi;}final double[]actual=x.combine(a,b,y).toArray();for (int i=0;i < dim;i++){final double delta;if (expected[i]== 0d){delta=Math.ulp(1d);}else {delta=Math.ulp(expected[i]);}Assert.assertEquals("elements [" + i + "]differ",expected[i],actual[i],delta);}}
@Test(expected=DimensionMismatchException.class)public void testCombinePreconditionMixedType(){final double a=1d;final double b=2d;double[]aux=new double[]{3d,4d,5d};final RealVector x=new ArrayRealVector(aux,false);aux=new double[]{6d,7d};final RealVector y=new OpenMapRealVector(aux);x.combine(a,b,y);}
@Test public void testCombineMixedTypes(){final Random random=new Random(20110726);final int dim=10;final double a=(2 * random.nextDouble()- 1);final double b=(2 * random.nextDouble()- 1);final RealVector x=new ArrayRealVector(dim);final RealVector y=new OpenMapRealVector(dim,0d);final double[]expected=new double[dim];for (int i=0;i < dim;i++){final double xi=2 * random.nextDouble()- 1;final double yi=2 * random.nextDouble()- 1;x.setEntry(i,xi);y.setEntry(i,yi);expected[i]=a * xi + b * yi;}final double[]actual=x.combine(a,b,y).toArray();for (int i=0;i < dim;i++){final double delta;if (expected[i]== 0d){delta=Math.ulp(1d);}else {delta=Math.ulp(expected[i]);}Assert.assertEquals("elements [" + i + "]differ",expected[i],actual[i],delta);}}
@Test(expected=DimensionMismatchException.class)public void testCombineToSelfPreconditionSameType(){final double a=1d;final double b=2d;double[]aux=new double[]{3d,4d,5d};final RealVector x=new ArrayRealVector(aux,false);aux=new double[]{6d,7d};final RealVector y=new ArrayRealVector(aux,false);x.combineToSelf(a,b,y);}
@Test public void testCombineToSelfSameType(){final Random random=new Random(20110726);final int dim=10;final double a=(2 * random.nextDouble()- 1);final double b=(2 * random.nextDouble()- 1);final RealVector x=new ArrayRealVector(dim);final RealVector y=new ArrayRealVector(dim);final double[]expected=new double[dim];for (int i=0;i < dim;i++){final double xi=2 * random.nextDouble()- 1;final double yi=2 * random.nextDouble()- 1;x.setEntry(i,xi);y.setEntry(i,yi);expected[i]=a * xi + b * yi;}Assert.assertSame(x,x.combineToSelf(a,b,y));final double[]actual=x.toArray();for (int i=0;i < dim;i++){final double delta;if (expected[i]== 0d){delta=Math.ulp(1d);}else {delta=Math.ulp(expected[i]);}Assert.assertEquals("elements [" + i + "]differ",expected[i],actual[i],delta);}}
@Test(expected=DimensionMismatchException.class)public void testCombineToSelfPreconditionMixedType(){final double a=1d;final double b=2d;double[]aux=new double[]{3d,4d,5d};final RealVector x=new ArrayRealVector(aux,false);aux=new double[]{6d,7d};final RealVector y=new OpenMapRealVector(aux);x.combineToSelf(a,b,y);}
@Test public void testCombineToSelfMixedTypes(){final Random random=new Random(20110726);final int dim=10;final double a=(2 * random.nextDouble()- 1);final double b=(2 * random.nextDouble()- 1);final RealVector x=new ArrayRealVector(dim);final RealVector y=new OpenMapRealVector(dim,0d);final double[]expected=new double[dim];for (int i=0;i < dim;i++){final double xi=2 * random.nextDouble()- 1;final double yi=2 * random.nextDouble()- 1;x.setEntry(i,xi);y.setEntry(i,yi);expected[i]=a * xi + b * yi;}Assert.assertSame(x,x.combineToSelf(a,b,y));final double[]actual=x.toArray();for (int i=0;i < dim;i++){final double delta;if (expected[i]== 0d){delta=Math.ulp(1d);}else {delta=Math.ulp(expected[i]);}Assert.assertEquals("elements [" + i + "]differ",expected[i],actual[i],delta);}}
@Test public void testAddToEntry(){final double[]v=new double[]{1,2,3};final ArrayRealVector x=new ArrayRealVector(v);final double inc=7;for (int i=0;i < x.getDimension();i++){x.addToEntry(i,inc);}for (int i=0;i < x.getDimension();i++){Assert.assertEquals(v[i]+ inc,x.getEntry(i),0);}}
@Test public void testSomeValues(){final double a=-1.2;final double w=0.34;final double p=5.6;final UnivariateFunction f=new HarmonicOscillator(a,w,p);final double d=0.12345;for (int i=0;i < 10;i++){final double v=i * d;Assert.assertEquals(a * FastMath.cos(w * v + p),f.value(v),0);}}
@Test public void testDerivative(){final double a=-1.2;final double w=0.34;final double p=5.6;final HarmonicOscillator f=new HarmonicOscillator(a,w,p);final UnivariateFunction dfdx=f.derivative();final double d=0.12345;for (int i=0;i < 10;i++){final double v=i * d;Assert.assertEquals(-a * w * FastMath.sin(w * v + p),dfdx.value(v),0);}}
@Test(expected=NullArgumentException.class)public void testParametricUsage1(){final HarmonicOscillator.Parametric g=new HarmonicOscillator.Parametric();g.value(0,null);}
@Test(expected=DimensionMismatchException.class)public void testParametricUsage2(){final HarmonicOscillator.Parametric g=new HarmonicOscillator.Parametric();g.value(0,new double[]{0});}
@Test(expected=NullArgumentException.class)public void testParametricUsage3(){final HarmonicOscillator.Parametric g=new HarmonicOscillator.Parametric();g.gradient(0,null);}
@Test(expected=DimensionMismatchException.class)public void testParametricUsage4(){final HarmonicOscillator.Parametric g=new HarmonicOscillator.Parametric();g.gradient(0,new double[]{0});}
@Test public void testParametricValue(){final double amplitude=2;final double omega=3;final double phase=4;final HarmonicOscillator f=new HarmonicOscillator(amplitude,omega,phase);final HarmonicOscillator.Parametric g=new HarmonicOscillator.Parametric();Assert.assertEquals(f.value(-1),g.value(-1,new double[]{amplitude,omega,phase}),0);Assert.assertEquals(f.value(0),g.value(0,new double[]{amplitude,omega,phase}),0);Assert.assertEquals(f.value(2),g.value(2,new double[]{amplitude,omega,phase}),0);}
@Test public void testParametricGradient(){final double amplitude=2;final double omega=3;final double phase=4;final HarmonicOscillator.Parametric f=new HarmonicOscillator.Parametric();final double x=1;final double[]grad=f.gradient(1,new double[]{amplitude,omega,phase});final double xTimesOmegaPlusPhase=omega * x + phase;final double a=FastMath.cos(xTimesOmegaPlusPhase);Assert.assertEquals(a,grad[0],EPS);final double w=-amplitude * x * FastMath.sin(xTimesOmegaPlusPhase);Assert.assertEquals(w,grad[1],EPS);final double p=-amplitude * FastMath.sin(xTimesOmegaPlusPhase);Assert.assertEquals(p,grad[2],EPS);}
/** * test solve dimension errors */@Test public void testSolveDimensionErrors(){DecompositionSolver solver=new CholeskyDecomposition(MatrixUtils.createRealMatrix(testData)).getSolver();RealMatrix b=MatrixUtils.createRealMatrix(new double[2][2]);try {solver.solve(b);Assert.fail("an exception should have been thrown");}catch(MathIllegalArgumentException iae){}try {solver.solve(b.getColumnVector(0));Assert.fail("an exception should have been thrown");}catch(MathIllegalArgumentException iae){}try {solver.solve(new ArrayRealVectorTest.RealVectorTestImpl(b.getColumn(0)));Assert.fail("an exception should have been thrown");}catch(MathIllegalArgumentException iae){}}
/** * test solve */@Test public void testSolve(){DecompositionSolver solver=new CholeskyDecomposition(MatrixUtils.createRealMatrix(testData)).getSolver();RealMatrix b=MatrixUtils.createRealMatrix(new double[][]{{78,-13,1},{414,-62,-1},{1312,-202,-37},{2989,-542,145},{5510,-1465,201}});RealMatrix xRef=MatrixUtils.createRealMatrix(new double[][]{{1,0,1},{0,1,1},{2,1,-4},{2,2,2},{5,-3,0}});Assert.assertEquals(0,solver.solve(b).subtract(xRef).getNorm(),1.0e-13);for (int i=0;i < b.getColumnDimension();++i){Assert.assertEquals(0,solver.solve(b.getColumnVector(i)).subtract(xRef.getColumnVector(i)).getNorm(),1.0e-13);}for (int i=0;i < b.getColumnDimension();++i){ArrayRealVectorTest.RealVectorTestImpl v=new ArrayRealVectorTest.RealVectorTestImpl(b.getColumn(i));Assert.assertEquals(0,solver.solve(v).subtract(xRef.getColumnVector(i)).getNorm(),1.0e-13);}}
/** * test determinant */@Test public void testDeterminant(){Assert.assertEquals(7290000.0,getDeterminant(MatrixUtils.createRealMatrix(testData)),1.0e-15);}
@Test public void testAccessors(){final MatrixDimensionMismatchException e=new MatrixDimensionMismatchException(1,2,3,4);Assert.assertEquals(1,e.getWrongRowDimension());Assert.assertEquals(2,e.getWrongColumnDimension());Assert.assertEquals(3,e.getExpectedRowDimension());Assert.assertEquals(4,e.getExpectedColumnDimension());}
@Test public void testInteraction(){FourthMoment m4=new FourthMoment();Mean m=new Mean(m4);Variance v=new Variance(m4);Skewness s=new Skewness(m4);Kurtosis k=new Kurtosis(m4);for (int i=0;i < testArray.length;i++){m4.increment(testArray[i]);}Assert.assertEquals(mean,m.getResult(),tolerance);Assert.assertEquals(var,v.getResult(),tolerance);Assert.assertEquals(skew,s.getResult(),tolerance);Assert.assertEquals(kurt,k.getResult(),tolerance);}
@Test public void testGetFittestChromosome(){Chromosome c1=new Chromosome(){public double fitness(){return 0;}};Chromosome c2=new Chromosome(){public double fitness(){return 10;}};Chromosome c3=new Chromosome(){public double fitness(){return 15;}};ArrayList<Chromosome> chromosomes=new ArrayList<Chromosome>();chromosomes.add(c1);chromosomes.add(c2);chromosomes.add(c3);ListPopulation population=new ListPopulation(chromosomes,10){public Population nextGeneration(){return null;}};Assert.assertEquals(c3,population.getFittestChromosome());}
@Test public void testNoReset(){double[]y={0.0,1.0,-2.0};DummyStepInterpolator interpolator=new DummyStepInterpolator(y,new double[y.length],true);interpolator.storeTime(0);interpolator.shift();interpolator.storeTime(1);double[]result=interpolator.getInterpolatedState();for (int i=0;i < result.length;++i){Assert.assertTrue(FastMath.abs(result[i]- y[i])< 1.0e-10);}}
@Test public void testFixedState(){double[]y={1.0,3.0,-4.0};DummyStepInterpolator interpolator=new DummyStepInterpolator(y,new double[y.length],true);interpolator.storeTime(0);interpolator.shift();interpolator.storeTime(1);interpolator.setInterpolatedTime(0.1);double[]result=interpolator.getInterpolatedState();for (int i=0;i < result.length;++i){Assert.assertTrue(FastMath.abs(result[i]- y[i])< 1.0e-10);}interpolator.setInterpolatedTime(0.5);result=interpolator.getInterpolatedState();for (int i=0;i < result.length;++i){Assert.assertTrue(FastMath.abs(result[i]- y[i])< 1.0e-10);}}
@Test public void testSerialization()throws IOException,ClassNotFoundException {double[]y={0.0,1.0,-2.0};DummyStepInterpolator interpolator=new DummyStepInterpolator(y,new double[y.length],true);interpolator.storeTime(0);interpolator.shift();interpolator.storeTime(1);ByteArrayOutputStream bos=new ByteArrayOutputStream();ObjectOutputStream oos=new ObjectOutputStream(bos);oos.writeObject(interpolator);Assert.assertTrue(bos.size()> 300);Assert.assertTrue(bos.size()< 500);ByteArrayInputStream bis=new ByteArrayInputStream(bos.toByteArray());ObjectInputStream ois=new ObjectInputStream(bis);DummyStepInterpolator dsi=(DummyStepInterpolator)ois.readObject();dsi.setInterpolatedTime(0.5);double[]result=dsi.getInterpolatedState();for (int i=0;i < result.length;++i){Assert.assertTrue(FastMath.abs(result[i]- y[i])< 1.0e-10);}}
@Test public void testImpossibleSerialization()throws IOException {double[]y={0.0,1.0,-2.0};AbstractStepInterpolator interpolator=new BadStepInterpolator(y,true);interpolator.storeTime(0);interpolator.shift();interpolator.storeTime(1);ByteArrayOutputStream bos=new ByteArrayOutputStream();ObjectOutputStream oos=new ObjectOutputStream(bos);try {oos.writeObject(interpolator);Assert.fail("an exception should have been thrown");}catch(MathIllegalStateException mise){Assert.assertEquals(0,mise.getMessage().length());}}
@Test public void testSpecialValues(){SumOfLogs sum=new SumOfLogs();Assert.assertEquals(0,sum.getResult(),0);sum.increment(1d);Assert.assertFalse(Double.isNaN(sum.getResult()));sum.increment(0d);Assert.assertEquals(Double.NEGATIVE_INFINITY,sum.getResult(),0);sum.increment(Double.POSITIVE_INFINITY);Assert.assertTrue(Double.isNaN(sum.getResult()));sum.clear();Assert.assertEquals(0,sum.getResult(),0);sum.increment(Double.POSITIVE_INFINITY);Assert.assertEquals(Double.POSITIVE_INFINITY,sum.getResult(),0);sum.increment(-2d);Assert.assertTrue(Double.isNaN(sum.getResult()));}
/** * Verifies that increment()and incrementAll work properly.*/@Test public void testIncrementation()throws Exception {StorelessUnivariateStatistic statistic=(StorelessUnivariateStatistic)getUnivariateStatistic();for (int i=0;i < testArray.length;i++){statistic.increment(testArray[i]);}Assert.assertEquals(expectedValue(),statistic.getResult(),getTolerance());Assert.assertEquals(testArray.length,statistic.getN());statistic.clear();statistic.incrementAll(testArray);Assert.assertEquals(expectedValue(),statistic.getResult(),getTolerance());Assert.assertEquals(testArray.length,statistic.getN());statistic.clear();checkClearValue(statistic);Assert.assertEquals(0,statistic.getN());}
@Test public void testSerialization()throws Exception {StorelessUnivariateStatistic statistic=(StorelessUnivariateStatistic)getUnivariateStatistic();TestUtils.checkSerializedEquality(statistic);statistic.clear();for (int i=0;i < testArray.length;i++){statistic.increment(testArray[i]);if (i % 5 == 0)statistic=(StorelessUnivariateStatistic)TestUtils.serializeAndRecover(statistic);}TestUtils.checkSerializedEquality(statistic);Assert.assertEquals(expectedValue(),statistic.getResult(),getTolerance());statistic.clear();checkClearValue(statistic);}
@Test public void testEqualsAndHashCode(){StorelessUnivariateStatistic statistic=(StorelessUnivariateStatistic)getUnivariateStatistic();StorelessUnivariateStatistic statistic2=null;Assert.assertTrue("non-null,compared to null",!statistic.equals(statistic2));Assert.assertTrue("reflexive,non-null",statistic.equals(statistic));int emptyHash=statistic.hashCode();statistic2=(StorelessUnivariateStatistic)getUnivariateStatistic();Assert.assertTrue("empty stats should be equal",statistic.equals(statistic2));Assert.assertEquals("empty stats should have the same hashcode",emptyHash,statistic2.hashCode());statistic.increment(1d);Assert.assertTrue("reflexive,non-empty",statistic.equals(statistic));Assert.assertTrue("non-empty,compared to empty",!statistic.equals(statistic2));Assert.assertTrue("non-empty,compared to empty",!statistic2.equals(statistic));Assert.assertTrue("non-empty stat should have different hashcode from empty stat",statistic.hashCode()!= emptyHash);statistic2.increment(1d);Assert.assertTrue("stats with same data should be equal",statistic.equals(statistic2));Assert.assertEquals("stats with same data should have the same hashcode",statistic.hashCode(),statistic2.hashCode());statistic.increment(Double.POSITIVE_INFINITY);Assert.assertTrue("stats with different n's should not be equal",!statistic2.equals(statistic));Assert.assertTrue("stats with different n's should have different hashcodes",statistic.hashCode()!= statistic2.hashCode());statistic2.increment(Double.POSITIVE_INFINITY);Assert.assertTrue("stats with same data should be equal",statistic.equals(statistic2));Assert.assertEquals("stats with same data should have the same hashcode",statistic.hashCode(),statistic2.hashCode());statistic.clear();statistic2.clear();Assert.assertTrue("cleared stats should be equal",statistic.equals(statistic2));Assert.assertEquals("cleared stats should have thashcode of empty stat",emptyHash,statistic2.hashCode());Assert.assertEquals("cleared stats should have thashcode of empty stat",emptyHash,statistic.hashCode());}
@Test public void testMomentSmallSamples(){UnivariateStatistic stat=getUnivariateStatistic();if (stat instanceof SecondMoment){SecondMoment moment=(SecondMoment)getUnivariateStatistic();Assert.assertTrue(Double.isNaN(moment.getResult()));moment.increment(1d);Assert.assertEquals(0d,moment.getResult(),0);}}
/** * Make sure that evaluate(double[])and inrementAll(double[]),getResult()give same results.*/@Test public void testConsistency(){StorelessUnivariateStatistic stat=(StorelessUnivariateStatistic)getUnivariateStatistic();stat.incrementAll(testArray);Assert.assertEquals(stat.getResult(),stat.evaluate(testArray),getTolerance());for (int i=0;i < smallSamples.length;i++){stat.clear();for (int j=0;j < smallSamples[i].length;j++){stat.increment(smallSamples[i][j]);}TestUtils.assertEquals(stat.getResult(),stat.evaluate(smallSamples[i]),getTolerance());}}
/** * Verifies that copied statistics remain equal to originals when incremented the same way.*/@Test public void testCopyConsistency(){StorelessUnivariateStatistic master=(StorelessUnivariateStatistic)getUnivariateStatistic();StorelessUnivariateStatistic replica=null;long index=FastMath.round((FastMath.random())* testArray.length);master.incrementAll(testArray,0,(int)index);replica=master.copy();Assert.assertTrue(replica.equals(master));Assert.assertTrue(master.equals(replica));master.incrementAll(testArray,(int)index,(int)(testArray.length - index));replica.incrementAll(testArray,(int)index,(int)(testArray.length - index));Assert.assertTrue(replica.equals(master));Assert.assertTrue(master.equals(replica));}
@Test public void testSerial(){StorelessUnivariateStatistic s=(StorelessUnivariateStatistic)getUnivariateStatistic();Assert.assertEquals(s,TestUtils.serializeAndRecover(s));}
@Test public void testEvaluation()throws Exception {Assert.assertEquals(expectedValue(),getUnivariateStatistic().evaluate(testArray),getTolerance());}
@Test public void testEvaluateArraySegment(){final UnivariateStatistic stat=getUnivariateStatistic();final double[]arrayZero=new double[5];System.arraycopy(testArray,0,arrayZero,0,5);Assert.assertEquals(stat.evaluate(arrayZero),stat.evaluate(testArray,0,5),0);final double[]arrayOne=new double[5];System.arraycopy(testArray,5,arrayOne,0,5);Assert.assertEquals(stat.evaluate(arrayOne),stat.evaluate(testArray,5,5),0);final double[]arrayEnd=new double[5];System.arraycopy(testArray,testArray.length - 5,arrayEnd,0,5);Assert.assertEquals(stat.evaluate(arrayEnd),stat.evaluate(testArray,testArray.length - 5,5),0);}
@Test public void testEvaluateArraySegmentWeighted(){UnivariateStatistic statistic=getUnivariateStatistic();if (!(statistic instanceof WeightedEvaluation)){return;}final WeightedEvaluation stat=(WeightedEvaluation)getUnivariateStatistic();final double[]arrayZero=new double[5];final double[]weightZero=new double[5];System.arraycopy(testArray,0,arrayZero,0,5);System.arraycopy(testWeightsArray,0,weightZero,0,5);Assert.assertEquals(stat.evaluate(arrayZero,weightZero),stat.evaluate(testArray,testWeightsArray,0,5),0);final double[]arrayOne=new double[5];final double[]weightOne=new double[5];System.arraycopy(testArray,5,arrayOne,0,5);System.arraycopy(testWeightsArray,5,weightOne,0,5);Assert.assertEquals(stat.evaluate(arrayOne,weightOne),stat.evaluate(testArray,testWeightsArray,5,5),0);final double[]arrayEnd=new double[5];final double[]weightEnd=new double[5];System.arraycopy(testArray,testArray.length - 5,arrayEnd,0,5);System.arraycopy(testWeightsArray,testArray.length - 5,weightEnd,0,5);Assert.assertEquals(stat.evaluate(arrayEnd,weightEnd),stat.evaluate(testArray,testWeightsArray,testArray.length - 5,5),0);}
@Test public void testCopy()throws Exception {UnivariateStatistic original=getUnivariateStatistic();UnivariateStatistic copy=original.copy();Assert.assertEquals(expectedValue(),copy.evaluate(testArray),getTolerance());}
/** * Tests consistency of weighted statistic computation. For statistics that support weighted evaluation,this test case compares the result of direct computation on an array with repeated values with a weighted computation on the corresponding (shorter)array with each value appearing only once but with a weight value equal to its multiplicity in the repeating array.*/@Test public void testWeightedConsistency()throws Exception {UnivariateStatistic statistic=getUnivariateStatistic();if (!(statistic instanceof WeightedEvaluation)){return;}final int len=10;final double mu=0;final double sigma=5;double[]values=new double[len];double[]weights=new double[len];RandomData randomData=new RandomDataImpl();int[]intWeights=new int[len];for (int i=0;i < len;i++){intWeights[i]=randomData.nextInt(1,5);weights[i]=intWeights[i];}List<Double> valuesList=new ArrayList<Double>();for (int i=0;i < len;i++){double value=randomData.nextGaussian(mu,sigma);values[i]=value;for (int j=0;j < intWeights[i];j++){valuesList.add(new Double(value));}}int sumWeights=valuesList.size();double[]repeatedValues=new double[sumWeights];for (int i=0;i < sumWeights;i++){repeatedValues[i]=valuesList.get(i);}WeightedEvaluation weightedStatistic=(WeightedEvaluation)statistic;TestUtils.assertRelativelyEquals(statistic.evaluate(repeatedValues),weightedStatistic.evaluate(values,weights,0,values.length),10E-14);Assert.assertEquals(weightedStatistic.evaluate(values,weights,0,values.length),weightedStatistic.evaluate(values,weights),Double.MIN_VALUE);}
@Test public void testArrayIsReference(){int[]array={-3,-2,-1,0,1};Assert.assertTrue(array == new EuclideanIntegerPoint(array).getPoint());}
@Test public void testDistance(){EuclideanIntegerPoint e1=new EuclideanIntegerPoint(new int[]{-3,-2,-1,0,1});EuclideanIntegerPoint e2=new EuclideanIntegerPoint(new int[]{1,0,-1,1,1});Assert.assertEquals(FastMath.sqrt(21.0),e1.distanceFrom(e2),1.0e-15);Assert.assertEquals(0.0,e1.distanceFrom(e1),1.0e-15);Assert.assertEquals(0.0,e2.distanceFrom(e2),1.0e-15);}
@Test public void testCentroid(){List<EuclideanIntegerPoint> list=new ArrayList<EuclideanIntegerPoint>();list.add(new EuclideanIntegerPoint(new int[]{1,3}));list.add(new EuclideanIntegerPoint(new int[]{2,2}));list.add(new EuclideanIntegerPoint(new int[]{3,3}));list.add(new EuclideanIntegerPoint(new int[]{2,4}));EuclideanIntegerPoint c=list.get(0).centroidOf(list);Assert.assertEquals(2,c.getPoint()[0]);Assert.assertEquals(3,c.getPoint()[1]);}
@Test public void testSerial(){EuclideanIntegerPoint p=new EuclideanIntegerPoint(new int[]{-3,-2,-1,0,1});Assert.assertEquals(p,TestUtils.serializeAndRecover(p));}
/** * Tests the standard aggregation behavior*/@Test public void testAggregation(){AggregateSummaryStatistics aggregate=new AggregateSummaryStatistics();SummaryStatistics setOneStats=aggregate.createContributingStatistics();SummaryStatistics setTwoStats=aggregate.createContributingStatistics();Assert.assertNotNull("The set one contributing stats are null",setOneStats);Assert.assertNotNull("The set two contributing stats are null",setTwoStats);Assert.assertNotSame("Contributing stats objects are the same",setOneStats,setTwoStats);setOneStats.addValue(2);setOneStats.addValue(3);setOneStats.addValue(5);setOneStats.addValue(7);setOneStats.addValue(11);Assert.assertEquals("Wrong number of set one values",5,setOneStats.getN());Assert.assertTrue("Wrong sum of set one values",Precision.equals(28.0,setOneStats.getSum(),1));setTwoStats.addValue(2);setTwoStats.addValue(4);setTwoStats.addValue(8);Assert.assertEquals("Wrong number of set two values",3,setTwoStats.getN());Assert.assertTrue("Wrong sum of set two values",Precision.equals(14.0,setTwoStats.getSum(),1));Assert.assertEquals("Wrong number of aggregate values",8,aggregate.getN());Assert.assertTrue("Wrong aggregate sum",Precision.equals(42.0,aggregate.getSum(),1));}
/** * Verify that aggregating over a partition gives the same results as direct computation. 1)Randomly generate a dataset of 10-100 values from [-100,100]2)Divide the dataset it into 2-5 partitions 3)Create an AggregateSummaryStatistic and ContributingStatistics for each partition 4)Compare results from the AggregateSummaryStatistic with values returned by a single SummaryStatistics instance that is provided the full dataset*/@Test public void testAggregationConsistency()throws Exception {double[]totalSample=generateSample();double[][]subSamples=generatePartition(totalSample);int nSamples=subSamples.length;AggregateSummaryStatistics aggregate=new AggregateSummaryStatistics();SummaryStatistics totalStats=new SummaryStatistics();SummaryStatistics componentStats[]=new SummaryStatistics[nSamples];for (int i=0;i < nSamples;i++){componentStats[i]=aggregate.createContributingStatistics();for (int j=0;j < subSamples[i].length;j++){componentStats[i].addValue(subSamples[i][j]);}}for (int i=0;i < totalSample.length;i++){totalStats.addValue(totalSample[i]);}Assert.assertEquals(totalStats.getSummary(),aggregate.getSummary());}
/** * Test aggregate function by randomly generating a dataset of 10-100 values from [-100,100],dividing it into 2-5 partitions,computing stats for each partition and comparing the result of aggregate(...)applied to the collection of per-partition SummaryStatistics with a single SummaryStatistics computed over the full sample.* @throws Exception*/@Test public void testAggregate()throws Exception {double[]totalSample=generateSample();double[][]subSamples=generatePartition(totalSample);int nSamples=subSamples.length;SummaryStatistics totalStats=new SummaryStatistics();for (int i=0;i < totalSample.length;i++){totalStats.addValue(totalSample[i]);}SummaryStatistics[]subSampleStats=new SummaryStatistics[nSamples];for (int i=0;i < nSamples;i++){subSampleStats[i]=new SummaryStatistics();}Collection<SummaryStatistics> aggregate=new ArrayList<SummaryStatistics>();for (int i=0;i < nSamples;i++){for (int j=0;j < subSamples[i].length;j++){subSampleStats[i].addValue(subSamples[i][j]);}aggregate.add(subSampleStats[i]);}StatisticalSummary aggregatedStats=AggregateSummaryStatistics.aggregate(aggregate);assertEquals(totalStats.getSummary(),aggregatedStats,10E-12);}
@Test public void testAggregateDegenerate()throws Exception {double[]totalSample={1,2,3,4,5};double[][]subSamples={{1},{2},{3},{4},{5}};SummaryStatistics totalStats=new SummaryStatistics();for (int i=0;i < totalSample.length;i++){totalStats.addValue(totalSample[i]);}SummaryStatistics[]subSampleStats=new SummaryStatistics[5];for (int i=0;i < 5;i++){subSampleStats[i]=new SummaryStatistics();}Collection<SummaryStatistics> aggregate=new ArrayList<SummaryStatistics>();for (int i=0;i < 5;i++){for (int j=0;j < subSamples[i].length;j++){subSampleStats[i].addValue(subSamples[i][j]);}aggregate.add(subSampleStats[i]);}StatisticalSummaryValues aggregatedStats=AggregateSummaryStatistics.aggregate(aggregate);assertEquals(totalStats.getSummary(),aggregatedStats,10E-12);}
@Test public void testAggregateSpecialValues()throws Exception {double[]totalSample={Double.POSITIVE_INFINITY,2,3,Double.NaN,5};double[][]subSamples={{Double.POSITIVE_INFINITY,2},{3},{Double.NaN},{5}};SummaryStatistics totalStats=new SummaryStatistics();for (int i=0;i < totalSample.length;i++){totalStats.addValue(totalSample[i]);}SummaryStatistics[]subSampleStats=new SummaryStatistics[5];for (int i=0;i < 4;i++){subSampleStats[i]=new SummaryStatistics();}Collection<SummaryStatistics> aggregate=new ArrayList<SummaryStatistics>();for (int i=0;i < 4;i++){for (int j=0;j < subSamples[i].length;j++){subSampleStats[i].addValue(subSamples[i][j]);}aggregate.add(subSampleStats[i]);}StatisticalSummaryValues aggregatedStats=AggregateSummaryStatistics.aggregate(aggregate);assertEquals(totalStats.getSummary(),aggregatedStats,10E-12);}
@Test public void testPolar2Complex(){TestUtils.assertEquals(Complex.ONE,ComplexUtils.polar2Complex(1,0),10e-12);TestUtils.assertEquals(Complex.ZERO,ComplexUtils.polar2Complex(0,1),10e-12);TestUtils.assertEquals(Complex.ZERO,ComplexUtils.polar2Complex(0,-1),10e-12);TestUtils.assertEquals(Complex.I,ComplexUtils.polar2Complex(1,pi / 2),10e-12);TestUtils.assertEquals(Complex.I.negate(),ComplexUtils.polar2Complex(1,-pi / 2),10e-12);double r=0;for (int i=0;i < 5;i++){r+=i;double theta=0;for (int j=0;j < 20;j++){theta+=pi / 6;TestUtils.assertEquals(altPolar(r,theta),ComplexUtils.polar2Complex(r,theta),10e-12);}theta=-2 * pi;for (int j=0;j < 20;j++){theta-=pi / 6;TestUtils.assertEquals(altPolar(r,theta),ComplexUtils.polar2Complex(r,theta),10e-12);}}}
@Test(expected=IllegalArgumentException.class)public void testPolar2ComplexIllegalModulus(){ComplexUtils.polar2Complex(-1,0);}
@Test public void testPolar2ComplexNaN(){TestUtils.assertSame(Complex.NaN,ComplexUtils.polar2Complex(nan,1));TestUtils.assertSame(Complex.NaN,ComplexUtils.polar2Complex(1,nan));TestUtils.assertSame(Complex.NaN,ComplexUtils.polar2Complex(nan,nan));}
@Test public void testPolar2ComplexInf(){TestUtils.assertSame(Complex.NaN,ComplexUtils.polar2Complex(1,inf));TestUtils.assertSame(Complex.NaN,ComplexUtils.polar2Complex(1,negInf));TestUtils.assertSame(Complex.NaN,ComplexUtils.polar2Complex(inf,inf));TestUtils.assertSame(Complex.NaN,ComplexUtils.polar2Complex(inf,negInf));TestUtils.assertSame(infInf,ComplexUtils.polar2Complex(inf,pi / 4));TestUtils.assertSame(infNaN,ComplexUtils.polar2Complex(inf,0));TestUtils.assertSame(infNegInf,ComplexUtils.polar2Complex(inf,-pi / 4));TestUtils.assertSame(negInfInf,ComplexUtils.polar2Complex(inf,3 * pi / 4));TestUtils.assertSame(negInfNegInf,ComplexUtils.polar2Complex(inf,5 * pi / 4));}
@Test public void testContains(){Plane p=new Plane(new Vector3D(0,0,1),new Vector3D(0,0,1));Assert.assertTrue(p.contains(new Vector3D(0,0,1)));Assert.assertTrue(p.contains(new Vector3D(17,-32,1)));Assert.assertTrue(!p.contains(new Vector3D(17,-32,1.001)));}
@Test public void testOffset(){Vector3D p1=new Vector3D(1,1,1);Plane p=new Plane(p1,new Vector3D(0.2,0,0));Assert.assertEquals(-5.0,p.getOffset(new Vector3D(-4,0,0)),1.0e-10);Assert.assertEquals(+5.0,p.getOffset(new Vector3D(6,10,-12)),1.0e-10);Assert.assertEquals(0.3,p.getOffset(new Vector3D(1.0,p1,0.3,p.getNormal())),1.0e-10);Assert.assertEquals(-0.3,p.getOffset(new Vector3D(1.0,p1,-0.3,p.getNormal())),1.0e-10);}
@Test public void testPoint(){Plane p=new Plane(new Vector3D(2,-3,1),new Vector3D(1,4,9));Assert.assertTrue(p.contains(p.getOrigin()));}
@Test public void testThreePoints(){Vector3D p1=new Vector3D(1.2,3.4,-5.8);Vector3D p2=new Vector3D(3.4,-5.8,1.2);Vector3D p3=new Vector3D(-2.0,4.3,0.7);Plane p=new Plane(p1,p2,p3);Assert.assertTrue(p.contains(p1));Assert.assertTrue(p.contains(p2));Assert.assertTrue(p.contains(p3));}
@Test public void testRotate(){Vector3D p1=new Vector3D(1.2,3.4,-5.8);Vector3D p2=new Vector3D(3.4,-5.8,1.2);Vector3D p3=new Vector3D(-2.0,4.3,0.7);Plane p=new Plane(p1,p2,p3);Vector3D oldNormal=p.getNormal();p=p.rotate(p2,new Rotation(p2.subtract(p1),1.7));Assert.assertTrue(p.contains(p1));Assert.assertTrue(p.contains(p2));Assert.assertTrue(!p.contains(p3));p=p.rotate(p2,new Rotation(oldNormal,0.1));Assert.assertTrue(!p.contains(p1));Assert.assertTrue(p.contains(p2));Assert.assertTrue(!p.contains(p3));p=p.rotate(p1,new Rotation(oldNormal,0.1));Assert.assertTrue(!p.contains(p1));Assert.assertTrue(!p.contains(p2));Assert.assertTrue(!p.contains(p3));}
@Test public void testTranslate(){Vector3D p1=new Vector3D(1.2,3.4,-5.8);Vector3D p2=new Vector3D(3.4,-5.8,1.2);Vector3D p3=new Vector3D(-2.0,4.3,0.7);Plane p=new Plane(p1,p2,p3);p=p.translate(new Vector3D(2.0,p.getU(),-1.5,p.getV()));Assert.assertTrue(p.contains(p1));Assert.assertTrue(p.contains(p2));Assert.assertTrue(p.contains(p3));p=p.translate(new Vector3D(-1.2,p.getNormal()));Assert.assertTrue(!p.contains(p1));Assert.assertTrue(!p.contains(p2));Assert.assertTrue(!p.contains(p3));p=p.translate(new Vector3D(+1.2,p.getNormal()));Assert.assertTrue(p.contains(p1));Assert.assertTrue(p.contains(p2));Assert.assertTrue(p.contains(p3));}
@Test public void testIntersection(){Plane p=new Plane(new Vector3D(1,2,3),new Vector3D(-4,1,-5));Line l=new Line(new Vector3D(0.2,-3.5,0.7),new Vector3D(1.2,-2.5,-0.3));Vector3D point=p.intersection(l);Assert.assertTrue(p.contains(point));Assert.assertTrue(l.contains(point));Assert.assertNull(p.intersection(new Line(new Vector3D(10,10,10),new Vector3D(10,10,10).add(p.getNormal().orthogonal()))));}
@Test public void testIntersection2(){Vector3D p1=new Vector3D(1.2,3.4,-5.8);Vector3D p2=new Vector3D(3.4,-5.8,1.2);Plane pA=new Plane(p1,p2,new Vector3D(-2.0,4.3,0.7));Plane pB=new Plane(p1,new Vector3D(11.4,-3.8,5.1),p2);Line l=pA.intersection(pB);Assert.assertTrue(l.contains(p1));Assert.assertTrue(l.contains(p2));Assert.assertNull(pA.intersection(pA));}
@Test public void testIntersection3(){Vector3D reference=new Vector3D(1.2,3.4,-5.8);Plane p1=new Plane(reference,new Vector3D(1,3,3));Plane p2=new Plane(reference,new Vector3D(-2,4,0));Plane p3=new Plane(reference,new Vector3D(7,0,-4));Vector3D p=Plane.intersection(p1,p2,p3);Assert.assertEquals(reference.getX(),p.getX(),1.0e-10);Assert.assertEquals(reference.getY(),p.getY(),1.0e-10);Assert.assertEquals(reference.getZ(),p.getZ(),1.0e-10);}
@Test public void testSimilar(){Vector3D p1=new Vector3D(1.2,3.4,-5.8);Vector3D p2=new Vector3D(3.4,-5.8,1.2);Vector3D p3=new Vector3D(-2.0,4.3,0.7);Plane pA=new Plane(p1,p2,p3);Plane pB=new Plane(p1,new Vector3D(11.4,-3.8,5.1),p2);Assert.assertTrue(!pA.isSimilarTo(pB));Assert.assertTrue(pA.isSimilarTo(pA));Assert.assertTrue(pA.isSimilarTo(new Plane(p1,p3,p2)));Vector3D shift=new Vector3D(0.3,pA.getNormal());Assert.assertTrue(!pA.isSimilarTo(new Plane(p1.add(shift),p3.add(shift),p2.add(shift))));}
@Test public void testAccessors(){NonMonotonicSequenceException e=new NonMonotonicSequenceException(0,-1,1,MathArrays.OrderDirection.DECREASING,false);Assert.assertEquals(0,e.getArgument());Assert.assertEquals(-1,e.getPrevious());Assert.assertEquals(1,e.getIndex());Assert.assertTrue(e.getDirection()== MathArrays.OrderDirection.DECREASING);Assert.assertFalse(e.getStrict());e=new NonMonotonicSequenceException(-1,0,1);Assert.assertEquals(-1,e.getArgument());Assert.assertEquals(0,e.getPrevious());Assert.assertEquals(1,e.getIndex());Assert.assertTrue(e.getDirection()== MathArrays.OrderDirection.INCREASING);Assert.assertTrue(e.getStrict());}
@Test public void testTrivial(){LinearProblem problem=new LinearProblem(new double[][]{{2}},new double[]{3});LevenbergMarquardtOptimizer optimizer=new LevenbergMarquardtOptimizer();VectorialPointValuePair optimum=optimizer.optimize(100,problem,problem.target,new double[]{1},new double[]{0});Assert.assertEquals(0,optimizer.getRMS(),1.0e-10);try {optimizer.guessParametersErrors();Assert.fail("an exception should have been thrown");}catch(NumberIsTooSmallException ee){}Assert.assertEquals(1.5,optimum.getPoint()[0],1.0e-10);Assert.assertEquals(3.0,optimum.getValue()[0],1.0e-10);}
@Test public void testQRColumnsPermutation(){LinearProblem problem=new LinearProblem(new double[][]{{1.0,-1.0},{0.0,2.0},{1.0,-2.0}},new double[]{4.0,6.0,1.0});LevenbergMarquardtOptimizer optimizer=new LevenbergMarquardtOptimizer();VectorialPointValuePair optimum=optimizer.optimize(100,problem,problem.target,new double[]{1,1,1},new double[]{0,0});Assert.assertEquals(0,optimizer.getRMS(),1.0e-10);Assert.assertEquals(7.0,optimum.getPoint()[0],1.0e-10);Assert.assertEquals(3.0,optimum.getPoint()[1],1.0e-10);Assert.assertEquals(4.0,optimum.getValue()[0],1.0e-10);Assert.assertEquals(6.0,optimum.getValue()[1],1.0e-10);Assert.assertEquals(1.0,optimum.getValue()[2],1.0e-10);}
@Test public void testNoDependency(){LinearProblem problem=new LinearProblem(new double[][]{{2,0,0,0,0,0},{0,2,0,0,0,0},{0,0,2,0,0,0},{0,0,0,2,0,0},{0,0,0,0,2,0},{0,0,0,0,0,2}},new double[]{0.0,1.1,2.2,3.3,4.4,5.5});LevenbergMarquardtOptimizer optimizer=new LevenbergMarquardtOptimizer();VectorialPointValuePair optimum=optimizer.optimize(100,problem,problem.target,new double[]{1,1,1,1,1,1},new double[]{0,0,0,0,0,0});Assert.assertEquals(0,optimizer.getRMS(),1.0e-10);for (int i=0;i < problem.target.length;++i){Assert.assertEquals(0.55 * i,optimum.getPoint()[i],1.0e-10);}}
@Test public void testOneSet(){LinearProblem problem=new LinearProblem(new double[][]{{1,0,0},{-1,1,0},{0,-1,1}},new double[]{1,1,1});LevenbergMarquardtOptimizer optimizer=new LevenbergMarquardtOptimizer();VectorialPointValuePair optimum=optimizer.optimize(100,problem,problem.target,new double[]{1,1,1},new double[]{0,0,0});Assert.assertEquals(0,optimizer.getRMS(),1.0e-10);Assert.assertEquals(1.0,optimum.getPoint()[0],1.0e-10);Assert.assertEquals(2.0,optimum.getPoint()[1],1.0e-10);Assert.assertEquals(3.0,optimum.getPoint()[2],1.0e-10);}
@Test public void testTwoSets(){double epsilon=1.0e-7;LinearProblem problem=new LinearProblem(new double[][]{{2,1,0,4,0,0},{-4,-2,3,-7,0,0},{4,1,-2,8,0,0},{0,-3,-12,-1,0,0},{0,0,0,0,epsilon,1},{0,0,0,0,1,1}},new double[]{2,-9,2,2,1 + epsilon * epsilon,2});LevenbergMarquardtOptimizer optimizer=new LevenbergMarquardtOptimizer();VectorialPointValuePair optimum=optimizer.optimize(100,problem,problem.target,new double[]{1,1,1,1,1,1},new double[]{0,0,0,0,0,0});Assert.assertEquals(0,optimizer.getRMS(),1.0e-10);Assert.assertEquals(3.0,optimum.getPoint()[0],1.0e-10);Assert.assertEquals(4.0,optimum.getPoint()[1],1.0e-10);Assert.assertEquals(-1.0,optimum.getPoint()[2],1.0e-10);Assert.assertEquals(-2.0,optimum.getPoint()[3],1.0e-10);Assert.assertEquals(1.0 + epsilon,optimum.getPoint()[4],1.0e-10);Assert.assertEquals(1.0 - epsilon,optimum.getPoint()[5],1.0e-10);}
@Test(expected=SingularMatrixException.class)public void testNonInvertible(){LinearProblem problem=new LinearProblem(new double[][]{{1,2,-3},{2,1,3},{-3,0,-9}},new double[]{1,1,1});LevenbergMarquardtOptimizer optimizer=new LevenbergMarquardtOptimizer();optimizer.optimize(100,problem,problem.target,new double[]{1,1,1},new double[]{0,0,0});Assert.assertTrue(FastMath.sqrt(problem.target.length)* optimizer.getRMS()> 0.6);optimizer.getCovariances();}
@Test public void testIllConditioned(){LinearProblem problem1=new LinearProblem(new double[][]{{10.0,7.0,8.0,7.0},{7.0,5.0,6.0,5.0},{8.0,6.0,10.0,9.0},{7.0,5.0,9.0,10.0}},new double[]{32,23,33,31});LevenbergMarquardtOptimizer optimizer=new LevenbergMarquardtOptimizer();VectorialPointValuePair optimum1=optimizer.optimize(100,problem1,problem1.target,new double[]{1,1,1,1},new double[]{0,1,2,3});Assert.assertEquals(0,optimizer.getRMS(),1.0e-10);Assert.assertEquals(1.0,optimum1.getPoint()[0],1.0e-10);Assert.assertEquals(1.0,optimum1.getPoint()[1],1.0e-10);Assert.assertEquals(1.0,optimum1.getPoint()[2],1.0e-10);Assert.assertEquals(1.0,optimum1.getPoint()[3],1.0e-10);LinearProblem problem2=new LinearProblem(new double[][]{{10.00,7.00,8.10,7.20},{7.08,5.04,6.00,5.00},{8.00,5.98,9.89,9.00},{6.99,4.99,9.00,9.98}},new double[]{32,23,33,31});VectorialPointValuePair optimum2=optimizer.optimize(100,problem2,problem2.target,new double[]{1,1,1,1},new double[]{0,1,2,3});Assert.assertEquals(0,optimizer.getRMS(),1.0e-10);Assert.assertEquals(-81.0,optimum2.getPoint()[0],1.0e-8);Assert.assertEquals(137.0,optimum2.getPoint()[1],1.0e-8);Assert.assertEquals(-34.0,optimum2.getPoint()[2],1.0e-8);Assert.assertEquals(22.0,optimum2.getPoint()[3],1.0e-8);}
@Test public void testMoreEstimatedParametersSimple(){LinearProblem problem=new LinearProblem(new double[][]{{3.0,2.0,0.0,0.0},{0.0,1.0,-1.0,1.0},{2.0,0.0,1.0,0.0}},new double[]{7.0,3.0,5.0});LevenbergMarquardtOptimizer optimizer=new LevenbergMarquardtOptimizer();optimizer.optimize(100,problem,problem.target,new double[]{1,1,1},new double[]{7,6,5,4});Assert.assertEquals(0,optimizer.getRMS(),1.0e-10);}
@Test public void testMoreEstimatedParametersUnsorted(){LinearProblem problem=new LinearProblem(new double[][]{{1.0,1.0,0.0,0.0,0.0,0.0},{0.0,0.0,1.0,1.0,1.0,0.0},{0.0,0.0,0.0,0.0,1.0,-1.0},{0.0,0.0,-1.0,1.0,0.0,1.0},{0.0,0.0,0.0,-1.0,1.0,0.0}},new double[]{3.0,12.0,-1.0,7.0,1.0});LevenbergMarquardtOptimizer optimizer=new LevenbergMarquardtOptimizer();VectorialPointValuePair optimum=optimizer.optimize(100,problem,problem.target,new double[]{1,1,1,1,1},new double[]{2,2,2,2,2,2});Assert.assertEquals(0,optimizer.getRMS(),1.0e-10);Assert.assertEquals(3.0,optimum.getPointRef()[2],1.0e-10);Assert.assertEquals(4.0,optimum.getPointRef()[3],1.0e-10);Assert.assertEquals(5.0,optimum.getPointRef()[4],1.0e-10);Assert.assertEquals(6.0,optimum.getPointRef()[5],1.0e-10);}
@Test public void testRedundantEquations(){LinearProblem problem=new LinearProblem(new double[][]{{1.0,1.0},{1.0,-1.0},{1.0,3.0}},new double[]{3.0,1.0,5.0});LevenbergMarquardtOptimizer optimizer=new LevenbergMarquardtOptimizer();VectorialPointValuePair optimum=optimizer.optimize(100,problem,problem.target,new double[]{1,1,1},new double[]{1,1});Assert.assertEquals(0,optimizer.getRMS(),1.0e-10);Assert.assertEquals(2.0,optimum.getPointRef()[0],1.0e-10);Assert.assertEquals(1.0,optimum.getPointRef()[1],1.0e-10);}
@Test public void testInconsistentEquations(){LinearProblem problem=new LinearProblem(new double[][]{{1.0,1.0},{1.0,-1.0},{1.0,3.0}},new double[]{3.0,1.0,4.0});LevenbergMarquardtOptimizer optimizer=new LevenbergMarquardtOptimizer();optimizer.optimize(100,problem,problem.target,new double[]{1,1,1},new double[]{1,1});Assert.assertTrue(optimizer.getRMS()> 0.1);}
@Test public void testInconsistentSizes(){LinearProblem problem=new LinearProblem(new double[][]{{1,0},{0,1}},new double[]{-1,1});LevenbergMarquardtOptimizer optimizer=new LevenbergMarquardtOptimizer();VectorialPointValuePair optimum=optimizer.optimize(100,problem,problem.target,new double[]{1,1},new double[]{0,0});Assert.assertEquals(0,optimizer.getRMS(),1.0e-10);Assert.assertEquals(-1,optimum.getPoint()[0],1.0e-10);Assert.assertEquals(+1,optimum.getPoint()[1],1.0e-10);try {optimizer.optimize(100,problem,problem.target,new double[]{1},new double[]{0,0});Assert.fail("an exception should have been thrown");}catch(DimensionMismatchException oe){}try {optimizer.optimize(100,problem,new double[]{1},new double[]{1},new double[]{0,0});Assert.fail("an exception should have been thrown");}catch(DimensionMismatchException oe){}}
@Test public void testControlParameters(){CircleVectorial circle=new CircleVectorial();circle.addPoint(30.0,68.0);circle.addPoint(50.0,-6.0);circle.addPoint(110.0,-20.0);circle.addPoint(35.0,15.0);circle.addPoint(45.0,97.0);checkEstimate(circle,0.1,10,1.0e-14,1.0e-16,1.0e-10,false);checkEstimate(circle,0.1,10,1.0e-15,1.0e-17,1.0e-10,true);checkEstimate(circle,0.1,5,1.0e-15,1.0e-16,1.0e-10,true);circle.addPoint(300,-300);checkEstimate(circle,0.1,20,1.0e-18,1.0e-16,1.0e-10,true);}
@Test public void testCircleFitting(){CircleVectorial circle=new CircleVectorial();circle.addPoint(30.0,68.0);circle.addPoint(50.0,-6.0);circle.addPoint(110.0,-20.0);circle.addPoint(35.0,15.0);circle.addPoint(45.0,97.0);LevenbergMarquardtOptimizer optimizer=new LevenbergMarquardtOptimizer();VectorialPointValuePair optimum=optimizer.optimize(100,circle,new double[]{0,0,0,0,0},new double[]{1,1,1,1,1},new double[]{98.680,47.345});Assert.assertTrue(optimizer.getEvaluations()< 10);Assert.assertTrue(optimizer.getJacobianEvaluations()< 10);double rms=optimizer.getRMS();Assert.assertEquals(1.768262623567235,FastMath.sqrt(circle.getN())* rms,1.0e-10);Point2D.Double center=new Point2D.Double(optimum.getPointRef()[0],optimum.getPointRef()[1]);Assert.assertEquals(69.96016176931406,circle.getRadius(center),1.0e-10);Assert.assertEquals(96.07590211815305,center.x,1.0e-10);Assert.assertEquals(48.13516790438953,center.y,1.0e-10);double[][]cov=optimizer.getCovariances();Assert.assertEquals(1.839,cov[0][0],0.001);Assert.assertEquals(0.731,cov[0][1],0.001);Assert.assertEquals(cov[0][1],cov[1][0],1.0e-14);Assert.assertEquals(0.786,cov[1][1],0.001);double[]errors=optimizer.guessParametersErrors();Assert.assertEquals(1.384,errors[0],0.001);Assert.assertEquals(0.905,errors[1],0.001);double r=circle.getRadius(center);for (double d=0;d < 2 * FastMath.PI;d+=0.01){circle.addPoint(center.x + r * FastMath.cos(d),center.y + r * FastMath.sin(d));}double[]target=new double[circle.getN()];Arrays.fill(target,0.0);double[]weights=new double[circle.getN()];Arrays.fill(weights,2.0);optimizer.optimize(100,circle,target,weights,new double[]{98.680,47.345});cov=optimizer.getCovariances();Assert.assertEquals(0.0016,cov[0][0],0.001);Assert.assertEquals(3.2e-7,cov[0][1],1.0e-9);Assert.assertEquals(cov[0][1],cov[1][0],1.0e-14);Assert.assertEquals(0.0016,cov[1][1],0.001);errors=optimizer.guessParametersErrors();Assert.assertEquals(0.004,errors[0],0.001);Assert.assertEquals(0.004,errors[1],0.001);}
@Test public void testCircleFittingBadInit(){CircleVectorial circle=new CircleVectorial();double[][]points=new double[][]{{-0.312967,0.072366},{-0.339248,0.132965},{-0.379780,0.202724},{-0.390426,0.260487},{-0.361212,0.328325},{-0.346039,0.392619},{-0.280579,0.444306},{-0.216035,0.470009},{-0.149127,0.493832},{-0.075133,0.483271},{-0.007759,0.452680},{0.060071,0.410235},{0.103037,0.341076},{0.118438,0.273884},{0.131293,0.192201},{0.115869,0.129797},{0.072223,0.058396},{0.022884,0.000718},{-0.053355,-0.020405},{-0.123584,-0.032451},{-0.216248,-0.032862},{-0.278592,-0.005008},{-0.337655,0.056658},{-0.385899,0.112526},{-0.405517,0.186957},{-0.415374,0.262071},{-0.387482,0.343398},{-0.347322,0.397943},{-0.287623,0.458425},{-0.223502,0.475513},{-0.135352,0.478186},{-0.061221,0.483371},{0.003711,0.422737},{0.065054,0.375830},{0.108108,0.297099},{0.123882,0.222850},{0.117729,0.134382},{0.085195,0.056820},{0.029800,-0.019138},{-0.027520,-0.072374},{-0.102268,-0.091555},{-0.200299,-0.106578},{-0.292731,-0.091473},{-0.356288,-0.051108},{-0.420561,0.014926},{-0.471036,0.074716},{-0.488638,0.182508},{-0.485990,0.254068},{-0.463943,0.338438},{-0.406453,0.404704},{-0.334287,0.466119},{-0.254244,0.503188},{-0.161548,0.495769},{-0.075733,0.495560},{0.001375,0.434937},{0.082787,0.385806},{0.115490,0.323807},{0.141089,0.223450},{0.138693,0.131703},{0.126415,0.049174},{0.066518,-0.010217},{-0.005184,-0.070647},{-0.080985,-0.103635},{-0.177377,-0.116887},{-0.260628,-0.100258},{-0.335756,-0.056251},{-0.405195,-0.000895},{-0.444937,0.085456},{-0.484357,0.175597},{-0.472453,0.248681},{-0.438580,0.347463},{-0.402304,0.422428},{-0.326777,0.479438},{-0.247797,0.505581},{-0.152676,0.519380},{-0.071754,0.516264},{0.015942,0.472802},{0.076608,0.419077},{0.127673,0.330264},{0.159951,0.262150},{0.153530,0.172681},{0.140653,0.089229},{0.078666,0.024981},{0.023807,-0.037022},{-0.048837,-0.077056},{-0.127729,-0.075338},{-0.221271,-0.067526}};double[]target=new double[points.length];Arrays.fill(target,0.0);double[]weights=new double[points.length];Arrays.fill(weights,2.0);for (int i=0;i < points.length;++i){circle.addPoint(points[i][0],points[i][1]);}LevenbergMarquardtOptimizer optimizer=new LevenbergMarquardtOptimizer(new SimpleVectorialValueChecker(1.0e-8,1.0e-8));VectorialPointValuePair optimum=optimizer.optimize(100,circle,target,weights,new double[]{-12,-12});Point2D.Double center=new Point2D.Double(optimum.getPointRef()[0],optimum.getPointRef()[1]);Assert.assertTrue(optimizer.getEvaluations()< 25);Assert.assertTrue(optimizer.getJacobianEvaluations()< 20);Assert.assertEquals(0.043,optimizer.getRMS(),1.0e-3);Assert.assertEquals(0.292235,circle.getRadius(center),1.0e-6);Assert.assertEquals(-0.151738,center.x,1.0e-6);Assert.assertEquals(0.2075001,center.y,1.0e-6);}
@Test public void testMath199(){try {QuadraticProblem problem=new QuadraticProblem();problem.addPoint(0,-3.182591015485607);problem.addPoint(1,-2.5581184967730577);problem.addPoint(2,-2.1488478161387325);problem.addPoint(3,-1.9122489313410047);problem.addPoint(4,1.7785661310051026);LevenbergMarquardtOptimizer optimizer=new LevenbergMarquardtOptimizer(100,1e-10,1e-10,1e-10,0);optimizer.optimize(100,problem,new double[]{0,0,0,0,0},new double[]{0.0,4.4e-323,1.0,4.4e-323,0.0},new double[]{0,0,0});Assert.fail("an exception should have been thrown");}catch(ConvergenceException ee){}}
/** * Test of transformer for the a 8-point FHT (means n=8)*/@Test public void test8Points(){checkAllTransforms(new int[]{1,4,-2,3,0,1,4,-1},new int[]{10,-4,2,-4,2,-12,6,8});}
/** * Test of transformer for the a 4-points FHT (means n=4)*/@Test public void test4Points(){checkAllTransforms(new int[]{1,2,3,4},new int[]{10,-2,-4,0});}
/** * Test the inverse transform of an integer vector is not always an integer vector*/@Test public void testNoIntInverse(){FastHadamardTransformer transformer=new FastHadamardTransformer();double[]x=transformer.inversetransform(new double[]{0,1,0,1});Assert.assertEquals(0.5,x[0],0);Assert.assertEquals(-0.5,x[1],0);Assert.assertEquals(0.0,x[2],0);Assert.assertEquals(0.0,x[3],0);}
/** * Test of transformer for wrong number of points*/@Test public void test3Points(){try {new FastHadamardTransformer().transform(new double[3]);Assert.fail("an exception should have been thrown");}catch(IllegalArgumentException iae){}}
@Test public void testContains(){Vector3D p1=new Vector3D(0,0,1);Line l=new Line(p1,new Vector3D(0,0,2));Assert.assertTrue(l.contains(p1));Assert.assertTrue(l.contains(new Vector3D(1.0,p1,0.3,l.getDirection())));Vector3D u=l.getDirection().orthogonal();Vector3D v=Vector3D.crossProduct(l.getDirection(),u);for (double alpha=0;alpha < 2 * FastMath.PI;alpha+=0.3){Assert.assertTrue(!l.contains(p1.add(new Vector3D(FastMath.cos(alpha),u,FastMath.sin(alpha),v))));}}
@Test public void testSimilar(){Vector3D p1=new Vector3D(1.2,3.4,-5.8);Vector3D p2=new Vector3D(3.4,-5.8,1.2);Line lA=new Line(p1,p2);Line lB=new Line(p2,p1);Assert.assertTrue(lA.isSimilarTo(lB));Assert.assertTrue(!lA.isSimilarTo(new Line(p1,p1.add(lA.getDirection().orthogonal()))));}
@Test public void testPointDistance(){Line l=new Line(new Vector3D(0,1,1),new Vector3D(0,2,2));Assert.assertEquals(FastMath.sqrt(3.0 / 2.0),l.distance(new Vector3D(1,0,1)),1.0e-10);Assert.assertEquals(0,l.distance(new Vector3D(0,-4,-4)),1.0e-10);}
@Test public void testLineDistance(){Line l=new Line(new Vector3D(0,1,1),new Vector3D(0,2,2));Assert.assertEquals(1.0,l.distance(new Line(new Vector3D(1,0,1),new Vector3D(1,0,2))),1.0e-10);Assert.assertEquals(0.5,l.distance(new Line(new Vector3D(-0.5,0,0),new Vector3D(-0.5,-1,-1))),1.0e-10);Assert.assertEquals(0.0,l.distance(l),1.0e-10);Assert.assertEquals(0.0,l.distance(new Line(new Vector3D(0,-4,-4),new Vector3D(0,-5,-5))),1.0e-10);Assert.assertEquals(0.0,l.distance(new Line(new Vector3D(0,-4,-4),new Vector3D(0,-3,-4))),1.0e-10);Assert.assertEquals(0.0,l.distance(new Line(new Vector3D(0,-4,-4),new Vector3D(1,-4,-4))),1.0e-10);Assert.assertEquals(FastMath.sqrt(8),l.distance(new Line(new Vector3D(0,-4,0),new Vector3D(1,-4,0))),1.0e-10);}
@Test public void testClosest(){Line l=new Line(new Vector3D(0,1,1),new Vector3D(0,2,2));Assert.assertEquals(0.0,l.closestPoint(new Line(new Vector3D(1,0,1),new Vector3D(1,0,2))).distance(new Vector3D(0,0,0)),1.0e-10);Assert.assertEquals(0.5,l.closestPoint(new Line(new Vector3D(-0.5,0,0),new Vector3D(-0.5,-1,-1))).distance(new Vector3D(-0.5,0,0)),1.0e-10);Assert.assertEquals(0.0,l.closestPoint(l).distance(new Vector3D(0,0,0)),1.0e-10);Assert.assertEquals(0.0,l.closestPoint(new Line(new Vector3D(0,-4,-4),new Vector3D(0,-5,-5))).distance(new Vector3D(0,0,0)),1.0e-10);Assert.assertEquals(0.0,l.closestPoint(new Line(new Vector3D(0,-4,-4),new Vector3D(0,-3,-4))).distance(new Vector3D(0,-4,-4)),1.0e-10);Assert.assertEquals(0.0,l.closestPoint(new Line(new Vector3D(0,-4,-4),new Vector3D(1,-4,-4))).distance(new Vector3D(0,-4,-4)),1.0e-10);Assert.assertEquals(0.0,l.closestPoint(new Line(new Vector3D(0,-4,0),new Vector3D(1,-4,0))).distance(new Vector3D(0,-2,-2)),1.0e-10);}
@Test public void testIntersection(){Line l=new Line(new Vector3D(0,1,1),new Vector3D(0,2,2));Assert.assertNull(l.intersection(new Line(new Vector3D(1,0,1),new Vector3D(1,0,2))));Assert.assertNull(l.intersection(new Line(new Vector3D(-0.5,0,0),new Vector3D(-0.5,-1,-1))));Assert.assertEquals(0.0,l.intersection(l).distance(new Vector3D(0,0,0)),1.0e-10);Assert.assertEquals(0.0,l.intersection(new Line(new Vector3D(0,-4,-4),new Vector3D(0,-5,-5))).distance(new Vector3D(0,0,0)),1.0e-10);Assert.assertEquals(0.0,l.intersection(new Line(new Vector3D(0,-4,-4),new Vector3D(0,-3,-4))).distance(new Vector3D(0,-4,-4)),1.0e-10);Assert.assertEquals(0.0,l.intersection(new Line(new Vector3D(0,-4,-4),new Vector3D(1,-4,-4))).distance(new Vector3D(0,-4,-4)),1.0e-10);Assert.assertNull(l.intersection(new Line(new Vector3D(0,-4,0),new Vector3D(1,-4,0))));}
@Test public void testCompose(){UnivariateFunction id=new Identity();Assert.assertEquals(3,FunctionUtils.compose(id,id,id).value(3),EPS);UnivariateFunction c=new Constant(4);Assert.assertEquals(4,FunctionUtils.compose(id,c).value(3),EPS);Assert.assertEquals(4,FunctionUtils.compose(c,id).value(3),EPS);UnivariateFunction m=new Minus();Assert.assertEquals(-3,FunctionUtils.compose(m).value(3),EPS);Assert.assertEquals(3,FunctionUtils.compose(m,m).value(3),EPS);UnivariateFunction inv=new Inverse();Assert.assertEquals(-0.25,FunctionUtils.compose(inv,m,c,id).value(3),EPS);UnivariateFunction pow=new Power(2);Assert.assertEquals(81,FunctionUtils.compose(pow,pow).value(3),EPS);}
@Test public void testComposeDifferentiable(){DifferentiableUnivariateFunction id=new Identity();Assert.assertEquals(1,FunctionUtils.compose(id,id,id).derivative().value(3),EPS);DifferentiableUnivariateFunction c=new Constant(4);Assert.assertEquals(0,FunctionUtils.compose(id,c).derivative().value(3),EPS);Assert.assertEquals(0,FunctionUtils.compose(c,id).derivative().value(3),EPS);DifferentiableUnivariateFunction m=new Minus();Assert.assertEquals(-1,FunctionUtils.compose(m).derivative().value(3),EPS);Assert.assertEquals(1,FunctionUtils.compose(m,m).derivative().value(3),EPS);DifferentiableUnivariateFunction inv=new Inverse();Assert.assertEquals(0.25,FunctionUtils.compose(inv,m,id).derivative().value(2),EPS);DifferentiableUnivariateFunction pow=new Power(2);Assert.assertEquals(108,FunctionUtils.compose(pow,pow).derivative().value(3),EPS);DifferentiableUnivariateFunction log=new Log();double a=9876.54321;Assert.assertEquals(pow.derivative().value(a)/ pow.value(a),FunctionUtils.compose(log,pow).derivative().value(a),EPS);}
@Test public void testAdd(){UnivariateFunction id=new Identity();UnivariateFunction c=new Constant(4);UnivariateFunction m=new Minus();UnivariateFunction inv=new Inverse();Assert.assertEquals(4.5,FunctionUtils.add(inv,m,c,id).value(2),EPS);Assert.assertEquals(4 + 2,FunctionUtils.add(c,id).value(2),EPS);Assert.assertEquals(4 - 2,FunctionUtils.add(c,FunctionUtils.compose(m,id)).value(2),EPS);}
@Test public void testAddDifferentiable(){DifferentiableUnivariateFunction sin=new Sin();DifferentiableUnivariateFunction c=new Constant(4);DifferentiableUnivariateFunction m=new Minus();DifferentiableUnivariateFunction inv=new Inverse();final double a=123.456;Assert.assertEquals(-1 / (a * a)- 1 + Math.cos(a),FunctionUtils.add(inv,m,c,sin).derivative().value(a),EPS);}
@Test public void testMultiply(){UnivariateFunction c=new Constant(4);Assert.assertEquals(16,FunctionUtils.multiply(c,c).value(12345),EPS);UnivariateFunction inv=new Inverse();UnivariateFunction pow=new Power(2);Assert.assertEquals(1,FunctionUtils.multiply(FunctionUtils.compose(inv,pow),pow).value(3.5),EPS);}
@Test public void testMultiplyDifferentiable(){DifferentiableUnivariateFunction c=new Constant(4);DifferentiableUnivariateFunction id=new Identity();final double a=1.2345678;Assert.assertEquals(8 * a,FunctionUtils.multiply(c,id,id).derivative().value(a),EPS);DifferentiableUnivariateFunction inv=new Inverse();DifferentiableUnivariateFunction pow=new Power(2.5);DifferentiableUnivariateFunction cos=new Cos();Assert.assertEquals(1.5 * Math.sqrt(a)* Math.cos(a)- Math.pow(a,1.5)* Math.sin(a),FunctionUtils.multiply(inv,pow,cos).derivative().value(a),EPS);DifferentiableUnivariateFunction cosh=new Cosh();Assert.assertEquals(1.5 * Math.sqrt(a)* Math.cosh(a)+ Math.pow(a,1.5)* Math.sinh(a),FunctionUtils.multiply(inv,pow,cosh).derivative().value(a),8 * EPS);}
@Test public void testCombine(){BivariateRealFunction bi=new Add();UnivariateFunction id=new Identity();UnivariateFunction m=new Minus();UnivariateFunction c=FunctionUtils.combine(bi,id,m);Assert.assertEquals(0,c.value(2.3456),EPS);bi=new Multiply();UnivariateFunction inv=new Inverse();c=FunctionUtils.combine(bi,id,inv);Assert.assertEquals(1,c.value(2.3456),EPS);}
@Test public void testCollector(){BivariateRealFunction bi=new Add();MultivariateFunction coll=FunctionUtils.collector(bi,0);Assert.assertEquals(10,coll.value(new double[]{1,2,3,4}),EPS);bi=new Multiply();coll=FunctionUtils.collector(bi,1);Assert.assertEquals(24,coll.value(new double[]{1,2,3,4}),EPS);bi=new Max();coll=FunctionUtils.collector(bi,Double.NEGATIVE_INFINITY);Assert.assertEquals(10,coll.value(new double[]{1,-2,7.5,10,-24,9.99}),0);bi=new Min();coll=FunctionUtils.collector(bi,Double.POSITIVE_INFINITY);Assert.assertEquals(-24,coll.value(new double[]{1,-2,7.5,10,-24,9.99}),0);}
@Test public void testSinc(){BivariateRealFunction div=new Divide();UnivariateFunction sin=new Sin();UnivariateFunction id=new Identity();UnivariateFunction sinc1=FunctionUtils.combine(div,sin,id);UnivariateFunction sinc2=new Sinc();for (int i=0;i < 10;i++){double x=Math.random();Assert.assertEquals(sinc1.value(x),sinc2.value(x),EPS);}}
@Test public void testFixingArguments(){UnivariateFunction scaler=FunctionUtils.fix1stArgument(new Multiply(),10);Assert.assertEquals(1.23456,scaler.value(0.123456),EPS);UnivariateFunction pow1=new Power(2);UnivariateFunction pow2=FunctionUtils.fix2ndArgument(new Pow(),2);for (int i=0;i < 10;i++){double x=Math.random()* 10;Assert.assertEquals(pow1.value(x),pow2.value(x),0);}}
@Test public void derivativesConsistency(){TestProblem3 pb=new TestProblem3();double step=(pb.getFinalTime()- pb.getInitialTime())* 0.001;ThreeEighthesIntegrator integ=new ThreeEighthesIntegrator(step);StepInterpolatorTestUtils.checkDerivativesConsistency(integ,pb,1.0e-10);}
@Test public void serialization()throws IOException,ClassNotFoundException {TestProblem3 pb=new TestProblem3(0.9);double step=(pb.getFinalTime()- pb.getInitialTime())* 0.0003;ThreeEighthesIntegrator integ=new ThreeEighthesIntegrator(step);integ.addStepHandler(new ContinuousOutputModel());integ.integrate(pb,pb.getInitialTime(),pb.getInitialState(),pb.getFinalTime(),new double[pb.getDimension()]);ByteArrayOutputStream bos=new ByteArrayOutputStream();ObjectOutputStream oos=new ObjectOutputStream(bos);for(StepHandler handler : integ.getStepHandlers()){oos.writeObject(handler);}Assert.assertTrue(bos.size()> 880000);Assert.assertTrue(bos.size()< 900000);ByteArrayInputStream bis=new ByteArrayInputStream(bos.toByteArray());ObjectInputStream ois=new ObjectInputStream(bis);ContinuousOutputModel cm=(ContinuousOutputModel)ois.readObject();Random random=new Random(347588535632l);double maxError=0.0;for (int i=0;i < 1000;++i){double r=random.nextDouble();double time=r * pb.getInitialTime()+ (1.0 - r)* pb.getFinalTime();cm.setInterpolatedTime(time);double[]interpolatedY=cm.getInterpolatedState();double[]theoreticalY=pb.computeTheoreticalState(time);double dx=interpolatedY[0]- theoreticalY[0];double dy=interpolatedY[1]- theoreticalY[1];double error=dx * dx + dy * dy;if (error > maxError){maxError=error;}}Assert.assertTrue(maxError > 0.005);}
@Test public void test(){GeneticAlgorithm ga=new GeneticAlgorithm(new OnePointCrossover<Integer>(),CROSSOVER_RATE,new RandomKeyMutation(),MUTATION_RATE,new TournamentSelection(TOURNAMENT_ARITY));Population initial=randomPopulation();StoppingCondition stopCond=new FixedGenerationCount(NUM_GENERATIONS);Chromosome bestInitial=initial.getFittestChromosome();Population finalPopulation=ga.evolve(initial,stopCond);Chromosome bestFinal=finalPopulation.getFittestChromosome();Assert.assertTrue(bestFinal.compareTo(bestInitial)> 0);}
@Test public void testSinZero(){UnivariateFunction f=new SinFunction();double result;BisectionSolver solver=new BisectionSolver();result=solver.solve(100,f,3,4);Assert.assertEquals(result,FastMath.PI,solver.getAbsoluteAccuracy());result=solver.solve(100,f,1,4);Assert.assertEquals(result,FastMath.PI,solver.getAbsoluteAccuracy());}
@Test public void testQuinticZero(){UnivariateFunction f=new QuinticFunction();double result;BisectionSolver solver=new BisectionSolver();result=solver.solve(100,f,-0.2,0.2);Assert.assertEquals(result,0,solver.getAbsoluteAccuracy());result=solver.solve(100,f,-0.1,0.3);Assert.assertEquals(result,0,solver.getAbsoluteAccuracy());result=solver.solve(100,f,-0.3,0.45);Assert.assertEquals(result,0,solver.getAbsoluteAccuracy());result=solver.solve(100,f,0.3,0.7);Assert.assertEquals(result,0.5,solver.getAbsoluteAccuracy());result=solver.solve(100,f,0.2,0.6);Assert.assertEquals(result,0.5,solver.getAbsoluteAccuracy());result=solver.solve(100,f,0.05,0.95);Assert.assertEquals(result,0.5,solver.getAbsoluteAccuracy());result=solver.solve(100,f,0.85,1.25);Assert.assertEquals(result,1.0,solver.getAbsoluteAccuracy());result=solver.solve(100,f,0.8,1.2);Assert.assertEquals(result,1.0,solver.getAbsoluteAccuracy());result=solver.solve(100,f,0.85,1.75);Assert.assertEquals(result,1.0,solver.getAbsoluteAccuracy());result=solver.solve(100,f,0.55,1.45);Assert.assertEquals(result,1.0,solver.getAbsoluteAccuracy());result=solver.solve(100,f,0.85,5);Assert.assertEquals(result,1.0,solver.getAbsoluteAccuracy());Assert.assertTrue(solver.getEvaluations()> 0);}
@Test public void testMath369(){UnivariateFunction f=new SinFunction();BisectionSolver solver=new BisectionSolver();Assert.assertEquals(FastMath.PI,solver.solve(100,f,3.0,3.2,3.1),solver.getAbsoluteAccuracy());}
@Test public void testChiSquare()throws Exception {long[]observed={10,9,11};double[]expected={10,10,10};Assert.assertEquals("chi-square statistic",0.2,testStatistic.chiSquare(expected,observed),10E-12);Assert.assertEquals("chi-square p-value",0.904837418036,testStatistic.chiSquareTest(expected,observed),1E-10);long[]observed1={500,623,72,70,31};double[]expected1={485,541,82,61,37};Assert.assertEquals("chi-square test statistic",9.023307936427388,testStatistic.chiSquare(expected1,observed1),1E-10);Assert.assertEquals("chi-square p-value",0.06051952647453607,testStatistic.chiSquareTest(expected1,observed1),1E-9);Assert.assertTrue("chi-square test reject",testStatistic.chiSquareTest(expected1,observed1,0.08));Assert.assertTrue("chi-square test accept",!testStatistic.chiSquareTest(expected1,observed1,0.05));try {testStatistic.chiSquareTest(expected1,observed1,95);Assert.fail("alpha out of range,MathIllegalArgumentException expected");}catch(MathIllegalArgumentException ex){}long[]tooShortObs={0};double[]tooShortEx={1};try {testStatistic.chiSquare(tooShortEx,tooShortObs);Assert.fail("arguments too short,MathIllegalArgumentException expected");}catch(MathIllegalArgumentException ex){}long[]unMatchedObs={0,1,2,3};double[]unMatchedEx={1,1,2};try {testStatistic.chiSquare(unMatchedEx,unMatchedObs);Assert.fail("arrays have different lengths,MathIllegalArgumentException expected");}catch(MathIllegalArgumentException ex){}expected[0]=0;try {testStatistic.chiSquareTest(expected,observed,.01);Assert.fail("bad expected count,MathIllegalArgumentException expected");}catch(MathIllegalArgumentException ex){}expected[0]=1;observed[0]=-1;try {testStatistic.chiSquareTest(expected,observed,.01);Assert.fail("bad expected count,MathIllegalArgumentException expected");}catch(MathIllegalArgumentException ex){}}
@Test public void testChiSquareIndependence()throws Exception {long[][]counts={{40,22,43},{91,21,28},{60,10,22}};Assert.assertEquals("chi-square test statistic",22.709027688,testStatistic.chiSquare(counts),1E-9);Assert.assertEquals("chi-square p-value",0.000144751460134,testStatistic.chiSquareTest(counts),1E-9);Assert.assertTrue("chi-square test reject",testStatistic.chiSquareTest(counts,0.0002));Assert.assertTrue("chi-square test accept",!testStatistic.chiSquareTest(counts,0.0001));long[][]counts2={{10,15},{30,40},{60,90}};Assert.assertEquals("chi-square test statistic",0.168965517241,testStatistic.chiSquare(counts2),1E-9);Assert.assertEquals("chi-square p-value",0.918987499852,testStatistic.chiSquareTest(counts2),1E-9);Assert.assertTrue("chi-square test accept",!testStatistic.chiSquareTest(counts2,0.1));long[][]counts3={{40,22,43},{91,21,28},{60,10}};try {testStatistic.chiSquare(counts3);Assert.fail("Expecting MathIllegalArgumentException");}catch(MathIllegalArgumentException ex){}long[][]counts4={{40,22,43}};try {testStatistic.chiSquare(counts4);Assert.fail("Expecting MathIllegalArgumentException");}catch(MathIllegalArgumentException ex){}long[][]counts5={{40},{40},{30},{10}};try {testStatistic.chiSquare(counts5);Assert.fail("Expecting MathIllegalArgumentException");}catch(MathIllegalArgumentException ex){}long[][]counts6={{10,-2},{30,40},{60,90}};try {testStatistic.chiSquare(counts6);Assert.fail("Expecting MathIllegalArgumentException");}catch(MathIllegalArgumentException ex){}try {testStatistic.chiSquareTest(counts,0);Assert.fail("Expecting MathIllegalArgumentException");}catch(MathIllegalArgumentException ex){}}
@Test public void testChiSquareLargeTestStatistic()throws Exception {double[]exp=new double[]{3389119.5,649136.6,285745.4,25357364.76,11291189.78,543628.0,232921.0,437665.75};long[]obs=new long[]{2372383,584222,257170,17750155,7903832,489265,209628,393899};org.apache.commons.math.stat.inference.ChiSquareTestImpl csti=new org.apache.commons.math.stat.inference.ChiSquareTestImpl();double cst=csti.chiSquareTest(exp,obs);Assert.assertEquals("chi-square p-value",0.0,cst,1E-3);Assert.assertEquals("chi-square test statistic",114875.90421929007,testStatistic.chiSquare(exp,obs),1E-9);}
/** * Contingency table containing zeros - PR # 32531 */@Test public void testChiSquareZeroCount()throws Exception {long[][]counts={{40,0,4},{91,1,2},{60,2,0}};Assert.assertEquals("chi-square test statistic",9.67444662263,testStatistic.chiSquare(counts),1E-9);Assert.assertEquals("chi-square p-value",0.0462835770603,testStatistic.chiSquareTest(counts),1E-9);}
/** * Target values verified using DATAPLOT version 2006.3 */@Test public void testChiSquareDataSetsComparisonEqualCounts()throws Exception {long[]observed1={10,12,12,10};long[]observed2={5,15,14,10};Assert.assertEquals("chi-square p value",0.541096,testStatistic.chiSquareTestDataSetsComparison(observed1,observed2),1E-6);Assert.assertEquals("chi-square test statistic",2.153846,testStatistic.chiSquareDataSetsComparison(observed1,observed2),1E-6);Assert.assertFalse("chi-square test result",testStatistic.chiSquareTestDataSetsComparison(observed1,observed2,0.4));}
/** * Target values verified using DATAPLOT version 2006.3 */@Test public void testChiSquareDataSetsComparisonUnEqualCounts()throws Exception {long[]observed1={10,12,12,10,15};long[]observed2={15,10,10,15,5};Assert.assertEquals("chi-square p value",0.124115,testStatistic.chiSquareTestDataSetsComparison(observed1,observed2),1E-6);Assert.assertEquals("chi-square test statistic",7.232189,testStatistic.chiSquareDataSetsComparison(observed1,observed2),1E-6);Assert.assertTrue("chi-square test result",testStatistic.chiSquareTestDataSetsComparison(observed1,observed2,0.13));Assert.assertFalse("chi-square test result",testStatistic.chiSquareTestDataSetsComparison(observed1,observed2,0.12));}
@Test public void testChiSquareDataSetsComparisonBadCounts()throws Exception {long[]observed1={10,-1,12,10,15};long[]observed2={15,10,10,15,5};try {testStatistic.chiSquareTestDataSetsComparison(observed1,observed2);Assert.fail("Expecting MathIllegalArgumentException - negative count");}catch(MathIllegalArgumentException ex){}long[]observed3={10,0,12,10,15};long[]observed4={15,0,10,15,5};try {testStatistic.chiSquareTestDataSetsComparison(observed3,observed4);Assert.fail("Expecting MathIllegalArgumentException - double 0's");}catch(MathIllegalArgumentException ex){}long[]observed5={10,10,12,10,15};long[]observed6={0,0,0,0,0};try {testStatistic.chiSquareTestDataSetsComparison(observed5,observed6);Assert.fail("Expecting MathIllegalArgumentException - vanishing counts");}catch(MathIllegalArgumentException ex){}}
@Test public void testSimpleNoDecimals(){Complex c=new Complex(1,2);String expected="1 + 2i";String actual=complexFormat.format(c);Assert.assertEquals(expected,actual);}
@Test public void testTrimOneImaginary(){final ComplexFormat fmt=ComplexFormat.getInstance(getLocale());fmt.getImaginaryFormat().setMaximumFractionDigits(1);Complex c=new Complex(1,1.04);String expected="1 + i";String actual=fmt.format(c);Assert.assertEquals(expected,actual);c=new Complex(1,1.09);expected="1 + 1" + getDecimalCharacter()+ "1i";actual=fmt.format(c);Assert.assertEquals(expected,actual);c=new Complex(1,-1.09);expected="1 - 1" + getDecimalCharacter()+ "1i";actual=fmt.format(c);Assert.assertEquals(expected,actual);c=new Complex(1,-1.04);expected="1 - i";actual=fmt.format(c);Assert.assertEquals(expected,actual);}
@Test public void testSimpleWithDecimals(){Complex c=new Complex(1.23,1.43);String expected="1" + getDecimalCharacter()+ "23 + 1"+ getDecimalCharacter()+ "43i";String actual=complexFormat.format(c);Assert.assertEquals(expected,actual);}
@Test public void testSimpleWithDecimalsTrunc(){Complex c=new Complex(1.2323,1.4343);String expected="1" + getDecimalCharacter()+ "23 + 1"+ getDecimalCharacter()+ "43i";String actual=complexFormat.format(c);Assert.assertEquals(expected,actual);}
@Test public void testNegativeReal(){Complex c=new Complex(-1.2323,1.4343);String expected="-1" + getDecimalCharacter()+ "23 + 1"+ getDecimalCharacter()+ "43i";String actual=complexFormat.format(c);Assert.assertEquals(expected,actual);}
@Test public void testNegativeImaginary(){Complex c=new Complex(1.2323,-1.4343);String expected="1" + getDecimalCharacter()+ "23 - 1"+ getDecimalCharacter()+ "43i";String actual=complexFormat.format(c);Assert.assertEquals(expected,actual);}
@Test public void testNegativeBoth(){Complex c=new Complex(-1.2323,-1.4343);String expected="-1" + getDecimalCharacter()+ "23 - 1"+ getDecimalCharacter()+ "43i";String actual=complexFormat.format(c);Assert.assertEquals(expected,actual);}
@Test public void testZeroReal(){Complex c=new Complex(0.0,-1.4343);String expected="0 - 1" + getDecimalCharacter()+ "43i";String actual=complexFormat.format(c);Assert.assertEquals(expected,actual);}
@Test public void testZeroImaginary(){Complex c=new Complex(30.233,0);String expected="30" + getDecimalCharacter()+ "23";String actual=complexFormat.format(c);Assert.assertEquals(expected,actual);}
@Test public void testDifferentImaginaryChar(){Complex c=new Complex(1,1);String expected="1 + j";String actual=complexFormatJ.format(c);Assert.assertEquals(expected,actual);}
@Test public void testDefaultFormatComplex(){Locale defaultLocal=Locale.getDefault();Locale.setDefault(getLocale());Complex c=new Complex(232.222,-342.33);String expected="232" + getDecimalCharacter()+ "22 - 342"+ getDecimalCharacter()+ "33i";String actual=(new ComplexFormat()).format(c);Assert.assertEquals(expected,actual);Locale.setDefault(defaultLocal);}
@Test public void testNan(){Complex c=new Complex(Double.NaN,Double.NaN);String expected="(NaN)+ (NaN)i";String actual=complexFormat.format(c);Assert.assertEquals(expected,actual);}
@Test public void testPositiveInfinity(){Complex c=new Complex(Double.POSITIVE_INFINITY,Double.POSITIVE_INFINITY);String expected="(Infinity)+ (Infinity)i";String actual=complexFormat.format(c);Assert.assertEquals(expected,actual);}
@Test public void testNegativeInfinity(){Complex c=new Complex(Double.NEGATIVE_INFINITY,Double.NEGATIVE_INFINITY);String expected="(-Infinity)- (Infinity)i";String actual=complexFormat.format(c);Assert.assertEquals(expected,actual);}
@Test public void testParseSimpleNoDecimals(){String source="1 + 1i";Complex expected=new Complex(1,1);Complex actual=complexFormat.parse(source);Assert.assertEquals(expected,actual);}
@Test public void testParseSimpleWithDecimals(){String source="1" + getDecimalCharacter()+ "23 + 1"+ getDecimalCharacter()+ "43i";Complex expected=new Complex(1.23,1.43);Complex actual=complexFormat.parse(source);Assert.assertEquals(expected,actual);}
@Test public void testParseSimpleWithDecimalsTrunc(){String source="1" + getDecimalCharacter()+ "2323 + 1"+ getDecimalCharacter()+ "4343i";Complex expected=new Complex(1.2323,1.4343);Complex actual=complexFormat.parse(source);Assert.assertEquals(expected,actual);}
@Test public void testParseNegativeReal(){String source="-1" + getDecimalCharacter()+ "2323 + 1"+ getDecimalCharacter()+ "4343i";Complex expected=new Complex(-1.2323,1.4343);Complex actual=complexFormat.parse(source);Assert.assertEquals(expected,actual);}
@Test public void testParseNegativeImaginary(){String source="1" + getDecimalCharacter()+ "2323 - 1"+ getDecimalCharacter()+ "4343i";Complex expected=new Complex(1.2323,-1.4343);Complex actual=complexFormat.parse(source);Assert.assertEquals(expected,actual);}
@Test public void testParseNegativeBoth(){String source="-1" + getDecimalCharacter()+ "2323 - 1"+ getDecimalCharacter()+ "4343i";Complex expected=new Complex(-1.2323,-1.4343);Complex actual=complexFormat.parse(source);Assert.assertEquals(expected,actual);}
@Test public void testParseZeroReal(){String source="0" + getDecimalCharacter()+ "0 - 1"+ getDecimalCharacter()+ "4343i";Complex expected=new Complex(0.0,-1.4343);Complex actual=complexFormat.parse(source);Assert.assertEquals(expected,actual);}
@Test public void testParseZeroImaginary(){String source="-1" + getDecimalCharacter()+ "2323";Complex expected=new Complex(-1.2323,0);Complex actual=complexFormat.parse(source);Assert.assertEquals(expected,actual);}
@Test public void testParseDifferentImaginaryChar(){String source="-1" + getDecimalCharacter()+ "2323 - 1"+ getDecimalCharacter()+ "4343j";Complex expected=new Complex(-1.2323,-1.4343);Complex actual=complexFormatJ.parse(source);Assert.assertEquals(expected,actual);}
@Test public void testParseNan(){String source="(NaN)+ (NaN)i";Complex expected=new Complex(Double.NaN,Double.NaN);Complex actual=complexFormat.parse(source);Assert.assertEquals(expected,actual);}
@Test public void testParsePositiveInfinity(){String source="(Infinity)+ (Infinity)i";Complex expected=new Complex(Double.POSITIVE_INFINITY,Double.POSITIVE_INFINITY);Complex actual=complexFormat.parse(source);Assert.assertEquals(expected,actual);}
@Test public void testPaseNegativeInfinity(){String source="(-Infinity)- (Infinity)i";Complex expected=new Complex(Double.NEGATIVE_INFINITY,Double.NEGATIVE_INFINITY);Complex actual=complexFormat.parse(source);Assert.assertEquals(expected,actual);}
@Test public void testConstructorSingleFormat(){NumberFormat nf=NumberFormat.getInstance();ComplexFormat cf=new ComplexFormat(nf);Assert.assertNotNull(cf);Assert.assertEquals(nf,cf.getRealFormat());}
@Test public void testGetImaginaryFormat(){NumberFormat nf=NumberFormat.getInstance();ComplexFormat cf=new ComplexFormat(nf);Assert.assertSame(nf,cf.getImaginaryFormat());}
@Test public void testGetRealFormat(){NumberFormat nf=NumberFormat.getInstance();ComplexFormat cf=new ComplexFormat(nf);Assert.assertSame(nf,cf.getRealFormat());}
@Test public void testFormatNumber(){ComplexFormat cf=ComplexFormat.getInstance(getLocale());Double pi=Double.valueOf(FastMath.PI);String text=cf.format(pi);Assert.assertEquals("3" + getDecimalCharacter()+ "14",text);}
@Test public void testForgottenImaginaryCharacter(){ParsePosition pos=new ParsePosition(0);Assert.assertNull(new ComplexFormat().parse("1 + 1",pos));Assert.assertEquals(5,pos.getErrorIndex());}
@Test public void testZero(){Assert.assertEquals(Fraction.ZERO,FractionField.getInstance().getZero());}
@Test public void testOne(){Assert.assertEquals(Fraction.ONE,FractionField.getInstance().getOne());}
@Test public void testSerial(){FractionField field=FractionField.getInstance();Assert.assertTrue(field == TestUtils.serializeAndRecover(field));}
@Test public void lanczosTest(){double obj=this.lanczosObjectFunc.value(correctParamLanczos);Assert.assertEquals(1.6117193594E-08,obj,1.0e-8);double[]grad=this.lanczosObjectFunc.getGradient(correctParamLanczos);double[]grad2=new double[6];grad2[0]=this.lanczosObjectFunc.partialDeriv(correctParamLanczos,0);grad2[1]=this.lanczosObjectFunc.partialDeriv(correctParamLanczos,1);grad2[2]=this.lanczosObjectFunc.partialDeriv(correctParamLanczos,2);grad2[3]=this.lanczosObjectFunc.partialDeriv(correctParamLanczos,3);grad2[4]=this.lanczosObjectFunc.partialDeriv(correctParamLanczos,4);grad2[5]=this.lanczosObjectFunc.partialDeriv(correctParamLanczos,5);TestUtils.assertEquals("Grads...",grad,grad2,1.0e-12);double[]n_grad=this.getGradient(lanczosObjectFunc,correctParamLanczos,1.0e-5);if (FastMath.abs(grad[0]- n_grad[0])> FastMath.max(1.0e-6,1.0e-6 * (grad[0]+ n_grad[0])/ 2.0)){Assert.fail("Check gradient at 1");}if (FastMath.abs(grad[1]- n_grad[1])> FastMath.max(1.0e-6,1.0e-6 * (grad[1]+ n_grad[1])/ 2.0)){Assert.fail("Check gradient at 2");}if (FastMath.abs(grad[2]- n_grad[2])> FastMath.max(1.0e-6,1.0e-6 * (grad[2]+ n_grad[2])/ 2.0)){Assert.fail("Check gradient at 2");}if (FastMath.abs(grad[3]- n_grad[3])> FastMath.max(1.0e-6,1.0e-6 * (grad[3]+ n_grad[3])/ 2.0)){Assert.fail("Check gradient at 2");}if (FastMath.abs(grad[4]- n_grad[4])> FastMath.max(1.0e-6,1.0e-6 * (grad[4]+ n_grad[4])/ 2.0)){Assert.fail("Check gradient at 2");}if (FastMath.abs(grad[5]- n_grad[5])> FastMath.max(1.0e-6,1.0e-6 * (grad[5]+ n_grad[5])/ 2.0)){Assert.fail("Check gradient at 2");}return;}
@Test public void chwirut1Test(){double obj=this.chwirut1ObjectFunc.value(correctParamChwirut1);Assert.assertEquals(2.3844771393e3,obj,1.0e-8);double[]grad=this.chwirut1ObjectFunc.getGradient(correctParamChwirut1);double[]grad2=new double[3];grad2[0]=this.chwirut1ObjectFunc.partialDeriv(correctParamChwirut1,0);grad2[1]=this.chwirut1ObjectFunc.partialDeriv(correctParamChwirut1,1);grad2[2]=this.chwirut1ObjectFunc.partialDeriv(correctParamChwirut1,2);TestUtils.assertEquals("Grads...",grad,grad2,1.0e-12);return;}
@Test public void chwirut2Test(){double obj=this.chwirut2ObjectFunc.value(correctParamChwirut2);Assert.assertEquals(5.1304802941e02,obj,1.0e-8);double[]grad=this.chwirut2ObjectFunc.getGradient(correctParamChwirut2);double[]grad2=new double[3];grad2[0]=this.chwirut2ObjectFunc.partialDeriv(correctParamChwirut2,0);grad2[1]=this.chwirut2ObjectFunc.partialDeriv(correctParamChwirut2,1);grad2[2]=this.chwirut2ObjectFunc.partialDeriv(correctParamChwirut2,2);TestUtils.assertEquals("Grads...",grad,grad2,1.0e-12);return;}
@Test public void misra1aTest(){double obj=this.misra1aObjectFunc.value(correctParamMisra1a);Assert.assertEquals(1.2455138894e-01,obj,1.0e-8);double[]grad=this.misra1aObjectFunc.getGradient(correctParamMisra1a);double[]grad2=new double[2];grad2[0]=this.misra1aObjectFunc.partialDeriv(correctParamMisra1a,0);grad2[1]=this.misra1aObjectFunc.partialDeriv(correctParamMisra1a,1);TestUtils.assertEquals("Grads...",grad,grad2,1.0e-12);return;}
@Test public void testBoundaries(){integ.addStepHandler(new ContinuousOutputModel());integ.integrate(pb,pb.getInitialTime(),pb.getInitialState(),pb.getFinalTime(),new double[pb.getDimension()]);ContinuousOutputModel cm=(ContinuousOutputModel)integ.getStepHandlers().iterator().next();cm.setInterpolatedTime(2.0 * pb.getInitialTime()- pb.getFinalTime());cm.setInterpolatedTime(2.0 * pb.getFinalTime()- pb.getInitialTime());cm.setInterpolatedTime(0.5 * (pb.getFinalTime()+ pb.getInitialTime()));}
@Test public void testRandomAccess(){ContinuousOutputModel cm=new ContinuousOutputModel();integ.addStepHandler(cm);integ.integrate(pb,pb.getInitialTime(),pb.getInitialState(),pb.getFinalTime(),new double[pb.getDimension()]);Random random=new Random(347588535632l);double maxError=0.0;for (int i=0;i < 1000;++i){double r=random.nextDouble();double time=r * pb.getInitialTime()+ (1.0 - r)* pb.getFinalTime();cm.setInterpolatedTime(time);double[]interpolatedY=cm.getInterpolatedState();double[]theoreticalY=pb.computeTheoreticalState(time);double dx=interpolatedY[0]- theoreticalY[0];double dy=interpolatedY[1]- theoreticalY[1];double error=dx * dx + dy * dy;if (error > maxError){maxError=error;}}Assert.assertTrue(maxError < 1.0e-9);}
@Test public void testModelsMerging(){FirstOrderDifferentialEquations problem=new FirstOrderDifferentialEquations(){public void computeDerivatives(double t,double[]y,double[]dot){dot[0]=-y[1];dot[1]=y[0];}public int getDimension(){return 2;}};ContinuousOutputModel cm1=new ContinuousOutputModel();FirstOrderIntegrator integ1=new DormandPrince853Integrator(0,1.0,1.0e-8,1.0e-8);integ1.addStepHandler(cm1);integ1.integrate(problem,FastMath.PI,new double[]{-1.0,0.0},0,new double[2]);ContinuousOutputModel cm2=new ContinuousOutputModel();FirstOrderIntegrator integ2=new DormandPrince853Integrator(0,0.1,1.0e-12,1.0e-12);integ2.addStepHandler(cm2);integ2.integrate(problem,2.0 * FastMath.PI,new double[]{1.0,0.0},FastMath.PI,new double[2]);ContinuousOutputModel cm=new ContinuousOutputModel();cm.append(cm2);cm.append(new ContinuousOutputModel());cm.append(cm1);Assert.assertEquals(2.0 * FastMath.PI,cm.getInitialTime(),1.0e-12);Assert.assertEquals(0,cm.getFinalTime(),1.0e-12);Assert.assertEquals(cm.getFinalTime(),cm.getInterpolatedTime(),1.0e-12);for (double t=0;t < 2.0 * FastMath.PI;t+=0.1){cm.setInterpolatedTime(t);double[]y=cm.getInterpolatedState();Assert.assertEquals(FastMath.cos(t),y[0],1.0e-7);Assert.assertEquals(FastMath.sin(t),y[1],1.0e-7);}}
@Test public void testErrorConditions(){ContinuousOutputModel cm=new ContinuousOutputModel();cm.handleStep(buildInterpolator(0,new double[]{0.0,1.0,-2.0},1),true);Assert.assertTrue(checkAppendError(cm,1.0,new double[]{0.0,1.0},2.0));Assert.assertTrue(checkAppendError(cm,10.0,new double[]{0.0,1.0,-2.0},20.0));Assert.assertTrue(checkAppendError(cm,1.0,new double[]{0.0,1.0,-2.0},0.0));Assert.assertFalse(checkAppendError(cm,1.0,new double[]{0.0,1.0,-2.0},2.0));}
@Test(expected=NumberIsTooSmallException.class)public void testInsufficientOrder3(){new BracketingNthOrderBrentSolverDFP(relativeAccuracy,absoluteAccuracy,functionValueAccuracy,1);}
@Test public void testConstructorOK(){BracketingNthOrderBrentSolverDFP solver=new BracketingNthOrderBrentSolverDFP(relativeAccuracy,absoluteAccuracy,functionValueAccuracy,2);Assert.assertEquals(2,solver.getMaximalOrder());}
@Test public void testConvergenceOnFunctionAccuracy(){BracketingNthOrderBrentSolverDFP solver=new BracketingNthOrderBrentSolverDFP(relativeAccuracy,absoluteAccuracy,field.newDfp(1.0e-20),20);UnivariateDfpFunction f=new UnivariateDfpFunction(){public Dfp value(Dfp x){Dfp one=field.getOne();Dfp oneHalf=one.divide(2);Dfp xMo=x.subtract(one);Dfp xMh=x.subtract(oneHalf);Dfp xPh=x.add(oneHalf);Dfp xPo=x.add(one);return xMo.multiply(xMh).multiply(x).multiply(xPh).multiply(xPo);}};Dfp result=solver.solve(20,f,field.newDfp(0.2),field.newDfp(0.9),field.newDfp(0.4),AllowedSolution.BELOW_SIDE);Assert.assertTrue(f.value(result).abs().lessThan(solver.getFunctionValueAccuracy()));Assert.assertTrue(f.value(result).negativeOrNull());Assert.assertTrue(result.subtract(field.newDfp(0.5)).subtract(solver.getAbsoluteAccuracy()).positiveOrNull());result=solver.solve(20,f,field.newDfp(-0.9),field.newDfp(-0.2),field.newDfp(-0.4),AllowedSolution.ABOVE_SIDE);Assert.assertTrue(f.value(result).abs().lessThan(solver.getFunctionValueAccuracy()));Assert.assertTrue(f.value(result).positiveOrNull());Assert.assertTrue(result.add(field.newDfp(0.5)).subtract(solver.getAbsoluteAccuracy()).negativeOrNull());}
@Test public void testNeta(){for(AllowedSolution allowed : AllowedSolution.values()){check(new UnivariateDfpFunction(){public Dfp value(Dfp x){return DfpMath.sin(x).subtract(x.divide(2));}},200,-2.0,2.0,allowed);check(new UnivariateDfpFunction(){public Dfp value(Dfp x){return DfpMath.pow(x,5).add(x).subtract(field.newDfp(10000));}},200,-5.0,10.0,allowed);check(new UnivariateDfpFunction(){public Dfp value(Dfp x){return x.sqrt().subtract(field.getOne().divide(x)).subtract(field.newDfp(3));}},200,0.001,10.0,allowed);check(new UnivariateDfpFunction(){public Dfp value(Dfp x){return DfpMath.exp(x).add(x).subtract(field.newDfp(20));}},200,-5.0,5.0,allowed);check(new UnivariateDfpFunction(){public Dfp value(Dfp x){return DfpMath.log(x).add(x.sqrt()).subtract(field.newDfp(5));}},200,0.001,10.0,allowed);check(new UnivariateDfpFunction(){public Dfp value(Dfp x){return x.subtract(field.getOne()).multiply(x).multiply(x).subtract(field.getOne());}},200,-0.5,1.5,allowed);}}
/** * test dimensions */@Test public void testDimensions(){SparseFieldMatrix<Fraction> m=createSparseMatrix(testData);SparseFieldMatrix<Fraction> m2=createSparseMatrix(testData2);Assert.assertEquals("testData row dimension",3,m.getRowDimension());Assert.assertEquals("testData column dimension",3,m.getColumnDimension());Assert.assertTrue("testData is square",m.isSquare());Assert.assertEquals("testData2 row dimension",m2.getRowDimension(),2);Assert.assertEquals("testData2 column dimension",m2.getColumnDimension(),3);Assert.assertTrue("testData2 is not square",!m2.isSquare());}
/** * test copy functions */@Test public void testCopyFunctions(){SparseFieldMatrix<Fraction> m1=createSparseMatrix(testData);FieldMatrix<Fraction> m2=m1.copy();Assert.assertEquals(m1.getClass(),m2.getClass());Assert.assertEquals((m2),m1);SparseFieldMatrix<Fraction> m3=createSparseMatrix(testData);FieldMatrix<Fraction> m4=m3.copy();Assert.assertEquals(m3.getClass(),m4.getClass());Assert.assertEquals((m4),m3);}
/** * test add */@Test public void testAdd(){SparseFieldMatrix<Fraction> m=createSparseMatrix(testData);SparseFieldMatrix<Fraction> mInv=createSparseMatrix(testDataInv);SparseFieldMatrix<Fraction> mDataPlusInv=createSparseMatrix(testDataPlusInv);FieldMatrix<Fraction> mPlusMInv=m.add(mInv);for (int row=0;row < m.getRowDimension();row++){for (int col=0;col < m.getColumnDimension();col++){Assert.assertEquals("sum entry entry",mDataPlusInv.getEntry(row,col).doubleValue(),mPlusMInv.getEntry(row,col).doubleValue(),entryTolerance);}}}
/** * test add failure */@Test public void testAddFail(){SparseFieldMatrix<Fraction> m=createSparseMatrix(testData);SparseFieldMatrix<Fraction> m2=createSparseMatrix(testData2);try {m.add(m2);Assert.fail("MathIllegalArgumentException expected");}catch(MathIllegalArgumentException ex){}}
/** * test m-n = m + -n */@Test public void testPlusMinus(){SparseFieldMatrix<Fraction> m=createSparseMatrix(testData);SparseFieldMatrix<Fraction> n=createSparseMatrix(testDataInv);assertClose("m-n = m + -n",m.subtract(n),n.scalarMultiply(new Fraction(-1)).add(m),entryTolerance);try {m.subtract(createSparseMatrix(testData2));Assert.fail("Expecting illegalArgumentException");}catch(MathIllegalArgumentException ex){}}
/** * test multiply */@Test public void testMultiply(){SparseFieldMatrix<Fraction> m=createSparseMatrix(testData);SparseFieldMatrix<Fraction> mInv=createSparseMatrix(testDataInv);SparseFieldMatrix<Fraction> identity=createSparseMatrix(id);SparseFieldMatrix<Fraction> m2=createSparseMatrix(testData2);assertClose("inverse multiply",m.multiply(mInv),identity,entryTolerance);assertClose("inverse multiply",m.multiply(new Array2DRowFieldMatrix<Fraction>(FractionField.getInstance(),testDataInv)),identity,entryTolerance);assertClose("inverse multiply",mInv.multiply(m),identity,entryTolerance);assertClose("identity multiply",m.multiply(identity),m,entryTolerance);assertClose("identity multiply",identity.multiply(mInv),mInv,entryTolerance);assertClose("identity multiply",m2.multiply(identity),m2,entryTolerance);try {m.multiply(createSparseMatrix(bigSingular));Assert.fail("Expecting illegalArgumentException");}catch(MathIllegalArgumentException ex){}}
@Test public void testMultiply2(){FieldMatrix<Fraction> m3=createSparseMatrix(d3);FieldMatrix<Fraction> m4=createSparseMatrix(d4);FieldMatrix<Fraction> m5=createSparseMatrix(d5);assertClose("m3*m4=m5",m3.multiply(m4),m5,entryTolerance);}
/** * test trace */@Test public void testTrace(){FieldMatrix<Fraction> m=createSparseMatrix(id);Assert.assertEquals("identity trace",3d,m.getTrace().doubleValue(),entryTolerance);m=createSparseMatrix(testData2);try {m.getTrace();Assert.fail("Expecting NonSquareMatrixException");}catch(NonSquareMatrixException ex){}}
/** * test sclarAdd */@Test public void testScalarAdd(){FieldMatrix<Fraction> m=createSparseMatrix(testData);assertClose("scalar add",createSparseMatrix(testDataPlus2),m.scalarAdd(new Fraction(2)),entryTolerance);}
/** * test operate */@Test public void testOperate(){FieldMatrix<Fraction> m=createSparseMatrix(id);assertClose("identity operate",testVector,m.operate(testVector),entryTolerance);assertClose("identity operate",testVector,m.operate(new ArrayFieldVector<Fraction>(testVector)).getData(),entryTolerance);m=createSparseMatrix(bigSingular);try {m.operate(testVector);Assert.fail("Expecting illegalArgumentException");}catch(MathIllegalArgumentException ex){}}
/** * test issue MATH-209 */@Test public void testMath209(){FieldMatrix<Fraction> a=createSparseMatrix(new Fraction[][]{{new Fraction(1),new Fraction(2)},{new Fraction(3),new Fraction(4)},{new Fraction(5),new Fraction(6)}});Fraction[]b=a.operate(new Fraction[]{new Fraction(1),new Fraction(1)});Assert.assertEquals(a.getRowDimension(),b.length);Assert.assertEquals(3.0,b[0].doubleValue(),1.0e-12);Assert.assertEquals(7.0,b[1].doubleValue(),1.0e-12);Assert.assertEquals(11.0,b[2].doubleValue(),1.0e-12);}
/** * test transpose */@Test public void testTranspose(){FieldMatrix<Fraction> m=createSparseMatrix(testData);FieldMatrix<Fraction> mIT=new FieldLUDecomposition<Fraction>(m).getSolver().getInverse().transpose();FieldMatrix<Fraction> mTI=new FieldLUDecomposition<Fraction>(m.transpose()).getSolver().getInverse();assertClose("inverse-transpose",mIT,mTI,normTolerance);m=createSparseMatrix(testData2);FieldMatrix<Fraction> mt=createSparseMatrix(testData2T);assertClose("transpose",mt,m.transpose(),normTolerance);}
/** * test preMultiply by vector */@Test public void testPremultiplyVector(){FieldMatrix<Fraction> m=createSparseMatrix(testData);assertClose("premultiply",m.preMultiply(testVector),preMultTest,normTolerance);assertClose("premultiply",m.preMultiply(new ArrayFieldVector<Fraction>(testVector).getData()),preMultTest,normTolerance);m=createSparseMatrix(bigSingular);try {m.preMultiply(testVector);Assert.fail("expecting MathIllegalArgumentException");}catch(MathIllegalArgumentException ex){}}
@Test public void testPremultiply(){FieldMatrix<Fraction> m3=createSparseMatrix(d3);FieldMatrix<Fraction> m4=createSparseMatrix(d4);FieldMatrix<Fraction> m5=createSparseMatrix(d5);assertClose("m3*m4=m5",m4.preMultiply(m3),m5,entryTolerance);SparseFieldMatrix<Fraction> m=createSparseMatrix(testData);SparseFieldMatrix<Fraction> mInv=createSparseMatrix(testDataInv);SparseFieldMatrix<Fraction> identity=createSparseMatrix(id);assertClose("inverse multiply",m.preMultiply(mInv),identity,entryTolerance);assertClose("inverse multiply",mInv.preMultiply(m),identity,entryTolerance);assertClose("identity multiply",m.preMultiply(identity),m,entryTolerance);assertClose("identity multiply",identity.preMultiply(mInv),mInv,entryTolerance);try {m.preMultiply(createSparseMatrix(bigSingular));Assert.fail("Expecting illegalArgumentException");}catch(MathIllegalArgumentException ex){}}
@Test public void testGetVectors(){FieldMatrix<Fraction> m=createSparseMatrix(testData);assertClose("get row",m.getRow(0),testDataRow1,entryTolerance);assertClose("get col",m.getColumn(2),testDataCol3,entryTolerance);try {m.getRow(10);Assert.fail("expecting OutOfRangeException");}catch(OutOfRangeException ex){}try {m.getColumn(-1);Assert.fail("expecting OutOfRangeException");}catch(OutOfRangeException ex){}}
@Test public void testGetEntry(){FieldMatrix<Fraction> m=createSparseMatrix(testData);Assert.assertEquals("get entry",m.getEntry(0,1).doubleValue(),2d,entryTolerance);try {m.getEntry(10,4);Assert.fail("Expecting OutOfRangeException");}catch(OutOfRangeException ex){}}
/** * test examples in user guide */@Test public void testExamples(){Fraction[][]matrixData={{new Fraction(1),new Fraction(2),new Fraction(3)},{new Fraction(2),new Fraction(5),new Fraction(3)}};FieldMatrix<Fraction> m=createSparseMatrix(matrixData);Fraction[][]matrixData2={{new Fraction(1),new Fraction(2)},{new Fraction(2),new Fraction(5)},{new Fraction(1),new Fraction(7)}};FieldMatrix<Fraction> n=createSparseMatrix(matrixData2);FieldMatrix<Fraction> p=m.multiply(n);Assert.assertEquals(2,p.getRowDimension());Assert.assertEquals(2,p.getColumnDimension());FieldMatrix<Fraction> pInverse=new FieldLUDecomposition<Fraction>(p).getSolver().getInverse();Assert.assertEquals(2,pInverse.getRowDimension());Assert.assertEquals(2,pInverse.getColumnDimension());Fraction[][]coefficientsData={{new Fraction(2),new Fraction(3),new Fraction(-2)},{new Fraction(-1),new Fraction(7),new Fraction(6)},{new Fraction(4),new Fraction(-3),new Fraction(-5)}};FieldMatrix<Fraction> coefficients=createSparseMatrix(coefficientsData);Fraction[]constants={new Fraction(1),new Fraction(-2),new Fraction(1)};Fraction[]solution;solution=new FieldLUDecomposition<Fraction>(coefficients).getSolver().solve(new ArrayFieldVector<Fraction>(constants,false)).toArray();Assert.assertEquals((new Fraction(2).multiply((solution[0])).add(new Fraction(3).multiply(solution[1])).subtract(new Fraction(2).multiply(solution[2]))).doubleValue(),constants[0].doubleValue(),1E-12);Assert.assertEquals(((new Fraction(-1).multiply(solution[0])).add(new Fraction(7).multiply(solution[1])).add(new Fraction(6).multiply(solution[2]))).doubleValue(),constants[1].doubleValue(),1E-12);Assert.assertEquals(((new Fraction(4).multiply(solution[0])).subtract(new Fraction(3).multiply(solution[1])).subtract(new Fraction(5).multiply(solution[2]))).doubleValue(),constants[2].doubleValue(),1E-12);}
@Test public void testSubMatrix(){FieldMatrix<Fraction> m=createSparseMatrix(subTestData);FieldMatrix<Fraction> mRows23Cols00=createSparseMatrix(subRows23Cols00);FieldMatrix<Fraction> mRows00Cols33=createSparseMatrix(subRows00Cols33);FieldMatrix<Fraction> mRows01Cols23=createSparseMatrix(subRows01Cols23);FieldMatrix<Fraction> mRows02Cols13=createSparseMatrix(subRows02Cols13);FieldMatrix<Fraction> mRows03Cols12=createSparseMatrix(subRows03Cols12);FieldMatrix<Fraction> mRows03Cols123=createSparseMatrix(subRows03Cols123);FieldMatrix<Fraction> mRows20Cols123=createSparseMatrix(subRows20Cols123);FieldMatrix<Fraction> mRows31Cols31=createSparseMatrix(subRows31Cols31);Assert.assertEquals("Rows23Cols00",mRows23Cols00,m.getSubMatrix(2,3,0,0));Assert.assertEquals("Rows00Cols33",mRows00Cols33,m.getSubMatrix(0,0,3,3));Assert.assertEquals("Rows01Cols23",mRows01Cols23,m.getSubMatrix(0,1,2,3));Assert.assertEquals("Rows02Cols13",mRows02Cols13,m.getSubMatrix(new int[]{0,2},new int[]{1,3}));Assert.assertEquals("Rows03Cols12",mRows03Cols12,m.getSubMatrix(new int[]{0,3},new int[]{1,2}));Assert.assertEquals("Rows03Cols123",mRows03Cols123,m.getSubMatrix(new int[]{0,3},new int[]{1,2,3}));Assert.assertEquals("Rows20Cols123",mRows20Cols123,m.getSubMatrix(new int[]{2,0},new int[]{1,2,3}));Assert.assertEquals("Rows31Cols31",mRows31Cols31,m.getSubMatrix(new int[]{3,1},new int[]{3,1}));Assert.assertEquals("Rows31Cols31",mRows31Cols31,m.getSubMatrix(new int[]{3,1},new int[]{3,1}));try {m.getSubMatrix(1,0,2,4);Assert.fail("Expecting NumberIsTooSmallException");}catch(NumberIsTooSmallException ex){}try {m.getSubMatrix(-1,1,2,2);Assert.fail("Expecting OutOfRangeException");}catch(OutOfRangeException ex){}try {m.getSubMatrix(1,0,2,2);Assert.fail("Expecting NumberIsTooSmallException");}catch(NumberIsTooSmallException ex){}try {m.getSubMatrix(1,0,2,4);Assert.fail("Expecting NumberIsTooSmallException");}catch(NumberIsTooSmallException ex){}try {m.getSubMatrix(new int[]{},new int[]{0});Assert.fail("Expecting NoDataException");}catch(NoDataException ex){}try {m.getSubMatrix(new int[]{0},new int[]{4});Assert.fail("Expecting OutOfRangeException");}catch(OutOfRangeException ex){}}
@Test public void testGetRowMatrix(){FieldMatrix<Fraction> m=createSparseMatrix(subTestData);FieldMatrix<Fraction> mRow0=createSparseMatrix(subRow0);FieldMatrix<Fraction> mRow3=createSparseMatrix(subRow3);Assert.assertEquals("Row0",mRow0,m.getRowMatrix(0));Assert.assertEquals("Row3",mRow3,m.getRowMatrix(3));try {m.getRowMatrix(-1);Assert.fail("Expecting OutOfRangeException");}catch(OutOfRangeException ex){}try {m.getRowMatrix(4);Assert.fail("Expecting OutOfRangeException");}catch(OutOfRangeException ex){}}
@Test public void testGetColumnMatrix(){FieldMatrix<Fraction> m=createSparseMatrix(subTestData);FieldMatrix<Fraction> mColumn1=createSparseMatrix(subColumn1);FieldMatrix<Fraction> mColumn3=createSparseMatrix(subColumn3);Assert.assertEquals("Column1",mColumn1,m.getColumnMatrix(1));Assert.assertEquals("Column3",mColumn3,m.getColumnMatrix(3));try {m.getColumnMatrix(-1);Assert.fail("Expecting OutOfRangeException");}catch(OutOfRangeException ex){}try {m.getColumnMatrix(4);Assert.fail("Expecting OutOfRangeException");}catch(OutOfRangeException ex){}}
@Test public void testGetRowVector(){FieldMatrix<Fraction> m=createSparseMatrix(subTestData);FieldVector<Fraction> mRow0=new ArrayFieldVector<Fraction>(subRow0[0]);FieldVector<Fraction> mRow3=new ArrayFieldVector<Fraction>(subRow3[0]);Assert.assertEquals("Row0",mRow0,m.getRowVector(0));Assert.assertEquals("Row3",mRow3,m.getRowVector(3));try {m.getRowVector(-1);Assert.fail("Expecting OutOfRangeException");}catch(OutOfRangeException ex){}try {m.getRowVector(4);Assert.fail("Expecting OutOfRangeException");}catch(OutOfRangeException ex){}}
@Test public void testGetColumnVector(){FieldMatrix<Fraction> m=createSparseMatrix(subTestData);FieldVector<Fraction> mColumn1=columnToVector(subColumn1);FieldVector<Fraction> mColumn3=columnToVector(subColumn3);Assert.assertEquals("Column1",mColumn1,m.getColumnVector(1));Assert.assertEquals("Column3",mColumn3,m.getColumnVector(3));try {m.getColumnVector(-1);Assert.fail("Expecting OutOfRangeException");}catch(OutOfRangeException ex){}try {m.getColumnVector(4);Assert.fail("Expecting OutOfRangeException");}catch(OutOfRangeException ex){}}
@Test public void testEqualsAndHashCode(){SparseFieldMatrix<Fraction> m=createSparseMatrix(testData);SparseFieldMatrix<Fraction> m1=(SparseFieldMatrix<Fraction>)m.copy();SparseFieldMatrix<Fraction> mt=(SparseFieldMatrix<Fraction>)m.transpose();Assert.assertTrue(m.hashCode()!= mt.hashCode());Assert.assertEquals(m.hashCode(),m1.hashCode());Assert.assertEquals(m,m);Assert.assertEquals(m,m1);Assert.assertFalse(m.equals(null));Assert.assertFalse(m.equals(mt));Assert.assertFalse(m.equals(createSparseMatrix(bigSingular)));}
@Test public void testSetSubMatrix()throws Exception {SparseFieldMatrix<Fraction> m=createSparseMatrix(testData);m.setSubMatrix(detData2,1,1);FieldMatrix<Fraction> expected=createSparseMatrix(new Fraction[][]{{new Fraction(1),new Fraction(2),new Fraction(3)},{new Fraction(2),new Fraction(1),new Fraction(3)},{new Fraction(1),new Fraction(2),new Fraction(4)}});Assert.assertEquals(expected,m);m.setSubMatrix(detData2,0,0);expected=createSparseMatrix(new Fraction[][]{{new Fraction(1),new Fraction(3),new Fraction(3)},{new Fraction(2),new Fraction(4),new Fraction(3)},{new Fraction(1),new Fraction(2),new Fraction(4)}});Assert.assertEquals(expected,m);m.setSubMatrix(testDataPlus2,0,0);expected=createSparseMatrix(new Fraction[][]{{new Fraction(3),new Fraction(4),new Fraction(5)},{new Fraction(4),new Fraction(7),new Fraction(5)},{new Fraction(3),new Fraction(2),new Fraction(10)}});Assert.assertEquals(expected,m);SparseFieldMatrix<Fraction> matrix=createSparseMatrix(new Fraction[][]{{new Fraction(1),new Fraction(2),new Fraction(3),new Fraction(4)},{new Fraction(5),new Fraction(6),new Fraction(7),new Fraction(8)},{new Fraction(9),new Fraction(0),new Fraction(1),new Fraction(2)}});matrix.setSubMatrix(new Fraction[][]{{new Fraction(3),new Fraction(4)},{new Fraction(5),new Fraction(6)}},1,1);expected=createSparseMatrix(new Fraction[][]{{new Fraction(1),new Fraction(2),new Fraction(3),new Fraction(4)},{new Fraction(5),new Fraction(3),new Fraction(4),new Fraction(8)},{new Fraction(9),new Fraction(5),new Fraction(6),new Fraction(2)}});Assert.assertEquals(expected,matrix);try {m.setSubMatrix(testData,1,1);Assert.fail("expecting OutOfRangeException");}catch(OutOfRangeException e){}try {m.setSubMatrix(testData,-1,1);Assert.fail("expecting OutOfRangeException");}catch(OutOfRangeException e){}try {m.setSubMatrix(testData,1,-1);Assert.fail("expecting OutOfRangeException");}catch(OutOfRangeException e){}try {m.setSubMatrix(null,1,1);Assert.fail("expecting NullArgumentException");}catch(NullArgumentException e){}try {new SparseFieldMatrix<Fraction>(field,0,0);Assert.fail("expecting MathIllegalArgumentException");}catch(MathIllegalArgumentException e){}try {m.setSubMatrix(new Fraction[][]{{new Fraction(1)},{new Fraction(2),new Fraction(3)}},0,0);Assert.fail("expecting MathIllegalArgumentException");}catch(MathIllegalArgumentException e){}try {m.setSubMatrix(new Fraction[][]{{}},0,0);Assert.fail("expecting MathIllegalArgumentException");}catch(MathIllegalArgumentException e){}}
/** * Make sure Double.NaN is returned iff n < 3*/@Test public void testNaN(){Skewness skew=new Skewness();Assert.assertTrue(Double.isNaN(skew.getResult()));skew.increment(1d);Assert.assertTrue(Double.isNaN(skew.getResult()));skew.increment(1d);Assert.assertTrue(Double.isNaN(skew.getResult()));skew.increment(1d);Assert.assertFalse(Double.isNaN(skew.getResult()));}
/** * Verifies that increment()and incrementAll work properly.*/@Test public void testIncrementation()throws Exception {StorelessUnivariateStatistic statistic=(StorelessUnivariateStatistic)getUnivariateStatistic();for (int i=0;i < testArray.length;i++){statistic.increment(testArray[i]);}Assert.assertEquals(expectedValue(),statistic.getResult(),getTolerance());Assert.assertEquals(testArray.length,statistic.getN());statistic.clear();statistic.incrementAll(testArray);Assert.assertEquals(expectedValue(),statistic.getResult(),getTolerance());Assert.assertEquals(testArray.length,statistic.getN());statistic.clear();checkClearValue(statistic);Assert.assertEquals(0,statistic.getN());}
@Test public void testSerialization()throws Exception {StorelessUnivariateStatistic statistic=(StorelessUnivariateStatistic)getUnivariateStatistic();TestUtils.checkSerializedEquality(statistic);statistic.clear();for (int i=0;i < testArray.length;i++){statistic.increment(testArray[i]);if (i % 5 == 0)statistic=(StorelessUnivariateStatistic)TestUtils.serializeAndRecover(statistic);}TestUtils.checkSerializedEquality(statistic);Assert.assertEquals(expectedValue(),statistic.getResult(),getTolerance());statistic.clear();checkClearValue(statistic);}
@Test public void testEqualsAndHashCode(){StorelessUnivariateStatistic statistic=(StorelessUnivariateStatistic)getUnivariateStatistic();StorelessUnivariateStatistic statistic2=null;Assert.assertTrue("non-null,compared to null",!statistic.equals(statistic2));Assert.assertTrue("reflexive,non-null",statistic.equals(statistic));int emptyHash=statistic.hashCode();statistic2=(StorelessUnivariateStatistic)getUnivariateStatistic();Assert.assertTrue("empty stats should be equal",statistic.equals(statistic2));Assert.assertEquals("empty stats should have the same hashcode",emptyHash,statistic2.hashCode());statistic.increment(1d);Assert.assertTrue("reflexive,non-empty",statistic.equals(statistic));Assert.assertTrue("non-empty,compared to empty",!statistic.equals(statistic2));Assert.assertTrue("non-empty,compared to empty",!statistic2.equals(statistic));Assert.assertTrue("non-empty stat should have different hashcode from empty stat",statistic.hashCode()!= emptyHash);statistic2.increment(1d);Assert.assertTrue("stats with same data should be equal",statistic.equals(statistic2));Assert.assertEquals("stats with same data should have the same hashcode",statistic.hashCode(),statistic2.hashCode());statistic.increment(Double.POSITIVE_INFINITY);Assert.assertTrue("stats with different n's should not be equal",!statistic2.equals(statistic));Assert.assertTrue("stats with different n's should have different hashcodes",statistic.hashCode()!= statistic2.hashCode());statistic2.increment(Double.POSITIVE_INFINITY);Assert.assertTrue("stats with same data should be equal",statistic.equals(statistic2));Assert.assertEquals("stats with same data should have the same hashcode",statistic.hashCode(),statistic2.hashCode());statistic.clear();statistic2.clear();Assert.assertTrue("cleared stats should be equal",statistic.equals(statistic2));Assert.assertEquals("cleared stats should have thashcode of empty stat",emptyHash,statistic2.hashCode());Assert.assertEquals("cleared stats should have thashcode of empty stat",emptyHash,statistic.hashCode());}
@Test public void testMomentSmallSamples(){UnivariateStatistic stat=getUnivariateStatistic();if (stat instanceof SecondMoment){SecondMoment moment=(SecondMoment)getUnivariateStatistic();Assert.assertTrue(Double.isNaN(moment.getResult()));moment.increment(1d);Assert.assertEquals(0d,moment.getResult(),0);}}
/** * Make sure that evaluate(double[])and inrementAll(double[]),getResult()give same results.*/@Test public void testConsistency(){StorelessUnivariateStatistic stat=(StorelessUnivariateStatistic)getUnivariateStatistic();stat.incrementAll(testArray);Assert.assertEquals(stat.getResult(),stat.evaluate(testArray),getTolerance());for (int i=0;i < smallSamples.length;i++){stat.clear();for (int j=0;j < smallSamples[i].length;j++){stat.increment(smallSamples[i][j]);}TestUtils.assertEquals(stat.getResult(),stat.evaluate(smallSamples[i]),getTolerance());}}
/** * Verifies that copied statistics remain equal to originals when incremented the same way.*/@Test public void testCopyConsistency(){StorelessUnivariateStatistic master=(StorelessUnivariateStatistic)getUnivariateStatistic();StorelessUnivariateStatistic replica=null;long index=FastMath.round((FastMath.random())* testArray.length);master.incrementAll(testArray,0,(int)index);replica=master.copy();Assert.assertTrue(replica.equals(master));Assert.assertTrue(master.equals(replica));master.incrementAll(testArray,(int)index,(int)(testArray.length - index));replica.incrementAll(testArray,(int)index,(int)(testArray.length - index));Assert.assertTrue(replica.equals(master));Assert.assertTrue(master.equals(replica));}
@Test public void testSerial(){StorelessUnivariateStatistic s=(StorelessUnivariateStatistic)getUnivariateStatistic();Assert.assertEquals(s,TestUtils.serializeAndRecover(s));}
@Test public void testEvaluation()throws Exception {Assert.assertEquals(expectedValue(),getUnivariateStatistic().evaluate(testArray),getTolerance());}
@Test public void testEvaluateArraySegment(){final UnivariateStatistic stat=getUnivariateStatistic();final double[]arrayZero=new double[5];System.arraycopy(testArray,0,arrayZero,0,5);Assert.assertEquals(stat.evaluate(arrayZero),stat.evaluate(testArray,0,5),0);final double[]arrayOne=new double[5];System.arraycopy(testArray,5,arrayOne,0,5);Assert.assertEquals(stat.evaluate(arrayOne),stat.evaluate(testArray,5,5),0);final double[]arrayEnd=new double[5];System.arraycopy(testArray,testArray.length - 5,arrayEnd,0,5);Assert.assertEquals(stat.evaluate(arrayEnd),stat.evaluate(testArray,testArray.length - 5,5),0);}
@Test public void testEvaluateArraySegmentWeighted(){UnivariateStatistic statistic=getUnivariateStatistic();if (!(statistic instanceof WeightedEvaluation)){return;}final WeightedEvaluation stat=(WeightedEvaluation)getUnivariateStatistic();final double[]arrayZero=new double[5];final double[]weightZero=new double[5];System.arraycopy(testArray,0,arrayZero,0,5);System.arraycopy(testWeightsArray,0,weightZero,0,5);Assert.assertEquals(stat.evaluate(arrayZero,weightZero),stat.evaluate(testArray,testWeightsArray,0,5),0);final double[]arrayOne=new double[5];final double[]weightOne=new double[5];System.arraycopy(testArray,5,arrayOne,0,5);System.arraycopy(testWeightsArray,5,weightOne,0,5);Assert.assertEquals(stat.evaluate(arrayOne,weightOne),stat.evaluate(testArray,testWeightsArray,5,5),0);final double[]arrayEnd=new double[5];final double[]weightEnd=new double[5];System.arraycopy(testArray,testArray.length - 5,arrayEnd,0,5);System.arraycopy(testWeightsArray,testArray.length - 5,weightEnd,0,5);Assert.assertEquals(stat.evaluate(arrayEnd,weightEnd),stat.evaluate(testArray,testWeightsArray,testArray.length - 5,5),0);}
@Test public void testCopy()throws Exception {UnivariateStatistic original=getUnivariateStatistic();UnivariateStatistic copy=original.copy();Assert.assertEquals(expectedValue(),copy.evaluate(testArray),getTolerance());}
/** * Tests consistency of weighted statistic computation. For statistics that support weighted evaluation,this test case compares the result of direct computation on an array with repeated values with a weighted computation on the corresponding (shorter)array with each value appearing only once but with a weight value equal to its multiplicity in the repeating array.*/@Test public void testWeightedConsistency()throws Exception {UnivariateStatistic statistic=getUnivariateStatistic();if (!(statistic instanceof WeightedEvaluation)){return;}final int len=10;final double mu=0;final double sigma=5;double[]values=new double[len];double[]weights=new double[len];RandomData randomData=new RandomDataImpl();int[]intWeights=new int[len];for (int i=0;i < len;i++){intWeights[i]=randomData.nextInt(1,5);weights[i]=intWeights[i];}List<Double> valuesList=new ArrayList<Double>();for (int i=0;i < len;i++){double value=randomData.nextGaussian(mu,sigma);values[i]=value;for (int j=0;j < intWeights[i];j++){valuesList.add(new Double(value));}}int sumWeights=valuesList.size();double[]repeatedValues=new double[sumWeights];for (int i=0;i < sumWeights;i++){repeatedValues[i]=valuesList.get(i);}WeightedEvaluation weightedStatistic=(WeightedEvaluation)statistic;TestUtils.assertRelativelyEquals(statistic.evaluate(repeatedValues),weightedStatistic.evaluate(values,weights,0,values.length),10E-14);Assert.assertEquals(weightedStatistic.evaluate(values,weights,0,values.length),weightedStatistic.evaluate(values,weights),Double.MIN_VALUE);}
@Test public void testPutAndGetWith0ExpectedSize(){OpenIntToDoubleHashMap map=new OpenIntToDoubleHashMap(0);assertPutAndGet(map);}
@Test public void testPutAndGetWithExpectedSize(){OpenIntToDoubleHashMap map=new OpenIntToDoubleHashMap(500);assertPutAndGet(map);}
@Test public void testPutAndGet(){OpenIntToDoubleHashMap map=new OpenIntToDoubleHashMap();assertPutAndGet(map);}
@Test public void testPutAbsentOnExisting(){OpenIntToDoubleHashMap map=createFromJavaMap();int size=javaMap.size();for(Map.Entry<Integer,Double> mapEntry : generateAbsent().entrySet()){map.put(mapEntry.getKey(),mapEntry.getValue());Assert.assertEquals(++size,map.size());Assert.assertTrue(Precision.equals(mapEntry.getValue(),map.get(mapEntry.getKey()),1));}}
@Test public void testPutOnExisting(){OpenIntToDoubleHashMap map=createFromJavaMap();for(Map.Entry<Integer,Double> mapEntry : javaMap.entrySet()){map.put(mapEntry.getKey(),mapEntry.getValue());Assert.assertEquals(javaMap.size(),map.size());Assert.assertTrue(Precision.equals(mapEntry.getValue(),map.get(mapEntry.getKey()),1));}}
@Test public void testGetAbsent(){Map<Integer,Double> generated=generateAbsent();OpenIntToDoubleHashMap map=createFromJavaMap();for(Map.Entry<Integer,Double> mapEntry : generated.entrySet())Assert.assertTrue(Double.isNaN(map.get(mapEntry.getKey())));}
@Test public void testGetFromEmpty(){OpenIntToDoubleHashMap map=new OpenIntToDoubleHashMap();Assert.assertTrue(Double.isNaN(map.get(5)));Assert.assertTrue(Double.isNaN(map.get(0)));Assert.assertTrue(Double.isNaN(map.get(50)));}
@Test public void testRemove(){OpenIntToDoubleHashMap map=createFromJavaMap();int mapSize=javaMap.size();Assert.assertEquals(mapSize,map.size());for(Map.Entry<Integer,Double> mapEntry : javaMap.entrySet()){map.remove(mapEntry.getKey());Assert.assertEquals(--mapSize,map.size());Assert.assertTrue(Double.isNaN(map.get(mapEntry.getKey())));}assertPutAndGet(map);}
@Test public void testRemove2(){OpenIntToDoubleHashMap map=createFromJavaMap();int mapSize=javaMap.size();int count=0;Set<Integer> keysInMap=new HashSet<Integer>(javaMap.keySet());for(Map.Entry<Integer,Double> mapEntry : javaMap.entrySet()){keysInMap.remove(mapEntry.getKey());map.remove(mapEntry.getKey());Assert.assertEquals(--mapSize,map.size());Assert.assertTrue(Double.isNaN(map.get(mapEntry.getKey())));if (count++ > 5)break;}assertPutAndGet(map,mapSize,keysInMap);}
@Test public void testRemoveFromEmpty(){OpenIntToDoubleHashMap map=new OpenIntToDoubleHashMap();Assert.assertTrue(Double.isNaN(map.remove(50)));}
@Test public void testRemoveAbsent(){Map<Integer,Double> generated=generateAbsent();OpenIntToDoubleHashMap map=createFromJavaMap();int mapSize=map.size();for(Map.Entry<Integer,Double> mapEntry : generated.entrySet()){map.remove(mapEntry.getKey());Assert.assertEquals(mapSize,map.size());Assert.assertTrue(Double.isNaN(map.get(mapEntry.getKey())));}}
@Test public void testCopy(){OpenIntToDoubleHashMap copy=new OpenIntToDoubleHashMap(createFromJavaMap());Assert.assertEquals(javaMap.size(),copy.size());for(Map.Entry<Integer,Double> mapEntry : javaMap.entrySet())Assert.assertTrue(Precision.equals(mapEntry.getValue(),copy.get(mapEntry.getKey()),1));}
@Test public void testContainsKey(){OpenIntToDoubleHashMap map=createFromJavaMap();for(Map.Entry<Integer,Double> mapEntry : javaMap.entrySet()){Assert.assertTrue(map.containsKey(mapEntry.getKey()));}for(Map.Entry<Integer,Double> mapEntry : generateAbsent().entrySet()){Assert.assertFalse(map.containsKey(mapEntry.getKey()));}for(Map.Entry<Integer,Double> mapEntry : javaMap.entrySet()){int key=mapEntry.getKey();Assert.assertTrue(map.containsKey(key));map.remove(key);Assert.assertFalse(map.containsKey(key));}}
@Test public void testIterator(){OpenIntToDoubleHashMap map=createFromJavaMap();OpenIntToDoubleHashMap.Iterator iterator=map.iterator();for (int i=0;i < map.size();++i){Assert.assertTrue(iterator.hasNext());iterator.advance();int key=iterator.key();Assert.assertTrue(map.containsKey(key));Assert.assertEquals(javaMap.get(key),map.get(key),0);Assert.assertEquals(javaMap.get(key),iterator.value(),0);Assert.assertTrue(javaMap.containsKey(key));}Assert.assertFalse(iterator.hasNext());try {iterator.advance();Assert.fail("an exception should have been thrown");}catch(NoSuchElementException nsee){}}
@Test public void testConcurrentModification(){OpenIntToDoubleHashMap map=createFromJavaMap();OpenIntToDoubleHashMap.Iterator iterator=map.iterator();map.put(3,3);try {iterator.advance();Assert.fail("an exception should have been thrown");}catch(ConcurrentModificationException cme){}}
/** * Regression test for a bug in findInsertionIndex where the hashing in the second probing loop was inconsistent with the first causing duplicate keys after the right sequence of puts and removes.*/@Test public void testPutKeysWithCollisions(){OpenIntToDoubleHashMap map=new OpenIntToDoubleHashMap();int key1=-1996012590;double value1=1.0;map.put(key1,value1);int key2=835099822;map.put(key2,value1);int key3=1008859686;map.put(key3,value1);Assert.assertTrue(Precision.equals(value1,map.get(key3),1));Assert.assertEquals(3,map.size());map.remove(key2);double value2=2.0;map.put(key3,value2);Assert.assertTrue(Precision.equals(value2,map.get(key3),1));Assert.assertEquals(2,map.size());}
/** * Similar to testPutKeysWithCollisions()but exercises the codepaths in a slightly different manner.*/@Test public void testPutKeysWithCollision2(){OpenIntToDoubleHashMap map=new OpenIntToDoubleHashMap();int key1=837989881;double value1=1.0;map.put(key1,value1);int key2=476463321;map.put(key2,value1);Assert.assertEquals(2,map.size());Assert.assertTrue(Precision.equals(value1,map.get(key2),1));map.remove(key1);double value2=2.0;map.put(key2,value2);Assert.assertEquals(1,map.size());Assert.assertTrue(Precision.equals(value2,map.get(key2),1));}
@Test public void testSpecialValues(){GeometricMean mean=new GeometricMean();Assert.assertTrue(Double.isNaN(mean.getResult()));mean.increment(1d);Assert.assertFalse(Double.isNaN(mean.getResult()));mean.increment(0d);Assert.assertEquals(0d,mean.getResult(),0);mean.increment(Double.POSITIVE_INFINITY);Assert.assertTrue(Double.isNaN(mean.getResult()));mean.clear();Assert.assertTrue(Double.isNaN(mean.getResult()));mean.increment(Double.POSITIVE_INFINITY);Assert.assertEquals(Double.POSITIVE_INFINITY,mean.getResult(),0);mean.increment(-2d);Assert.assertTrue(Double.isNaN(mean.getResult()));}
/** * Verifies that increment()and incrementAll work properly.*/@Test public void testIncrementation()throws Exception {StorelessUnivariateStatistic statistic=(StorelessUnivariateStatistic)getUnivariateStatistic();for (int i=0;i < testArray.length;i++){statistic.increment(testArray[i]);}Assert.assertEquals(expectedValue(),statistic.getResult(),getTolerance());Assert.assertEquals(testArray.length,statistic.getN());statistic.clear();statistic.incrementAll(testArray);Assert.assertEquals(expectedValue(),statistic.getResult(),getTolerance());Assert.assertEquals(testArray.length,statistic.getN());statistic.clear();checkClearValue(statistic);Assert.assertEquals(0,statistic.getN());}
@Test public void testSerialization()throws Exception {StorelessUnivariateStatistic statistic=(StorelessUnivariateStatistic)getUnivariateStatistic();TestUtils.checkSerializedEquality(statistic);statistic.clear();for (int i=0;i < testArray.length;i++){statistic.increment(testArray[i]);if (i % 5 == 0)statistic=(StorelessUnivariateStatistic)TestUtils.serializeAndRecover(statistic);}TestUtils.checkSerializedEquality(statistic);Assert.assertEquals(expectedValue(),statistic.getResult(),getTolerance());statistic.clear();checkClearValue(statistic);}
@Test public void testEqualsAndHashCode(){StorelessUnivariateStatistic statistic=(StorelessUnivariateStatistic)getUnivariateStatistic();StorelessUnivariateStatistic statistic2=null;Assert.assertTrue("non-null,compared to null",!statistic.equals(statistic2));Assert.assertTrue("reflexive,non-null",statistic.equals(statistic));int emptyHash=statistic.hashCode();statistic2=(StorelessUnivariateStatistic)getUnivariateStatistic();Assert.assertTrue("empty stats should be equal",statistic.equals(statistic2));Assert.assertEquals("empty stats should have the same hashcode",emptyHash,statistic2.hashCode());statistic.increment(1d);Assert.assertTrue("reflexive,non-empty",statistic.equals(statistic));Assert.assertTrue("non-empty,compared to empty",!statistic.equals(statistic2));Assert.assertTrue("non-empty,compared to empty",!statistic2.equals(statistic));Assert.assertTrue("non-empty stat should have different hashcode from empty stat",statistic.hashCode()!= emptyHash);statistic2.increment(1d);Assert.assertTrue("stats with same data should be equal",statistic.equals(statistic2));Assert.assertEquals("stats with same data should have the same hashcode",statistic.hashCode(),statistic2.hashCode());statistic.increment(Double.POSITIVE_INFINITY);Assert.assertTrue("stats with different n's should not be equal",!statistic2.equals(statistic));Assert.assertTrue("stats with different n's should have different hashcodes",statistic.hashCode()!= statistic2.hashCode());statistic2.increment(Double.POSITIVE_INFINITY);Assert.assertTrue("stats with same data should be equal",statistic.equals(statistic2));Assert.assertEquals("stats with same data should have the same hashcode",statistic.hashCode(),statistic2.hashCode());statistic.clear();statistic2.clear();Assert.assertTrue("cleared stats should be equal",statistic.equals(statistic2));Assert.assertEquals("cleared stats should have thashcode of empty stat",emptyHash,statistic2.hashCode());Assert.assertEquals("cleared stats should have thashcode of empty stat",emptyHash,statistic.hashCode());}
@Test public void testMomentSmallSamples(){UnivariateStatistic stat=getUnivariateStatistic();if (stat instanceof SecondMoment){SecondMoment moment=(SecondMoment)getUnivariateStatistic();Assert.assertTrue(Double.isNaN(moment.getResult()));moment.increment(1d);Assert.assertEquals(0d,moment.getResult(),0);}}
/** * Make sure that evaluate(double[])and inrementAll(double[]),getResult()give same results.*/@Test public void testConsistency(){StorelessUnivariateStatistic stat=(StorelessUnivariateStatistic)getUnivariateStatistic();stat.incrementAll(testArray);Assert.assertEquals(stat.getResult(),stat.evaluate(testArray),getTolerance());for (int i=0;i < smallSamples.length;i++){stat.clear();for (int j=0;j < smallSamples[i].length;j++){stat.increment(smallSamples[i][j]);}TestUtils.assertEquals(stat.getResult(),stat.evaluate(smallSamples[i]),getTolerance());}}
/** * Verifies that copied statistics remain equal to originals when incremented the same way.*/@Test public void testCopyConsistency(){StorelessUnivariateStatistic master=(StorelessUnivariateStatistic)getUnivariateStatistic();StorelessUnivariateStatistic replica=null;long index=FastMath.round((FastMath.random())* testArray.length);master.incrementAll(testArray,0,(int)index);replica=master.copy();Assert.assertTrue(replica.equals(master));Assert.assertTrue(master.equals(replica));master.incrementAll(testArray,(int)index,(int)(testArray.length - index));replica.incrementAll(testArray,(int)index,(int)(testArray.length - index));Assert.assertTrue(replica.equals(master));Assert.assertTrue(master.equals(replica));}
@Test public void testSerial(){StorelessUnivariateStatistic s=(StorelessUnivariateStatistic)getUnivariateStatistic();Assert.assertEquals(s,TestUtils.serializeAndRecover(s));}
@Test public void testEvaluation()throws Exception {Assert.assertEquals(expectedValue(),getUnivariateStatistic().evaluate(testArray),getTolerance());}
@Test public void testEvaluateArraySegment(){final UnivariateStatistic stat=getUnivariateStatistic();final double[]arrayZero=new double[5];System.arraycopy(testArray,0,arrayZero,0,5);Assert.assertEquals(stat.evaluate(arrayZero),stat.evaluate(testArray,0,5),0);final double[]arrayOne=new double[5];System.arraycopy(testArray,5,arrayOne,0,5);Assert.assertEquals(stat.evaluate(arrayOne),stat.evaluate(testArray,5,5),0);final double[]arrayEnd=new double[5];System.arraycopy(testArray,testArray.length - 5,arrayEnd,0,5);Assert.assertEquals(stat.evaluate(arrayEnd),stat.evaluate(testArray,testArray.length - 5,5),0);}
@Test public void testEvaluateArraySegmentWeighted(){UnivariateStatistic statistic=getUnivariateStatistic();if (!(statistic instanceof WeightedEvaluation)){return;}final WeightedEvaluation stat=(WeightedEvaluation)getUnivariateStatistic();final double[]arrayZero=new double[5];final double[]weightZero=new double[5];System.arraycopy(testArray,0,arrayZero,0,5);System.arraycopy(testWeightsArray,0,weightZero,0,5);Assert.assertEquals(stat.evaluate(arrayZero,weightZero),stat.evaluate(testArray,testWeightsArray,0,5),0);final double[]arrayOne=new double[5];final double[]weightOne=new double[5];System.arraycopy(testArray,5,arrayOne,0,5);System.arraycopy(testWeightsArray,5,weightOne,0,5);Assert.assertEquals(stat.evaluate(arrayOne,weightOne),stat.evaluate(testArray,testWeightsArray,5,5),0);final double[]arrayEnd=new double[5];final double[]weightEnd=new double[5];System.arraycopy(testArray,testArray.length - 5,arrayEnd,0,5);System.arraycopy(testWeightsArray,testArray.length - 5,weightEnd,0,5);Assert.assertEquals(stat.evaluate(arrayEnd,weightEnd),stat.evaluate(testArray,testWeightsArray,testArray.length - 5,5),0);}
@Test public void testCopy()throws Exception {UnivariateStatistic original=getUnivariateStatistic();UnivariateStatistic copy=original.copy();Assert.assertEquals(expectedValue(),copy.evaluate(testArray),getTolerance());}
/** * Tests consistency of weighted statistic computation. For statistics that support weighted evaluation,this test case compares the result of direct computation on an array with repeated values with a weighted computation on the corresponding (shorter)array with each value appearing only once but with a weight value equal to its multiplicity in the repeating array.*/@Test public void testWeightedConsistency()throws Exception {UnivariateStatistic statistic=getUnivariateStatistic();if (!(statistic instanceof WeightedEvaluation)){return;}final int len=10;final double mu=0;final double sigma=5;double[]values=new double[len];double[]weights=new double[len];RandomData randomData=new RandomDataImpl();int[]intWeights=new int[len];for (int i=0;i < len;i++){intWeights[i]=randomData.nextInt(1,5);weights[i]=intWeights[i];}List<Double> valuesList=new ArrayList<Double>();for (int i=0;i < len;i++){double value=randomData.nextGaussian(mu,sigma);values[i]=value;for (int j=0;j < intWeights[i];j++){valuesList.add(new Double(value));}}int sumWeights=valuesList.size();double[]repeatedValues=new double[sumWeights];for (int i=0;i < sumWeights;i++){repeatedValues[i]=valuesList.get(i);}WeightedEvaluation weightedStatistic=(WeightedEvaluation)statistic;TestUtils.assertRelativelyEquals(statistic.evaluate(repeatedValues),weightedStatistic.evaluate(values,weights,0,values.length),10E-14);Assert.assertEquals(weightedStatistic.evaluate(values,weights,0,values.length),weightedStatistic.evaluate(values,weights),Double.MIN_VALUE);}
@Test public void testAccessors(){final NotPositiveException e=new NotPositiveException(-1);Assert.assertEquals(-1,e.getArgument());Assert.assertEquals(0,e.getMin());Assert.assertTrue(e.getBoundIsAllowed());}
@Test public void testRegularizedGammaNanPositive(){testRegularizedGamma(Double.NaN,Double.NaN,1.0);}
@Test public void testRegularizedGammaPositiveNan(){testRegularizedGamma(Double.NaN,1.0,Double.NaN);}
@Test public void testRegularizedGammaNegativePositive(){testRegularizedGamma(Double.NaN,-1.5,1.0);}
@Test public void testRegularizedGammaPositiveNegative(){testRegularizedGamma(Double.NaN,1.0,-1.0);}
@Test public void testRegularizedGammaZeroPositive(){testRegularizedGamma(Double.NaN,0.0,1.0);}
@Test public void testRegularizedGammaPositiveZero(){testRegularizedGamma(0.0,1.0,0.0);}
@Test public void testRegularizedGammaPositivePositive(){testRegularizedGamma(0.632120558828558,1.0,1.0);}
@Test public void testLogGammaNan(){testLogGamma(Double.NaN,Double.NaN);}
@Test public void testLogGammaNegative(){testLogGamma(Double.NaN,-1.0);}
@Test public void testLogGammaZero(){testLogGamma(Double.NaN,0.0);}
@Test public void testLogGammaPositive(){testLogGamma(0.6931471805599457,3.0);}
@Test public void testDigammaLargeArgs(){double eps=1e-8;Assert.assertEquals(4.6001618527380874002,Gamma.digamma(100),eps);Assert.assertEquals(3.9019896734278921970,Gamma.digamma(50),eps);Assert.assertEquals(2.9705239922421490509,Gamma.digamma(20),eps);Assert.assertEquals(2.9958363947076465821,Gamma.digamma(20.5),eps);Assert.assertEquals(2.2622143570941481605,Gamma.digamma(10.1),eps);Assert.assertEquals(2.1168588189004379233,Gamma.digamma(8.8),eps);Assert.assertEquals(1.8727843350984671394,Gamma.digamma(7),eps);Assert.assertEquals(0.42278433509846713939,Gamma.digamma(2),eps);Assert.assertEquals(-100.56088545786867450,Gamma.digamma(0.01),eps);Assert.assertEquals(-4.0390398965921882955,Gamma.digamma(-0.8),eps);Assert.assertEquals(4.2003210041401844726,Gamma.digamma(-6.3),eps);}
@Test public void testDigammaSmallArgs(){double[]expected={-10.423754940411076795,-100.56088545786867450,-1000.5755719318103005,-10000.577051183514335,-100000.57719921568107,-1.0000005772140199687e6,-1.0000000577215500408e7,-1.0000000057721564845e8,-1.0000000005772156633e9,-1.0000000000577215665e10,-1.0000000000057721566e11,-1.0000000000005772157e12,-1.0000000000000577216e13,-1.0000000000000057722e14,-1.0000000000000005772e15,-1e+16,-1e+17,-1e+18,-1e+19,-1e+20,-1e+21,-1e+22,-1e+23,-1e+24,-1e+25,-1e+26,-1e+27,-1e+28,-1e+29,-1e+30};for (double n=1;n < 30;n++){checkRelativeError(String.format("Test %.0f: ",n),expected[(int)(n - 1)],Gamma.digamma(FastMath.pow(10.0,-n)),1e-8);}}
@Test public void testTrigamma(){double eps=1e-8;double[]data={1e-4,1.0000000164469368793e8,1e-3,1.0000016425331958690e6,1e-2,10001.621213528313220,1e-1,101.43329915079275882,1,1.6449340668482264365,2,0.64493406684822643647,3,0.39493406684822643647,4,0.28382295573711532536,5,0.22132295573711532536,10,0.10516633568168574612,20,0.051270822935203119832,50,0.020201333226697125806,100,0.010050166663333571395};for (int i=data.length - 2;i >= 0;i-=2){Assert.assertEquals(String.format("trigamma %.0f",data[i]),data[i + 1],Gamma.trigamma(data[i]),eps);}}
@Test(expected=DimensionMismatchException.class)public void testDimensionCheck(){TestProblem1 pb=new TestProblem1();AdaptiveStepsizeIntegrator integrator=new GraggBulirschStoerIntegrator(0.0,1.0,1.0e-10,1.0e-10);integrator.integrate(pb,0.0,new double[pb.getDimension()+ 10],1.0,new double[pb.getDimension()+ 10]);}
@Test(expected=NumberIsTooSmallException.class)public void testNullIntervalCheck(){TestProblem1 pb=new TestProblem1();GraggBulirschStoerIntegrator integrator=new GraggBulirschStoerIntegrator(0.0,1.0,1.0e-10,1.0e-10);integrator.integrate(pb,0.0,new double[pb.getDimension()],0.0,new double[pb.getDimension()]);}
@Test(expected=NumberIsTooSmallException.class)public void testMinStep(){TestProblem5 pb=new TestProblem5();double minStep=0.1 * FastMath.abs(pb.getFinalTime()- pb.getInitialTime());double maxStep=FastMath.abs(pb.getFinalTime()- pb.getInitialTime());double[]vecAbsoluteTolerance={1.0e-20,1.0e-21};double[]vecRelativeTolerance={1.0e-20,1.0e-21};FirstOrderIntegrator integ=new GraggBulirschStoerIntegrator(minStep,maxStep,vecAbsoluteTolerance,vecRelativeTolerance);TestProblemHandler handler=new TestProblemHandler(pb,integ);integ.addStepHandler(handler);integ.integrate(pb,pb.getInitialTime(),pb.getInitialState(),pb.getFinalTime(),new double[pb.getDimension()]);}
@Test public void testBackward(){TestProblem5 pb=new TestProblem5();double minStep=0;double maxStep=pb.getFinalTime()- pb.getInitialTime();double scalAbsoluteTolerance=1.0e-8;double scalRelativeTolerance=0.01 * scalAbsoluteTolerance;FirstOrderIntegrator integ=new GraggBulirschStoerIntegrator(minStep,maxStep,scalAbsoluteTolerance,scalRelativeTolerance);TestProblemHandler handler=new TestProblemHandler(pb,integ);integ.addStepHandler(handler);integ.integrate(pb,pb.getInitialTime(),pb.getInitialState(),pb.getFinalTime(),new double[pb.getDimension()]);Assert.assertTrue(handler.getLastError()< 7.5e-9);Assert.assertTrue(handler.getMaximalValueError()< 8.1e-9);Assert.assertEquals(0,handler.getMaximalTimeError(),1.0e-12);Assert.assertEquals("Gragg-Bulirsch-Stoer",integ.getName());}
@Test public void testIncreasingTolerance(){int previousCalls=Integer.MAX_VALUE;for (int i=-12;i < -4;++i){TestProblem1 pb=new TestProblem1();double minStep=0;double maxStep=pb.getFinalTime()- pb.getInitialTime();double absTolerance=FastMath.pow(10.0,i);double relTolerance=absTolerance;FirstOrderIntegrator integ=new GraggBulirschStoerIntegrator(minStep,maxStep,absTolerance,relTolerance);TestProblemHandler handler=new TestProblemHandler(pb,integ);integ.addStepHandler(handler);integ.integrate(pb,pb.getInitialTime(),pb.getInitialState(),pb.getFinalTime(),new double[pb.getDimension()]);double ratio=handler.getMaximalValueError()/ absTolerance;Assert.assertTrue(ratio < 2.4);Assert.assertTrue(ratio > 0.02);Assert.assertEquals(0,handler.getMaximalTimeError(),1.0e-12);int calls=pb.getCalls();Assert.assertEquals(integ.getEvaluations(),calls);Assert.assertTrue(calls <= previousCalls);previousCalls=calls;}}
@Test public void testIntegratorControls(){}
@Test public void testEvents(){TestProblem4 pb=new TestProblem4();double minStep=0;double maxStep=pb.getFinalTime()- pb.getInitialTime();double scalAbsoluteTolerance=1.0e-10;double scalRelativeTolerance=0.01 * scalAbsoluteTolerance;FirstOrderIntegrator integ=new GraggBulirschStoerIntegrator(minStep,maxStep,scalAbsoluteTolerance,scalRelativeTolerance);TestProblemHandler handler=new TestProblemHandler(pb,integ);integ.addStepHandler(handler);EventHandler[]functions=pb.getEventsHandlers();double convergence=1.0e-8 * maxStep;for (int l=0;l < functions.length;++l){integ.addEventHandler(functions[l],Double.POSITIVE_INFINITY,convergence,1000);}Assert.assertEquals(functions.length,integ.getEventHandlers().size());integ.integrate(pb,pb.getInitialTime(),pb.getInitialState(),pb.getFinalTime(),new double[pb.getDimension()]);Assert.assertTrue(handler.getMaximalValueError()< 4.0e-7);Assert.assertEquals(0,handler.getMaximalTimeError(),convergence);Assert.assertEquals(12.0,handler.getLastTime(),convergence);integ.clearEventHandlers();Assert.assertEquals(0,integ.getEventHandlers().size());}
@Test public void testKepler(){final TestProblem3 pb=new TestProblem3(0.9);double minStep=0;double maxStep=pb.getFinalTime()- pb.getInitialTime();double absTolerance=1.0e-6;double relTolerance=1.0e-6;FirstOrderIntegrator integ=new GraggBulirschStoerIntegrator(minStep,maxStep,absTolerance,relTolerance);integ.addStepHandler(new KeplerStepHandler(pb));integ.integrate(pb,pb.getInitialTime(),pb.getInitialState(),pb.getFinalTime(),new double[pb.getDimension()]);Assert.assertEquals(integ.getEvaluations(),pb.getCalls());Assert.assertTrue(pb.getCalls()< 2150);}
@Test public void testVariableSteps(){final TestProblem3 pb=new TestProblem3(0.9);double minStep=0;double maxStep=pb.getFinalTime()- pb.getInitialTime();double absTolerance=1.0e-8;double relTolerance=1.0e-8;FirstOrderIntegrator integ=new GraggBulirschStoerIntegrator(minStep,maxStep,absTolerance,relTolerance);integ.addStepHandler(new VariableStepHandler());double stopTime=integ.integrate(pb,pb.getInitialTime(),pb.getInitialState(),pb.getFinalTime(),new double[pb.getDimension()]);Assert.assertEquals(pb.getFinalTime(),stopTime,1.0e-10);Assert.assertEquals("Gragg-Bulirsch-Stoer",integ.getName());}
@Test public void testUnstableDerivative(){final StepProblem stepProblem=new StepProblem(0.0,1.0,2.0);FirstOrderIntegrator integ=new GraggBulirschStoerIntegrator(0.1,10,1.0e-12,0.0);integ.addEventHandler(stepProblem,1.0,1.0e-12,1000);double[]y={Double.NaN};integ.integrate(stepProblem,0.0,new double[]{0.0},10.0,y);Assert.assertEquals(8.0,y[0],1.0e-12);}
@Test public void testIssue596(){FirstOrderIntegrator integ=new GraggBulirschStoerIntegrator(1e-10,100.0,1e-7,1e-7);integ.addStepHandler(new StepHandler(){public void init(double t0,double[]y0,double t){}public void handleStep(StepInterpolator interpolator,boolean isLast){double t=interpolator.getCurrentTime();interpolator.setInterpolatedTime(t);double[]y=interpolator.getInterpolatedState();double[]yDot=interpolator.getInterpolatedDerivatives();Assert.assertEquals(3.0 * t - 5.0,y[0],1.0e-14);Assert.assertEquals(3.0,yDot[0],1.0e-14);}});double[]y={4.0};double t0=3.0;double tend=10.0;integ.integrate(new FirstOrderDifferentialEquations(){public int getDimension(){return 1;}public void computeDerivatives(double t,double[]y,double[]yDot){yDot[0]=3.0;}},t0,y,tend,y);}
@Test public void testMoreRows(){final double[]singularValues={123.456,2.3,1.001,0.999};final int rows=singularValues.length + 2;final int columns=singularValues.length;Random r=new Random(15338437322523l);SingularValueDecomposition svd=new SingularValueDecomposition(createTestMatrix(r,rows,columns,singularValues));double[]computedSV=svd.getSingularValues();Assert.assertEquals(singularValues.length,computedSV.length);for (int i=0;i < singularValues.length;++i){Assert.assertEquals(singularValues[i],computedSV[i],1.0e-10);}}
@Test public void testMoreColumns(){final double[]singularValues={123.456,2.3,1.001,0.999};final int rows=singularValues.length;final int columns=singularValues.length + 2;Random r=new Random(732763225836210l);SingularValueDecomposition svd=new SingularValueDecomposition(createTestMatrix(r,rows,columns,singularValues));double[]computedSV=svd.getSingularValues();Assert.assertEquals(singularValues.length,computedSV.length);for (int i=0;i < singularValues.length;++i){Assert.assertEquals(singularValues[i],computedSV[i],1.0e-10);}}
/** * test dimensions */@Test public void testDimensions(){RealMatrix matrix=MatrixUtils.createRealMatrix(testSquare);final int m=matrix.getRowDimension();final int n=matrix.getColumnDimension();SingularValueDecomposition svd=new SingularValueDecomposition(matrix);Assert.assertEquals(m,svd.getU().getRowDimension());Assert.assertEquals(m,svd.getU().getColumnDimension());Assert.assertEquals(m,svd.getS().getColumnDimension());Assert.assertEquals(n,svd.getS().getColumnDimension());Assert.assertEquals(n,svd.getV().getRowDimension());Assert.assertEquals(n,svd.getV().getColumnDimension());}
/** * Test based on a dimension 4 Hadamard matrix. */@Test public void testHadamard(){RealMatrix matrix=new Array2DRowRealMatrix(new double[][]{{15.0 / 2.0,5.0 / 2.0,9.0 / 2.0,3.0 / 2.0},{5.0 / 2.0,15.0 / 2.0,3.0 / 2.0,9.0 / 2.0},{9.0 / 2.0,3.0 / 2.0,15.0 / 2.0,5.0 / 2.0},{3.0 / 2.0,9.0 / 2.0,5.0 / 2.0,15.0 / 2.0}},false);SingularValueDecomposition svd=new SingularValueDecomposition(matrix);Assert.assertEquals(16.0,svd.getSingularValues()[0],1.0e-14);Assert.assertEquals(8.0,svd.getSingularValues()[1],1.0e-14);Assert.assertEquals(4.0,svd.getSingularValues()[2],1.0e-14);Assert.assertEquals(2.0,svd.getSingularValues()[3],1.0e-14);RealMatrix fullCovariance=new Array2DRowRealMatrix(new double[][]{{85.0 / 1024,-51.0 / 1024,-75.0 / 1024,45.0 / 1024},{-51.0 / 1024,85.0 / 1024,45.0 / 1024,-75.0 / 1024},{-75.0 / 1024,45.0 / 1024,85.0 / 1024,-51.0 / 1024},{45.0 / 1024,-75.0 / 1024,-51.0 / 1024,85.0 / 1024}},false);Assert.assertEquals(0.0,fullCovariance.subtract(svd.getCovariance(0.0)).getNorm(),1.0e-14);RealMatrix halfCovariance=new Array2DRowRealMatrix(new double[][]{{5.0 / 1024,-3.0 / 1024,5.0 / 1024,-3.0 / 1024},{-3.0 / 1024,5.0 / 1024,-3.0 / 1024,5.0 / 1024},{5.0 / 1024,-3.0 / 1024,5.0 / 1024,-3.0 / 1024},{-3.0 / 1024,5.0 / 1024,-3.0 / 1024,5.0 / 1024}},false);Assert.assertEquals(0.0,halfCovariance.subtract(svd.getCovariance(6.0)).getNorm(),1.0e-14);}
/** * test A = USVt */@Test public void testAEqualUSVt(){checkAEqualUSVt(MatrixUtils.createRealMatrix(testSquare));checkAEqualUSVt(MatrixUtils.createRealMatrix(testNonSquare));checkAEqualUSVt(MatrixUtils.createRealMatrix(testNonSquare).transpose());}
/** * test that U is orthogonal */@Test public void testUOrthogonal(){checkOrthogonal(new SingularValueDecomposition(MatrixUtils.createRealMatrix(testSquare)).getU());checkOrthogonal(new SingularValueDecomposition(MatrixUtils.createRealMatrix(testNonSquare)).getU());checkOrthogonal(new SingularValueDecomposition(MatrixUtils.createRealMatrix(testNonSquare).transpose()).getU());}
/** * test that V is orthogonal */@Test public void testVOrthogonal(){checkOrthogonal(new SingularValueDecomposition(MatrixUtils.createRealMatrix(testSquare)).getV());checkOrthogonal(new SingularValueDecomposition(MatrixUtils.createRealMatrix(testNonSquare)).getV());checkOrthogonal(new SingularValueDecomposition(MatrixUtils.createRealMatrix(testNonSquare).transpose()).getV());}
/** * test matrices values */public void testMatricesValues1(){SingularValueDecomposition svd=new SingularValueDecomposition(MatrixUtils.createRealMatrix(testSquare));RealMatrix uRef=MatrixUtils.createRealMatrix(new double[][]{{3.0 / 5.0,-4.0 / 5.0},{4.0 / 5.0,3.0 / 5.0}});RealMatrix sRef=MatrixUtils.createRealMatrix(new double[][]{{3.0,0.0},{0.0,1.0}});RealMatrix vRef=MatrixUtils.createRealMatrix(new double[][]{{4.0 / 5.0,3.0 / 5.0},{3.0 / 5.0,-4.0 / 5.0}});RealMatrix u=svd.getU();Assert.assertEquals(0,u.subtract(uRef).getNorm(),normTolerance);RealMatrix s=svd.getS();Assert.assertEquals(0,s.subtract(sRef).getNorm(),normTolerance);RealMatrix v=svd.getV();Assert.assertEquals(0,v.subtract(vRef).getNorm(),normTolerance);Assert.assertTrue(u == svd.getU());Assert.assertTrue(s == svd.getS());Assert.assertTrue(v == svd.getV());}
/** * test MATH-465 */@Test public void testRank(){double[][]d={{1,1,1},{0,0,0},{1,2,3}};RealMatrix m=new Array2DRowRealMatrix(d);SingularValueDecomposition svd=new SingularValueDecomposition(m);Assert.assertEquals(2,svd.getRank());}
/** * test MATH-583 */@Test public void testStability1(){RealMatrix m=new Array2DRowRealMatrix(201,201);loadRealMatrix(m,"matrix1.csv");try {new SingularValueDecomposition(m);}catch(Exception e){Assert.fail("Exception whilst constructing SVD");}}
/** * test MATH-327 */@Test public void testStability2(){RealMatrix m=new Array2DRowRealMatrix(7,168);loadRealMatrix(m,"matrix2.csv");try {new SingularValueDecomposition(m);}catch(Throwable e){Assert.fail("Exception whilst constructing SVD");}}
/** * test condition number */@Test public void testConditionNumber(){SingularValueDecomposition svd=new SingularValueDecomposition(MatrixUtils.createRealMatrix(testSquare));Assert.assertEquals(3.0,svd.getConditionNumber(),1.5e-15);}
@Test public void testInverseConditionNumber(){SingularValueDecomposition svd=new SingularValueDecomposition(MatrixUtils.createRealMatrix(testSquare));Assert.assertEquals(1.0 / 3.0,svd.getInverseConditionNumber(),1.5e-15);}
/** * test dimensions */@Test public void testDimensions(){checkDimension(MatrixUtils.createRealMatrix(testData3x3NonSingular));checkDimension(MatrixUtils.createRealMatrix(testData4x3));checkDimension(MatrixUtils.createRealMatrix(testData3x4));Random r=new Random(643895747384642l);int p=(5 * BlockRealMatrix.BLOCK_SIZE)/ 4;int q=(7 * BlockRealMatrix.BLOCK_SIZE)/ 4;checkDimension(createTestMatrix(r,p,q));checkDimension(createTestMatrix(r,q,p));}
/** * test A = QR */@Test public void testAEqualQR(){checkAEqualQR(MatrixUtils.createRealMatrix(testData3x3NonSingular));checkAEqualQR(MatrixUtils.createRealMatrix(testData3x3Singular));checkAEqualQR(MatrixUtils.createRealMatrix(testData3x4));checkAEqualQR(MatrixUtils.createRealMatrix(testData4x3));Random r=new Random(643895747384642l);int p=(5 * BlockRealMatrix.BLOCK_SIZE)/ 4;int q=(7 * BlockRealMatrix.BLOCK_SIZE)/ 4;checkAEqualQR(createTestMatrix(r,p,q));checkAEqualQR(createTestMatrix(r,q,p));}
/** * test the orthogonality of Q */@Test public void testQOrthogonal(){checkQOrthogonal(MatrixUtils.createRealMatrix(testData3x3NonSingular));checkQOrthogonal(MatrixUtils.createRealMatrix(testData3x3Singular));checkQOrthogonal(MatrixUtils.createRealMatrix(testData3x4));checkQOrthogonal(MatrixUtils.createRealMatrix(testData4x3));Random r=new Random(643895747384642l);int p=(5 * BlockRealMatrix.BLOCK_SIZE)/ 4;int q=(7 * BlockRealMatrix.BLOCK_SIZE)/ 4;checkQOrthogonal(createTestMatrix(r,p,q));checkQOrthogonal(createTestMatrix(r,q,p));}
/** * test that R is upper triangular */@Test public void testRUpperTriangular(){RealMatrix matrix=MatrixUtils.createRealMatrix(testData3x3NonSingular);checkUpperTriangular(new QRDecomposition(matrix).getR());matrix=MatrixUtils.createRealMatrix(testData3x3Singular);checkUpperTriangular(new QRDecomposition(matrix).getR());matrix=MatrixUtils.createRealMatrix(testData3x4);checkUpperTriangular(new QRDecomposition(matrix).getR());matrix=MatrixUtils.createRealMatrix(testData4x3);checkUpperTriangular(new QRDecomposition(matrix).getR());Random r=new Random(643895747384642l);int p=(5 * BlockRealMatrix.BLOCK_SIZE)/ 4;int q=(7 * BlockRealMatrix.BLOCK_SIZE)/ 4;matrix=createTestMatrix(r,p,q);checkUpperTriangular(new QRDecomposition(matrix).getR());matrix=createTestMatrix(r,p,q);checkUpperTriangular(new QRDecomposition(matrix).getR());}
/** * test that H is trapezoidal */@Test public void testHTrapezoidal(){RealMatrix matrix=MatrixUtils.createRealMatrix(testData3x3NonSingular);checkTrapezoidal(new QRDecomposition(matrix).getH());matrix=MatrixUtils.createRealMatrix(testData3x3Singular);checkTrapezoidal(new QRDecomposition(matrix).getH());matrix=MatrixUtils.createRealMatrix(testData3x4);checkTrapezoidal(new QRDecomposition(matrix).getH());matrix=MatrixUtils.createRealMatrix(testData4x3);checkTrapezoidal(new QRDecomposition(matrix).getH());Random r=new Random(643895747384642l);int p=(5 * BlockRealMatrix.BLOCK_SIZE)/ 4;int q=(7 * BlockRealMatrix.BLOCK_SIZE)/ 4;matrix=createTestMatrix(r,p,q);checkTrapezoidal(new QRDecomposition(matrix).getH());matrix=createTestMatrix(r,p,q);checkTrapezoidal(new QRDecomposition(matrix).getH());}
/** * test matrices values */@Test public void testMatricesValues(){QRDecomposition qr=new QRDecomposition(MatrixUtils.createRealMatrix(testData3x3NonSingular));RealMatrix qRef=MatrixUtils.createRealMatrix(new double[][]{{-12.0 / 14.0,69.0 / 175.0,-58.0 / 175.0},{-6.0 / 14.0,-158.0 / 175.0,6.0 / 175.0},{4.0 / 14.0,-30.0 / 175.0,-165.0 / 175.0}});RealMatrix rRef=MatrixUtils.createRealMatrix(new double[][]{{-14.0,-21.0,14.0},{0.0,-175.0,70.0},{0.0,0.0,35.0}});RealMatrix hRef=MatrixUtils.createRealMatrix(new double[][]{{26.0 / 14.0,0.0,0.0},{6.0 / 14.0,648.0 / 325.0,0.0},{-4.0 / 14.0,36.0 / 325.0,2.0}});RealMatrix q=qr.getQ();Assert.assertEquals(0,q.subtract(qRef).getNorm(),1.0e-13);RealMatrix qT=qr.getQT();Assert.assertEquals(0,qT.subtract(qRef.transpose()).getNorm(),1.0e-13);RealMatrix r=qr.getR();Assert.assertEquals(0,r.subtract(rRef).getNorm(),1.0e-13);RealMatrix h=qr.getH();Assert.assertEquals(0,h.subtract(hRef).getNorm(),1.0e-13);Assert.assertTrue(q == qr.getQ());Assert.assertTrue(r == qr.getR());Assert.assertTrue(h == qr.getH());}
@Test public void testCompareTo(){Chromosome c1=new Chromosome(){public double fitness(){return 0;}};Chromosome c2=new Chromosome(){public double fitness(){return 10;}};Chromosome c3=new Chromosome(){public double fitness(){return 10;}};Assert.assertTrue(c1.compareTo(c2)< 0);Assert.assertTrue(c2.compareTo(c1)> 0);Assert.assertEquals(0,c3.compareTo(c2));Assert.assertEquals(0,c2.compareTo(c3));}
@Test public void testFindSameChromosome(){Chromosome c1=new DummyChromosome(1){public double fitness(){return 1;}};Chromosome c2=new DummyChromosome(2){public double fitness(){return 2;}};Chromosome c3=new DummyChromosome(3){public double fitness(){return 3;}};Chromosome c4=new DummyChromosome(1){public double fitness(){return 5;}};Chromosome c5=new DummyChromosome(15){public double fitness(){return 15;}};List<Chromosome> popChr=new ArrayList<Chromosome>();popChr.add(c1);popChr.add(c2);popChr.add(c3);Population pop=new ListPopulation(popChr,3){public Population nextGeneration(){return null;}};Assert.assertNull(c5.findSameChromosome(pop));Assert.assertEquals(c1,c4.findSameChromosome(pop));c4.searchForFitnessUpdate(pop);Assert.assertEquals(1,c4.getFitness(),0);}
/** * Verify that b(0,0)= 1 */@Test public void test0Choose0(){Assert.assertEquals(ArithmeticUtils.binomialCoefficientDouble(0,0),1d,0);Assert.assertEquals(ArithmeticUtils.binomialCoefficientLog(0,0),0d,0);Assert.assertEquals(ArithmeticUtils.binomialCoefficient(0,0),1);}
@Test public void testAddAndCheck(){int big=Integer.MAX_VALUE;int bigNeg=Integer.MIN_VALUE;Assert.assertEquals(big,ArithmeticUtils.addAndCheck(big,0));try {ArithmeticUtils.addAndCheck(big,1);Assert.fail("Expecting MathArithmeticException");}catch(MathArithmeticException ex){}try {ArithmeticUtils.addAndCheck(bigNeg,-1);Assert.fail("Expecting MathArithmeticException");}catch(MathArithmeticException ex){}}
@Test public void testAddAndCheckLong(){long max=Long.MAX_VALUE;long min=Long.MIN_VALUE;Assert.assertEquals(max,ArithmeticUtils.addAndCheck(max,0L));Assert.assertEquals(min,ArithmeticUtils.addAndCheck(min,0L));Assert.assertEquals(max,ArithmeticUtils.addAndCheck(0L,max));Assert.assertEquals(min,ArithmeticUtils.addAndCheck(0L,min));Assert.assertEquals(1,ArithmeticUtils.addAndCheck(-1L,2L));Assert.assertEquals(1,ArithmeticUtils.addAndCheck(2L,-1L));Assert.assertEquals(-3,ArithmeticUtils.addAndCheck(-2L,-1L));Assert.assertEquals(min,ArithmeticUtils.addAndCheck(min + 1,-1L));testAddAndCheckLongFailure(max,1L);testAddAndCheckLongFailure(min,-1L);testAddAndCheckLongFailure(1L,max);testAddAndCheckLongFailure(-1L,min);}
@Test public void testBinomialCoefficient(){long[]bcoef5={1,5,10,10,5,1};long[]bcoef6={1,6,15,20,15,6,1};for (int i=0;i < 6;i++){Assert.assertEquals("5 choose " + i,bcoef5[i],ArithmeticUtils.binomialCoefficient(5,i));}for (int i=0;i < 7;i++){Assert.assertEquals("6 choose " + i,bcoef6[i],ArithmeticUtils.binomialCoefficient(6,i));}for (int n=1;n < 10;n++){for (int k=0;k <= n;k++){Assert.assertEquals(n + " choose " + k,binomialCoefficient(n,k),ArithmeticUtils.binomialCoefficient(n,k));Assert.assertEquals(n + " choose " + k,binomialCoefficient(n,k),ArithmeticUtils.binomialCoefficientDouble(n,k),Double.MIN_VALUE);Assert.assertEquals(n + " choose " + k,FastMath.log(binomialCoefficient(n,k)),ArithmeticUtils.binomialCoefficientLog(n,k),10E-12);}}int[]n={34,66,100,1500,1500};int[]k={17,33,10,1500 - 4,4};for (int i=0;i < n.length;i++){long expected=binomialCoefficient(n[i],k[i]);Assert.assertEquals(n[i]+ " choose " + k[i],expected,ArithmeticUtils.binomialCoefficient(n[i],k[i]));Assert.assertEquals(n[i]+ " choose " + k[i],expected,ArithmeticUtils.binomialCoefficientDouble(n[i],k[i]),0.0);Assert.assertEquals("log(" + n[i]+ " choose "+ k[i]+ ")",FastMath.log(expected),ArithmeticUtils.binomialCoefficientLog(n[i],k[i]),0.0);}}
@Test public void testBinomialCoefficientFail(){try {ArithmeticUtils.binomialCoefficient(4,5);Assert.fail("expecting MathIllegalArgumentException");}catch(MathIllegalArgumentException ex){}try {ArithmeticUtils.binomialCoefficientDouble(4,5);Assert.fail("expecting MathIllegalArgumentException");}catch(MathIllegalArgumentException ex){}try {ArithmeticUtils.binomialCoefficientLog(4,5);Assert.fail("expecting MathIllegalArgumentException");}catch(MathIllegalArgumentException ex){}try {ArithmeticUtils.binomialCoefficient(-1,-2);Assert.fail("expecting MathIllegalArgumentException");}catch(MathIllegalArgumentException ex){}try {ArithmeticUtils.binomialCoefficientDouble(-1,-2);Assert.fail("expecting MathIllegalArgumentException");}catch(MathIllegalArgumentException ex){}try {ArithmeticUtils.binomialCoefficientLog(-1,-2);Assert.fail("expecting MathIllegalArgumentException");}catch(MathIllegalArgumentException ex){}try {ArithmeticUtils.binomialCoefficient(67,30);Assert.fail("expecting MathArithmeticException");}catch(MathArithmeticException ex){}try {ArithmeticUtils.binomialCoefficient(67,34);Assert.fail("expecting MathArithmeticException");}catch(MathArithmeticException ex){}double x=ArithmeticUtils.binomialCoefficientDouble(1030,515);Assert.assertTrue("expecting infinite binomial coefficient",Double.isInfinite(x));}
/** * Tests correctness for large n and sharpness of upper bound in API doc JIRA: MATH-241*/@Test public void testBinomialCoefficientLarge()throws Exception {for (int n=0;n <= 200;n++){for (int k=0;k <= n;k++){long ourResult=-1;long exactResult=-1;boolean shouldThrow=false;boolean didThrow=false;try {ourResult=ArithmeticUtils.binomialCoefficient(n,k);}catch(MathArithmeticException ex){didThrow=true;}try {exactResult=binomialCoefficient(n,k);}catch(MathArithmeticException ex){shouldThrow=true;}Assert.assertEquals(n + " choose " + k,exactResult,ourResult);Assert.assertEquals(n + " choose " + k,shouldThrow,didThrow);Assert.assertTrue(n + " choose " + k,(n > 66 || !didThrow));if (!shouldThrow && exactResult > 1){Assert.assertEquals(n + " choose " + k,1.,ArithmeticUtils.binomialCoefficientDouble(n,k)/ exactResult,1e-10);Assert.assertEquals(n + " choose " + k,1,ArithmeticUtils.binomialCoefficientLog(n,k)/ FastMath.log(exactResult),1e-10);}}}long ourResult=ArithmeticUtils.binomialCoefficient(300,3);long exactResult=binomialCoefficient(300,3);Assert.assertEquals(exactResult,ourResult);ourResult=ArithmeticUtils.binomialCoefficient(700,697);exactResult=binomialCoefficient(700,697);Assert.assertEquals(exactResult,ourResult);try {ArithmeticUtils.binomialCoefficient(700,300);Assert.fail("Expecting MathArithmeticException");}catch(MathArithmeticException ex){}int n=10000;ourResult=ArithmeticUtils.binomialCoefficient(n,3);exactResult=binomialCoefficient(n,3);Assert.assertEquals(exactResult,ourResult);Assert.assertEquals(1,ArithmeticUtils.binomialCoefficientDouble(n,3)/ exactResult,1e-10);Assert.assertEquals(1,ArithmeticUtils.binomialCoefficientLog(n,3)/ FastMath.log(exactResult),1e-10);}
@Test public void testFactorial(){for (int i=1;i < 21;i++){Assert.assertEquals(i + "! ",factorial(i),ArithmeticUtils.factorial(i));Assert.assertEquals(i + "! ",factorial(i),ArithmeticUtils.factorialDouble(i),Double.MIN_VALUE);Assert.assertEquals(i + "! ",FastMath.log(factorial(i)),ArithmeticUtils.factorialLog(i),10E-12);}Assert.assertEquals("0",1,ArithmeticUtils.factorial(0));Assert.assertEquals("0",1.0d,ArithmeticUtils.factorialDouble(0),1E-14);Assert.assertEquals("0",0.0d,ArithmeticUtils.factorialLog(0),1E-14);}
@Test public void testFactorialFail(){try {ArithmeticUtils.factorial(-1);Assert.fail("expecting MathIllegalArgumentException");}catch(MathIllegalArgumentException ex){}try {ArithmeticUtils.factorialDouble(-1);Assert.fail("expecting MathIllegalArgumentException");}catch(MathIllegalArgumentException ex){}try {ArithmeticUtils.factorialLog(-1);Assert.fail("expecting MathIllegalArgumentException");}catch(MathIllegalArgumentException ex){}try {ArithmeticUtils.factorial(21);Assert.fail("expecting MathArithmeticException");}catch(MathArithmeticException ex){}Assert.assertTrue("expecting infinite factorial value",Double.isInfinite(ArithmeticUtils.factorialDouble(171)));}
@Test public void testGcd(){int a=30;int b=50;int c=77;Assert.assertEquals(0,ArithmeticUtils.gcd(0,0));Assert.assertEquals(b,ArithmeticUtils.gcd(0,b));Assert.assertEquals(a,ArithmeticUtils.gcd(a,0));Assert.assertEquals(b,ArithmeticUtils.gcd(0,-b));Assert.assertEquals(a,ArithmeticUtils.gcd(-a,0));Assert.assertEquals(10,ArithmeticUtils.gcd(a,b));Assert.assertEquals(10,ArithmeticUtils.gcd(-a,b));Assert.assertEquals(10,ArithmeticUtils.gcd(a,-b));Assert.assertEquals(10,ArithmeticUtils.gcd(-a,-b));Assert.assertEquals(1,ArithmeticUtils.gcd(a,c));Assert.assertEquals(1,ArithmeticUtils.gcd(-a,c));Assert.assertEquals(1,ArithmeticUtils.gcd(a,-c));Assert.assertEquals(1,ArithmeticUtils.gcd(-a,-c));Assert.assertEquals(3 * (1 << 15),ArithmeticUtils.gcd(3 * (1 << 20),9 * (1 << 15)));Assert.assertEquals(Integer.MAX_VALUE,ArithmeticUtils.gcd(Integer.MAX_VALUE,0));Assert.assertEquals(Integer.MAX_VALUE,ArithmeticUtils.gcd(-Integer.MAX_VALUE,0));Assert.assertEquals(1 << 30,ArithmeticUtils.gcd(1 << 30,-Integer.MIN_VALUE));try {ArithmeticUtils.gcd(Integer.MIN_VALUE,0);Assert.fail("expecting MathArithmeticException");}catch(MathArithmeticException expected){}try {ArithmeticUtils.gcd(0,Integer.MIN_VALUE);Assert.fail("expecting MathArithmeticException");}catch(MathArithmeticException expected){}try {ArithmeticUtils.gcd(Integer.MIN_VALUE,Integer.MIN_VALUE);Assert.fail("expecting MathArithmeticException");}catch(MathArithmeticException expected){}}
@Test public void testGcdConsistency(){int[]primeList={19,23,53,67,73,79,101,103,111,131};ArrayList<Integer> primes=new ArrayList<Integer>();for (int i=0;i < primeList.length;i++){primes.add(Integer.valueOf(primeList[i]));}RandomDataImpl randomData=new RandomDataImpl();for (int i=0;i < 20;i++){Object[]sample=randomData.nextSample(primes,4);int p1=((Integer)sample[0]).intValue();int p2=((Integer)sample[1]).intValue();int p3=((Integer)sample[2]).intValue();int p4=((Integer)sample[3]).intValue();int i1=p1 * p2 * p3;int i2=p1 * p2 * p4;int gcd=p1 * p2;Assert.assertEquals(gcd,ArithmeticUtils.gcd(i1,i2));long l1=i1;long l2=i2;Assert.assertEquals(gcd,ArithmeticUtils.gcd(l1,l2));}}
@Test public void testGcdLong(){long a=30;long b=50;long c=77;Assert.assertEquals(0,ArithmeticUtils.gcd(0L,0));Assert.assertEquals(b,ArithmeticUtils.gcd(0,b));Assert.assertEquals(a,ArithmeticUtils.gcd(a,0));Assert.assertEquals(b,ArithmeticUtils.gcd(0,-b));Assert.assertEquals(a,ArithmeticUtils.gcd(-a,0));Assert.assertEquals(10,ArithmeticUtils.gcd(a,b));Assert.assertEquals(10,ArithmeticUtils.gcd(-a,b));Assert.assertEquals(10,ArithmeticUtils.gcd(a,-b));Assert.assertEquals(10,ArithmeticUtils.gcd(-a,-b));Assert.assertEquals(1,ArithmeticUtils.gcd(a,c));Assert.assertEquals(1,ArithmeticUtils.gcd(-a,c));Assert.assertEquals(1,ArithmeticUtils.gcd(a,-c));Assert.assertEquals(1,ArithmeticUtils.gcd(-a,-c));Assert.assertEquals(3L * (1L << 45),ArithmeticUtils.gcd(3L * (1L << 50),9L * (1L << 45)));Assert.assertEquals(1L << 45,ArithmeticUtils.gcd(1L << 45,Long.MIN_VALUE));Assert.assertEquals(Long.MAX_VALUE,ArithmeticUtils.gcd(Long.MAX_VALUE,0L));Assert.assertEquals(Long.MAX_VALUE,ArithmeticUtils.gcd(-Long.MAX_VALUE,0L));Assert.assertEquals(1,ArithmeticUtils.gcd(60247241209L,153092023L));try {ArithmeticUtils.gcd(Long.MIN_VALUE,0);Assert.fail("expecting MathArithmeticException");}catch(MathArithmeticException expected){}try {ArithmeticUtils.gcd(0,Long.MIN_VALUE);Assert.fail("expecting MathArithmeticException");}catch(MathArithmeticException expected){}try {ArithmeticUtils.gcd(Long.MIN_VALUE,Long.MIN_VALUE);Assert.fail("expecting MathArithmeticException");}catch(MathArithmeticException expected){}}
@Test public void testLcm(){int a=30;int b=50;int c=77;Assert.assertEquals(0,ArithmeticUtils.lcm(0,b));Assert.assertEquals(0,ArithmeticUtils.lcm(a,0));Assert.assertEquals(b,ArithmeticUtils.lcm(1,b));Assert.assertEquals(a,ArithmeticUtils.lcm(a,1));Assert.assertEquals(150,ArithmeticUtils.lcm(a,b));Assert.assertEquals(150,ArithmeticUtils.lcm(-a,b));Assert.assertEquals(150,ArithmeticUtils.lcm(a,-b));Assert.assertEquals(150,ArithmeticUtils.lcm(-a,-b));Assert.assertEquals(2310,ArithmeticUtils.lcm(a,c));Assert.assertEquals((1 << 20)* 15,ArithmeticUtils.lcm((1 << 20)* 3,(1 << 20)* 5));Assert.assertEquals(0,ArithmeticUtils.lcm(0,0));try {ArithmeticUtils.lcm(Integer.MIN_VALUE,1);Assert.fail("Expecting MathArithmeticException");}catch(MathArithmeticException expected){}try {ArithmeticUtils.lcm(Integer.MIN_VALUE,1 << 20);Assert.fail("Expecting MathArithmeticException");}catch(MathArithmeticException expected){}try {ArithmeticUtils.lcm(Integer.MAX_VALUE,Integer.MAX_VALUE - 1);Assert.fail("Expecting MathArithmeticException");}catch(MathArithmeticException expected){}}
@Test public void testLcmLong(){long a=30;long b=50;long c=77;Assert.assertEquals(0,ArithmeticUtils.lcm(0,b));Assert.assertEquals(0,ArithmeticUtils.lcm(a,0));Assert.assertEquals(b,ArithmeticUtils.lcm(1,b));Assert.assertEquals(a,ArithmeticUtils.lcm(a,1));Assert.assertEquals(150,ArithmeticUtils.lcm(a,b));Assert.assertEquals(150,ArithmeticUtils.lcm(-a,b));Assert.assertEquals(150,ArithmeticUtils.lcm(a,-b));Assert.assertEquals(150,ArithmeticUtils.lcm(-a,-b));Assert.assertEquals(2310,ArithmeticUtils.lcm(a,c));Assert.assertEquals(Long.MAX_VALUE,ArithmeticUtils.lcm(60247241209L,153092023L));Assert.assertEquals((1L << 50)* 15,ArithmeticUtils.lcm((1L << 45)* 3,(1L << 50)* 5));Assert.assertEquals(0L,ArithmeticUtils.lcm(0L,0L));try {ArithmeticUtils.lcm(Long.MIN_VALUE,1);Assert.fail("Expecting MathArithmeticException");}catch(MathArithmeticException expected){}try {ArithmeticUtils.lcm(Long.MIN_VALUE,1 << 20);Assert.fail("Expecting MathArithmeticException");}catch(MathArithmeticException expected){}Assert.assertEquals((long)Integer.MAX_VALUE * (Integer.MAX_VALUE - 1),ArithmeticUtils.lcm((long)Integer.MAX_VALUE,Integer.MAX_VALUE - 1));try {ArithmeticUtils.lcm(Long.MAX_VALUE,Long.MAX_VALUE - 1);Assert.fail("Expecting MathArithmeticException");}catch(MathArithmeticException expected){}}
@Test public void testMulAndCheck(){int big=Integer.MAX_VALUE;int bigNeg=Integer.MIN_VALUE;Assert.assertEquals(big,ArithmeticUtils.mulAndCheck(big,1));try {ArithmeticUtils.mulAndCheck(big,2);Assert.fail("Expecting MathArithmeticException");}catch(MathArithmeticException ex){}try {ArithmeticUtils.mulAndCheck(bigNeg,2);Assert.fail("Expecting MathArithmeticException");}catch(MathArithmeticException ex){}}
@Test public void testMulAndCheckLong(){long max=Long.MAX_VALUE;long min=Long.MIN_VALUE;Assert.assertEquals(max,ArithmeticUtils.mulAndCheck(max,1L));Assert.assertEquals(min,ArithmeticUtils.mulAndCheck(min,1L));Assert.assertEquals(0L,ArithmeticUtils.mulAndCheck(max,0L));Assert.assertEquals(0L,ArithmeticUtils.mulAndCheck(min,0L));Assert.assertEquals(max,ArithmeticUtils.mulAndCheck(1L,max));Assert.assertEquals(min,ArithmeticUtils.mulAndCheck(1L,min));Assert.assertEquals(0L,ArithmeticUtils.mulAndCheck(0L,max));Assert.assertEquals(0L,ArithmeticUtils.mulAndCheck(0L,min));Assert.assertEquals(1L,ArithmeticUtils.mulAndCheck(-1L,-1L));Assert.assertEquals(min,ArithmeticUtils.mulAndCheck(min / 2,2));testMulAndCheckLongFailure(max,2L);testMulAndCheckLongFailure(2L,max);testMulAndCheckLongFailure(min,2L);testMulAndCheckLongFailure(2L,min);testMulAndCheckLongFailure(min,-1L);testMulAndCheckLongFailure(-1L,min);}
@Test public void testSubAndCheck(){int big=Integer.MAX_VALUE;int bigNeg=Integer.MIN_VALUE;Assert.assertEquals(big,ArithmeticUtils.subAndCheck(big,0));Assert.assertEquals(bigNeg + 1,ArithmeticUtils.subAndCheck(bigNeg,-1));Assert.assertEquals(-1,ArithmeticUtils.subAndCheck(bigNeg,-big));try {ArithmeticUtils.subAndCheck(big,-1);Assert.fail("Expecting MathArithmeticException");}catch(MathArithmeticException ex){}try {ArithmeticUtils.subAndCheck(bigNeg,1);Assert.fail("Expecting MathArithmeticException");}catch(MathArithmeticException ex){}}
@Test public void testSubAndCheckErrorMessage(){int big=Integer.MAX_VALUE;try {ArithmeticUtils.subAndCheck(big,-1);Assert.fail("Expecting MathArithmeticException");}catch(MathArithmeticException ex){Assert.assertTrue(ex.getMessage().length()> 1);}}
@Test public void testSubAndCheckLong(){long max=Long.MAX_VALUE;long min=Long.MIN_VALUE;Assert.assertEquals(max,ArithmeticUtils.subAndCheck(max,0));Assert.assertEquals(min,ArithmeticUtils.subAndCheck(min,0));Assert.assertEquals(-max,ArithmeticUtils.subAndCheck(0,max));Assert.assertEquals(min + 1,ArithmeticUtils.subAndCheck(min,-1));Assert.assertEquals(-1,ArithmeticUtils.subAndCheck(-max - 1,-max));Assert.assertEquals(max,ArithmeticUtils.subAndCheck(-1,-1 - max));testSubAndCheckLongFailure(0L,min);testSubAndCheckLongFailure(max,-1L);testSubAndCheckLongFailure(min,1L);}
@Test public void testPow(){Assert.assertEquals(1801088541,ArithmeticUtils.pow(21,7));Assert.assertEquals(1,ArithmeticUtils.pow(21,0));try {ArithmeticUtils.pow(21,-7);Assert.fail("Expecting MathIllegalArgumentException");}catch(MathIllegalArgumentException e){}Assert.assertEquals(1801088541,ArithmeticUtils.pow(21,7l));Assert.assertEquals(1,ArithmeticUtils.pow(21,0l));try {ArithmeticUtils.pow(21,-7l);Assert.fail("Expecting MathIllegalArgumentException");}catch(MathIllegalArgumentException e){}Assert.assertEquals(1801088541l,ArithmeticUtils.pow(21l,7));Assert.assertEquals(1l,ArithmeticUtils.pow(21l,0));try {ArithmeticUtils.pow(21l,-7);Assert.fail("Expecting MathIllegalArgumentException");}catch(MathIllegalArgumentException e){}Assert.assertEquals(1801088541l,ArithmeticUtils.pow(21l,7l));Assert.assertEquals(1l,ArithmeticUtils.pow(21l,0l));try {ArithmeticUtils.pow(21l,-7l);Assert.fail("Expecting MathIllegalArgumentException");}catch(MathIllegalArgumentException e){}BigInteger twentyOne=BigInteger.valueOf(21l);Assert.assertEquals(BigInteger.valueOf(1801088541l),ArithmeticUtils.pow(twentyOne,7));Assert.assertEquals(BigInteger.ONE,ArithmeticUtils.pow(twentyOne,0));try {ArithmeticUtils.pow(twentyOne,-7);Assert.fail("Expecting MathIllegalArgumentException");}catch(MathIllegalArgumentException e){}Assert.assertEquals(BigInteger.valueOf(1801088541l),ArithmeticUtils.pow(twentyOne,7l));Assert.assertEquals(BigInteger.ONE,ArithmeticUtils.pow(twentyOne,0l));try {ArithmeticUtils.pow(twentyOne,-7l);Assert.fail("Expecting MathIllegalArgumentException");}catch(MathIllegalArgumentException e){}Assert.assertEquals(BigInteger.valueOf(1801088541l),ArithmeticUtils.pow(twentyOne,BigInteger.valueOf(7l)));Assert.assertEquals(BigInteger.ONE,ArithmeticUtils.pow(twentyOne,BigInteger.ZERO));try {ArithmeticUtils.pow(twentyOne,BigInteger.valueOf(-7l));Assert.fail("Expecting MathIllegalArgumentException");}catch(MathIllegalArgumentException e){}BigInteger bigOne=new BigInteger("1543786922199448028351389769265814882661837148" + "4763915343722775611762713982220306372888519211" + "560905579993523402015636025177602059044911261");Assert.assertEquals(bigOne,ArithmeticUtils.pow(twentyOne,103));Assert.assertEquals(bigOne,ArithmeticUtils.pow(twentyOne,103l));Assert.assertEquals(bigOne,ArithmeticUtils.pow(twentyOne,BigInteger.valueOf(103l)));}
@Test(expected=DimensionMismatchException.class)public void testDimensionCheck(){TestProblem1 pb=new TestProblem1();new GillIntegrator(0.01).integrate(pb,0.0,new double[pb.getDimension()+ 10],1.0,new double[pb.getDimension()+ 10]);Assert.fail("an exception should have been thrown");}
@Test public void testDecreasingSteps(){TestProblemAbstract[]problems=TestProblemFactory.getProblems();for (int k=0;k < problems.length;++k){double previousValueError=Double.NaN;double previousTimeError=Double.NaN;for (int i=5;i < 10;++i){TestProblemAbstract pb=problems[k].copy();double step=(pb.getFinalTime()- pb.getInitialTime())* FastMath.pow(2.0,-i);FirstOrderIntegrator integ=new GillIntegrator(step);TestProblemHandler handler=new TestProblemHandler(pb,integ);integ.addStepHandler(handler);EventHandler[]functions=pb.getEventsHandlers();for (int l=0;l < functions.length;++l){integ.addEventHandler(functions[l],Double.POSITIVE_INFINITY,1.0e-6 * step,1000);}double stopTime=integ.integrate(pb,pb.getInitialTime(),pb.getInitialState(),pb.getFinalTime(),new double[pb.getDimension()]);if (functions.length == 0){Assert.assertEquals(pb.getFinalTime(),stopTime,1.0e-10);}double valueError=handler.getMaximalValueError();if (i > 5){Assert.assertTrue(valueError < 1.01 * FastMath.abs(previousValueError));}previousValueError=valueError;double timeError=handler.getMaximalTimeError();if (i > 5){Assert.assertTrue(timeError <= FastMath.abs(previousTimeError));}previousTimeError=timeError;}}}
@Test public void testSmallStep(){TestProblem1 pb=new TestProblem1();double step=(pb.getFinalTime()- pb.getInitialTime())* 0.001;FirstOrderIntegrator integ=new GillIntegrator(step);TestProblemHandler handler=new TestProblemHandler(pb,integ);integ.addStepHandler(handler);integ.integrate(pb,pb.getInitialTime(),pb.getInitialState(),pb.getFinalTime(),new double[pb.getDimension()]);Assert.assertTrue(handler.getLastError()< 2.0e-13);Assert.assertTrue(handler.getMaximalValueError()< 4.0e-12);Assert.assertEquals(0,handler.getMaximalTimeError(),1.0e-12);Assert.assertEquals("Gill",integ.getName());}
@Test public void testBigStep(){TestProblem1 pb=new TestProblem1();double step=(pb.getFinalTime()- pb.getInitialTime())* 0.2;FirstOrderIntegrator integ=new GillIntegrator(step);TestProblemHandler handler=new TestProblemHandler(pb,integ);integ.addStepHandler(handler);integ.integrate(pb,pb.getInitialTime(),pb.getInitialState(),pb.getFinalTime(),new double[pb.getDimension()]);Assert.assertTrue(handler.getLastError()> 0.0004);Assert.assertTrue(handler.getMaximalValueError()> 0.005);Assert.assertEquals(0,handler.getMaximalTimeError(),1.0e-12);}
@Test public void testBackward(){TestProblem5 pb=new TestProblem5();double step=FastMath.abs(pb.getFinalTime()- pb.getInitialTime())* 0.001;FirstOrderIntegrator integ=new GillIntegrator(step);TestProblemHandler handler=new TestProblemHandler(pb,integ);integ.addStepHandler(handler);integ.integrate(pb,pb.getInitialTime(),pb.getInitialState(),pb.getFinalTime(),new double[pb.getDimension()]);Assert.assertTrue(handler.getLastError()< 5.0e-10);Assert.assertTrue(handler.getMaximalValueError()< 7.0e-10);Assert.assertEquals(0,handler.getMaximalTimeError(),1.0e-12);Assert.assertEquals("Gill",integ.getName());}
@Test public void testKepler(){final TestProblem3 pb=new TestProblem3(0.9);double step=(pb.getFinalTime()- pb.getInitialTime())* 0.0003;FirstOrderIntegrator integ=new GillIntegrator(step);integ.addStepHandler(new KeplerStepHandler(pb));integ.integrate(pb,pb.getInitialTime(),pb.getInitialState(),pb.getFinalTime(),new double[pb.getDimension()]);}
@Test public void testUnstableDerivative(){final StepProblem stepProblem=new StepProblem(0.0,1.0,2.0);FirstOrderIntegrator integ=new GillIntegrator(0.3);integ.addEventHandler(stepProblem,1.0,1.0e-12,1000);double[]y={Double.NaN};integ.integrate(stepProblem,0.0,new double[]{0.0},10.0,y);Assert.assertEquals(8.0,y[0],1.0e-12);}
@Test public void testStepSize(){final double step=1.23456;FirstOrderIntegrator integ=new GillIntegrator(step);integ.addStepHandler(new StepHandler(){public void handleStep(StepInterpolator interpolator,boolean isLast){if (!isLast){Assert.assertEquals(step,interpolator.getCurrentTime()- interpolator.getPreviousTime(),1.0e-12);}}public void init(double t0,double[]y0,double t){}});integ.integrate(new FirstOrderDifferentialEquations(){public void computeDerivatives(double t,double[]y,double[]dot){dot[0]=1.0;}public int getDimension(){return 1;}},0.0,new double[]{0.0},5.0,new double[1]);}
/** */@Test public void testPutTransformer(){NumberTransformer expected=new DefaultTransformer();TransformerMap map=new TransformerMap();map.putTransformer(TransformerMapTest.class,expected);Assert.assertEquals(expected,map.getTransformer(TransformerMapTest.class));}
/** */@Test public void testContainsClass(){NumberTransformer expected=new DefaultTransformer();TransformerMap map=new TransformerMap();map.putTransformer(TransformerMapTest.class,expected);Assert.assertTrue(map.containsClass(TransformerMapTest.class));}
/** */@Test public void testContainsTransformer(){NumberTransformer expected=new DefaultTransformer();TransformerMap map=new TransformerMap();map.putTransformer(TransformerMapTest.class,expected);Assert.assertTrue(map.containsTransformer(expected));}
/** */@Test public void testRemoveTransformer(){NumberTransformer expected=new DefaultTransformer();TransformerMap map=new TransformerMap();map.putTransformer(TransformerMapTest.class,expected);Assert.assertTrue(map.containsClass(TransformerMapTest.class));Assert.assertTrue(map.containsTransformer(expected));map.removeTransformer(TransformerMapTest.class);Assert.assertFalse(map.containsClass(TransformerMapTest.class));Assert.assertFalse(map.containsTransformer(expected));}
/** */@Test public void testClear(){NumberTransformer expected=new DefaultTransformer();TransformerMap map=new TransformerMap();map.putTransformer(TransformerMapTest.class,expected);Assert.assertTrue(map.containsClass(TransformerMapTest.class));map.clear();Assert.assertFalse(map.containsClass(TransformerMapTest.class));}
/** */@Test public void testClasses(){NumberTransformer expected=new DefaultTransformer();TransformerMap map=new TransformerMap();map.putTransformer(TransformerMapTest.class,expected);Assert.assertTrue(map.classes().contains(TransformerMapTest.class));}
/** */@Test public void testTransformers(){NumberTransformer expected=new DefaultTransformer();TransformerMap map=new TransformerMap();map.putTransformer(TransformerMapTest.class,expected);Assert.assertTrue(map.transformers().contains(expected));}
@Test public void testSerial(){NumberTransformer expected=new DefaultTransformer();TransformerMap map=new TransformerMap();map.putTransformer(TransformerMapTest.class,expected);Assert.assertEquals(map,TestUtils.serializeAndRecover(map));}
@Test public void testSinMin(){UnivariateFunction f=new SinFunction();UnivariateRealOptimizer underlying=new BrentOptimizer(1e-10,1e-14);JDKRandomGenerator g=new JDKRandomGenerator();g.setSeed(44428400075l);MultiStartUnivariateRealOptimizer<UnivariateFunction> optimizer=new MultiStartUnivariateRealOptimizer<UnivariateFunction>(underlying,10,g);optimizer.optimize(300,f,GoalType.MINIMIZE,-100.0,100.0);UnivariateRealPointValuePair[]optima=optimizer.getOptima();for (int i=1;i < optima.length;++i){double d=(optima[i].getPoint()- optima[i - 1].getPoint())/ (2 * FastMath.PI);Assert.assertTrue(FastMath.abs(d - FastMath.rint(d))< 1.0e-8);Assert.assertEquals(-1.0,f.value(optima[i].getPoint()),1.0e-10);Assert.assertEquals(f.value(optima[i].getPoint()),optima[i].getValue(),1.0e-10);}Assert.assertTrue(optimizer.getEvaluations()> 200);Assert.assertTrue(optimizer.getEvaluations()< 300);}
@Test public void testQuinticMin(){UnivariateFunction f=new QuinticFunction();UnivariateRealOptimizer underlying=new BrentOptimizer(1e-9,1e-14);JDKRandomGenerator g=new JDKRandomGenerator();g.setSeed(4312000053L);MultiStartUnivariateRealOptimizer<UnivariateFunction> optimizer=new MultiStartUnivariateRealOptimizer<UnivariateFunction>(underlying,5,g);UnivariateRealPointValuePair optimum=optimizer.optimize(300,f,GoalType.MINIMIZE,-0.3,-0.2);Assert.assertEquals(-0.2719561293,optimum.getPoint(),1e-9);Assert.assertEquals(-0.0443342695,optimum.getValue(),1e-9);UnivariateRealPointValuePair[]optima=optimizer.getOptima();for (int i=0;i < optima.length;++i){Assert.assertEquals(f.value(optima[i].getPoint()),optima[i].getValue(),1e-9);}Assert.assertTrue(optimizer.getEvaluations()>= 50);Assert.assertTrue(optimizer.getEvaluations()<= 100);}
@Test public void testBadFunction(){UnivariateFunction f=new UnivariateFunction(){public double value(double x){if (x < 0){throw new LocalException();}return 0;}};UnivariateRealOptimizer underlying=new BrentOptimizer(1e-9,1e-14);JDKRandomGenerator g=new JDKRandomGenerator();g.setSeed(4312000053L);MultiStartUnivariateRealOptimizer<UnivariateFunction> optimizer=new MultiStartUnivariateRealOptimizer<UnivariateFunction>(underlying,5,g);try {optimizer.optimize(300,f,GoalType.MINIMIZE,-0.3,-0.2);Assert.fail();}catch(LocalException e){}Assert.assertTrue(optimizer.getOptima()[0]== null);}
@Test public void testEndPoints(){Vector3D p1=new Vector3D(-1,-7,2);Vector3D p2=new Vector3D(7,-1,0);Segment segment=new Segment(p1,p2,new Line(p1,p2));SubLine sub=new SubLine(segment);List<Segment> segments=sub.getSegments();Assert.assertEquals(1,segments.size());Assert.assertEquals(0.0,new Vector3D(-1,-7,2).distance(segments.get(0).getStart()),1.0e-10);Assert.assertEquals(0.0,new Vector3D(7,-1,0).distance(segments.get(0).getEnd()),1.0e-10);}
@Test public void testNoEndPoints(){SubLine wholeLine=new Line(new Vector3D(-1,7,2),new Vector3D(7,1,0)).wholeLine();List<Segment> segments=wholeLine.getSegments();Assert.assertEquals(1,segments.size());Assert.assertTrue(Double.isInfinite(segments.get(0).getStart().getX())&& segments.get(0).getStart().getX()< 0);Assert.assertTrue(Double.isInfinite(segments.get(0).getStart().getY())&& segments.get(0).getStart().getY()> 0);Assert.assertTrue(Double.isInfinite(segments.get(0).getStart().getZ())&& segments.get(0).getStart().getZ()> 0);Assert.assertTrue(Double.isInfinite(segments.get(0).getEnd().getX())&& segments.get(0).getEnd().getX()> 0);Assert.assertTrue(Double.isInfinite(segments.get(0).getEnd().getY())&& segments.get(0).getEnd().getY()< 0);Assert.assertTrue(Double.isInfinite(segments.get(0).getEnd().getZ())&& segments.get(0).getEnd().getZ()< 0);}
@Test public void testNoSegments(){SubLine empty=new SubLine(new Line(new Vector3D(-1,-7,2),new Vector3D(7,-1,0)),(IntervalsSet)new RegionFactory<Euclidean1D>().getComplement(new IntervalsSet()));List<Segment> segments=empty.getSegments();Assert.assertEquals(0,segments.size());}
@Test public void testSeveralSegments(){SubLine twoSubs=new SubLine(new Line(new Vector3D(-1,-7,2),new Vector3D(7,-1,0)),(IntervalsSet)new RegionFactory<Euclidean1D>().union(new IntervalsSet(1,2),new IntervalsSet(3,4)));List<Segment> segments=twoSubs.getSegments();Assert.assertEquals(2,segments.size());}
@Test public void testHalfInfiniteNeg(){SubLine empty=new SubLine(new Line(new Vector3D(-1,-7,2),new Vector3D(7,-1,-2)),new IntervalsSet(Double.NEGATIVE_INFINITY,0.0));List<Segment> segments=empty.getSegments();Assert.assertEquals(1,segments.size());Assert.assertTrue(Double.isInfinite(segments.get(0).getStart().getX())&& segments.get(0).getStart().getX()< 0);Assert.assertTrue(Double.isInfinite(segments.get(0).getStart().getY())&& segments.get(0).getStart().getY()< 0);Assert.assertTrue(Double.isInfinite(segments.get(0).getStart().getZ())&& segments.get(0).getStart().getZ()> 0);Assert.assertEquals(0.0,new Vector3D(3,-4,0).distance(segments.get(0).getEnd()),1.0e-10);}
@Test public void testHalfInfinitePos(){SubLine empty=new SubLine(new Line(new Vector3D(-1,-7,2),new Vector3D(7,-1,-2)),new IntervalsSet(0.0,Double.POSITIVE_INFINITY));List<Segment> segments=empty.getSegments();Assert.assertEquals(1,segments.size());Assert.assertEquals(0.0,new Vector3D(3,-4,0).distance(segments.get(0).getStart()),1.0e-10);Assert.assertTrue(Double.isInfinite(segments.get(0).getEnd().getX())&& segments.get(0).getEnd().getX()> 0);Assert.assertTrue(Double.isInfinite(segments.get(0).getEnd().getY())&& segments.get(0).getEnd().getY()> 0);Assert.assertTrue(Double.isInfinite(segments.get(0).getEnd().getZ())&& segments.get(0).getEnd().getZ()< 0);}
@Test public void testIntersectionInsideInside(){SubLine sub1=new SubLine(new Vector3D(1,1,1),new Vector3D(3,1,1));SubLine sub2=new SubLine(new Vector3D(2,0,0),new Vector3D(2,2,2));Assert.assertEquals(0.0,new Vector3D(2,1,1).distance(sub1.intersection(sub2,true)),1.0e-12);Assert.assertEquals(0.0,new Vector3D(2,1,1).distance(sub1.intersection(sub2,false)),1.0e-12);}
@Test public void testIntersectionInsideBoundary(){SubLine sub1=new SubLine(new Vector3D(1,1,1),new Vector3D(3,1,1));SubLine sub2=new SubLine(new Vector3D(2,0,0),new Vector3D(2,1,1));Assert.assertEquals(0.0,new Vector3D(2,1,1).distance(sub1.intersection(sub2,true)),1.0e-12);Assert.assertNull(sub1.intersection(sub2,false));}
@Test public void testIntersectionInsideOutside(){SubLine sub1=new SubLine(new Vector3D(1,1,1),new Vector3D(3,1,1));SubLine sub2=new SubLine(new Vector3D(2,0,0),new Vector3D(2,0.5,0.5));Assert.assertNull(sub1.intersection(sub2,true));Assert.assertNull(sub1.intersection(sub2,false));}
@Test public void testIntersectionBoundaryBoundary(){SubLine sub1=new SubLine(new Vector3D(1,1,1),new Vector3D(2,1,1));SubLine sub2=new SubLine(new Vector3D(2,0,0),new Vector3D(2,1,1));Assert.assertEquals(0.0,new Vector3D(2,1,1).distance(sub1.intersection(sub2,true)),1.0e-12);Assert.assertNull(sub1.intersection(sub2,false));}
@Test public void testIntersectionBoundaryOutside(){SubLine sub1=new SubLine(new Vector3D(1,1,1),new Vector3D(2,1,1));SubLine sub2=new SubLine(new Vector3D(2,0,0),new Vector3D(2,0.5,0.5));Assert.assertNull(sub1.intersection(sub2,true));Assert.assertNull(sub1.intersection(sub2,false));}
@Test public void testIntersectionOutsideOutside(){SubLine sub1=new SubLine(new Vector3D(1,1,1),new Vector3D(1.5,1,1));SubLine sub2=new SubLine(new Vector3D(2,0,0),new Vector3D(2,0.5,0.5));Assert.assertNull(sub1.intersection(sub2,true));Assert.assertNull(sub1.intersection(sub2,false));}
@Test public void testAccessors(){final OutOfRangeException e=new OutOfRangeException(-1,0,2);Assert.assertEquals(-1,e.getArgument());Assert.assertEquals(0,e.getLo());Assert.assertEquals(2,e.getHi());}
/** * Test preconditions.*/@Test public void testPreconditions(){double[]xval=new double[]{3,4,5,6.5};double[]yval=new double[]{-4,-3,-1,2.5};double[][]zval=new double[xval.length][yval.length];BivariateRealGridInterpolator interpolator=new BicubicSplineInterpolator();@SuppressWarnings("unused")BivariateRealFunction p=interpolator.interpolate(xval,yval,zval);double[]wxval=new double[]{3,2,5,6.5};try {p=interpolator.interpolate(wxval,yval,zval);Assert.fail("an exception should have been thrown");}catch(MathIllegalArgumentException e){}double[]wyval=new double[]{-4,-3,-1,-1};try {p=interpolator.interpolate(xval,wyval,zval);Assert.fail("an exception should have been thrown");}catch(MathIllegalArgumentException e){}double[][]wzval=new double[xval.length][yval.length + 1];try {p=interpolator.interpolate(xval,yval,wzval);Assert.fail("an exception should have been thrown");}catch(DimensionMismatchException e){}wzval=new double[xval.length - 1][yval.length];try {p=interpolator.interpolate(xval,yval,wzval);Assert.fail("an exception should have been thrown");}catch(DimensionMismatchException e){}}
/** * Test of interpolator for a plane. <p> z = 2 x - 3 y + 5*/@Test public void testPlane(){BivariateRealFunction f=new BivariateRealFunction(){public double value(double x,double y){return 2 * x - 3 * y + 5;}};BivariateRealGridInterpolator interpolator=new BicubicSplineInterpolator();double[]xval=new double[]{3,4,5,6.5};double[]yval=new double[]{-4,-3,-1,2,2.5};double[][]zval=new double[xval.length][yval.length];for (int i=0;i < xval.length;i++){for (int j=0;j < yval.length;j++){zval[i][j]=f.value(xval[i],yval[j]);}}BivariateRealFunction p=interpolator.interpolate(xval,yval,zval);double x,y;double expected,result;x=4;y=-3;expected=f.value(x,y);result=p.value(x,y);Assert.assertEquals("On sample point",expected,result,1e-15);x=4.5;y=-1.5;expected=f.value(x,y);result=p.value(x,y);Assert.assertEquals("half-way between sample points (middle of the patch)",expected,result,0.3);x=3.5;y=-3.5;expected=f.value(x,y);result=p.value(x,y);Assert.assertEquals("half-way between sample points (border of the patch)",expected,result,0.3);}
/** * Test of interpolator for a paraboloid. <p> z = 2 x<sup>2</sup> - 3 y<sup>2</sup> + 4 x y - 5*/@Test public void testParaboloid(){BivariateRealFunction f=new BivariateRealFunction(){public double value(double x,double y){return 2 * x * x - 3 * y * y + 4 * x * y - 5;}};BivariateRealGridInterpolator interpolator=new BicubicSplineInterpolator();double[]xval=new double[]{3,4,5,6.5};double[]yval=new double[]{-4,-3,-2,-1,0.5,2.5};double[][]zval=new double[xval.length][yval.length];for (int i=0;i < xval.length;i++){for (int j=0;j < yval.length;j++){zval[i][j]=f.value(xval[i],yval[j]);}}BivariateRealFunction p=interpolator.interpolate(xval,yval,zval);double x,y;double expected,result;x=5;y=0.5;expected=f.value(x,y);result=p.value(x,y);Assert.assertEquals("On sample point",expected,result,1e-13);x=4.5;y=-1.5;expected=f.value(x,y);result=p.value(x,y);Assert.assertEquals("half-way between sample points (middle of the patch)",expected,result,0.2);x=3.5;y=-3.5;expected=f.value(x,y);result=p.value(x,y);Assert.assertEquals("half-way between sample points (border of the patch)",expected,result,0.2);}
/** * Test for events that occur at the exact same time,but due to numerical calculations occur very close together instead. Uses event type 0. See {@link org.apache.commons.math.ode.events.EventHandler#g(double,double[])EventHandler.g(double,double[])}.*/@Test public void testOverlappingEvents0(){test(0);}
/** * Test for events that occur at the exact same time,but due to numerical calculations occur very close together instead. Uses event type 1. See {@link org.apache.commons.math.ode.events.EventHandler#g(double,double[])EventHandler.g(double,double[])}.*/@Test public void testOverlappingEvents1(){test(1);}
/** * Test for events that occur at the exact same time,but due to numerical calculations occur very close together instead.* @param eventType the type of events to use. See{@link org.apache.commons.math.ode.events.EventHandler#g(double,double[])EventHandler.g(double,double[])}.*/public void test(int eventType){double e=1e-15;FirstOrderIntegrator integrator=new DormandPrince853Integrator(e,100.0,1e-7,1e-7);BaseSecantSolver rootSolver=new PegasusSolver(e,e);EventHandler evt1=new Event(0,eventType);EventHandler evt2=new Event(1,eventType);integrator.addEventHandler(evt1,0.1,e,999,rootSolver);integrator.addEventHandler(evt2,0.1,e,999,rootSolver);double t=0.0;double tEnd=10.0;double[]y={0.0,0.0};List<Double> events1=new ArrayList<Double>();List<Double> events2=new ArrayList<Double>();while (t < tEnd){t=integrator.integrate(this,t,y,tEnd,y);if (y[0]>= 1.0){y[0]=0.0;events1.add(t);}if (y[1]>= 1.0){y[1]=0.0;events2.add(t);}}Assert.assertEquals(EVENT_TIMES1.length,events1.size());Assert.assertEquals(EVENT_TIMES2.length,events2.size());for (int i=0;i < EVENT_TIMES1.length;i++){Assert.assertEquals(EVENT_TIMES1[i],events1.get(i),1e-7);}for (int i=0;i < EVENT_TIMES2.length;i++){Assert.assertEquals(EVENT_TIMES2[i],events2.get(i),1e-7);}}
/** * test dimensions */@Test public void testDimensions(){Array2DRowRealMatrix m=new Array2DRowRealMatrix(testData);Array2DRowRealMatrix m2=new Array2DRowRealMatrix(testData2);Assert.assertEquals("testData row dimension",3,m.getRowDimension());Assert.assertEquals("testData column dimension",3,m.getColumnDimension());Assert.assertTrue("testData is square",m.isSquare());Assert.assertEquals("testData2 row dimension",m2.getRowDimension(),2);Assert.assertEquals("testData2 column dimension",m2.getColumnDimension(),3);Assert.assertTrue("testData2 is not square",!m2.isSquare());}
/** * test copy functions */@Test public void testCopyFunctions(){Array2DRowRealMatrix m1=new Array2DRowRealMatrix(testData);Array2DRowRealMatrix m2=new Array2DRowRealMatrix(m1.getData());Assert.assertEquals(m2,m1);Array2DRowRealMatrix m3=new Array2DRowRealMatrix(testData);Array2DRowRealMatrix m4=new Array2DRowRealMatrix(m3.getData(),false);Assert.assertEquals(m4,m3);}
/** * test add */@Test public void testAdd(){Array2DRowRealMatrix m=new Array2DRowRealMatrix(testData);Array2DRowRealMatrix mInv=new Array2DRowRealMatrix(testDataInv);RealMatrix mPlusMInv=m.add(mInv);double[][]sumEntries=mPlusMInv.getData();for (int row=0;row < m.getRowDimension();row++){for (int col=0;col < m.getColumnDimension();col++){Assert.assertEquals("sum entry entry",testDataPlusInv[row][col],sumEntries[row][col],entryTolerance);}}}
/** * test add failure */@Test public void testAddFail(){Array2DRowRealMatrix m=new Array2DRowRealMatrix(testData);Array2DRowRealMatrix m2=new Array2DRowRealMatrix(testData2);try {m.add(m2);Assert.fail("MathIllegalArgumentException expected");}catch(MathIllegalArgumentException ex){}}
/** * test norm */@Test public void testNorm(){Array2DRowRealMatrix m=new Array2DRowRealMatrix(testData);Array2DRowRealMatrix m2=new Array2DRowRealMatrix(testData2);Assert.assertEquals("testData norm",14d,m.getNorm(),entryTolerance);Assert.assertEquals("testData2 norm",7d,m2.getNorm(),entryTolerance);}
/** * test Frobenius norm */@Test public void testFrobeniusNorm(){Array2DRowRealMatrix m=new Array2DRowRealMatrix(testData);Array2DRowRealMatrix m2=new Array2DRowRealMatrix(testData2);Assert.assertEquals("testData Frobenius norm",FastMath.sqrt(117.0),m.getFrobeniusNorm(),entryTolerance);Assert.assertEquals("testData2 Frobenius norm",FastMath.sqrt(52.0),m2.getFrobeniusNorm(),entryTolerance);}
/** * test m-n = m + -n */@Test public void testPlusMinus(){Array2DRowRealMatrix m=new Array2DRowRealMatrix(testData);Array2DRowRealMatrix m2=new Array2DRowRealMatrix(testDataInv);TestUtils.assertEquals("m-n = m + -n",m.subtract(m2),m2.scalarMultiply(-1d).add(m),entryTolerance);try {m.subtract(new Array2DRowRealMatrix(testData2));Assert.fail("Expecting illegalArgumentException");}catch(MathIllegalArgumentException ex){}}
/** * test multiply */@Test public void testMultiply(){Array2DRowRealMatrix m=new Array2DRowRealMatrix(testData);Array2DRowRealMatrix mInv=new Array2DRowRealMatrix(testDataInv);Array2DRowRealMatrix identity=new Array2DRowRealMatrix(id);Array2DRowRealMatrix m2=new Array2DRowRealMatrix(testData2);TestUtils.assertEquals("inverse multiply",m.multiply(mInv),identity,entryTolerance);TestUtils.assertEquals("inverse multiply",mInv.multiply(m),identity,entryTolerance);TestUtils.assertEquals("identity multiply",m.multiply(identity),m,entryTolerance);TestUtils.assertEquals("identity multiply",identity.multiply(mInv),mInv,entryTolerance);TestUtils.assertEquals("identity multiply",m2.multiply(identity),m2,entryTolerance);try {m.multiply(new Array2DRowRealMatrix(bigSingular));Assert.fail("Expecting illegalArgumentException");}catch(MathIllegalArgumentException ex){}}
@Test public void testMultiply2(){RealMatrix m3=new Array2DRowRealMatrix(d3);RealMatrix m4=new Array2DRowRealMatrix(d4);RealMatrix m5=new Array2DRowRealMatrix(d5);TestUtils.assertEquals("m3*m4=m5",m3.multiply(m4),m5,entryTolerance);}
@Test public void testPower(){Array2DRowRealMatrix m=new Array2DRowRealMatrix(testData);Array2DRowRealMatrix mInv=new Array2DRowRealMatrix(testDataInv);Array2DRowRealMatrix mPlusInv=new Array2DRowRealMatrix(testDataPlusInv);Array2DRowRealMatrix identity=new Array2DRowRealMatrix(id);TestUtils.assertEquals("m^0",m.power(0),identity,entryTolerance);TestUtils.assertEquals("mInv^0",mInv.power(0),identity,entryTolerance);TestUtils.assertEquals("mPlusInv^0",mPlusInv.power(0),identity,entryTolerance);TestUtils.assertEquals("m^1",m.power(1),m,entryTolerance);TestUtils.assertEquals("mInv^1",mInv.power(1),mInv,entryTolerance);TestUtils.assertEquals("mPlusInv^1",mPlusInv.power(1),mPlusInv,entryTolerance);RealMatrix C1=m.copy();RealMatrix C2=mInv.copy();RealMatrix C3=mPlusInv.copy();for (int i=2;i <= 10;++i){C1=C1.multiply(m);C2=C2.multiply(mInv);C3=C3.multiply(mPlusInv);TestUtils.assertEquals("m^" + i,m.power(i),C1,entryTolerance);TestUtils.assertEquals("mInv^" + i,mInv.power(i),C2,entryTolerance);TestUtils.assertEquals("mPlusInv^" + i,mPlusInv.power(i),C3,entryTolerance);}try {Array2DRowRealMatrix mNotSquare=new Array2DRowRealMatrix(testData2T);mNotSquare.power(2);Assert.fail("Expecting NonSquareMatrixException");}catch(NonSquareMatrixException ex){}try {m.power(-1);Assert.fail("Expecting IllegalArgumentException");}catch(IllegalArgumentException ex){}}
/** * test trace */@Test public void testTrace(){RealMatrix m=new Array2DRowRealMatrix(id);Assert.assertEquals("identity trace",3d,m.getTrace(),entryTolerance);m=new Array2DRowRealMatrix(testData2);try {m.getTrace();Assert.fail("Expecting NonSquareMatrixException");}catch(NonSquareMatrixException ex){}}
/** * test sclarAdd */@Test public void testScalarAdd(){RealMatrix m=new Array2DRowRealMatrix(testData);TestUtils.assertEquals("scalar add",new Array2DRowRealMatrix(testDataPlus2),m.scalarAdd(2d),entryTolerance);}
/** * test operate */@Test public void testOperate(){RealMatrix m=new Array2DRowRealMatrix(id);TestUtils.assertEquals("identity operate",testVector,m.operate(testVector),entryTolerance);TestUtils.assertEquals("identity operate",testVector,m.operate(new ArrayRealVector(testVector)).toArray(),entryTolerance);m=new Array2DRowRealMatrix(bigSingular);try {m.operate(testVector);Assert.fail("Expecting illegalArgumentException");}catch(MathIllegalArgumentException ex){}}
/** * test issue MATH-209 */@Test public void testMath209(){RealMatrix a=new Array2DRowRealMatrix(new double[][]{{1,2},{3,4},{5,6}},false);double[]b=a.operate(new double[]{1,1});Assert.assertEquals(a.getRowDimension(),b.length);Assert.assertEquals(3.0,b[0],1.0e-12);Assert.assertEquals(7.0,b[1],1.0e-12);Assert.assertEquals(11.0,b[2],1.0e-12);}
/** * test transpose */@Test public void testTranspose(){RealMatrix m=new Array2DRowRealMatrix(testData);RealMatrix mIT=new LUDecomposition(m).getSolver().getInverse().transpose();RealMatrix mTI=new LUDecomposition(m.transpose()).getSolver().getInverse();TestUtils.assertEquals("inverse-transpose",mIT,mTI,normTolerance);m=new Array2DRowRealMatrix(testData2);RealMatrix mt=new Array2DRowRealMatrix(testData2T);TestUtils.assertEquals("transpose",mt,m.transpose(),normTolerance);}
/** * test preMultiply by vector */@Test public void testPremultiplyVector(){RealMatrix m=new Array2DRowRealMatrix(testData);TestUtils.assertEquals("premultiply",m.preMultiply(testVector),preMultTest,normTolerance);TestUtils.assertEquals("premultiply",m.preMultiply(new ArrayRealVector(testVector).toArray()),preMultTest,normTolerance);m=new Array2DRowRealMatrix(bigSingular);try {m.preMultiply(testVector);Assert.fail("expecting MathIllegalArgumentException");}catch(MathIllegalArgumentException ex){}}
@Test public void testPremultiply(){RealMatrix m3=new Array2DRowRealMatrix(d3);RealMatrix m4=new Array2DRowRealMatrix(d4);RealMatrix m5=new Array2DRowRealMatrix(d5);TestUtils.assertEquals("m3*m4=m5",m4.preMultiply(m3),m5,entryTolerance);Array2DRowRealMatrix m=new Array2DRowRealMatrix(testData);Array2DRowRealMatrix mInv=new Array2DRowRealMatrix(testDataInv);Array2DRowRealMatrix identity=new Array2DRowRealMatrix(id);TestUtils.assertEquals("inverse multiply",m.preMultiply(mInv),identity,entryTolerance);TestUtils.assertEquals("inverse multiply",mInv.preMultiply(m),identity,entryTolerance);TestUtils.assertEquals("identity multiply",m.preMultiply(identity),m,entryTolerance);TestUtils.assertEquals("identity multiply",identity.preMultiply(mInv),mInv,entryTolerance);try {m.preMultiply(new Array2DRowRealMatrix(bigSingular));Assert.fail("Expecting illegalArgumentException");}catch(MathIllegalArgumentException ex){}}
@Test public void testGetVectors(){RealMatrix m=new Array2DRowRealMatrix(testData);TestUtils.assertEquals("get row",m.getRow(0),testDataRow1,entryTolerance);TestUtils.assertEquals("get col",m.getColumn(2),testDataCol3,entryTolerance);try {m.getRow(10);Assert.fail("expecting OutOfRangeException");}catch(OutOfRangeException ex){}try {m.getColumn(-1);Assert.fail("expecting OutOfRangeException");}catch(OutOfRangeException ex){}}
@Test public void testGetEntry(){RealMatrix m=new Array2DRowRealMatrix(testData);Assert.assertEquals("get entry",m.getEntry(0,1),2d,entryTolerance);try {m.getEntry(10,4);Assert.fail("Expecting OutOfRangeException");}catch(OutOfRangeException ex){}}
/** * test examples in user guide */@Test public void testExamples(){double[][]matrixData={{1d,2d,3d},{2d,5d,3d}};RealMatrix m=new Array2DRowRealMatrix(matrixData);double[][]matrixData2={{1d,2d},{2d,5d},{1d,7d}};RealMatrix n=new Array2DRowRealMatrix(matrixData2);RealMatrix p=m.multiply(n);Assert.assertEquals(2,p.getRowDimension());Assert.assertEquals(2,p.getColumnDimension());RealMatrix pInverse=new LUDecomposition(p).getSolver().getInverse();Assert.assertEquals(2,pInverse.getRowDimension());Assert.assertEquals(2,pInverse.getColumnDimension());double[][]coefficientsData={{2,3,-2},{-1,7,6},{4,-3,-5}};RealMatrix coefficients=new Array2DRowRealMatrix(coefficientsData);RealVector constants=new ArrayRealVector(new double[]{1,-2,1},false);RealVector solution=new LUDecomposition(coefficients).getSolver().solve(constants);final double cst0=constants.getEntry(0);final double cst1=constants.getEntry(1);final double cst2=constants.getEntry(2);final double sol0=solution.getEntry(0);final double sol1=solution.getEntry(1);final double sol2=solution.getEntry(2);Assert.assertEquals(2 * sol0 + 3 * sol1 - 2 * sol2,cst0,1E-12);Assert.assertEquals(-1 * sol0 + 7 * sol1 + 6 * sol2,cst1,1E-12);Assert.assertEquals(4 * sol0 - 3 * sol1 - 5 * sol2,cst2,1E-12);}
@Test public void testGetSubMatrix(){RealMatrix m=new Array2DRowRealMatrix(subTestData);checkGetSubMatrix(m,subRows23Cols00,2,3,0,0,false);checkGetSubMatrix(m,subRows00Cols33,0,0,3,3,false);checkGetSubMatrix(m,subRows01Cols23,0,1,2,3,false);checkGetSubMatrix(m,subRows02Cols13,new int[]{0,2},new int[]{1,3},false);checkGetSubMatrix(m,subRows03Cols12,new int[]{0,3},new int[]{1,2},false);checkGetSubMatrix(m,subRows03Cols123,new int[]{0,3},new int[]{1,2,3},false);checkGetSubMatrix(m,subRows20Cols123,new int[]{2,0},new int[]{1,2,3},false);checkGetSubMatrix(m,subRows31Cols31,new int[]{3,1},new int[]{3,1},false);checkGetSubMatrix(m,subRows31Cols31,new int[]{3,1},new int[]{3,1},false);checkGetSubMatrix(m,null,1,0,2,4,true);checkGetSubMatrix(m,null,-1,1,2,2,true);checkGetSubMatrix(m,null,1,0,2,2,true);checkGetSubMatrix(m,null,1,0,2,4,true);checkGetSubMatrix(m,null,new int[]{},new int[]{0},true);checkGetSubMatrix(m,null,new int[]{0},new int[]{4},true);}
@Test public void testCopySubMatrix(){RealMatrix m=new Array2DRowRealMatrix(subTestData);checkCopy(m,subRows23Cols00,2,3,0,0,false);checkCopy(m,subRows00Cols33,0,0,3,3,false);checkCopy(m,subRows01Cols23,0,1,2,3,false);checkCopy(m,subRows02Cols13,new int[]{0,2},new int[]{1,3},false);checkCopy(m,subRows03Cols12,new int[]{0,3},new int[]{1,2},false);checkCopy(m,subRows03Cols123,new int[]{0,3},new int[]{1,2,3},false);checkCopy(m,subRows20Cols123,new int[]{2,0},new int[]{1,2,3},false);checkCopy(m,subRows31Cols31,new int[]{3,1},new int[]{3,1},false);checkCopy(m,subRows31Cols31,new int[]{3,1},new int[]{3,1},false);checkCopy(m,null,1,0,2,4,true);checkCopy(m,null,-1,1,2,2,true);checkCopy(m,null,1,0,2,2,true);checkCopy(m,null,1,0,2,4,true);checkCopy(m,null,new int[]{},new int[]{0},true);checkCopy(m,null,new int[]{0},new int[]{4},true);}
@Test public void testGetRowMatrix(){RealMatrix m=new Array2DRowRealMatrix(subTestData);RealMatrix mRow0=new Array2DRowRealMatrix(subRow0);RealMatrix mRow3=new Array2DRowRealMatrix(subRow3);Assert.assertEquals("Row0",mRow0,m.getRowMatrix(0));Assert.assertEquals("Row3",mRow3,m.getRowMatrix(3));try {m.getRowMatrix(-1);Assert.fail("Expecting OutOfRangeException");}catch(OutOfRangeException ex){}try {m.getRowMatrix(4);Assert.fail("Expecting OutOfRangeException");}catch(OutOfRangeException ex){}}
@Test public void testSetRowMatrix(){RealMatrix m=new Array2DRowRealMatrix(subTestData);RealMatrix mRow3=new Array2DRowRealMatrix(subRow3);Assert.assertNotSame(mRow3,m.getRowMatrix(0));m.setRowMatrix(0,mRow3);Assert.assertEquals(mRow3,m.getRowMatrix(0));try {m.setRowMatrix(-1,mRow3);Assert.fail("Expecting OutOfRangeException");}catch(OutOfRangeException ex){}try {m.setRowMatrix(0,m);Assert.fail("Expecting MatrixDimensionMismatchException");}catch(MatrixDimensionMismatchException ex){}}
@Test public void testGetColumnMatrix(){RealMatrix m=new Array2DRowRealMatrix(subTestData);RealMatrix mColumn1=new Array2DRowRealMatrix(subColumn1);RealMatrix mColumn3=new Array2DRowRealMatrix(subColumn3);Assert.assertEquals("Column1",mColumn1,m.getColumnMatrix(1));Assert.assertEquals("Column3",mColumn3,m.getColumnMatrix(3));try {m.getColumnMatrix(-1);Assert.fail("Expecting OutOfRangeException");}catch(OutOfRangeException ex){}try {m.getColumnMatrix(4);Assert.fail("Expecting OutOfRangeException");}catch(OutOfRangeException ex){}}
@Test public void testSetColumnMatrix(){RealMatrix m=new Array2DRowRealMatrix(subTestData);RealMatrix mColumn3=new Array2DRowRealMatrix(subColumn3);Assert.assertNotSame(mColumn3,m.getColumnMatrix(1));m.setColumnMatrix(1,mColumn3);Assert.assertEquals(mColumn3,m.getColumnMatrix(1));try {m.setColumnMatrix(-1,mColumn3);Assert.fail("Expecting OutOfRangeException");}catch(OutOfRangeException ex){}try {m.setColumnMatrix(0,m);Assert.fail("Expecting MatrixDimensionMismatchException");}catch(MatrixDimensionMismatchException ex){}}
@Test public void testGetRowVector(){RealMatrix m=new Array2DRowRealMatrix(subTestData);RealVector mRow0=new ArrayRealVector(subRow0[0]);RealVector mRow3=new ArrayRealVector(subRow3[0]);Assert.assertEquals("Row0",mRow0,m.getRowVector(0));Assert.assertEquals("Row3",mRow3,m.getRowVector(3));try {m.getRowVector(-1);Assert.fail("Expecting OutOfRangeException");}catch(OutOfRangeException ex){}try {m.getRowVector(4);Assert.fail("Expecting OutOfRangeException");}catch(OutOfRangeException ex){}}
@Test public void testSetRowVector(){RealMatrix m=new Array2DRowRealMatrix(subTestData);RealVector mRow3=new ArrayRealVector(subRow3[0]);Assert.assertNotSame(mRow3,m.getRowMatrix(0));m.setRowVector(0,mRow3);Assert.assertEquals(mRow3,m.getRowVector(0));try {m.setRowVector(-1,mRow3);Assert.fail("Expecting OutOfRangeException");}catch(OutOfRangeException ex){}try {m.setRowVector(0,new ArrayRealVector(5));Assert.fail("Expecting MatrixDimensionMismatchException");}catch(MatrixDimensionMismatchException ex){}}
@Test public void testGetColumnVector(){RealMatrix m=new Array2DRowRealMatrix(subTestData);RealVector mColumn1=columnToVector(subColumn1);RealVector mColumn3=columnToVector(subColumn3);Assert.assertEquals("Column1",mColumn1,m.getColumnVector(1));Assert.assertEquals("Column3",mColumn3,m.getColumnVector(3));try {m.getColumnVector(-1);Assert.fail("Expecting OutOfRangeException");}catch(OutOfRangeException ex){}try {m.getColumnVector(4);Assert.fail("Expecting OutOfRangeException");}catch(OutOfRangeException ex){}}
@Test public void testSetColumnVector(){RealMatrix m=new Array2DRowRealMatrix(subTestData);RealVector mColumn3=columnToVector(subColumn3);Assert.assertNotSame(mColumn3,m.getColumnVector(1));m.setColumnVector(1,mColumn3);Assert.assertEquals(mColumn3,m.getColumnVector(1));try {m.setColumnVector(-1,mColumn3);Assert.fail("Expecting OutOfRangeException");}catch(OutOfRangeException ex){}try {m.setColumnVector(0,new ArrayRealVector(5));Assert.fail("Expecting MatrixDimensionMismatchException");}catch(MatrixDimensionMismatchException ex){}}
@Test public void testGetRow(){RealMatrix m=new Array2DRowRealMatrix(subTestData);checkArrays(subRow0[0],m.getRow(0));checkArrays(subRow3[0],m.getRow(3));try {m.getRow(-1);Assert.fail("Expecting OutOfRangeException");}catch(OutOfRangeException ex){}try {m.getRow(4);Assert.fail("Expecting OutOfRangeException");}catch(OutOfRangeException ex){}}
@Test public void testSetRow(){RealMatrix m=new Array2DRowRealMatrix(subTestData);Assert.assertTrue(subRow3[0][0]!= m.getRow(0)[0]);m.setRow(0,subRow3[0]);checkArrays(subRow3[0],m.getRow(0));try {m.setRow(-1,subRow3[0]);Assert.fail("Expecting OutOfRangeException");}catch(OutOfRangeException ex){}try {m.setRow(0,new double[5]);Assert.fail("Expecting MatrixDimensionMismatchException");}catch(MatrixDimensionMismatchException ex){}}
@Test public void testGetColumn(){RealMatrix m=new Array2DRowRealMatrix(subTestData);double[]mColumn1=columnToArray(subColumn1);double[]mColumn3=columnToArray(subColumn3);checkArrays(mColumn1,m.getColumn(1));checkArrays(mColumn3,m.getColumn(3));try {m.getColumn(-1);Assert.fail("Expecting OutOfRangeException");}catch(OutOfRangeException ex){}try {m.getColumn(4);Assert.fail("Expecting OutOfRangeException");}catch(OutOfRangeException ex){}}
@Test public void testSetColumn(){RealMatrix m=new Array2DRowRealMatrix(subTestData);double[]mColumn3=columnToArray(subColumn3);Assert.assertTrue(mColumn3[0]!= m.getColumn(1)[0]);m.setColumn(1,mColumn3);checkArrays(mColumn3,m.getColumn(1));try {m.setColumn(-1,mColumn3);Assert.fail("Expecting OutOfRangeException");}catch(OutOfRangeException ex){}try {m.setColumn(0,new double[5]);Assert.fail("Expecting MatrixDimensionMismatchException");}catch(MatrixDimensionMismatchException ex){}}
@Test public void testEqualsAndHashCode(){Array2DRowRealMatrix m=new Array2DRowRealMatrix(testData);Array2DRowRealMatrix m1=(Array2DRowRealMatrix)m.copy();Array2DRowRealMatrix mt=(Array2DRowRealMatrix)m.transpose();Assert.assertTrue(m.hashCode()!= mt.hashCode());Assert.assertEquals(m.hashCode(),m1.hashCode());Assert.assertEquals(m,m);Assert.assertEquals(m,m1);Assert.assertFalse(m.equals(null));Assert.assertFalse(m.equals(mt));Assert.assertFalse(m.equals(new Array2DRowRealMatrix(bigSingular)));}
@Test public void testToString(){Array2DRowRealMatrix m=new Array2DRowRealMatrix(testData);Assert.assertEquals("Array2DRowRealMatrix{{1.0,2.0,3.0},{2.0,5.0,3.0},{1.0,0.0,8.0}}",m.toString());m=new Array2DRowRealMatrix();Assert.assertEquals("Array2DRowRealMatrix{}",m.toString());}
@Test public void testSetSubMatrix()throws Exception {Array2DRowRealMatrix m=new Array2DRowRealMatrix(testData);m.setSubMatrix(detData2,1,1);RealMatrix expected=MatrixUtils.createRealMatrix(new double[][]{{1.0,2.0,3.0},{2.0,1.0,3.0},{1.0,2.0,4.0}});Assert.assertEquals(expected,m);m.setSubMatrix(detData2,0,0);expected=MatrixUtils.createRealMatrix(new double[][]{{1.0,3.0,3.0},{2.0,4.0,3.0},{1.0,2.0,4.0}});Assert.assertEquals(expected,m);m.setSubMatrix(testDataPlus2,0,0);expected=MatrixUtils.createRealMatrix(new double[][]{{3.0,4.0,5.0},{4.0,7.0,5.0},{3.0,2.0,10.0}});Assert.assertEquals(expected,m);try {m.setSubMatrix(testData,1,1);Assert.fail("expecting OutOfRangeException");}catch(OutOfRangeException e){}try {m.setSubMatrix(testData,-1,1);Assert.fail("expecting OutOfRangeException");}catch(OutOfRangeException e){}try {m.setSubMatrix(testData,1,-1);Assert.fail("expecting OutOfRangeException");}catch(OutOfRangeException e){}try {m.setSubMatrix(null,1,1);Assert.fail("expecting NullArgumentException");}catch(NullArgumentException e){}Array2DRowRealMatrix m2=new Array2DRowRealMatrix();try {m2.setSubMatrix(testData,0,1);Assert.fail("expecting MathIllegalStateException");}catch(MathIllegalStateException e){}try {m2.setSubMatrix(testData,1,0);Assert.fail("expecting MathIllegalStateException");}catch(MathIllegalStateException e){}try {m.setSubMatrix(new double[][]{{1},{2,3}},0,0);Assert.fail("expecting MathIllegalArgumentException");}catch(MathIllegalArgumentException e){}try {m.setSubMatrix(new double[][]{{}},0,0);Assert.fail("expecting MathIllegalArgumentException");}catch(MathIllegalArgumentException e){}}
@Test public void testWalk(){int rows=150;int columns=75;RealMatrix m=new Array2DRowRealMatrix(rows,columns);m.walkInRowOrder(new SetVisitor());GetVisitor getVisitor=new GetVisitor();m.walkInOptimizedOrder(getVisitor);Assert.assertEquals(rows * columns,getVisitor.getCount());m=new Array2DRowRealMatrix(rows,columns);m.walkInRowOrder(new SetVisitor(),1,rows - 2,1,columns - 2);getVisitor=new GetVisitor();m.walkInOptimizedOrder(getVisitor,1,rows - 2,1,columns - 2);Assert.assertEquals((rows - 2)* (columns - 2),getVisitor.getCount());for (int i=0;i < rows;++i){Assert.assertEquals(0.0,m.getEntry(i,0),0);Assert.assertEquals(0.0,m.getEntry(i,columns - 1),0);}for (int j=0;j < columns;++j){Assert.assertEquals(0.0,m.getEntry(0,j),0);Assert.assertEquals(0.0,m.getEntry(rows - 1,j),0);}m=new Array2DRowRealMatrix(rows,columns);m.walkInColumnOrder(new SetVisitor());getVisitor=new GetVisitor();m.walkInOptimizedOrder(getVisitor);Assert.assertEquals(rows * columns,getVisitor.getCount());m=new Array2DRowRealMatrix(rows,columns);m.walkInColumnOrder(new SetVisitor(),1,rows - 2,1,columns - 2);getVisitor=new GetVisitor();m.walkInOptimizedOrder(getVisitor,1,rows - 2,1,columns - 2);Assert.assertEquals((rows - 2)* (columns - 2),getVisitor.getCount());for (int i=0;i < rows;++i){Assert.assertEquals(0.0,m.getEntry(i,0),0);Assert.assertEquals(0.0,m.getEntry(i,columns - 1),0);}for (int j=0;j < columns;++j){Assert.assertEquals(0.0,m.getEntry(0,j),0);Assert.assertEquals(0.0,m.getEntry(rows - 1,j),0);}m=new Array2DRowRealMatrix(rows,columns);m.walkInOptimizedOrder(new SetVisitor());getVisitor=new GetVisitor();m.walkInRowOrder(getVisitor);Assert.assertEquals(rows * columns,getVisitor.getCount());m=new Array2DRowRealMatrix(rows,columns);m.walkInOptimizedOrder(new SetVisitor(),1,rows - 2,1,columns - 2);getVisitor=new GetVisitor();m.walkInRowOrder(getVisitor,1,rows - 2,1,columns - 2);Assert.assertEquals((rows - 2)* (columns - 2),getVisitor.getCount());for (int i=0;i < rows;++i){Assert.assertEquals(0.0,m.getEntry(i,0),0);Assert.assertEquals(0.0,m.getEntry(i,columns - 1),0);}for (int j=0;j < columns;++j){Assert.assertEquals(0.0,m.getEntry(0,j),0);Assert.assertEquals(0.0,m.getEntry(rows - 1,j),0);}m=new Array2DRowRealMatrix(rows,columns);m.walkInOptimizedOrder(new SetVisitor());getVisitor=new GetVisitor();m.walkInColumnOrder(getVisitor);Assert.assertEquals(rows * columns,getVisitor.getCount());m=new Array2DRowRealMatrix(rows,columns);m.walkInOptimizedOrder(new SetVisitor(),1,rows - 2,1,columns - 2);getVisitor=new GetVisitor();m.walkInColumnOrder(getVisitor,1,rows - 2,1,columns - 2);Assert.assertEquals((rows - 2)* (columns - 2),getVisitor.getCount());for (int i=0;i < rows;++i){Assert.assertEquals(0.0,m.getEntry(i,0),0);Assert.assertEquals(0.0,m.getEntry(i,columns - 1),0);}for (int j=0;j < columns;++j){Assert.assertEquals(0.0,m.getEntry(0,j),0);Assert.assertEquals(0.0,m.getEntry(rows - 1,j),0);}}
@Test public void testSerial(){Array2DRowRealMatrix m=new Array2DRowRealMatrix(testData);Assert.assertEquals(m,TestUtils.serializeAndRecover(m));}
@Test public void test(){GeneticAlgorithm ga=new GeneticAlgorithm(new OnePointCrossover<Integer>(),CROSSOVER_RATE,new BinaryMutation(),MUTATION_RATE,new TournamentSelection(TOURNAMENT_ARITY));Assert.assertEquals(0,ga.getGenerationsEvolved());Population initial=randomPopulation();StoppingCondition stopCond=new FixedGenerationCount(NUM_GENERATIONS);Chromosome bestInitial=initial.getFittestChromosome();Population finalPopulation=ga.evolve(initial,stopCond);Chromosome bestFinal=finalPopulation.getFittestChromosome();Assert.assertTrue(bestFinal.compareTo(bestInitial)> 0);Assert.assertEquals(NUM_GENERATIONS,ga.getGenerationsEvolved());}
@Test public void testMismatch(){try {new VectorialCovariance(8,true).increment(new double[5]);Assert.fail("an exception should have been thrown");}catch(DimensionMismatchException dme){Assert.assertEquals(5,dme.getArgument());Assert.assertEquals(8,dme.getDimension());}}
@Test public void testSimplistic(){VectorialCovariance stat=new VectorialCovariance(2,true);stat.increment(new double[]{-1.0,1.0});stat.increment(new double[]{1.0,-1.0});RealMatrix c=stat.getResult();Assert.assertEquals(2.0,c.getEntry(0,0),1.0e-12);Assert.assertEquals(-2.0,c.getEntry(1,0),1.0e-12);Assert.assertEquals(2.0,c.getEntry(1,1),1.0e-12);}
@Test public void testBasicStats(){VectorialCovariance stat=new VectorialCovariance(points[0].length,true);for (int i=0;i < points.length;++i){stat.increment(points[i]);}Assert.assertEquals(points.length,stat.getN());RealMatrix c=stat.getResult();double[][]refC=new double[][]{{8.0470,-1.9195,-3.4445},{-1.9195,1.0470,3.2795},{-3.4445,3.2795,12.2070}};for (int i=0;i < c.getRowDimension();++i){for (int j=0;j <= i;++j){Assert.assertEquals(refC[i][j],c.getEntry(i,j),1.0e-12);}}}
@Test public void testSerial(){VectorialCovariance stat=new VectorialCovariance(points[0].length,true);Assert.assertEquals(stat,TestUtils.serializeAndRecover(stat));}
/** * Test degenerate case p = 0 */@Test public void testDegenerate0()throws Exception {setDistribution(new BinomialDistribution(5,0.0d));setCumulativeTestPoints(new int[]{-1,0,1,5,10});setCumulativeTestValues(new double[]{0d,1d,1d,1d,1d});setDensityTestPoints(new int[]{-1,0,1,10,11});setDensityTestValues(new double[]{0d,1d,0d,0d,0d});setInverseCumulativeTestPoints(new double[]{0.1d,0.5d});setInverseCumulativeTestValues(new int[]{-1,-1});verifyDensities();verifyCumulativeProbabilities();verifyInverseCumulativeProbabilities();}
/** * Test degenerate case p = 1 */@Test public void testDegenerate1()throws Exception {setDistribution(new BinomialDistribution(5,1.0d));setCumulativeTestPoints(new int[]{-1,0,1,2,5,10});setCumulativeTestValues(new double[]{0d,0d,0d,0d,1d,1d});setDensityTestPoints(new int[]{-1,0,1,2,5,10});setDensityTestValues(new double[]{0d,0d,0d,0d,1d,0d});setInverseCumulativeTestPoints(new double[]{0.1d,0.5d});setInverseCumulativeTestValues(new int[]{4,4});verifyDensities();verifyCumulativeProbabilities();verifyInverseCumulativeProbabilities();}
@Test public void testMoments(){final double tol=1e-9;BinomialDistribution dist;dist=new BinomialDistribution(10,0.5);Assert.assertEquals(dist.getNumericalMean(),10d * 0.5d,tol);Assert.assertEquals(dist.getNumericalVariance(),10d * 0.5d * 0.5d,tol);dist=new BinomialDistribution(30,0.3);Assert.assertEquals(dist.getNumericalMean(),30d * 0.3d,tol);Assert.assertEquals(dist.getNumericalVariance(),30d * 0.3d * (1d - 0.3d),tol);}
/** * Verifies that probability density calculations match expected values using default test instance data*/@Test public void testDensities()throws Exception {verifyDensities();}
/** * Verifies that cumulative probability density calculations match expected values using default test instance data*/@Test public void testCumulativeProbabilities()throws Exception {verifyCumulativeProbabilities();}
/** * Verifies that floating point arguments are correctly handled by cumulativeProbablility(-,-)JIRA: MATH-184*/@Test public void testFloatingPointArguments()throws Exception {for (int i=0;i < cumulativeTestPoints.length;i++){double arg=cumulativeTestPoints[i];Assert.assertEquals("Incorrect cumulative probability value returned for " + cumulativeTestPoints[i],cumulativeTestValues[i],distribution.cumulativeProbability(arg),tolerance);if (i < cumulativeTestPoints.length - 1){double arg2=cumulativeTestPoints[i + 1];Assert.assertEquals("Inconsistent probability for discrete range " + "[" + arg + ","+ arg2+ " ]",distribution.cumulativeProbability(cumulativeTestPoints[i],cumulativeTestPoints[i + 1]),distribution.cumulativeProbability(arg,arg2),tolerance);arg=arg - FastMath.random();arg2=arg2 + FastMath.random();Assert.assertEquals("Inconsistent probability for discrete range " + "[" + arg + ","+ arg2+ " ]",distribution.cumulativeProbability(cumulativeTestPoints[i],cumulativeTestPoints[i + 1]),distribution.cumulativeProbability(arg,arg2),tolerance);}}int one=1;int ten=10;int two=2;double oned=one;double twod=two;double tend=ten;Assert.assertEquals(distribution.cumulativeProbability(one,two),distribution.cumulativeProbability(oned,twod),tolerance);Assert.assertEquals(distribution.cumulativeProbability(one,two),distribution.cumulativeProbability(oned - tolerance,twod + 0.9),tolerance);Assert.assertEquals(distribution.cumulativeProbability(two,ten),distribution.cumulativeProbability(twod,tend),tolerance);Assert.assertEquals(distribution.cumulativeProbability(two,ten),distribution.cumulativeProbability(twod - tolerance,tend + 0.9),tolerance);}
/** * Verifies that inverse cumulative probability density calculations match expected values using default test instance data*/@Test public void testInverseCumulativeProbabilities()throws Exception {verifyInverseCumulativeProbabilities();}
/** * Verifies that illegal arguments are correctly handled*/@Test public void testIllegalArguments()throws Exception {try {distribution.cumulativeProbability(1,0);Assert.fail("Expecting MathIllegalArgumentException for bad cumulativeProbability interval");}catch(MathIllegalArgumentException ex){}try {distribution.inverseCumulativeProbability(-1);Assert.fail("Expecting MathIllegalArgumentException for p = -1");}catch(MathIllegalArgumentException ex){}try {distribution.inverseCumulativeProbability(2);Assert.fail("Expecting MathIllegalArgumentException for p = 2");}catch(MathIllegalArgumentException ex){}}
/** * Test sampling*/@Test public void testSampling()throws Exception {int[]densityPoints=makeDensityTestPoints();double[]densityValues=makeDensityTestValues();int sampleSize=1000;int length=TestUtils.eliminateZeroMassPoints(densityPoints,densityValues);AbstractIntegerDistribution distribution=(AbstractIntegerDistribution)makeDistribution();double[]expectedCounts=new double[length];long[]observedCounts=new long[length];for (int i=0;i < length;i++){expectedCounts[i]=sampleSize * densityValues[i];}distribution.reseedRandomGenerator(1000);int[]sample=distribution.sample(sampleSize);for (int i=0;i < sampleSize;i++){for (int j=0;j < length;j++){if (sample[i]== densityPoints[j]){observedCounts[j]++;}}}TestUtils.assertChiSquareAccept(densityPoints,expectedCounts,observedCounts,.001);}
/** * Test of solver for the linear function.*/@Test public void testLinearFunction(){double min,max,expected,result,tolerance;double coefficients[]={-1.0,4.0};PolynomialFunction f=new PolynomialFunction(coefficients);LaguerreSolver solver=new LaguerreSolver();min=0.0;max=1.0;expected=0.25;tolerance=FastMath.max(solver.getAbsoluteAccuracy(),FastMath.abs(expected * solver.getRelativeAccuracy()));result=solver.solve(100,f,min,max);Assert.assertEquals(expected,result,tolerance);}
/** * Test of solver for the quadratic function.*/@Test public void testQuadraticFunction(){double min,max,expected,result,tolerance;double coefficients[]={-3.0,5.0,2.0};PolynomialFunction f=new PolynomialFunction(coefficients);LaguerreSolver solver=new LaguerreSolver();min=0.0;max=2.0;expected=0.5;tolerance=FastMath.max(solver.getAbsoluteAccuracy(),FastMath.abs(expected * solver.getRelativeAccuracy()));result=solver.solve(100,f,min,max);Assert.assertEquals(expected,result,tolerance);min=-4.0;max=-1.0;expected=-3.0;tolerance=FastMath.max(solver.getAbsoluteAccuracy(),FastMath.abs(expected * solver.getRelativeAccuracy()));result=solver.solve(100,f,min,max);Assert.assertEquals(expected,result,tolerance);}
/** * Test of solver for the quintic function.*/@Test public void testQuinticFunction(){double min,max,expected,result,tolerance;double coefficients[]={-12.0,-1.0,1.0,-12.0,-1.0,1.0};PolynomialFunction f=new PolynomialFunction(coefficients);LaguerreSolver solver=new LaguerreSolver();min=-2.0;max=2.0;expected=-1.0;tolerance=FastMath.max(solver.getAbsoluteAccuracy(),FastMath.abs(expected * solver.getRelativeAccuracy()));result=solver.solve(100,f,min,max);Assert.assertEquals(expected,result,tolerance);min=-5.0;max=-2.5;expected=-3.0;tolerance=FastMath.max(solver.getAbsoluteAccuracy(),FastMath.abs(expected * solver.getRelativeAccuracy()));result=solver.solve(100,f,min,max);Assert.assertEquals(expected,result,tolerance);min=3.0;max=6.0;expected=4.0;tolerance=FastMath.max(solver.getAbsoluteAccuracy(),FastMath.abs(expected * solver.getRelativeAccuracy()));result=solver.solve(100,f,min,max);Assert.assertEquals(expected,result,tolerance);}
/** * Test of parameters for the solver.*/@Test public void testParameters(){double coefficients[]={-3.0,5.0,2.0};PolynomialFunction f=new PolynomialFunction(coefficients);LaguerreSolver solver=new LaguerreSolver();try {solver.solve(100,f,1,-1);Assert.fail("Expecting NumberIsTooLargeException - bad interval");}catch(NumberIsTooLargeException ex){}try {solver.solve(100,f,2,3);Assert.fail("Expecting NoBracketingException - no bracketing");}catch(NoBracketingException ex){}}
@Test public void testRosenbrock(){Rosenbrock rosenbrock=new Rosenbrock();SimplexOptimizer underlying=new SimplexOptimizer(new SimpleScalarValueChecker(-1,1.0e-3));NelderMeadSimplex simplex=new NelderMeadSimplex(new double[][]{{-1.2,1.0},{0.9,1.2},{3.5,-2.3}});underlying.setSimplex(simplex);JDKRandomGenerator g=new JDKRandomGenerator();g.setSeed(16069223052l);RandomVectorGenerator generator=new UncorrelatedRandomVectorGenerator(2,new GaussianRandomGenerator(g));MultiStartMultivariateRealOptimizer optimizer=new MultiStartMultivariateRealOptimizer(underlying,10,generator);RealPointValuePair optimum=optimizer.optimize(1100,rosenbrock,GoalType.MINIMIZE,new double[]{-1.2,1.0});Assert.assertEquals(rosenbrock.getCount(),optimizer.getEvaluations());Assert.assertTrue(optimizer.getEvaluations()> 900);Assert.assertTrue(optimizer.getEvaluations()< 1200);Assert.assertTrue(optimum.getValue()< 8.0e-4);}
@Test public void testQuantiles()throws Exception {setDensityTestValues(new double[]{0.0385649760808,0.172836231799,0.284958771715,0.172836231799,0.0385649760808,0.00316560600853,9.55930184035e-05,1.06194251052e-06});verifyQuantiles();verifyDensities();setDistribution(new NormalDistribution(0,1));setDensityTestValues(new double[]{0.0539909665132,0.241970724519,0.398942280401,0.241970724519,0.0539909665132,0.00443184841194,0.000133830225765,1.48671951473e-06});verifyQuantiles();verifyDensities();setDistribution(new NormalDistribution(0,0.1));setDensityTestValues(new double[]{0.539909665132,2.41970724519,3.98942280401,2.41970724519,0.539909665132,0.0443184841194,0.00133830225765,1.48671951473e-05});verifyQuantiles();verifyDensities();}
@Test public void testInverseCumulativeProbabilityExtremes()throws Exception {setInverseCumulativeTestPoints(new double[]{0,1});setInverseCumulativeTestValues(new double[]{Double.NEGATIVE_INFINITY,Double.POSITIVE_INFINITY});verifyInverseCumulativeProbabilities();}
@Test public void testGetMean(){NormalDistribution distribution=(NormalDistribution)getDistribution();Assert.assertEquals(2.1,distribution.getMean(),0);}
@Test public void testGetStandardDeviation(){NormalDistribution distribution=(NormalDistribution)getDistribution();Assert.assertEquals(1.4,distribution.getStandardDeviation(),0);}
@Test(expected=NotStrictlyPositiveException.class)public void testPreconditions(){new NormalDistribution(1,0);}
@Test public void testDensity(){double[]x=new double[]{-2,-1,0,1,2};checkDensity(0,1,x,new double[]{0.05399096651,0.24197072452,0.39894228040,0.24197072452,0.05399096651});checkDensity(1.1,1,x,new double[]{0.003266819056,0.043983595980,0.217852177033,0.396952547477,0.266085249899});}
/** * Check to make sure top-coding of extreme values works correctly. Verifies fixes for JIRA MATH-167,MATH-414*/@Test public void testExtremeValues()throws Exception {NormalDistribution distribution=new NormalDistribution(0,1);for (int i=0;i < 100;i++){double lowerTail=distribution.cumulativeProbability(-i);double upperTail=distribution.cumulativeProbability(i);if (i < 9){Assert.assertTrue(lowerTail > 0.0d);Assert.assertTrue(upperTail < 1.0d);}else {Assert.assertTrue(lowerTail < 0.00001);Assert.assertTrue(upperTail > 0.99999);}}Assert.assertEquals(distribution.cumulativeProbability(Double.MAX_VALUE),1,0);Assert.assertEquals(distribution.cumulativeProbability(-Double.MAX_VALUE),0,0);Assert.assertEquals(distribution.cumulativeProbability(Double.POSITIVE_INFINITY),1,0);Assert.assertEquals(distribution.cumulativeProbability(Double.NEGATIVE_INFINITY),0,0);}
@Test public void testMath280(){NormalDistribution normal=new NormalDistribution(0,1);double result=normal.inverseCumulativeProbability(0.9986501019683698);Assert.assertEquals(3.0,result,defaultTolerance);result=normal.inverseCumulativeProbability(0.841344746068543);Assert.assertEquals(1.0,result,defaultTolerance);result=normal.inverseCumulativeProbability(0.9999683287581673);Assert.assertEquals(4.0,result,defaultTolerance);result=normal.inverseCumulativeProbability(0.9772498680518209);Assert.assertEquals(2.0,result,defaultTolerance);}
@Test public void testMoments(){final double tol=1e-9;NormalDistribution dist;dist=new NormalDistribution(0,1);Assert.assertEquals(dist.getNumericalMean(),0,tol);Assert.assertEquals(dist.getNumericalVariance(),1,tol);dist=new NormalDistribution(2.2,1.4);Assert.assertEquals(dist.getNumericalMean(),2.2,tol);Assert.assertEquals(dist.getNumericalVariance(),1.4 * 1.4,tol);dist=new NormalDistribution(-2000.9,10.4);Assert.assertEquals(dist.getNumericalMean(),-2000.9,tol);Assert.assertEquals(dist.getNumericalVariance(),10.4 * 10.4,tol);}
/** * Verifies that cumulative probability density calculations match expected values using default test instance data*/@Test public void testCumulativeProbabilities()throws Exception {verifyCumulativeProbabilities();}
/** * Verifies that inverse cumulative probability density calculations match expected values using default test instance data*/@Test public void testInverseCumulativeProbabilities()throws Exception {verifyInverseCumulativeProbabilities();}
/** * Verifies that density calculations return expected values for default test instance data*/@Test public void testDensities()throws Exception {verifyDensities();}
/** * Verifies that probability computations are consistent*/@Test public void testConsistency()throws Exception {for (int i=1;i < cumulativeTestPoints.length;i++){TestUtils.assertEquals(0d,distribution.cumulativeProbability(cumulativeTestPoints[i],cumulativeTestPoints[i]),tolerance);double upper=FastMath.max(cumulativeTestPoints[i],cumulativeTestPoints[i - 1]);double lower=FastMath.min(cumulativeTestPoints[i],cumulativeTestPoints[i - 1]);double diff=distribution.cumulativeProbability(upper)- distribution.cumulativeProbability(lower);double direct=distribution.cumulativeProbability(lower,upper);TestUtils.assertEquals("Inconsistent cumulative probabilities for (" + lower + ","+ upper+ ")",diff,direct,tolerance);}}
/** * Verifies that illegal arguments are correctly handled*/@Test public void testIllegalArguments()throws Exception {try {distribution.cumulativeProbability(1,0);Assert.fail("Expecting MathIllegalArgumentException for bad cumulativeProbability interval");}catch(MathIllegalArgumentException ex){}try {distribution.inverseCumulativeProbability(-1);Assert.fail("Expecting MathIllegalArgumentException for p = -1");}catch(MathIllegalArgumentException ex){}try {distribution.inverseCumulativeProbability(2);Assert.fail("Expecting MathIllegalArgumentException for p = 2");}catch(MathIllegalArgumentException ex){}}
/** * Test sampling*/@Test public void testSampling()throws Exception {AbstractContinuousDistribution dist=(AbstractContinuousDistribution)makeDistribution();final int sampleSize=1000;dist.reseedRandomGenerator(1000);double[]sample=dist.sample(sampleSize);double[]quartiles=TestUtils.getDistributionQuartiles(dist);double[]expected={250,250,250,250};long[]counts=new long[4];for (int i=0;i < sampleSize;i++){TestUtils.updateCounts(sample[i],counts,quartiles);}TestUtils.assertChiSquareAccept(expected,counts,0.001);}
/** * test dimensions */@Test public void testDimensions(){Array2DRowFieldMatrix<Fraction> m=new Array2DRowFieldMatrix<Fraction>(testData);Array2DRowFieldMatrix<Fraction> m2=new Array2DRowFieldMatrix<Fraction>(testData2);Assert.assertEquals("testData row dimension",3,m.getRowDimension());Assert.assertEquals("testData column dimension",3,m.getColumnDimension());Assert.assertTrue("testData is square",m.isSquare());Assert.assertEquals("testData2 row dimension",m2.getRowDimension(),2);Assert.assertEquals("testData2 column dimension",m2.getColumnDimension(),3);Assert.assertTrue("testData2 is not square",!m2.isSquare());}
/** * test copy functions */@Test public void testCopyFunctions(){Array2DRowFieldMatrix<Fraction> m1=new Array2DRowFieldMatrix<Fraction>(testData);Array2DRowFieldMatrix<Fraction> m2=new Array2DRowFieldMatrix<Fraction>(m1.getData());Assert.assertEquals(m2,m1);Array2DRowFieldMatrix<Fraction> m3=new Array2DRowFieldMatrix<Fraction>(testData);Array2DRowFieldMatrix<Fraction> m4=new Array2DRowFieldMatrix<Fraction>(m3.getData(),false);Assert.assertEquals(m4,m3);}
/** * test add */@Test public void testAdd(){Array2DRowFieldMatrix<Fraction> m=new Array2DRowFieldMatrix<Fraction>(testData);Array2DRowFieldMatrix<Fraction> mInv=new Array2DRowFieldMatrix<Fraction>(testDataInv);FieldMatrix<Fraction> mPlusMInv=m.add(mInv);Fraction[][]sumEntries=mPlusMInv.getData();for (int row=0;row < m.getRowDimension();row++){for (int col=0;col < m.getColumnDimension();col++){Assert.assertEquals(testDataPlusInv[row][col],sumEntries[row][col]);}}}
/** * test add failure */@Test public void testAddFail(){Array2DRowFieldMatrix<Fraction> m=new Array2DRowFieldMatrix<Fraction>(testData);Array2DRowFieldMatrix<Fraction> m2=new Array2DRowFieldMatrix<Fraction>(testData2);try {m.add(m2);Assert.fail("MathIllegalArgumentException expected");}catch(MathIllegalArgumentException ex){}}
/** * test m-n = m + -n */@Test public void testPlusMinus(){Array2DRowFieldMatrix<Fraction> m=new Array2DRowFieldMatrix<Fraction>(testData);Array2DRowFieldMatrix<Fraction> m2=new Array2DRowFieldMatrix<Fraction>(testDataInv);TestUtils.assertEquals(m.subtract(m2),m2.scalarMultiply(new Fraction(-1)).add(m));try {m.subtract(new Array2DRowFieldMatrix<Fraction>(testData2));Assert.fail("Expecting illegalArgumentException");}catch(MathIllegalArgumentException ex){}}
/** * test multiply */@Test public void testMultiply(){Array2DRowFieldMatrix<Fraction> m=new Array2DRowFieldMatrix<Fraction>(testData);Array2DRowFieldMatrix<Fraction> mInv=new Array2DRowFieldMatrix<Fraction>(testDataInv);Array2DRowFieldMatrix<Fraction> identity=new Array2DRowFieldMatrix<Fraction>(id);Array2DRowFieldMatrix<Fraction> m2=new Array2DRowFieldMatrix<Fraction>(testData2);TestUtils.assertEquals(m.multiply(mInv),identity);TestUtils.assertEquals(mInv.multiply(m),identity);TestUtils.assertEquals(m.multiply(identity),m);TestUtils.assertEquals(identity.multiply(mInv),mInv);TestUtils.assertEquals(m2.multiply(identity),m2);try {m.multiply(new Array2DRowFieldMatrix<Fraction>(bigSingular));Assert.fail("Expecting illegalArgumentException");}catch(MathIllegalArgumentException ex){}}
@Test public void testMultiply2(){FieldMatrix<Fraction> m3=new Array2DRowFieldMatrix<Fraction>(d3);FieldMatrix<Fraction> m4=new Array2DRowFieldMatrix<Fraction>(d4);FieldMatrix<Fraction> m5=new Array2DRowFieldMatrix<Fraction>(d5);TestUtils.assertEquals(m3.multiply(m4),m5);}
@Test public void testPower(){FieldMatrix<Fraction> m=new Array2DRowFieldMatrix<Fraction>(testData);FieldMatrix<Fraction> mInv=new Array2DRowFieldMatrix<Fraction>(testDataInv);FieldMatrix<Fraction> mPlusInv=new Array2DRowFieldMatrix<Fraction>(testDataPlusInv);FieldMatrix<Fraction> identity=new Array2DRowFieldMatrix<Fraction>(id);TestUtils.assertEquals(m.power(0),identity);TestUtils.assertEquals(mInv.power(0),identity);TestUtils.assertEquals(mPlusInv.power(0),identity);TestUtils.assertEquals(m.power(1),m);TestUtils.assertEquals(mInv.power(1),mInv);TestUtils.assertEquals(mPlusInv.power(1),mPlusInv);FieldMatrix<Fraction> C1=m.copy();FieldMatrix<Fraction> C2=mInv.copy();FieldMatrix<Fraction> C3=mPlusInv.copy();for (int i=2;i <= 5;++i){C1=C1.multiply(m);C2=C2.multiply(mInv);C3=C3.multiply(mPlusInv);TestUtils.assertEquals(m.power(i),C1);TestUtils.assertEquals(mInv.power(i),C2);TestUtils.assertEquals(mPlusInv.power(i),C3);}try {FieldMatrix<Fraction> mNotSquare=new Array2DRowFieldMatrix<Fraction>(testData2T);mNotSquare.power(2);Assert.fail("Expecting NonSquareMatrixException");}catch(NonSquareMatrixException ex){}try {m.power(-1);Assert.fail("Expecting IllegalArgumentException");}catch(IllegalArgumentException ex){}}
/** * test trace */@Test public void testTrace(){FieldMatrix<Fraction> m=new Array2DRowFieldMatrix<Fraction>(id);Assert.assertEquals("identity trace",new Fraction(3),m.getTrace());m=new Array2DRowFieldMatrix<Fraction>(testData2);try {m.getTrace();Assert.fail("Expecting NonSquareMatrixException");}catch(NonSquareMatrixException ex){}}
/** * test sclarAdd */@Test public void testScalarAdd(){FieldMatrix<Fraction> m=new Array2DRowFieldMatrix<Fraction>(testData);TestUtils.assertEquals(new Array2DRowFieldMatrix<Fraction>(testDataPlus2),m.scalarAdd(new Fraction(2)));}
/** * test operate */@Test public void testOperate(){FieldMatrix<Fraction> m=new Array2DRowFieldMatrix<Fraction>(id);TestUtils.assertEquals(testVector,m.operate(testVector));TestUtils.assertEquals(testVector,m.operate(new ArrayFieldVector<Fraction>(testVector)).getData());m=new Array2DRowFieldMatrix<Fraction>(bigSingular);try {m.operate(testVector);Assert.fail("Expecting illegalArgumentException");}catch(MathIllegalArgumentException ex){}}
/** * test issue MATH-209 */@Test public void testMath209(){FieldMatrix<Fraction> a=new Array2DRowFieldMatrix<Fraction>(new Fraction[][]{{new Fraction(1),new Fraction(2)},{new Fraction(3),new Fraction(4)},{new Fraction(5),new Fraction(6)}},false);Fraction[]b=a.operate(new Fraction[]{new Fraction(1),new Fraction(1)});Assert.assertEquals(a.getRowDimension(),b.length);Assert.assertEquals(new Fraction(3),b[0]);Assert.assertEquals(new Fraction(7),b[1]);Assert.assertEquals(new Fraction(11),b[2]);}
/** * test transpose */@Test public void testTranspose(){FieldMatrix<Fraction> m=new Array2DRowFieldMatrix<Fraction>(testData);FieldMatrix<Fraction> mIT=new FieldLUDecomposition<Fraction>(m).getSolver().getInverse().transpose();FieldMatrix<Fraction> mTI=new FieldLUDecomposition<Fraction>(m.transpose()).getSolver().getInverse();TestUtils.assertEquals(mIT,mTI);m=new Array2DRowFieldMatrix<Fraction>(testData2);FieldMatrix<Fraction> mt=new Array2DRowFieldMatrix<Fraction>(testData2T);TestUtils.assertEquals(mt,m.transpose());}
/** * test preMultiply by vector */@Test public void testPremultiplyVector(){FieldMatrix<Fraction> m=new Array2DRowFieldMatrix<Fraction>(testData);TestUtils.assertEquals(m.preMultiply(testVector),preMultTest);TestUtils.assertEquals(m.preMultiply(new ArrayFieldVector<Fraction>(testVector).getData()),preMultTest);m=new Array2DRowFieldMatrix<Fraction>(bigSingular);try {m.preMultiply(testVector);Assert.fail("expecting MathIllegalArgumentException");}catch(MathIllegalArgumentException ex){}}
@Test public void testPremultiply(){FieldMatrix<Fraction> m3=new Array2DRowFieldMatrix<Fraction>(d3);FieldMatrix<Fraction> m4=new Array2DRowFieldMatrix<Fraction>(d4);FieldMatrix<Fraction> m5=new Array2DRowFieldMatrix<Fraction>(d5);TestUtils.assertEquals(m4.preMultiply(m3),m5);Array2DRowFieldMatrix<Fraction> m=new Array2DRowFieldMatrix<Fraction>(testData);Array2DRowFieldMatrix<Fraction> mInv=new Array2DRowFieldMatrix<Fraction>(testDataInv);Array2DRowFieldMatrix<Fraction> identity=new Array2DRowFieldMatrix<Fraction>(id);TestUtils.assertEquals(m.preMultiply(mInv),identity);TestUtils.assertEquals(mInv.preMultiply(m),identity);TestUtils.assertEquals(m.preMultiply(identity),m);TestUtils.assertEquals(identity.preMultiply(mInv),mInv);try {m.preMultiply(new Array2DRowFieldMatrix<Fraction>(bigSingular));Assert.fail("Expecting illegalArgumentException");}catch(MathIllegalArgumentException ex){}}
@Test public void testGetVectors(){FieldMatrix<Fraction> m=new Array2DRowFieldMatrix<Fraction>(testData);TestUtils.assertEquals(m.getRow(0),testDataRow1);TestUtils.assertEquals(m.getColumn(2),testDataCol3);try {m.getRow(10);Assert.fail("expecting OutOfRangeException");}catch(OutOfRangeException ex){}try {m.getColumn(-1);Assert.fail("expecting OutOfRangeException");}catch(OutOfRangeException ex){}}
@Test public void testGetEntry(){FieldMatrix<Fraction> m=new Array2DRowFieldMatrix<Fraction>(testData);Assert.assertEquals("get entry",m.getEntry(0,1),new Fraction(2));try {m.getEntry(10,4);Assert.fail("Expecting OutOfRangeException");}catch(OutOfRangeException ex){}}
/** * test examples in user guide */@Test public void testExamples(){Fraction[][]matrixData={{new Fraction(1),new Fraction(2),new Fraction(3)},{new Fraction(2),new Fraction(5),new Fraction(3)}};FieldMatrix<Fraction> m=new Array2DRowFieldMatrix<Fraction>(matrixData);Fraction[][]matrixData2={{new Fraction(1),new Fraction(2)},{new Fraction(2),new Fraction(5)},{new Fraction(1),new Fraction(7)}};FieldMatrix<Fraction> n=new Array2DRowFieldMatrix<Fraction>(matrixData2);FieldMatrix<Fraction> p=m.multiply(n);Assert.assertEquals(2,p.getRowDimension());Assert.assertEquals(2,p.getColumnDimension());FieldMatrix<Fraction> pInverse=new FieldLUDecomposition<Fraction>(p).getSolver().getInverse();Assert.assertEquals(2,pInverse.getRowDimension());Assert.assertEquals(2,pInverse.getColumnDimension());Fraction[][]coefficientsData={{new Fraction(2),new Fraction(3),new Fraction(-2)},{new Fraction(-1),new Fraction(7),new Fraction(6)},{new Fraction(4),new Fraction(-3),new Fraction(-5)}};FieldMatrix<Fraction> coefficients=new Array2DRowFieldMatrix<Fraction>(coefficientsData);Fraction[]constants={new Fraction(1),new Fraction(-2),new Fraction(1)};Fraction[]solution;solution=new FieldLUDecomposition<Fraction>(coefficients).getSolver().solve(new ArrayFieldVector<Fraction>(constants,false)).toArray();Assert.assertEquals(new Fraction(2).multiply(solution[0]).add(new Fraction(3).multiply(solution[1])).subtract(new Fraction(2).multiply(solution[2])),constants[0]);Assert.assertEquals(new Fraction(-1).multiply(solution[0]).add(new Fraction(7).multiply(solution[1])).add(new Fraction(6).multiply(solution[2])),constants[1]);Assert.assertEquals(new Fraction(4).multiply(solution[0]).subtract(new Fraction(3).multiply(solution[1])).subtract(new Fraction(5).multiply(solution[2])),constants[2]);}
@Test public void testGetSubMatrix(){FieldMatrix<Fraction> m=new Array2DRowFieldMatrix<Fraction>(subTestData);checkGetSubMatrix(m,subRows23Cols00,2,3,0,0);checkGetSubMatrix(m,subRows00Cols33,0,0,3,3);checkGetSubMatrix(m,subRows01Cols23,0,1,2,3);checkGetSubMatrix(m,subRows02Cols13,new int[]{0,2},new int[]{1,3});checkGetSubMatrix(m,subRows03Cols12,new int[]{0,3},new int[]{1,2});checkGetSubMatrix(m,subRows03Cols123,new int[]{0,3},new int[]{1,2,3});checkGetSubMatrix(m,subRows20Cols123,new int[]{2,0},new int[]{1,2,3});checkGetSubMatrix(m,subRows31Cols31,new int[]{3,1},new int[]{3,1});checkGetSubMatrix(m,subRows31Cols31,new int[]{3,1},new int[]{3,1});checkGetSubMatrix(m,null,1,0,2,4);checkGetSubMatrix(m,null,-1,1,2,2);checkGetSubMatrix(m,null,1,0,2,2);checkGetSubMatrix(m,null,1,0,2,4);checkGetSubMatrix(m,null,new int[]{},new int[]{0});checkGetSubMatrix(m,null,new int[]{0},new int[]{4});}
@Test public void testCopySubMatrix(){FieldMatrix<Fraction> m=new Array2DRowFieldMatrix<Fraction>(subTestData);checkCopy(m,subRows23Cols00,2,3,0,0);checkCopy(m,subRows00Cols33,0,0,3,3);checkCopy(m,subRows01Cols23,0,1,2,3);checkCopy(m,subRows02Cols13,new int[]{0,2},new int[]{1,3});checkCopy(m,subRows03Cols12,new int[]{0,3},new int[]{1,2});checkCopy(m,subRows03Cols123,new int[]{0,3},new int[]{1,2,3});checkCopy(m,subRows20Cols123,new int[]{2,0},new int[]{1,2,3});checkCopy(m,subRows31Cols31,new int[]{3,1},new int[]{3,1});checkCopy(m,subRows31Cols31,new int[]{3,1},new int[]{3,1});checkCopy(m,null,1,0,2,4);checkCopy(m,null,-1,1,2,2);checkCopy(m,null,1,0,2,2);checkCopy(m,null,1,0,2,4);checkCopy(m,null,new int[]{},new int[]{0});checkCopy(m,null,new int[]{0},new int[]{4});}
@Test public void testGetRowMatrix(){FieldMatrix<Fraction> m=new Array2DRowFieldMatrix<Fraction>(subTestData);FieldMatrix<Fraction> mRow0=new Array2DRowFieldMatrix<Fraction>(subRow0);FieldMatrix<Fraction> mRow3=new Array2DRowFieldMatrix<Fraction>(subRow3);Assert.assertEquals("Row0",mRow0,m.getRowMatrix(0));Assert.assertEquals("Row3",mRow3,m.getRowMatrix(3));try {m.getRowMatrix(-1);Assert.fail("Expecting OutOfRangeException");}catch(OutOfRangeException ex){}try {m.getRowMatrix(4);Assert.fail("Expecting OutOfRangeException");}catch(OutOfRangeException ex){}}
@Test public void testSetRowMatrix(){FieldMatrix<Fraction> m=new Array2DRowFieldMatrix<Fraction>(subTestData);FieldMatrix<Fraction> mRow3=new Array2DRowFieldMatrix<Fraction>(subRow3);Assert.assertNotSame(mRow3,m.getRowMatrix(0));m.setRowMatrix(0,mRow3);Assert.assertEquals(mRow3,m.getRowMatrix(0));try {m.setRowMatrix(-1,mRow3);Assert.fail("Expecting OutOfRangeException");}catch(OutOfRangeException ex){}try {m.setRowMatrix(0,m);Assert.fail("Expecting MatrixDimensionMismatchException");}catch(MatrixDimensionMismatchException ex){}}
@Test public void testGetColumnMatrix(){FieldMatrix<Fraction> m=new Array2DRowFieldMatrix<Fraction>(subTestData);FieldMatrix<Fraction> mColumn1=new Array2DRowFieldMatrix<Fraction>(subColumn1);FieldMatrix<Fraction> mColumn3=new Array2DRowFieldMatrix<Fraction>(subColumn3);Assert.assertEquals("Column1",mColumn1,m.getColumnMatrix(1));Assert.assertEquals("Column3",mColumn3,m.getColumnMatrix(3));try {m.getColumnMatrix(-1);Assert.fail("Expecting OutOfRangeException");}catch(OutOfRangeException ex){}try {m.getColumnMatrix(4);Assert.fail("Expecting OutOfRangeException");}catch(OutOfRangeException ex){}}
@Test public void testSetColumnMatrix(){FieldMatrix<Fraction> m=new Array2DRowFieldMatrix<Fraction>(subTestData);FieldMatrix<Fraction> mColumn3=new Array2DRowFieldMatrix<Fraction>(subColumn3);Assert.assertNotSame(mColumn3,m.getColumnMatrix(1));m.setColumnMatrix(1,mColumn3);Assert.assertEquals(mColumn3,m.getColumnMatrix(1));try {m.setColumnMatrix(-1,mColumn3);Assert.fail("Expecting OutOfRangeException");}catch(OutOfRangeException ex){}try {m.setColumnMatrix(0,m);Assert.fail("Expecting MatrixDimensionMismatchException");}catch(MatrixDimensionMismatchException ex){}}
@Test public void testGetRowVector(){FieldMatrix<Fraction> m=new Array2DRowFieldMatrix<Fraction>(subTestData);FieldVector<Fraction> mRow0=new ArrayFieldVector<Fraction>(subRow0[0]);FieldVector<Fraction> mRow3=new ArrayFieldVector<Fraction>(subRow3[0]);Assert.assertEquals("Row0",mRow0,m.getRowVector(0));Assert.assertEquals("Row3",mRow3,m.getRowVector(3));try {m.getRowVector(-1);Assert.fail("Expecting OutOfRangeException");}catch(OutOfRangeException ex){}try {m.getRowVector(4);Assert.fail("Expecting OutOfRangeException");}catch(OutOfRangeException ex){}}
@Test public void testSetRowVector(){FieldMatrix<Fraction> m=new Array2DRowFieldMatrix<Fraction>(subTestData);FieldVector<Fraction> mRow3=new ArrayFieldVector<Fraction>(subRow3[0]);Assert.assertNotSame(mRow3,m.getRowMatrix(0));m.setRowVector(0,mRow3);Assert.assertEquals(mRow3,m.getRowVector(0));try {m.setRowVector(-1,mRow3);Assert.fail("Expecting OutOfRangeException");}catch(OutOfRangeException ex){}try {m.setRowVector(0,new ArrayFieldVector<Fraction>(FractionField.getInstance(),5));Assert.fail("Expecting MatrixDimensionMismatchException");}catch(MatrixDimensionMismatchException ex){}}
@Test public void testGetColumnVector(){FieldMatrix<Fraction> m=new Array2DRowFieldMatrix<Fraction>(subTestData);FieldVector<Fraction> mColumn1=columnToVector(subColumn1);FieldVector<Fraction> mColumn3=columnToVector(subColumn3);Assert.assertEquals("Column1",mColumn1,m.getColumnVector(1));Assert.assertEquals("Column3",mColumn3,m.getColumnVector(3));try {m.getColumnVector(-1);Assert.fail("Expecting OutOfRangeException");}catch(OutOfRangeException ex){}try {m.getColumnVector(4);Assert.fail("Expecting OutOfRangeException");}catch(OutOfRangeException ex){}}
@Test public void testSetColumnVector(){FieldMatrix<Fraction> m=new Array2DRowFieldMatrix<Fraction>(subTestData);FieldVector<Fraction> mColumn3=columnToVector(subColumn3);Assert.assertNotSame(mColumn3,m.getColumnVector(1));m.setColumnVector(1,mColumn3);Assert.assertEquals(mColumn3,m.getColumnVector(1));try {m.setColumnVector(-1,mColumn3);Assert.fail("Expecting OutOfRangeException");}catch(OutOfRangeException ex){}try {m.setColumnVector(0,new ArrayFieldVector<Fraction>(FractionField.getInstance(),5));Assert.fail("Expecting MatrixDimensionMismatchException");}catch(MatrixDimensionMismatchException ex){}}
@Test public void testGetRow(){FieldMatrix<Fraction> m=new Array2DRowFieldMatrix<Fraction>(subTestData);checkArrays(subRow0[0],m.getRow(0));checkArrays(subRow3[0],m.getRow(3));try {m.getRow(-1);Assert.fail("Expecting OutOfRangeException");}catch(OutOfRangeException ex){}try {m.getRow(4);Assert.fail("Expecting OutOfRangeException");}catch(OutOfRangeException ex){}}
@Test public void testSetRow(){FieldMatrix<Fraction> m=new Array2DRowFieldMatrix<Fraction>(subTestData);Assert.assertTrue(subRow3[0][0]!= m.getRow(0)[0]);m.setRow(0,subRow3[0]);checkArrays(subRow3[0],m.getRow(0));try {m.setRow(-1,subRow3[0]);Assert.fail("Expecting OutOfRangeException");}catch(OutOfRangeException ex){}try {m.setRow(0,new Fraction[5]);Assert.fail("Expecting MatrixDimensionMismatchException");}catch(MatrixDimensionMismatchException ex){}}
@Test public void testGetColumn(){FieldMatrix<Fraction> m=new Array2DRowFieldMatrix<Fraction>(subTestData);Fraction[]mColumn1=columnToArray(subColumn1);Fraction[]mColumn3=columnToArray(subColumn3);checkArrays(mColumn1,m.getColumn(1));checkArrays(mColumn3,m.getColumn(3));try {m.getColumn(-1);Assert.fail("Expecting OutOfRangeException");}catch(OutOfRangeException ex){}try {m.getColumn(4);Assert.fail("Expecting OutOfRangeException");}catch(OutOfRangeException ex){}}
@Test public void testSetColumn(){FieldMatrix<Fraction> m=new Array2DRowFieldMatrix<Fraction>(subTestData);Fraction[]mColumn3=columnToArray(subColumn3);Assert.assertTrue(mColumn3[0]!= m.getColumn(1)[0]);m.setColumn(1,mColumn3);checkArrays(mColumn3,m.getColumn(1));try {m.setColumn(-1,mColumn3);Assert.fail("Expecting OutOfRangeException");}catch(OutOfRangeException ex){}try {m.setColumn(0,new Fraction[5]);Assert.fail("Expecting MatrixDimensionMismatchException");}catch(MatrixDimensionMismatchException ex){}}
@Test public void testEqualsAndHashCode(){Array2DRowFieldMatrix<Fraction> m=new Array2DRowFieldMatrix<Fraction>(testData);Array2DRowFieldMatrix<Fraction> m1=(Array2DRowFieldMatrix<Fraction>)m.copy();Array2DRowFieldMatrix<Fraction> mt=(Array2DRowFieldMatrix<Fraction>)m.transpose();Assert.assertTrue(m.hashCode()!= mt.hashCode());Assert.assertEquals(m.hashCode(),m1.hashCode());Assert.assertEquals(m,m);Assert.assertEquals(m,m1);Assert.assertFalse(m.equals(null));Assert.assertFalse(m.equals(mt));Assert.assertFalse(m.equals(new Array2DRowFieldMatrix<Fraction>(bigSingular)));}
@Test public void testToString(){Array2DRowFieldMatrix<Fraction> m=new Array2DRowFieldMatrix<Fraction>(testData);Assert.assertEquals("Array2DRowFieldMatrix{{1,2,3},{2,5,3},{1,0,8}}",m.toString());m=new Array2DRowFieldMatrix<Fraction>(FractionField.getInstance());Assert.assertEquals("Array2DRowFieldMatrix{}",m.toString());}
@Test public void testSetSubMatrix()throws Exception {Array2DRowFieldMatrix<Fraction> m=new Array2DRowFieldMatrix<Fraction>(testData);m.setSubMatrix(detData2,1,1);FieldMatrix<Fraction> expected=new Array2DRowFieldMatrix<Fraction>(new Fraction[][]{{new Fraction(1),new Fraction(2),new Fraction(3)},{new Fraction(2),new Fraction(1),new Fraction(3)},{new Fraction(1),new Fraction(2),new Fraction(4)}});Assert.assertEquals(expected,m);m.setSubMatrix(detData2,0,0);expected=new Array2DRowFieldMatrix<Fraction>(new Fraction[][]{{new Fraction(1),new Fraction(3),new Fraction(3)},{new Fraction(2),new Fraction(4),new Fraction(3)},{new Fraction(1),new Fraction(2),new Fraction(4)}});Assert.assertEquals(expected,m);m.setSubMatrix(testDataPlus2,0,0);expected=new Array2DRowFieldMatrix<Fraction>(new Fraction[][]{{new Fraction(3),new Fraction(4),new Fraction(5)},{new Fraction(4),new Fraction(7),new Fraction(5)},{new Fraction(3),new Fraction(2),new Fraction(10)}});Assert.assertEquals(expected,m);try {m.setSubMatrix(testData,1,1);Assert.fail("expecting OutOfRangeException");}catch(OutOfRangeException e){}try {m.setSubMatrix(testData,-1,1);Assert.fail("expecting OutOfRangeException");}catch(OutOfRangeException e){}try {m.setSubMatrix(testData,1,-1);Assert.fail("expecting OutOfRangeException");}catch(OutOfRangeException e){}try {m.setSubMatrix(null,1,1);Assert.fail("expecting NullArgumentException");}catch(NullArgumentException e){}Array2DRowFieldMatrix<Fraction> m2=new Array2DRowFieldMatrix<Fraction>(FractionField.getInstance());try {m2.setSubMatrix(testData,0,1);Assert.fail("expecting MathIllegalStateException");}catch(MathIllegalStateException e){}try {m2.setSubMatrix(testData,1,0);Assert.fail("expecting MathIllegalStateException");}catch(MathIllegalStateException e){}try {m.setSubMatrix(new Fraction[][]{{new Fraction(1)},{new Fraction(2),new Fraction(3)}},0,0);Assert.fail("expecting MathIllegalArgumentException");}catch(MathIllegalArgumentException e){}try {m.setSubMatrix(new Fraction[][]{{}},0,0);Assert.fail("expecting MathIllegalArgumentException");}catch(MathIllegalArgumentException e){}}
@Test public void testWalk(){int rows=150;int columns=75;FieldMatrix<Fraction> m=new Array2DRowFieldMatrix<Fraction>(FractionField.getInstance(),rows,columns);m.walkInRowOrder(new SetVisitor());GetVisitor getVisitor=new GetVisitor();m.walkInOptimizedOrder(getVisitor);Assert.assertEquals(rows * columns,getVisitor.getCount());m=new Array2DRowFieldMatrix<Fraction>(FractionField.getInstance(),rows,columns);m.walkInRowOrder(new SetVisitor(),1,rows - 2,1,columns - 2);getVisitor=new GetVisitor();m.walkInOptimizedOrder(getVisitor,1,rows - 2,1,columns - 2);Assert.assertEquals((rows - 2)* (columns - 2),getVisitor.getCount());for (int i=0;i < rows;++i){Assert.assertEquals(new Fraction(0),m.getEntry(i,0));Assert.assertEquals(new Fraction(0),m.getEntry(i,columns - 1));}for (int j=0;j < columns;++j){Assert.assertEquals(new Fraction(0),m.getEntry(0,j));Assert.assertEquals(new Fraction(0),m.getEntry(rows - 1,j));}m=new Array2DRowFieldMatrix<Fraction>(FractionField.getInstance(),rows,columns);m.walkInColumnOrder(new SetVisitor());getVisitor=new GetVisitor();m.walkInOptimizedOrder(getVisitor);Assert.assertEquals(rows * columns,getVisitor.getCount());m=new Array2DRowFieldMatrix<Fraction>(FractionField.getInstance(),rows,columns);m.walkInColumnOrder(new SetVisitor(),1,rows - 2,1,columns - 2);getVisitor=new GetVisitor();m.walkInOptimizedOrder(getVisitor,1,rows - 2,1,columns - 2);Assert.assertEquals((rows - 2)* (columns - 2),getVisitor.getCount());for (int i=0;i < rows;++i){Assert.assertEquals(new Fraction(0),m.getEntry(i,0));Assert.assertEquals(new Fraction(0),m.getEntry(i,columns - 1));}for (int j=0;j < columns;++j){Assert.assertEquals(new Fraction(0),m.getEntry(0,j));Assert.assertEquals(new Fraction(0),m.getEntry(rows - 1,j));}m=new Array2DRowFieldMatrix<Fraction>(FractionField.getInstance(),rows,columns);m.walkInOptimizedOrder(new SetVisitor());getVisitor=new GetVisitor();m.walkInRowOrder(getVisitor);Assert.assertEquals(rows * columns,getVisitor.getCount());m=new Array2DRowFieldMatrix<Fraction>(FractionField.getInstance(),rows,columns);m.walkInOptimizedOrder(new SetVisitor(),1,rows - 2,1,columns - 2);getVisitor=new GetVisitor();m.walkInRowOrder(getVisitor,1,rows - 2,1,columns - 2);Assert.assertEquals((rows - 2)* (columns - 2),getVisitor.getCount());for (int i=0;i < rows;++i){Assert.assertEquals(new Fraction(0),m.getEntry(i,0));Assert.assertEquals(new Fraction(0),m.getEntry(i,columns - 1));}for (int j=0;j < columns;++j){Assert.assertEquals(new Fraction(0),m.getEntry(0,j));Assert.assertEquals(new Fraction(0),m.getEntry(rows - 1,j));}m=new Array2DRowFieldMatrix<Fraction>(FractionField.getInstance(),rows,columns);m.walkInOptimizedOrder(new SetVisitor());getVisitor=new GetVisitor();m.walkInColumnOrder(getVisitor);Assert.assertEquals(rows * columns,getVisitor.getCount());m=new Array2DRowFieldMatrix<Fraction>(FractionField.getInstance(),rows,columns);m.walkInOptimizedOrder(new SetVisitor(),1,rows - 2,1,columns - 2);getVisitor=new GetVisitor();m.walkInColumnOrder(getVisitor,1,rows - 2,1,columns - 2);Assert.assertEquals((rows - 2)* (columns - 2),getVisitor.getCount());for (int i=0;i < rows;++i){Assert.assertEquals(new Fraction(0),m.getEntry(i,0));Assert.assertEquals(new Fraction(0),m.getEntry(i,columns - 1));}for (int j=0;j < columns;++j){Assert.assertEquals(new Fraction(0),m.getEntry(0,j));Assert.assertEquals(new Fraction(0),m.getEntry(rows - 1,j));}}
@Test public void testSerial(){Array2DRowFieldMatrix<Fraction> m=new Array2DRowFieldMatrix<Fraction>(testData);Assert.assertEquals(m,TestUtils.serializeAndRecover(m));}
@Test public void testInterpolateLinearDegenerateTwoSegment()throws Exception {double x[]={0.0,0.5,1.0};double y[]={0.0,0.5,1.0};UnivariateRealInterpolator i=new LinearInterpolator();UnivariateFunction f=i.interpolate(x,y);verifyInterpolation(f,x,y);PolynomialFunction polynomials[]=((PolynomialSplineFunction)f).getPolynomials();double target[]={y[0],1d};TestUtils.assertEquals(polynomials[0].getCoefficients(),target,coefficientTolerance);target=new double[]{y[1],1d};TestUtils.assertEquals(polynomials[1].getCoefficients(),target,coefficientTolerance);Assert.assertEquals(0.0,f.value(0.0),interpolationTolerance);Assert.assertEquals(0.4,f.value(0.4),interpolationTolerance);Assert.assertEquals(1.0,f.value(1.0),interpolationTolerance);}
@Test public void testInterpolateLinearDegenerateThreeSegment()throws Exception {double x[]={0.0,0.5,1.0,1.5};double y[]={0.0,0.5,1.0,1.5};UnivariateRealInterpolator i=new LinearInterpolator();UnivariateFunction f=i.interpolate(x,y);verifyInterpolation(f,x,y);PolynomialFunction polynomials[]=((PolynomialSplineFunction)f).getPolynomials();double target[]={y[0],1d};TestUtils.assertEquals(polynomials[0].getCoefficients(),target,coefficientTolerance);target=new double[]{y[1],1d};TestUtils.assertEquals(polynomials[1].getCoefficients(),target,coefficientTolerance);target=new double[]{y[2],1d};TestUtils.assertEquals(polynomials[2].getCoefficients(),target,coefficientTolerance);Assert.assertEquals(0,f.value(0),interpolationTolerance);Assert.assertEquals(1.4,f.value(1.4),interpolationTolerance);Assert.assertEquals(1.5,f.value(1.5),interpolationTolerance);}
@Test public void testInterpolateLinear()throws Exception {double x[]={0.0,0.5,1.0};double y[]={0.0,0.5,0.0};UnivariateRealInterpolator i=new LinearInterpolator();UnivariateFunction f=i.interpolate(x,y);verifyInterpolation(f,x,y);PolynomialFunction polynomials[]=((PolynomialSplineFunction)f).getPolynomials();double target[]={y[0],1d};TestUtils.assertEquals(polynomials[0].getCoefficients(),target,coefficientTolerance);target=new double[]{y[1],-1d};TestUtils.assertEquals(polynomials[1].getCoefficients(),target,coefficientTolerance);}
@Test public void testIllegalArguments(){UnivariateRealInterpolator i=new LinearInterpolator();try {double xval[]={0.0,1.0};double yval[]={0.0,1.0,2.0};i.interpolate(xval,yval);Assert.fail("Failed to detect data set array with different sizes.");}catch(DimensionMismatchException iae){}try {double xval[]={0.0,1.0,0.5};double yval[]={0.0,1.0,2.0};i.interpolate(xval,yval);Assert.fail("Failed to detect unsorted arguments.");}catch(NonMonotonicSequenceException iae){}try {double xval[]={0.0};double yval[]={0.0};i.interpolate(xval,yval);Assert.fail("Failed to detect unsorted arguments.");}catch(NumberIsTooSmallException iae){}}
@Test public void testCumulativeProbabilityExtremes()throws Exception {setCumulativeTestPoints(new double[]{-2,0});setCumulativeTestValues(new double[]{0,0});verifyCumulativeProbabilities();}
@Test public void testInverseCumulativeProbabilityExtremes()throws Exception {setInverseCumulativeTestPoints(new double[]{0,1});setInverseCumulativeTestValues(new double[]{0,Double.POSITIVE_INFINITY});verifyInverseCumulativeProbabilities();}
@Test public void testCumulativeProbability2()throws Exception {double actual=getDistribution().cumulativeProbability(0.25,0.75);Assert.assertEquals(0.0905214,actual,10e-4);}
@Test public void testDensity(){ExponentialDistribution d1=new ExponentialDistribution(1);Assert.assertTrue(Precision.equals(0.0,d1.density(-1e-9),1));Assert.assertTrue(Precision.equals(1.0,d1.density(0.0),1));Assert.assertTrue(Precision.equals(0.0,d1.density(1000.0),1));Assert.assertTrue(Precision.equals(FastMath.exp(-1),d1.density(1.0),1));Assert.assertTrue(Precision.equals(FastMath.exp(-2),d1.density(2.0),1));ExponentialDistribution d2=new ExponentialDistribution(3);Assert.assertTrue(Precision.equals(1 / 3.0,d2.density(0.0),1));Assert.assertEquals(0.2388437702,d2.density(1.0),1e-8);Assert.assertEquals(0.1711390397,d2.density(2.0),1e-8);}
@Test public void testMeanAccessors(){ExponentialDistribution distribution=(ExponentialDistribution)getDistribution();Assert.assertEquals(5d,distribution.getMean(),Double.MIN_VALUE);}
@Test(expected=NotStrictlyPositiveException.class)public void testPreconditions(){new ExponentialDistribution(0);}
@Test public void testMoments(){final double tol=1e-9;ExponentialDistribution dist;dist=new ExponentialDistribution(11d);Assert.assertEquals(dist.getNumericalMean(),11d,tol);Assert.assertEquals(dist.getNumericalVariance(),11d * 11d,tol);dist=new ExponentialDistribution(10.5d);Assert.assertEquals(dist.getNumericalMean(),10.5d,tol);Assert.assertEquals(dist.getNumericalVariance(),10.5d * 10.5d,tol);}
/** * Verifies that cumulative probability density calculations match expected values using default test instance data*/@Test public void testCumulativeProbabilities()throws Exception {verifyCumulativeProbabilities();}
/** * Verifies that inverse cumulative probability density calculations match expected values using default test instance data*/@Test public void testInverseCumulativeProbabilities()throws Exception {verifyInverseCumulativeProbabilities();}
/** * Verifies that density calculations return expected values for default test instance data*/@Test public void testDensities()throws Exception {verifyDensities();}
/** * Verifies that probability computations are consistent*/@Test public void testConsistency()throws Exception {for (int i=1;i < cumulativeTestPoints.length;i++){TestUtils.assertEquals(0d,distribution.cumulativeProbability(cumulativeTestPoints[i],cumulativeTestPoints[i]),tolerance);double upper=FastMath.max(cumulativeTestPoints[i],cumulativeTestPoints[i - 1]);double lower=FastMath.min(cumulativeTestPoints[i],cumulativeTestPoints[i - 1]);double diff=distribution.cumulativeProbability(upper)- distribution.cumulativeProbability(lower);double direct=distribution.cumulativeProbability(lower,upper);TestUtils.assertEquals("Inconsistent cumulative probabilities for (" + lower + ","+ upper+ ")",diff,direct,tolerance);}}
/** * Verifies that illegal arguments are correctly handled*/@Test public void testIllegalArguments()throws Exception {try {distribution.cumulativeProbability(1,0);Assert.fail("Expecting MathIllegalArgumentException for bad cumulativeProbability interval");}catch(MathIllegalArgumentException ex){}try {distribution.inverseCumulativeProbability(-1);Assert.fail("Expecting MathIllegalArgumentException for p = -1");}catch(MathIllegalArgumentException ex){}try {distribution.inverseCumulativeProbability(2);Assert.fail("Expecting MathIllegalArgumentException for p = 2");}catch(MathIllegalArgumentException ex){}}
/** * Test sampling*/@Test public void testSampling()throws Exception {AbstractContinuousDistribution dist=(AbstractContinuousDistribution)makeDistribution();final int sampleSize=1000;dist.reseedRandomGenerator(1000);double[]sample=dist.sample(sampleSize);double[]quartiles=TestUtils.getDistributionQuartiles(dist);double[]expected={250,250,250,250};long[]counts=new long[4];for (int i=0;i < sampleSize;i++){TestUtils.updateCounts(sample[i],counts,quartiles);}TestUtils.assertChiSquareAccept(expected,counts,0.001);}
@Test public void testDimensions(){checkdimensions(MatrixUtils.createRealMatrix(testSquare));checkdimensions(MatrixUtils.createRealMatrix(testNonSquare));checkdimensions(MatrixUtils.createRealMatrix(testNonSquare).transpose());}
@Test public void testAEqualUSVt(){checkAEqualUSVt(MatrixUtils.createRealMatrix(testSquare));checkAEqualUSVt(MatrixUtils.createRealMatrix(testNonSquare));checkAEqualUSVt(MatrixUtils.createRealMatrix(testNonSquare).transpose());}
@Test public void testUOrthogonal(){checkOrthogonal(new BiDiagonalTransformer(MatrixUtils.createRealMatrix(testSquare)).getU());checkOrthogonal(new BiDiagonalTransformer(MatrixUtils.createRealMatrix(testNonSquare)).getU());checkOrthogonal(new BiDiagonalTransformer(MatrixUtils.createRealMatrix(testNonSquare).transpose()).getU());}
@Test public void testVOrthogonal(){checkOrthogonal(new BiDiagonalTransformer(MatrixUtils.createRealMatrix(testSquare)).getV());checkOrthogonal(new BiDiagonalTransformer(MatrixUtils.createRealMatrix(testNonSquare)).getV());checkOrthogonal(new BiDiagonalTransformer(MatrixUtils.createRealMatrix(testNonSquare).transpose()).getV());}
@Test public void testBBiDiagonal(){checkBiDiagonal(new BiDiagonalTransformer(MatrixUtils.createRealMatrix(testSquare)).getB());checkBiDiagonal(new BiDiagonalTransformer(MatrixUtils.createRealMatrix(testNonSquare)).getB());checkBiDiagonal(new BiDiagonalTransformer(MatrixUtils.createRealMatrix(testNonSquare).transpose()).getB());}
@Test public void testSingularMatrix(){BiDiagonalTransformer transformer=new BiDiagonalTransformer(MatrixUtils.createRealMatrix(new double[][]{{1.0,2.0,3.0},{2.0,3.0,4.0},{3.0,5.0,7.0}}));final double s3=FastMath.sqrt(3.0);final double s14=FastMath.sqrt(14.0);final double s1553=FastMath.sqrt(1553.0);RealMatrix uRef=MatrixUtils.createRealMatrix(new double[][]{{-1.0 / s14,5.0 / (s3 * s14),1.0 / s3},{-2.0 / s14,-4.0 / (s3 * s14),1.0 / s3},{-3.0 / s14,1.0 / (s3 * s14),-1.0 / s3}});RealMatrix bRef=MatrixUtils.createRealMatrix(new double[][]{{-s14,s1553 / s14,0.0},{0.0,-87 * s3 / (s14 * s1553),-s3 * s14 / s1553},{0.0,0.0,0.0}});RealMatrix vRef=MatrixUtils.createRealMatrix(new double[][]{{1.0,0.0,0.0},{0.0,-23 / s1553,32 / s1553},{0.0,-32 / s1553,-23 / s1553}});RealMatrix u=transformer.getU();Assert.assertEquals(0,u.subtract(uRef).getNorm(),1.0e-14);RealMatrix b=transformer.getB();Assert.assertEquals(0,b.subtract(bRef).getNorm(),1.0e-14);RealMatrix v=transformer.getV();Assert.assertEquals(0,v.subtract(vRef).getNorm(),1.0e-14);Assert.assertTrue(u == transformer.getU());Assert.assertTrue(b == transformer.getB());Assert.assertTrue(v == transformer.getV());}
@Test public void testMatricesValues(){BiDiagonalTransformer transformer=new BiDiagonalTransformer(MatrixUtils.createRealMatrix(testSquare));final double s17=FastMath.sqrt(17.0);RealMatrix uRef=MatrixUtils.createRealMatrix(new double[][]{{-8 / (5 * s17),19 / (5 * s17)},{-19 / (5 * s17),-8 / (5 * s17)}});RealMatrix bRef=MatrixUtils.createRealMatrix(new double[][]{{-3 * s17 / 5,32 * s17 / 85},{0.0,-5 * s17 / 17}});RealMatrix vRef=MatrixUtils.createRealMatrix(new double[][]{{1.0,0.0},{0.0,-1.0}});RealMatrix u=transformer.getU();Assert.assertEquals(0,u.subtract(uRef).getNorm(),1.0e-14);RealMatrix b=transformer.getB();Assert.assertEquals(0,b.subtract(bRef).getNorm(),1.0e-14);RealMatrix v=transformer.getV();Assert.assertEquals(0,v.subtract(vRef).getNorm(),1.0e-14);Assert.assertTrue(u == transformer.getU());Assert.assertTrue(b == transformer.getB());Assert.assertTrue(v == transformer.getV());}
@Test public void testUpperOrLower(){Assert.assertTrue(new BiDiagonalTransformer(MatrixUtils.createRealMatrix(testSquare)).isUpperBiDiagonal());Assert.assertTrue(new BiDiagonalTransformer(MatrixUtils.createRealMatrix(testNonSquare)).isUpperBiDiagonal());Assert.assertFalse(new BiDiagonalTransformer(MatrixUtils.createRealMatrix(testNonSquare).transpose()).isUpperBiDiagonal());}
@Test public void testComparison(){final Sqrt s=new Sqrt();final UnivariateFunction f=new UnivariateFunction(){public double value(double x){return Math.sqrt(x);}};for (double x=1e-30;x < 1e10;x*=2){final double fX=f.value(x);final double sX=s.value(x);Assert.assertEquals("x=" + x,fX,sX,0);}}
@Test public void testDerivativeComparison(){final UnivariateFunction sPrime=(new Sqrt()).derivative();final UnivariateFunction f=new UnivariateFunction(){public double value(double x){return 1 / (2 * Math.sqrt(x));}};for (double x=1e-30;x < 1e10;x*=2){final double fX=f.value(x);final double sX=sPrime.value(x);Assert.assertEquals("x=" + x,fX,sX,0);}}
@Test public void testEvaluation()throws Exception {Assert.assertEquals(expectedValue(),getUnivariateStatistic().evaluate(testArray),getTolerance());}
@Test public void testEvaluateArraySegment(){final UnivariateStatistic stat=getUnivariateStatistic();final double[]arrayZero=new double[5];System.arraycopy(testArray,0,arrayZero,0,5);Assert.assertEquals(stat.evaluate(arrayZero),stat.evaluate(testArray,0,5),0);final double[]arrayOne=new double[5];System.arraycopy(testArray,5,arrayOne,0,5);Assert.assertEquals(stat.evaluate(arrayOne),stat.evaluate(testArray,5,5),0);final double[]arrayEnd=new double[5];System.arraycopy(testArray,testArray.length - 5,arrayEnd,0,5);Assert.assertEquals(stat.evaluate(arrayEnd),stat.evaluate(testArray,testArray.length - 5,5),0);}
@Test public void testEvaluateArraySegmentWeighted(){UnivariateStatistic statistic=getUnivariateStatistic();if (!(statistic instanceof WeightedEvaluation)){return;}final WeightedEvaluation stat=(WeightedEvaluation)getUnivariateStatistic();final double[]arrayZero=new double[5];final double[]weightZero=new double[5];System.arraycopy(testArray,0,arrayZero,0,5);System.arraycopy(testWeightsArray,0,weightZero,0,5);Assert.assertEquals(stat.evaluate(arrayZero,weightZero),stat.evaluate(testArray,testWeightsArray,0,5),0);final double[]arrayOne=new double[5];final double[]weightOne=new double[5];System.arraycopy(testArray,5,arrayOne,0,5);System.arraycopy(testWeightsArray,5,weightOne,0,5);Assert.assertEquals(stat.evaluate(arrayOne,weightOne),stat.evaluate(testArray,testWeightsArray,5,5),0);final double[]arrayEnd=new double[5];final double[]weightEnd=new double[5];System.arraycopy(testArray,testArray.length - 5,arrayEnd,0,5);System.arraycopy(testWeightsArray,testArray.length - 5,weightEnd,0,5);Assert.assertEquals(stat.evaluate(arrayEnd,weightEnd),stat.evaluate(testArray,testWeightsArray,testArray.length - 5,5),0);}
@Test public void testCopy()throws Exception {UnivariateStatistic original=getUnivariateStatistic();UnivariateStatistic copy=original.copy();Assert.assertEquals(expectedValue(),copy.evaluate(testArray),getTolerance());}
/** * Tests consistency of weighted statistic computation. For statistics that support weighted evaluation,this test case compares the result of direct computation on an array with repeated values with a weighted computation on the corresponding (shorter)array with each value appearing only once but with a weight value equal to its multiplicity in the repeating array.*/@Test public void testWeightedConsistency()throws Exception {UnivariateStatistic statistic=getUnivariateStatistic();if (!(statistic instanceof WeightedEvaluation)){return;}final int len=10;final double mu=0;final double sigma=5;double[]values=new double[len];double[]weights=new double[len];RandomData randomData=new RandomDataImpl();int[]intWeights=new int[len];for (int i=0;i < len;i++){intWeights[i]=randomData.nextInt(1,5);weights[i]=intWeights[i];}List<Double> valuesList=new ArrayList<Double>();for (int i=0;i < len;i++){double value=randomData.nextGaussian(mu,sigma);values[i]=value;for (int j=0;j < intWeights[i];j++){valuesList.add(new Double(value));}}int sumWeights=valuesList.size();double[]repeatedValues=new double[sumWeights];for (int i=0;i < sumWeights;i++){repeatedValues[i]=valuesList.get(i);}WeightedEvaluation weightedStatistic=(WeightedEvaluation)statistic;TestUtils.assertRelativelyEquals(statistic.evaluate(repeatedValues),weightedStatistic.evaluate(values,weights,0,values.length),10E-14);Assert.assertEquals(weightedStatistic.evaluate(values,weights,0,values.length),weightedStatistic.evaluate(values,weights),Double.MIN_VALUE);}
@Test public void testZero(){Assert.assertEquals(BigFraction.ZERO,BigFractionField.getInstance().getZero());}
@Test public void testOne(){Assert.assertEquals(BigFraction.ONE,BigFractionField.getInstance().getOne());}
@Test public void testSerial(){BigFractionField field=BigFractionField.getInstance();Assert.assertTrue(field == TestUtils.serializeAndRecover(field));}
@Test public void testL1DistanceDouble(){double[]p1={2.5,0.0};double[]p2={-0.5,4.0};Assert.assertTrue(Precision.equals(7.0,MathArrays.distance1(p1,p2),1));}
@Test public void testL1DistanceInt(){int[]p1={3,0};int[]p2={0,4};Assert.assertEquals(7,MathArrays.distance1(p1,p2));}
@Test public void testL2DistanceDouble(){double[]p1={2.5,0.0};double[]p2={-0.5,4.0};Assert.assertTrue(Precision.equals(5.0,MathArrays.distance(p1,p2),1));}
@Test public void testL2DistanceInt(){int[]p1={3,0};int[]p2={0,4};Assert.assertTrue(Precision.equals(5,MathArrays.distance(p1,p2),1));}
@Test public void testLInfDistanceDouble(){double[]p1={2.5,0.0};double[]p2={-0.5,4.0};Assert.assertTrue(Precision.equals(4.0,MathArrays.distanceInf(p1,p2),1));}
@Test public void testLInfDistanceInt(){int[]p1={3,0};int[]p2={0,4};Assert.assertEquals(4,MathArrays.distanceInf(p1,p2));}
@Test public void testCheckOrder(){MathArrays.checkOrder(new double[]{-15,-5.5,-1,2,15},MathArrays.OrderDirection.INCREASING,true);MathArrays.checkOrder(new double[]{-15,-5.5,-1,2,2},MathArrays.OrderDirection.INCREASING,false);MathArrays.checkOrder(new double[]{3,-5.5,-11,-27.5},MathArrays.OrderDirection.DECREASING,true);MathArrays.checkOrder(new double[]{3,0,0,-5.5,-11,-27.5},MathArrays.OrderDirection.DECREASING,false);try {MathArrays.checkOrder(new double[]{-15,-5.5,-1,-1,2,15},MathArrays.OrderDirection.INCREASING,true);Assert.fail("an exception should have been thrown");}catch(NonMonotonicSequenceException e){}try {MathArrays.checkOrder(new double[]{-15,-5.5,-1,-2,2},MathArrays.OrderDirection.INCREASING,false);Assert.fail("an exception should have been thrown");}catch(NonMonotonicSequenceException e){}try {MathArrays.checkOrder(new double[]{3,3,-5.5,-11,-27.5},MathArrays.OrderDirection.DECREASING,true);Assert.fail("an exception should have been thrown");}catch(NonMonotonicSequenceException e){}try {MathArrays.checkOrder(new double[]{3,-1,0,-5.5,-11,-27.5},MathArrays.OrderDirection.DECREASING,false);Assert.fail("an exception should have been thrown");}catch(NonMonotonicSequenceException e){}try {MathArrays.checkOrder(new double[]{3,0,-5.5,-11,-10},MathArrays.OrderDirection.DECREASING,false);Assert.fail("an exception should have been thrown");}catch(NonMonotonicSequenceException e){}}
@Test public void testIsMonotonic(){Assert.assertFalse(MathArrays.isMonotonic(new double[]{-15,-5.5,-1,-1,2,15},MathArrays.OrderDirection.INCREASING,true));Assert.assertTrue(MathArrays.isMonotonic(new double[]{-15,-5.5,-1,0,2,15},MathArrays.OrderDirection.INCREASING,true));Assert.assertFalse(MathArrays.isMonotonic(new double[]{-15,-5.5,-1,-2,2},MathArrays.OrderDirection.INCREASING,false));Assert.assertTrue(MathArrays.isMonotonic(new double[]{-15,-5.5,-1,-1,2},MathArrays.OrderDirection.INCREASING,false));Assert.assertFalse(MathArrays.isMonotonic(new double[]{3,3,-5.5,-11,-27.5},MathArrays.OrderDirection.DECREASING,true));Assert.assertTrue(MathArrays.isMonotonic(new double[]{3,2,-5.5,-11,-27.5},MathArrays.OrderDirection.DECREASING,true));Assert.assertFalse(MathArrays.isMonotonic(new double[]{3,-1,0,-5.5,-11,-27.5},MathArrays.OrderDirection.DECREASING,false));Assert.assertTrue(MathArrays.isMonotonic(new double[]{3,0,0,-5.5,-11,-27.5},MathArrays.OrderDirection.DECREASING,false));}
@Test public void testIsMonotonicComparable(){Assert.assertFalse(MathArrays.isMonotonic(new Double[]{new Double(-15),new Double(-5.5),new Double(-1),new Double(-1),new Double(2),new Double(15)},MathArrays.OrderDirection.INCREASING,true));Assert.assertTrue(MathArrays.isMonotonic(new Double[]{new Double(-15),new Double(-5.5),new Double(-1),new Double(0),new Double(2),new Double(15)},MathArrays.OrderDirection.INCREASING,true));Assert.assertFalse(MathArrays.isMonotonic(new Double[]{new Double(-15),new Double(-5.5),new Double(-1),new Double(-2),new Double(2)},MathArrays.OrderDirection.INCREASING,false));Assert.assertTrue(MathArrays.isMonotonic(new Double[]{new Double(-15),new Double(-5.5),new Double(-1),new Double(-1),new Double(2)},MathArrays.OrderDirection.INCREASING,false));Assert.assertFalse(MathArrays.isMonotonic(new Double[]{new Double(3),new Double(3),new Double(-5.5),new Double(-11),new Double(-27.5)},MathArrays.OrderDirection.DECREASING,true));Assert.assertTrue(MathArrays.isMonotonic(new Double[]{new Double(3),new Double(2),new Double(-5.5),new Double(-11),new Double(-27.5)},MathArrays.OrderDirection.DECREASING,true));Assert.assertFalse(MathArrays.isMonotonic(new Double[]{new Double(3),new Double(-1),new Double(0),new Double(-5.5),new Double(-11),new Double(-27.5)},MathArrays.OrderDirection.DECREASING,false));Assert.assertTrue(MathArrays.isMonotonic(new Double[]{new Double(3),new Double(0),new Double(0),new Double(-5.5),new Double(-11),new Double(-27.5)},MathArrays.OrderDirection.DECREASING,false));}
@Test public void testSortInPlace(){final double[]x1={2,5,-3,1,4};final double[]x2={4,25,9,1,16};final double[]x3={8,125,-27,1,64};MathArrays.sortInPlace(x1,x2,x3);Assert.assertEquals(-3,x1[0],Math.ulp(1d));Assert.assertEquals(9,x2[0],Math.ulp(1d));Assert.assertEquals(-27,x3[0],Math.ulp(1d));Assert.assertEquals(1,x1[1],Math.ulp(1d));Assert.assertEquals(1,x2[1],Math.ulp(1d));Assert.assertEquals(1,x3[1],Math.ulp(1d));Assert.assertEquals(2,x1[2],Math.ulp(1d));Assert.assertEquals(4,x2[2],Math.ulp(1d));Assert.assertEquals(8,x3[2],Math.ulp(1d));Assert.assertEquals(4,x1[3],Math.ulp(1d));Assert.assertEquals(16,x2[3],Math.ulp(1d));Assert.assertEquals(64,x3[3],Math.ulp(1d));Assert.assertEquals(5,x1[4],Math.ulp(1d));Assert.assertEquals(25,x2[4],Math.ulp(1d));Assert.assertEquals(125,x3[4],Math.ulp(1d));}
@Test public void testSortInPlaceExample(){final double[]x={3,1,2};final double[]y={1,2,3};final double[]z={0,5,7};MathArrays.sortInPlace(x,y,z);final double[]sx={1,2,3};final double[]sy={2,3,1};final double[]sz={5,7,0};Assert.assertTrue(Arrays.equals(sx,x));Assert.assertTrue(Arrays.equals(sy,y));Assert.assertTrue(Arrays.equals(sz,z));}
@Test public void testSortInPlaceFailures(){final double[]nullArray=null;final double[]one={1};final double[]two={1,2};final double[]onep={2};try {MathArrays.sortInPlace(one,two);Assert.fail("Expecting DimensionMismatchException");}catch(DimensionMismatchException ex){}try {MathArrays.sortInPlace(one,nullArray);Assert.fail("Expecting NullArgumentException");}catch(NullArgumentException ex){}try {MathArrays.sortInPlace(one,onep,nullArray);Assert.fail("Expecting NullArgumentException");}catch(NullArgumentException ex){}}
@Test public void testCopyOfInt(){final int[]source={Integer.MIN_VALUE,-1,0,1,3,113,4769,Integer.MAX_VALUE};final int[]dest=MathArrays.copyOf(source);Assert.assertEquals(dest.length,source.length);for (int i=0;i < source.length;i++){Assert.assertEquals(source[i],dest[i]);}}
@Test public void testCopyOfInt2(){final int[]source={Integer.MIN_VALUE,-1,0,1,3,113,4769,Integer.MAX_VALUE};final int offset=3;final int[]dest=MathArrays.copyOf(source,source.length - offset);Assert.assertEquals(dest.length,source.length - offset);for (int i=0;i < source.length - offset;i++){Assert.assertEquals(source[i],dest[i]);}}
@Test public void testCopyOfInt3(){final int[]source={Integer.MIN_VALUE,-1,0,1,3,113,4769,Integer.MAX_VALUE};final int offset=3;final int[]dest=MathArrays.copyOf(source,source.length + offset);Assert.assertEquals(dest.length,source.length + offset);for (int i=0;i < source.length;i++){Assert.assertEquals(source[i],dest[i]);}for (int i=source.length;i < source.length + offset;i++){Assert.assertEquals(0,dest[i],0);}}
@Test public void testCopyOfDouble(){final double[]source={Double.NEGATIVE_INFINITY,-Double.MAX_VALUE,-1,0,Double.MIN_VALUE,Math.ulp(1d),1,3,113,4769,Double.MAX_VALUE,Double.POSITIVE_INFINITY};final double[]dest=MathArrays.copyOf(source);Assert.assertEquals(dest.length,source.length);for (int i=0;i < source.length;i++){Assert.assertEquals(source[i],dest[i],0);}}
@Test public void testCopyOfDouble2(){final double[]source={Double.NEGATIVE_INFINITY,-Double.MAX_VALUE,-1,0,Double.MIN_VALUE,Math.ulp(1d),1,3,113,4769,Double.MAX_VALUE,Double.POSITIVE_INFINITY};final int offset=3;final double[]dest=MathArrays.copyOf(source,source.length - offset);Assert.assertEquals(dest.length,source.length - offset);for (int i=0;i < source.length - offset;i++){Assert.assertEquals(source[i],dest[i],0);}}
@Test public void testCopyOfDouble3(){final double[]source={Double.NEGATIVE_INFINITY,-Double.MAX_VALUE,-1,0,Double.MIN_VALUE,Math.ulp(1d),1,3,113,4769,Double.MAX_VALUE,Double.POSITIVE_INFINITY};final int offset=3;final double[]dest=MathArrays.copyOf(source,source.length + offset);Assert.assertEquals(dest.length,source.length + offset);for (int i=0;i < source.length;i++){Assert.assertEquals(source[i],dest[i],0);}for (int i=source.length;i < source.length + offset;i++){Assert.assertEquals(0,dest[i],0);}}
@Test public void testLinearCombination1(){final double[]a=new double[]{-1321008684645961.0 / 268435456.0,-5774608829631843.0 / 268435456.0,-7645843051051357.0 / 8589934592.0};final double[]b=new double[]{-5712344449280879.0 / 2097152.0,-4550117129121957.0 / 2097152.0,8846951984510141.0 / 131072.0};final double abSumInline=MathArrays.linearCombination(a[0],b[0],a[1],b[1],a[2],b[2]);final double abSumArray=MathArrays.linearCombination(a,b);Assert.assertEquals(abSumInline,abSumArray,0);}
@Test public void testLinearCombination2(){Well1024a random=new Well1024a(553267312521321234l);for (int i=0;i < 10000;++i){final double ux=1e17 * random.nextDouble();final double uy=1e17 * random.nextDouble();final double uz=1e17 * random.nextDouble();final double vx=1e17 * random.nextDouble();final double vy=1e17 * random.nextDouble();final double vz=1e17 * random.nextDouble();final double sInline=MathArrays.linearCombination(ux,vx,uy,vy,uz,vz);final double sArray=MathArrays.linearCombination(new double[]{ux,uy,uz},new double[]{vx,vy,vz});Assert.assertEquals(sInline,sArray,0);}}
@Test public void testLinearCombinationInfinite(){final double[][]a=new double[][]{{1,2,3,4},{1,Double.POSITIVE_INFINITY,3,4},{1,2,Double.POSITIVE_INFINITY,4},{1,Double.POSITIVE_INFINITY,3,Double.NEGATIVE_INFINITY},{1,2,3,4},{1,2,3,4},{1,2,3,4},{1,2,3,4}};final double[][]b=new double[][]{{1,-2,3,4},{1,-2,3,4},{1,-2,3,4},{1,-2,3,4},{1,Double.POSITIVE_INFINITY,3,4},{1,-2,Double.POSITIVE_INFINITY,4},{1,Double.POSITIVE_INFINITY,3,Double.NEGATIVE_INFINITY},{Double.NaN,-2,3,4}};Assert.assertEquals(-3,MathArrays.linearCombination(a[0][0],b[0][0],a[0][1],b[0][1]),1.0e-10);Assert.assertEquals(6,MathArrays.linearCombination(a[0][0],b[0][0],a[0][1],b[0][1],a[0][2],b[0][2]),1.0e-10);Assert.assertEquals(22,MathArrays.linearCombination(a[0][0],b[0][0],a[0][1],b[0][1],a[0][2],b[0][2],a[0][3],b[0][3]),1.0e-10);Assert.assertEquals(22,MathArrays.linearCombination(a[0],b[0]),1.0e-10);Assert.assertEquals(Double.NEGATIVE_INFINITY,MathArrays.linearCombination(a[1][0],b[1][0],a[1][1],b[1][1]),1.0e-10);Assert.assertEquals(Double.NEGATIVE_INFINITY,MathArrays.linearCombination(a[1][0],b[1][0],a[1][1],b[1][1],a[1][2],b[1][2]),1.0e-10);Assert.assertEquals(Double.NEGATIVE_INFINITY,MathArrays.linearCombination(a[1][0],b[1][0],a[1][1],b[1][1],a[1][2],b[1][2],a[1][3],b[1][3]),1.0e-10);Assert.assertEquals(Double.NEGATIVE_INFINITY,MathArrays.linearCombination(a[1],b[1]),1.0e-10);Assert.assertEquals(-3,MathArrays.linearCombination(a[2][0],b[2][0],a[2][1],b[2][1]),1.0e-10);Assert.assertEquals(Double.POSITIVE_INFINITY,MathArrays.linearCombination(a[2][0],b[2][0],a[2][1],b[2][1],a[2][2],b[2][2]),1.0e-10);Assert.assertEquals(Double.POSITIVE_INFINITY,MathArrays.linearCombination(a[2][0],b[2][0],a[2][1],b[2][1],a[2][2],b[2][2],a[2][3],b[2][3]),1.0e-10);Assert.assertEquals(Double.POSITIVE_INFINITY,MathArrays.linearCombination(a[2],b[2]),1.0e-10);Assert.assertEquals(Double.NEGATIVE_INFINITY,MathArrays.linearCombination(a[3][0],b[3][0],a[3][1],b[3][1]),1.0e-10);Assert.assertEquals(Double.NEGATIVE_INFINITY,MathArrays.linearCombination(a[3][0],b[3][0],a[3][1],b[3][1],a[3][2],b[3][2]),1.0e-10);Assert.assertEquals(Double.NEGATIVE_INFINITY,MathArrays.linearCombination(a[3][0],b[3][0],a[3][1],b[3][1],a[3][2],b[3][2],a[3][3],b[3][3]),1.0e-10);Assert.assertEquals(Double.NEGATIVE_INFINITY,MathArrays.linearCombination(a[3],b[3]),1.0e-10);Assert.assertEquals(Double.POSITIVE_INFINITY,MathArrays.linearCombination(a[4][0],b[4][0],a[4][1],b[4][1]),1.0e-10);Assert.assertEquals(Double.POSITIVE_INFINITY,MathArrays.linearCombination(a[4][0],b[4][0],a[4][1],b[4][1],a[4][2],b[4][2]),1.0e-10);Assert.assertEquals(Double.POSITIVE_INFINITY,MathArrays.linearCombination(a[4][0],b[4][0],a[4][1],b[4][1],a[4][2],b[4][2],a[4][3],b[4][3]),1.0e-10);Assert.assertEquals(Double.POSITIVE_INFINITY,MathArrays.linearCombination(a[4],b[4]),1.0e-10);Assert.assertEquals(-3,MathArrays.linearCombination(a[5][0],b[5][0],a[5][1],b[5][1]),1.0e-10);Assert.assertEquals(Double.POSITIVE_INFINITY,MathArrays.linearCombination(a[5][0],b[5][0],a[5][1],b[5][1],a[5][2],b[5][2]),1.0e-10);Assert.assertEquals(Double.POSITIVE_INFINITY,MathArrays.linearCombination(a[5][0],b[5][0],a[5][1],b[5][1],a[5][2],b[5][2],a[5][3],b[5][3]),1.0e-10);Assert.assertEquals(Double.POSITIVE_INFINITY,MathArrays.linearCombination(a[5],b[5]),1.0e-10);Assert.assertEquals(Double.POSITIVE_INFINITY,MathArrays.linearCombination(a[6][0],b[6][0],a[6][1],b[6][1]),1.0e-10);Assert.assertEquals(Double.POSITIVE_INFINITY,MathArrays.linearCombination(a[6][0],b[6][0],a[6][1],b[6][1],a[6][2],b[6][2]),1.0e-10);Assert.assertTrue(Double.isNaN(MathArrays.linearCombination(a[6][0],b[6][0],a[6][1],b[6][1],a[6][2],b[6][2],a[6][3],b[6][3])));Assert.assertTrue(Double.isNaN(MathArrays.linearCombination(a[6],b[6])));Assert.assertTrue(Double.isNaN(MathArrays.linearCombination(a[7][0],b[7][0],a[7][1],b[7][1])));Assert.assertTrue(Double.isNaN(MathArrays.linearCombination(a[7][0],b[7][0],a[7][1],b[7][1],a[7][2],b[7][2])));Assert.assertTrue(Double.isNaN(MathArrays.linearCombination(a[7][0],b[7][0],a[7][1],b[7][1],a[7][2],b[7][2],a[7][3],b[7][3])));Assert.assertTrue(Double.isNaN(MathArrays.linearCombination(a[7],b[7])));}
@Test public void testArrayEquals(){Assert.assertFalse(MathArrays.equals(new double[]{1d},null));Assert.assertFalse(MathArrays.equals(null,new double[]{1d}));Assert.assertTrue(MathArrays.equals((double[])null,(double[])null));Assert.assertFalse(MathArrays.equals(new double[]{1d},new double[0]));Assert.assertTrue(MathArrays.equals(new double[]{1d},new double[]{1d}));Assert.assertTrue(MathArrays.equals(new double[]{Double.POSITIVE_INFINITY,Double.NEGATIVE_INFINITY,1d,0d},new double[]{Double.POSITIVE_INFINITY,Double.NEGATIVE_INFINITY,1d,0d}));Assert.assertFalse(MathArrays.equals(new double[]{Double.NaN},new double[]{Double.NaN}));Assert.assertFalse(MathArrays.equals(new double[]{Double.POSITIVE_INFINITY},new double[]{Double.NEGATIVE_INFINITY}));Assert.assertFalse(MathArrays.equals(new double[]{1d},new double[]{FastMath.nextAfter(FastMath.nextAfter(1d,2d),2d)}));}
@Test public void testArrayEqualsIncludingNaN(){Assert.assertFalse(MathArrays.equalsIncludingNaN(new double[]{1d},null));Assert.assertFalse(MathArrays.equalsIncludingNaN(null,new double[]{1d}));Assert.assertTrue(MathArrays.equalsIncludingNaN((double[])null,(double[])null));Assert.assertFalse(MathArrays.equalsIncludingNaN(new double[]{1d},new double[0]));Assert.assertTrue(MathArrays.equalsIncludingNaN(new double[]{1d},new double[]{1d}));Assert.assertTrue(MathArrays.equalsIncludingNaN(new double[]{Double.NaN,Double.POSITIVE_INFINITY,Double.NEGATIVE_INFINITY,1d,0d},new double[]{Double.NaN,Double.POSITIVE_INFINITY,Double.NEGATIVE_INFINITY,1d,0d}));Assert.assertFalse(MathArrays.equalsIncludingNaN(new double[]{Double.POSITIVE_INFINITY},new double[]{Double.NEGATIVE_INFINITY}));Assert.assertFalse(MathArrays.equalsIncludingNaN(new double[]{1d},new double[]{FastMath.nextAfter(FastMath.nextAfter(1d,2d),2d)}));}
@Test public void testNormalizeArray(){double[]testValues1=new double[]{1,1,2};TestUtils.assertEquals(new double[]{.25,.25,.5},MathArrays.normalizeArray(testValues1,1),Double.MIN_VALUE);double[]testValues2=new double[]{-1,-1,1};TestUtils.assertEquals(new double[]{1,1,-1},MathArrays.normalizeArray(testValues2,1),Double.MIN_VALUE);double[]testValues3=new double[]{-1,-1,Double.NaN,1,Double.NaN};TestUtils.assertEquals(new double[]{1,1,Double.NaN,-1,Double.NaN},MathArrays.normalizeArray(testValues3,1),Double.MIN_VALUE);double[]zeroSum=new double[]{-1,1};try {MathArrays.normalizeArray(zeroSum,1);Assert.fail("expecting MathArithmeticException");}catch(MathArithmeticException ex){}double[]hasInf=new double[]{1,2,1,Double.NEGATIVE_INFINITY};try {MathArrays.normalizeArray(hasInf,1);Assert.fail("expecting MathIllegalArgumentException");}catch(MathIllegalArgumentException ex){}try {MathArrays.normalizeArray(testValues1,Double.POSITIVE_INFINITY);Assert.fail("expecting MathIllegalArgumentException");}catch(MathIllegalArgumentException ex){}try {MathArrays.normalizeArray(testValues1,Double.NaN);Assert.fail("expecting MathIllegalArgumentException");}catch(MathIllegalArgumentException ex){}}
@Test public void testFormat(){BigFraction c=new BigFraction(1,2);String expected="1 / 2";String actual=properFormat.format(c);Assert.assertEquals(expected,actual);actual=improperFormat.format(c);Assert.assertEquals(expected,actual);}
@Test public void testFormatNegative(){BigFraction c=new BigFraction(-1,2);String expected="-1 / 2";String actual=properFormat.format(c);Assert.assertEquals(expected,actual);actual=improperFormat.format(c);Assert.assertEquals(expected,actual);}
@Test public void testFormatZero(){BigFraction c=new BigFraction(0,1);String expected="0 / 1";String actual=properFormat.format(c);Assert.assertEquals(expected,actual);actual=improperFormat.format(c);Assert.assertEquals(expected,actual);}
@Test public void testFormatImproper(){BigFraction c=new BigFraction(5,3);String actual=properFormat.format(c);Assert.assertEquals("1 2 / 3",actual);actual=improperFormat.format(c);Assert.assertEquals("5 / 3",actual);}
@Test public void testFormatImproperNegative(){BigFraction c=new BigFraction(-5,3);String actual=properFormat.format(c);Assert.assertEquals("-1 2 / 3",actual);actual=improperFormat.format(c);Assert.assertEquals("-5 / 3",actual);}
@Test public void testParse(){String source="1 / 2";{BigFraction c=properFormat.parse(source);Assert.assertNotNull(c);Assert.assertEquals(BigInteger.ONE,c.getNumerator());Assert.assertEquals(BigInteger.valueOf(2l),c.getDenominator());c=improperFormat.parse(source);Assert.assertNotNull(c);Assert.assertEquals(BigInteger.ONE,c.getNumerator());Assert.assertEquals(BigInteger.valueOf(2l),c.getDenominator());}}
@Test public void testParseInteger(){String source="10";{BigFraction c=properFormat.parse(source);Assert.assertNotNull(c);Assert.assertEquals(BigInteger.TEN,c.getNumerator());Assert.assertEquals(BigInteger.ONE,c.getDenominator());}{BigFraction c=improperFormat.parse(source);Assert.assertNotNull(c);Assert.assertEquals(BigInteger.TEN,c.getNumerator());Assert.assertEquals(BigInteger.ONE,c.getDenominator());}}
@Test public void testParseInvalid(){String source="a";String msg="should not be able to parse '10 / a'.";try {properFormat.parse(source);Assert.fail(msg);}catch(MathParseException ex){}try {improperFormat.parse(source);Assert.fail(msg);}catch(MathParseException ex){}}
@Test public void testParseInvalidDenominator(){String source="10 / a";String msg="should not be able to parse '10 / a'.";try {properFormat.parse(source);Assert.fail(msg);}catch(MathParseException ex){}try {improperFormat.parse(source);Assert.fail(msg);}catch(MathParseException ex){}}
@Test public void testParseNegative(){{String source="-1 / 2";BigFraction c=properFormat.parse(source);Assert.assertNotNull(c);Assert.assertEquals(-1,c.getNumeratorAsInt());Assert.assertEquals(2,c.getDenominatorAsInt());c=improperFormat.parse(source);Assert.assertNotNull(c);Assert.assertEquals(-1,c.getNumeratorAsInt());Assert.assertEquals(2,c.getDenominatorAsInt());source="1 / -2";c=properFormat.parse(source);Assert.assertNotNull(c);Assert.assertEquals(-1,c.getNumeratorAsInt());Assert.assertEquals(2,c.getDenominatorAsInt());c=improperFormat.parse(source);Assert.assertNotNull(c);Assert.assertEquals(-1,c.getNumeratorAsInt());Assert.assertEquals(2,c.getDenominatorAsInt());}}
@Test public void testParseProper(){String source="1 2 / 3";{BigFraction c=properFormat.parse(source);Assert.assertNotNull(c);Assert.assertEquals(5,c.getNumeratorAsInt());Assert.assertEquals(3,c.getDenominatorAsInt());}try {improperFormat.parse(source);Assert.fail("invalid improper fraction.");}catch(MathParseException ex){}}
@Test public void testParseProperNegative(){String source="-1 2 / 3";{BigFraction c=properFormat.parse(source);Assert.assertNotNull(c);Assert.assertEquals(-5,c.getNumeratorAsInt());Assert.assertEquals(3,c.getDenominatorAsInt());}try {improperFormat.parse(source);Assert.fail("invalid improper fraction.");}catch(MathParseException ex){}}
@Test public void testParseProperInvalidMinus(){String source="2 -2 / 3";try {properFormat.parse(source);Assert.fail("invalid minus in improper fraction.");}catch(MathParseException ex){}source="2 2 / -3";try {properFormat.parse(source);Assert.fail("invalid minus in improper fraction.");}catch(MathParseException ex){}}
@Test public void testParseBig(){BigFraction f1=improperFormat.parse("167213075789791382630275400487886041651764456874403" + " / " + "53225575123090058458126718248444563466137046489291");Assert.assertEquals(FastMath.PI,f1.doubleValue(),0.0);BigFraction f2=properFormat.parse("3 " + "7536350420521207255895245742552351253353317406530" + " / "+ "53225575123090058458126718248444563466137046489291");Assert.assertEquals(FastMath.PI,f2.doubleValue(),0.0);Assert.assertEquals(f1,f2);BigDecimal pi=new BigDecimal("3.141592653589793238462643383279502884197169399375105820974944592307816406286208998628034825342117068");Assert.assertEquals(pi,f1.bigDecimalValue(99,BigDecimal.ROUND_HALF_EVEN));}
@Test public void testNumeratorFormat(){NumberFormat old=properFormat.getNumeratorFormat();NumberFormat nf=NumberFormat.getInstance();nf.setParseIntegerOnly(true);properFormat.setNumeratorFormat(nf);Assert.assertEquals(nf,properFormat.getNumeratorFormat());properFormat.setNumeratorFormat(old);old=improperFormat.getNumeratorFormat();nf=NumberFormat.getInstance();nf.setParseIntegerOnly(true);improperFormat.setNumeratorFormat(nf);Assert.assertEquals(nf,improperFormat.getNumeratorFormat());improperFormat.setNumeratorFormat(old);}
@Test public void testDenominatorFormat(){NumberFormat old=properFormat.getDenominatorFormat();NumberFormat nf=NumberFormat.getInstance();nf.setParseIntegerOnly(true);properFormat.setDenominatorFormat(nf);Assert.assertEquals(nf,properFormat.getDenominatorFormat());properFormat.setDenominatorFormat(old);old=improperFormat.getDenominatorFormat();nf=NumberFormat.getInstance();nf.setParseIntegerOnly(true);improperFormat.setDenominatorFormat(nf);Assert.assertEquals(nf,improperFormat.getDenominatorFormat());improperFormat.setDenominatorFormat(old);}
@Test public void testWholeFormat(){ProperBigFractionFormat format=(ProperBigFractionFormat)properFormat;NumberFormat old=format.getWholeFormat();NumberFormat nf=NumberFormat.getInstance();nf.setParseIntegerOnly(true);format.setWholeFormat(nf);Assert.assertEquals(nf,format.getWholeFormat());format.setWholeFormat(old);}
@Test public void testLongFormat(){Assert.assertEquals("10 / 1",improperFormat.format(10l));}
@Test public void testDoubleFormat(){Assert.assertEquals("1 / 16",improperFormat.format(0.0625));}
/** * Test of hasIntercept method,of class MillerUpdatingRegression.*/@Test public void testHasIntercept(){MillerUpdatingRegression instance=new MillerUpdatingRegression(10,false);if (instance.hasIntercept()){fail("Should not have intercept");}instance=new MillerUpdatingRegression(10,true);if (!instance.hasIntercept()){fail("Should have intercept");}}
/** * Test of getN method,of class MillerUpdatingRegression.*/@Test public void testAddObsGetNClear(){MillerUpdatingRegression instance=new MillerUpdatingRegression(3,true);double[][]xAll=new double[airdata[0].length][];double[]y=new double[airdata[0].length];for (int i=0;i < airdata[0].length;i++){xAll[i]=new double[3];xAll[i][0]=Math.log(airdata[3][i]);xAll[i][1]=Math.log(airdata[4][i]);xAll[i][2]=airdata[5][i];y[i]=Math.log(airdata[2][i]);}instance.addObservations(xAll,y);if (instance.getN()!= xAll.length){fail("Number of observations not correct in bulk addition");}instance.clear();for (int i=0;i < xAll.length;i++){instance.addObservation(xAll[i],y[i]);}if (instance.getN()!= xAll.length){fail("Number of observations not correct in drip addition");}return;}
@Test public void testNegativeTestAddObs(){MillerUpdatingRegression instance=new MillerUpdatingRegression(3,true);try {instance.addObservation(new double[]{1.0},0.0);fail("Should throw IllegalArgumentException");}catch(IllegalArgumentException iae){}catch(Exception e){fail("Should throw IllegalArgumentException");}try {instance.addObservation(new double[]{1.0,1.0,1.0,1.0,1.0,1.0,1.0},0.0);fail("Should throw IllegalArgumentException");}catch(IllegalArgumentException iae){}catch(Exception e){fail("Should throw IllegalArgumentException");}try {instance.addObservation(new double[]{1.0,1.0,1.0},0.0);}catch(Exception e){fail("Should throw IllegalArgumentException");}instance=new MillerUpdatingRegression(3,false);try {instance.addObservation(new double[]{1.0},0.0);fail("Should throw IllegalArgumentException [NOINTERCEPT]");}catch(IllegalArgumentException iae){}catch(Exception e){fail("Should throw IllegalArgumentException [NOINTERCEPT]");}try {instance.addObservation(new double[]{1.0,1.0,1.0,1.0,1.0,1.0,1.0},0.0);fail("Should throw IllegalArgumentException [NOINTERCEPT]");}catch(IllegalArgumentException iae){}catch(Exception e){fail("Should throw IllegalArgumentException [NOINTERCEPT]");}try {instance.addObservation(new double[]{1.0,1.0,1.0},0.0);}catch(Exception e){fail("Should throw IllegalArgumentException [NOINTERCEPT]");}}
@Test public void testNegativeTestAddMultipleObs(){MillerUpdatingRegression instance=new MillerUpdatingRegression(3,true);try {double[][]tst={{1.0,1.0,1.0},{1.20,2.0,2.1}};double[]y={1.0};instance.addObservations(tst,y);fail("Should throw IllegalArgumentException");}catch(IllegalArgumentException iae){}catch(Exception e){fail("Should throw IllegalArgumentException");}try {double[][]tst={{1.0,1.0,1.0},{1.20,2.0,2.1}};double[]y={1.0,4.0,5.0,6.0,7.0,8.0,9.0,10.0};instance.addObservations(tst,y);fail("Should throw IllegalArgumentException");}catch(IllegalArgumentException iae){}catch(Exception e){fail("Should throw IllegalArgumentException");}}
@Test public void testRegressAirlineConstantExternal(){MillerUpdatingRegression instance=new MillerUpdatingRegression(4,false);double[][]x=new double[airdata[0].length][];double[]y=new double[airdata[0].length];for (int i=0;i < airdata[0].length;i++){x[i]=new double[4];x[i][0]=1.0;x[i][1]=Math.log(airdata[3][i]);x[i][2]=Math.log(airdata[4][i]);x[i][3]=airdata[5][i];y[i]=Math.log(airdata[2][i]);}instance.addObservations(x,y);try {RegressionResults result=instance.regress();Assert.assertNotNull("The test case is a prototype.",result);TestUtils.assertEquals(new double[]{9.5169,0.8827,0.4540,-1.6275},result.getParameterEstimates(),1e-4);TestUtils.assertEquals(new double[]{.2292445,.0132545,.0203042,.345302},result.getStdErrorOfEstimates(),1.0e-4);TestUtils.assertEquals(0.01552839,result.getMeanSquareError(),1.0e-8);}catch(Exception e){fail("Should not throw exception but does");}}
@Test public void testRegressAirlineConstantInternal(){MillerUpdatingRegression instance=new MillerUpdatingRegression(3,true);double[][]x=new double[airdata[0].length][];double[]y=new double[airdata[0].length];for (int i=0;i < airdata[0].length;i++){x[i]=new double[3];x[i][0]=Math.log(airdata[3][i]);x[i][1]=Math.log(airdata[4][i]);x[i][2]=airdata[5][i];y[i]=Math.log(airdata[2][i]);}instance.addObservations(x,y);try {RegressionResults result=instance.regress();Assert.assertNotNull("The test case is a prototype.",result);TestUtils.assertEquals(new double[]{9.5169,0.8827,0.4540,-1.6275},result.getParameterEstimates(),1e-4);TestUtils.assertEquals(new double[]{.2292445,.0132545,.0203042,.345302},result.getStdErrorOfEstimates(),1.0e-4);TestUtils.assertEquals(0.9883,result.getRSquared(),1.0e-4);TestUtils.assertEquals(0.01552839,result.getMeanSquareError(),1.0e-8);}catch(Exception e){fail("Should not throw exception but does");}}
@Test public void testFilippelli(){double[]data=new double[]{0.8116,-6.860120914,0.9072,-4.324130045,0.9052,-4.358625055,0.9039,-4.358426747,0.8053,-6.955852379,0.8377,-6.661145254,0.8667,-6.355462942,0.8809,-6.118102026,0.7975,-7.115148017,0.8162,-6.815308569,0.8515,-6.519993057,0.8766,-6.204119983,0.8885,-5.853871964,0.8859,-6.109523091,0.8959,-5.79832982,0.8913,-5.482672118,0.8959,-5.171791386,0.8971,-4.851705903,0.9021,-4.517126416,0.909,-4.143573228,0.9139,-3.709075441,0.9199,-3.499489089,0.8692,-6.300769497,0.8872,-5.953504836,0.89,-5.642065153,0.891,-5.031376979,0.8977,-4.680685696,0.9035,-4.329846955,0.9078,-3.928486195,0.7675,-8.56735134,0.7705,-8.363211311,0.7713,-8.107682739,0.7736,-7.823908741,0.7775,-7.522878745,0.7841,-7.218819279,0.7971,-6.920818754,0.8329,-6.628932138,0.8641,-6.323946875,0.8804,-5.991399828,0.7668,-8.781464495,0.7633,-8.663140179,0.7678,-8.473531488,0.7697,-8.247337057,0.77,-7.971428747,0.7749,-7.676129393,0.7796,-7.352812702,0.7897,-7.072065318,0.8131,-6.774174009,0.8498,-6.478861916,0.8741,-6.159517513,0.8061,-6.835647144,0.846,-6.53165267,0.8751,-6.224098421,0.8856,-5.910094889,0.8919,-5.598599459,0.8934,-5.290645224,0.894,-4.974284616,0.8957,-4.64454848,0.9047,-4.290560426,0.9129,-3.885055584,0.9209,-3.408378962,0.9219,-3.13200249,0.7739,-8.726767166,0.7681,-8.66695597,0.7665,-8.511026475,0.7703,-8.165388579,0.7702,-7.886056648,0.7761,-7.588043762,0.7809,-7.283412422,0.7961,-6.995678626,0.8253,-6.691862621,0.8602,-6.392544977,0.8809,-6.067374056,0.8301,-6.684029655,0.8664,-6.378719832,0.8834,-6.065855188,0.8898,-5.752272167,0.8964,-5.132414673,0.8963,-4.811352704,0.9074,-4.098269308,0.9119,-3.66174277,0.9228,-3.2644011};MillerUpdatingRegression model=new MillerUpdatingRegression(10,true);int off=0;double[]tmp=new double[10];int nobs=82;for (int i=0;i < nobs;i++){tmp[0]=data[off + 1];tmp[1]=tmp[0]* tmp[0];tmp[2]=tmp[0]* tmp[1];tmp[3]=tmp[0]* tmp[2];tmp[4]=tmp[0]* tmp[3];tmp[5]=tmp[0]* tmp[4];tmp[6]=tmp[0]* tmp[5];tmp[7]=tmp[0]* tmp[6];tmp[8]=tmp[0]* tmp[7];tmp[9]=tmp[0]* tmp[8];model.addObservation(tmp,data[off]);off+=2;}RegressionResults result=model.regress();double[]betaHat=result.getParameterEstimates();TestUtils.assertEquals(betaHat,new double[]{-1467.48961422980,-2772.17959193342,-2316.37108160893,-1127.97394098372,-354.478233703349,-75.1242017393757,-10.8753180355343,-1.06221498588947,-0.670191154593408E-01,-0.246781078275479E-02,-0.402962525080404E-04},1E-5);double[]se=result.getStdErrorOfEstimates();TestUtils.assertEquals(se,new double[]{298.084530995537,559.779865474950,466.477572127796,227.204274477751,71.6478660875927,15.2897178747400,2.23691159816033,0.221624321934227,0.142363763154724E-01,0.535617408889821E-03,0.896632837373868E-05},1E-5);TestUtils.assertEquals(0.996727416185620,result.getRSquared(),1.0e-8);TestUtils.assertEquals(0.112091743968020E-04,result.getMeanSquareError(),1.0e-10);TestUtils.assertEquals(0.795851382172941E-03,result.getErrorSumSquares(),1.0e-10);}
@Test public void testWampler1(){double[]data=new double[]{1,0,6,1,63,2,364,3,1365,4,3906,5,9331,6,19608,7,37449,8,66430,9,111111,10,177156,11,271453,12,402234,13,579195,14,813616,15,1118481,16,1508598,17,2000719,18,2613660,19,3368421,20};MillerUpdatingRegression model=new MillerUpdatingRegression(5,true);int off=0;double[]tmp=new double[5];int nobs=21;for (int i=0;i < nobs;i++){tmp[0]=data[off + 1];tmp[1]=tmp[0]* tmp[0];tmp[2]=tmp[0]* tmp[1];tmp[3]=tmp[0]* tmp[2];tmp[4]=tmp[0]* tmp[3];model.addObservation(tmp,data[off]);off+=2;}RegressionResults result=model.regress();double[]betaHat=result.getParameterEstimates();TestUtils.assertEquals(betaHat,new double[]{1.0,1.0,1.0,1.0,1.0,1.0},1E-8);double[]se=result.getStdErrorOfEstimates();TestUtils.assertEquals(se,new double[]{0.0,0.0,0.0,0.0,0.0,0.0},1E-8);TestUtils.assertEquals(1.0,result.getRSquared(),1.0e-10);TestUtils.assertEquals(0,result.getMeanSquareError(),1.0e-7);TestUtils.assertEquals(0.00,result.getErrorSumSquares(),1.0e-6);return;}
@Test public void testWampler2(){double[]data=new double[]{1.00000,0,1.11111,1,1.24992,2,1.42753,3,1.65984,4,1.96875,5,2.38336,6,2.94117,7,3.68928,8,4.68559,9,6.00000,10,7.71561,11,9.92992,12,12.75603,13,16.32384,14,20.78125,15,26.29536,16,33.05367,17,41.26528,18,51.16209,19,63.00000,20};MillerUpdatingRegression model=new MillerUpdatingRegression(5,true);int off=0;double[]tmp=new double[5];int nobs=21;for (int i=0;i < nobs;i++){tmp[0]=data[off + 1];tmp[1]=tmp[0]* tmp[0];tmp[2]=tmp[0]* tmp[1];tmp[3]=tmp[0]* tmp[2];tmp[4]=tmp[0]* tmp[3];model.addObservation(tmp,data[off]);off+=2;}RegressionResults result=model.regress();double[]betaHat=result.getParameterEstimates();TestUtils.assertEquals(betaHat,new double[]{1.0,1.0e-1,1.0e-2,1.0e-3,1.0e-4,1.0e-5},1E-8);double[]se=result.getStdErrorOfEstimates();TestUtils.assertEquals(se,new double[]{0.0,0.0,0.0,0.0,0.0,0.0},1E-8);TestUtils.assertEquals(1.0,result.getRSquared(),1.0e-10);TestUtils.assertEquals(0,result.getMeanSquareError(),1.0e-7);TestUtils.assertEquals(0.00,result.getErrorSumSquares(),1.0e-6);return;}
@Test public void testWampler3(){double[]data=new double[]{760,0,-2042,1,2111,2,-1684,3,3888,4,1858,5,11379,6,17560,7,39287,8,64382,9,113159,10,175108,11,273291,12,400186,13,581243,14,811568,15,1121004,16,1506550,17,2002767,18,2611612,19,3369180,20};MillerUpdatingRegression model=new MillerUpdatingRegression(5,true);int off=0;double[]tmp=new double[5];int nobs=21;for (int i=0;i < nobs;i++){tmp[0]=data[off + 1];tmp[1]=tmp[0]* tmp[0];tmp[2]=tmp[0]* tmp[1];tmp[3]=tmp[0]* tmp[2];tmp[4]=tmp[0]* tmp[3];model.addObservation(tmp,data[off]);off+=2;}RegressionResults result=model.regress();double[]betaHat=result.getParameterEstimates();TestUtils.assertEquals(betaHat,new double[]{1.0,1.0,1.0,1.0,1.0,1.0},1E-8);double[]se=result.getStdErrorOfEstimates();TestUtils.assertEquals(se,new double[]{2152.32624678170,2363.55173469681,779.343524331583,101.475507550350,5.64566512170752,0.112324854679312},1E-8);TestUtils.assertEquals(.999995559025820,result.getRSquared(),1.0e-10);TestUtils.assertEquals(5570284.53333333,result.getMeanSquareError(),1.0e-7);TestUtils.assertEquals(83554268.0000000,result.getErrorSumSquares(),1.0e-6);return;}
public void testWampler4(){double[]data=new double[]{75901,0,-204794,1,204863,2,-204436,3,253665,4,-200894,5,214131,6,-185192,7,221249,8,-138370,9,315911,10,-27644,11,455253,12,197434,13,783995,14,608816,15,1370781,16,1303798,17,2205519,18,2408860,19,3444321,20};MillerUpdatingRegression model=new MillerUpdatingRegression(5,true);int off=0;double[]tmp=new double[5];int nobs=21;for (int i=0;i < nobs;i++){tmp[0]=data[off + 1];tmp[1]=tmp[0]* tmp[0];tmp[2]=tmp[0]* tmp[1];tmp[3]=tmp[0]* tmp[2];tmp[4]=tmp[0]* tmp[3];model.addObservation(tmp,data[off]);off+=2;}RegressionResults result=model.regress();double[]betaHat=result.getParameterEstimates();TestUtils.assertEquals(betaHat,new double[]{1.0,1.0,1.0,1.0,1.0,1.0},1E-8);double[]se=result.getStdErrorOfEstimates();TestUtils.assertEquals(se,new double[]{215232.624678170,236355.173469681,77934.3524331583,10147.5507550350,564.566512170752,11.2324854679312},1E-8);TestUtils.assertEquals(.957478440825662,result.getRSquared(),1.0e-10);TestUtils.assertEquals(55702845333.3333,result.getMeanSquareError(),1.0e-4);TestUtils.assertEquals(835542680000.000,result.getErrorSumSquares(),1.0e-3);return;}
/** * Test Longley dataset against certified values provided by NIST. Data Source: J. Longley (1967)"An Appraisal of Least Squares Programs for the Electronic Computer from the Point of View of the User" Journal of the American Statistical Association,vol. 62. September,pp. 819-841. Certified values (and data)are from NIST: http://www.itl.nist.gov/div898/strd/lls/data/LINKS/DATA/Longley.dat*/@Test public void testLongly()throws Exception {double[]design=new double[]{60323,83.0,234289,2356,1590,107608,1947,61122,88.5,259426,2325,1456,108632,1948,60171,88.2,258054,3682,1616,109773,1949,61187,89.5,284599,3351,1650,110929,1950,63221,96.2,328975,2099,3099,112075,1951,63639,98.1,346999,1932,3594,113270,1952,64989,99.0,365385,1870,3547,115094,1953,63761,100.0,363112,3578,3350,116219,1954,66019,101.2,397469,2904,3048,117388,1955,67857,104.6,419180,2822,2857,118734,1956,68169,108.4,442769,2936,2798,120445,1957,66513,110.8,444546,4681,2637,121950,1958,68655,112.6,482704,3813,2552,123366,1959,69564,114.2,502601,3931,2514,125368,1960,69331,115.7,518173,4806,2572,127852,1961,70551,116.9,554894,4007,2827,130081,1962};final int nobs=16;final int nvars=6;MillerUpdatingRegression model=new MillerUpdatingRegression(6,true);int off=0;double[]tmp=new double[6];for (int i=0;i < nobs;i++){System.arraycopy(design,off + 1,tmp,0,nvars);model.addObservation(tmp,design[off]);off+=nvars + 1;}RegressionResults result=model.regress();double[]betaHat=result.getParameterEstimates();TestUtils.assertEquals(betaHat,new double[]{-3482258.63459582,15.0618722713733,-0.358191792925910E-01,-2.02022980381683,-1.03322686717359,-0.511041056535807E-01,1829.15146461355},1E-8);double[]errors=result.getStdErrorOfEstimates();TestUtils.assertEquals(new double[]{890420.383607373,84.9149257747669,0.334910077722432E-01,0.488399681651699,0.214274163161675,0.226073200069370,455.478499142212},errors,1E-6);TestUtils.assertEquals(0.995479004577296,result.getRSquared(),1E-12);TestUtils.assertEquals(0.992465007628826,result.getAdjustedRSquared(),1E-12);model=new MillerUpdatingRegression(6,false);off=0;for (int i=0;i < nobs;i++){System.arraycopy(design,off + 1,tmp,0,nvars);model.addObservation(tmp,design[off]);off+=nvars + 1;}result=model.regress();betaHat=result.getParameterEstimates();TestUtils.assertEquals(betaHat,new double[]{-52.99357013868291,0.07107319907358,-0.42346585566399,-0.57256866841929,-0.41420358884978,48.41786562001326},1E-11);errors=result.getStdErrorOfEstimates();TestUtils.assertEquals(new double[]{129.54486693117232,0.03016640003786,0.41773654056612,0.27899087467676,0.32128496193363,17.68948737819961},errors,1E-11);TestUtils.assertEquals(0.9999670130706,result.getRSquared(),1E-12);TestUtils.assertEquals(0.999947220913,result.getAdjustedRSquared(),1E-12);}
@Test public void testOneRedundantColumn(){MillerUpdatingRegression instance=new MillerUpdatingRegression(4,false);MillerUpdatingRegression instance2=new MillerUpdatingRegression(5,false);double[][]x=new double[airdata[0].length][];double[][]x2=new double[airdata[0].length][];double[]y=new double[airdata[0].length];for (int i=0;i < airdata[0].length;i++){x[i]=new double[4];x2[i]=new double[5];x[i][0]=1.0;x[i][1]=Math.log(airdata[3][i]);x[i][2]=Math.log(airdata[4][i]);x[i][3]=airdata[5][i];x2[i][0]=x[i][0];x2[i][1]=x[i][1];x2[i][2]=x[i][2];x2[i][3]=x[i][3];x2[i][4]=x[i][3];y[i]=Math.log(airdata[2][i]);}instance.addObservations(x,y);RegressionResults result=instance.regress();Assert.assertNotNull("Could not estimate initial regression",result);instance2.addObservations(x2,y);RegressionResults resultRedundant=instance2.regress();Assert.assertNotNull("Could not estimate redundant regression",resultRedundant);double[]beta=result.getParameterEstimates();double[]betar=resultRedundant.getParameterEstimates();double[]se=result.getStdErrorOfEstimates();double[]ser=resultRedundant.getStdErrorOfEstimates();for (int i=0;i < beta.length;i++){if (Math.abs(beta[i]- betar[i])> 1.0e-8){fail("Parameters not correctly estimated");}if (Math.abs(se[i]- ser[i])> 1.0e-8){fail("Standard errors not correctly estimated");}for (int j=0;j < i;j++){if (Math.abs(result.getCovarianceOfParameters(i,j)- resultRedundant.getCovarianceOfParameters(i,j))> 1.0e-8){fail("Variance Covariance not correct");}}}TestUtils.assertEquals(result.getAdjustedRSquared(),resultRedundant.getAdjustedRSquared(),1.0e-8);TestUtils.assertEquals(result.getErrorSumSquares(),resultRedundant.getErrorSumSquares(),1.0e-8);TestUtils.assertEquals(result.getMeanSquareError(),resultRedundant.getMeanSquareError(),1.0e-8);TestUtils.assertEquals(result.getRSquared(),resultRedundant.getRSquared(),1.0e-8);return;}
@Test public void testThreeRedundantColumn(){MillerUpdatingRegression instance=new MillerUpdatingRegression(4,false);MillerUpdatingRegression instance2=new MillerUpdatingRegression(7,false);double[][]x=new double[airdata[0].length][];double[][]x2=new double[airdata[0].length][];double[]y=new double[airdata[0].length];for (int i=0;i < airdata[0].length;i++){x[i]=new double[4];x2[i]=new double[7];x[i][0]=1.0;x[i][1]=Math.log(airdata[3][i]);x[i][2]=Math.log(airdata[4][i]);x[i][3]=airdata[5][i];x2[i][0]=x[i][0];x2[i][1]=x[i][0];x2[i][2]=x[i][1];x2[i][3]=x[i][2];x2[i][4]=x[i][1];x2[i][5]=x[i][3];x2[i][6]=x[i][2];y[i]=Math.log(airdata[2][i]);}instance.addObservations(x,y);RegressionResults result=instance.regress();Assert.assertNotNull("Could not estimate initial regression",result);instance2.addObservations(x2,y);RegressionResults resultRedundant=instance2.regress();Assert.assertNotNull("Could not estimate redundant regression",resultRedundant);double[]beta=result.getParameterEstimates();double[]betar=resultRedundant.getParameterEstimates();double[]se=result.getStdErrorOfEstimates();double[]ser=resultRedundant.getStdErrorOfEstimates();if (Math.abs(beta[0]- betar[0])> 1.0e-8){fail("Parameters not correct after reorder (0,3)");}if (Math.abs(beta[1]- betar[2])> 1.0e-8){fail("Parameters not correct after reorder (1,2)");}if (Math.abs(beta[2]- betar[3])> 1.0e-8){fail("Parameters not correct after reorder (2,1)");}if (Math.abs(beta[3]- betar[5])> 1.0e-8){fail("Parameters not correct after reorder (3,0)");}if (Math.abs(se[0]- ser[0])> 1.0e-8){fail("Se not correct after reorder (0,3)");}if (Math.abs(se[1]- ser[2])> 1.0e-8){fail("Se not correct after reorder (1,2)");}if (Math.abs(se[2]- ser[3])> 1.0e-8){fail("Se not correct after reorder (2,1)");}if (Math.abs(se[3]- ser[5])> 1.0e-8){fail("Se not correct after reorder (3,0)");}if (Math.abs(result.getCovarianceOfParameters(0,0)- resultRedundant.getCovarianceOfParameters(0,0))> 1.0e-8){fail("VCV not correct after reorder (0,0)");}if (Math.abs(result.getCovarianceOfParameters(0,1)- resultRedundant.getCovarianceOfParameters(0,2))> 1.0e-8){fail("VCV not correct after reorder (0,1)<->(0,2)");}if (Math.abs(result.getCovarianceOfParameters(0,2)- resultRedundant.getCovarianceOfParameters(0,3))> 1.0e-8){fail("VCV not correct after reorder (0,2)<->(0,1)");}if (Math.abs(result.getCovarianceOfParameters(0,3)- resultRedundant.getCovarianceOfParameters(0,5))> 1.0e-8){fail("VCV not correct after reorder (0,3)<->(0,3)");}if (Math.abs(result.getCovarianceOfParameters(1,0)- resultRedundant.getCovarianceOfParameters(2,0))> 1.0e-8){fail("VCV not correct after reorder (1,0)<->(2,0)");}if (Math.abs(result.getCovarianceOfParameters(1,1)- resultRedundant.getCovarianceOfParameters(2,2))> 1.0e-8){fail("VCV not correct  (1,1)<->(2,1)");}if (Math.abs(result.getCovarianceOfParameters(1,2)- resultRedundant.getCovarianceOfParameters(2,3))> 1.0e-8){fail("VCV not correct  (1,2)<->(2,2)");}if (Math.abs(result.getCovarianceOfParameters(2,0)- resultRedundant.getCovarianceOfParameters(3,0))> 1.0e-8){fail("VCV not correct  (2,0)<->(1,0)");}if (Math.abs(result.getCovarianceOfParameters(2,1)- resultRedundant.getCovarianceOfParameters(3,2))> 1.0e-8){fail("VCV not correct  (2,1)<->(1,2)");}if (Math.abs(result.getCovarianceOfParameters(3,3)- resultRedundant.getCovarianceOfParameters(5,5))> 1.0e-8){fail("VCV not correct  (3,3)<->(3,2)");}TestUtils.assertEquals(result.getAdjustedRSquared(),resultRedundant.getAdjustedRSquared(),1.0e-8);TestUtils.assertEquals(result.getErrorSumSquares(),resultRedundant.getErrorSumSquares(),1.0e-8);TestUtils.assertEquals(result.getMeanSquareError(),resultRedundant.getMeanSquareError(),1.0e-8);TestUtils.assertEquals(result.getRSquared(),resultRedundant.getRSquared(),1.0e-8);return;}
@Test public void testPCorr(){MillerUpdatingRegression instance=new MillerUpdatingRegression(4,false);double[][]x=new double[airdata[0].length][];double[]y=new double[airdata[0].length];double[]cp=new double[10];double[]yxcorr=new double[4];double[]diag=new double[4];double sumysq=0.0;int off=0;for (int i=0;i < airdata[0].length;i++){x[i]=new double[4];x[i][0]=1.0;x[i][1]=Math.log(airdata[3][i]);x[i][2]=Math.log(airdata[4][i]);x[i][3]=airdata[5][i];y[i]=Math.log(airdata[2][i]);off=0;for (int j=0;j < 4;j++){double tmp=x[i][j];for (int k=0;k <= j;k++,off++){cp[off]+=tmp * x[i][k];}yxcorr[j]+=tmp * y[i];}sumysq+=y[i]* y[i];}PearsonsCorrelation pearson=new PearsonsCorrelation(x);RealMatrix corr=pearson.getCorrelationMatrix();off=0;for (int i=0;i < 4;i++,off+=(i + 1)){diag[i]=FastMath.sqrt(cp[off]);}instance.addObservations(x,y);double[]pc=instance.getPartialCorrelations(0);int idx=0;off=0;int off2=6;for (int i=0;i < 4;i++){for (int j=0;j < i;j++){if (Math.abs(pc[idx]- cp[off]/ (diag[i]* diag[j]))> 1.0e-8){fail("Failed cross products... i = " + i + " j = "+ j);}++idx;++off;}++off;if (Math.abs(pc[i + off2]- yxcorr[i]/ (FastMath.sqrt(sumysq)* diag[i]))> 1.0e-8){fail("failed cross product i = " + i + " y");}}double[]pc2=instance.getPartialCorrelations(1);idx=0;for (int i=1;i < 4;i++){for (int j=1;j < i;j++){if (Math.abs(pc2[idx]- corr.getEntry(j,i))> 1.0e-8){fail("Failed cross products... i = " + i + " j = "+ j);}++idx;}}double[]pc3=instance.getPartialCorrelations(2);if (pc3 == null){fail("Should not be null");}return;}
@Test public void testHdiag(){MillerUpdatingRegression instance=new MillerUpdatingRegression(4,false);double[][]x=new double[airdata[0].length][];double[]y=new double[airdata[0].length];for (int i=0;i < airdata[0].length;i++){x[i]=new double[4];x[i][0]=1.0;x[i][1]=Math.log(airdata[3][i]);x[i][2]=Math.log(airdata[4][i]);x[i][3]=airdata[5][i];y[i]=Math.log(airdata[2][i]);}instance.addObservations(x,y);OLSMultipleLinearRegression ols=new OLSMultipleLinearRegression();ols.setNoIntercept(true);ols.newSampleData(y,x);RealMatrix rm=ols.calculateHat();for (int i=0;i < x.length;i++){TestUtils.assertEquals(instance.getDiagonalOfHatMatrix(x[i]),rm.getEntry(i,i),1.0e-8);}return;}
@Test public void testHdiagConstant(){MillerUpdatingRegression instance=new MillerUpdatingRegression(3,true);double[][]x=new double[airdata[0].length][];double[]y=new double[airdata[0].length];for (int i=0;i < airdata[0].length;i++){x[i]=new double[3];x[i][0]=Math.log(airdata[3][i]);x[i][1]=Math.log(airdata[4][i]);x[i][2]=airdata[5][i];y[i]=Math.log(airdata[2][i]);}instance.addObservations(x,y);OLSMultipleLinearRegression ols=new OLSMultipleLinearRegression();ols.setNoIntercept(false);ols.newSampleData(y,x);RealMatrix rm=ols.calculateHat();for (int i=0;i < x.length;i++){TestUtils.assertEquals(instance.getDiagonalOfHatMatrix(x[i]),rm.getEntry(i,i),1.0e-8);}return;}
@Test public void testSubsetRegression(){MillerUpdatingRegression instance=new MillerUpdatingRegression(3,true);MillerUpdatingRegression redRegression=new MillerUpdatingRegression(2,true);double[][]x=new double[airdata[0].length][];double[][]xReduced=new double[airdata[0].length][];double[]y=new double[airdata[0].length];for (int i=0;i < airdata[0].length;i++){x[i]=new double[3];x[i][0]=Math.log(airdata[3][i]);x[i][1]=Math.log(airdata[4][i]);x[i][2]=airdata[5][i];xReduced[i]=new double[2];xReduced[i][0]=Math.log(airdata[3][i]);xReduced[i][1]=Math.log(airdata[4][i]);y[i]=Math.log(airdata[2][i]);}instance.addObservations(x,y);redRegression.addObservations(xReduced,y);RegressionResults resultsInstance=instance.regress(new int[]{0,1,2});RegressionResults resultsReduced=redRegression.regress();TestUtils.assertEquals(resultsInstance.getParameterEstimates(),resultsReduced.getParameterEstimates(),1.0e-12);TestUtils.assertEquals(resultsInstance.getStdErrorOfEstimates(),resultsReduced.getStdErrorOfEstimates(),1.0e-12);}
@Test public void testBoundaries(){double range=pb.getFinalTime()- pb.getInitialTime();setLastSeen(false);integ.addStepHandler(new StepNormalizer(range / 10.0,new FixedStepHandler(){private boolean firstCall=true;public void init(double t0,double[]y0,double t){}public void handleStep(double t,double[]y,double[]yDot,boolean isLast){if (firstCall){checkValue(t,pb.getInitialTime());firstCall=false;}if (isLast){setLastSeen(true);checkValue(t,pb.getFinalTime());}}}));integ.integrate(pb,pb.getInitialTime(),pb.getInitialState(),pb.getFinalTime(),new double[pb.getDimension()]);Assert.assertTrue(lastSeen);}
@Test public void testBeforeEnd(){final double range=pb.getFinalTime()- pb.getInitialTime();setLastSeen(false);integ.addStepHandler(new StepNormalizer(range / 10.5,new FixedStepHandler(){public void init(double t0,double[]y0,double t){}public void handleStep(double t,double[]y,double[]yDot,boolean isLast){if (isLast){setLastSeen(true);checkValue(t,pb.getFinalTime()- range / 21.0);}}}));integ.integrate(pb,pb.getInitialTime(),pb.getInitialState(),pb.getFinalTime(),new double[pb.getDimension()]);Assert.assertTrue(lastSeen);}
/** * test solve dimension errors */@Test public void testSolveDimensionErrors(){DecompositionSolver solver=new SingularValueDecomposition(MatrixUtils.createRealMatrix(testSquare)).getSolver();RealMatrix b=MatrixUtils.createRealMatrix(new double[3][2]);try {solver.solve(b);Assert.fail("an exception should have been thrown");}catch(MathIllegalArgumentException iae){}try {solver.solve(b.getColumnVector(0));Assert.fail("an exception should have been thrown");}catch(MathIllegalArgumentException iae){}try {solver.solve(new ArrayRealVectorTest.RealVectorTestImpl(b.getColumn(0)));Assert.fail("an exception should have been thrown");}catch(MathIllegalArgumentException iae){}}
/** * test least square solve */@Test public void testLeastSquareSolve(){RealMatrix m=MatrixUtils.createRealMatrix(new double[][]{{1.0,0.0},{0.0,0.0}});DecompositionSolver solver=new SingularValueDecomposition(m).getSolver();RealMatrix b=MatrixUtils.createRealMatrix(new double[][]{{11,12},{21,22}});RealMatrix xMatrix=solver.solve(b);Assert.assertEquals(11,xMatrix.getEntry(0,0),1.0e-15);Assert.assertEquals(12,xMatrix.getEntry(0,1),1.0e-15);Assert.assertEquals(0,xMatrix.getEntry(1,0),1.0e-15);Assert.assertEquals(0,xMatrix.getEntry(1,1),1.0e-15);RealVector xColVec=solver.solve(b.getColumnVector(0));Assert.assertEquals(11,xColVec.getEntry(0),1.0e-15);Assert.assertEquals(0,xColVec.getEntry(1),1.0e-15);RealVector xColOtherVec=solver.solve(new ArrayRealVectorTest.RealVectorTestImpl(b.getColumn(0)));Assert.assertEquals(11,xColOtherVec.getEntry(0),1.0e-15);Assert.assertEquals(0,xColOtherVec.getEntry(1),1.0e-15);}
/** * test solve */@Test public void testSolve(){DecompositionSolver solver=new SingularValueDecomposition(MatrixUtils.createRealMatrix(testSquare)).getSolver();RealMatrix b=MatrixUtils.createRealMatrix(new double[][]{{1,2,3},{0,-5,1}});RealMatrix xRef=MatrixUtils.createRealMatrix(new double[][]{{-8.0 / 25.0,-263.0 / 75.0,-29.0 / 75.0},{19.0 / 25.0,78.0 / 25.0,49.0 / 25.0}});Assert.assertEquals(0,solver.solve(b).subtract(xRef).getNorm(),normTolerance);for (int i=0;i < b.getColumnDimension();++i){Assert.assertEquals(0,solver.solve(b.getColumnVector(i)).subtract(xRef.getColumnVector(i)).getNorm(),1.0e-13);}for (int i=0;i < b.getColumnDimension();++i){ArrayRealVectorTest.RealVectorTestImpl v=new ArrayRealVectorTest.RealVectorTestImpl(b.getColumn(i));Assert.assertEquals(0,solver.solve(v).subtract(xRef.getColumnVector(i)).getNorm(),1.0e-13);}}
/** * test condition number */@Test public void testConditionNumber(){SingularValueDecomposition svd=new SingularValueDecomposition(MatrixUtils.createRealMatrix(testSquare));Assert.assertEquals(3.0,svd.getConditionNumber(),1.5e-15);}
@Test public void testMath320B(){RealMatrix rm=new Array2DRowRealMatrix(new double[][]{{1.0,2.0},{1.0,2.0}});SingularValueDecomposition svd=new SingularValueDecomposition(rm);RealMatrix recomposed=svd.getU().multiply(svd.getS()).multiply(svd.getVT());Assert.assertEquals(0.0,recomposed.subtract(rm).getNorm(),2.0e-15);}
@Test public void testHash(){double[]testArray={Double.NaN,Double.POSITIVE_INFINITY,Double.NEGATIVE_INFINITY,1d,0d,1E-14,(1 + 1E-14),Double.MIN_VALUE,Double.MAX_VALUE};for (int i=0;i < testArray.length;i++){for (int j=0;j < testArray.length;j++){if (i == j){Assert.assertEquals(MathUtils.hash(testArray[i]),MathUtils.hash(testArray[j]));Assert.assertEquals(MathUtils.hash(testArray[j]),MathUtils.hash(testArray[i]));}else {Assert.assertTrue(MathUtils.hash(testArray[i])!= MathUtils.hash(testArray[j]));Assert.assertTrue(MathUtils.hash(testArray[j])!= MathUtils.hash(testArray[i]));}}}}
@Test public void testArrayHash(){Assert.assertEquals(0,MathUtils.hash((double[])null));Assert.assertEquals(MathUtils.hash(new double[]{Double.NaN,Double.POSITIVE_INFINITY,Double.NEGATIVE_INFINITY,1d,0d}),MathUtils.hash(new double[]{Double.NaN,Double.POSITIVE_INFINITY,Double.NEGATIVE_INFINITY,1d,0d}));Assert.assertFalse(MathUtils.hash(new double[]{1d})== MathUtils.hash(new double[]{FastMath.nextAfter(1d,2d)}));Assert.assertFalse(MathUtils.hash(new double[]{1d})== MathUtils.hash(new double[]{1d,1d}));}
/** * Make sure that permuted arrays do not hash to the same value.*/@Test public void testPermutedArrayHash(){double[]original=new double[10];double[]permuted=new double[10];RandomDataImpl random=new RandomDataImpl();for (int i=0;i < 10;i++){original[i]=random.nextUniform(i + 0.5,i + 0.75);}boolean isIdentity=true;do {int[]permutation=random.nextPermutation(10,10);for (int i=0;i < 10;i++){if (i != permutation[i]){isIdentity=false;}permuted[i]=original[permutation[i]];}}while (isIdentity);Assert.assertFalse(MathUtils.hash(original)== MathUtils.hash(permuted));}
@Test public void testIndicatorByte(){Assert.assertEquals((byte)1,MathUtils.copySign((byte)1,(byte)2));Assert.assertEquals((byte)1,MathUtils.copySign((byte)1,(byte)0));Assert.assertEquals((byte)(-1),MathUtils.copySign((byte)1,(byte)(-2)));}
@Test public void testIndicatorInt(){Assert.assertEquals(1,MathUtils.copySign(1,2));Assert.assertEquals(1,MathUtils.copySign(1,0));Assert.assertEquals((-1),MathUtils.copySign(1,-2));}
@Test public void testIndicatorLong(){Assert.assertEquals(1L,MathUtils.copySign(1L,2L));Assert.assertEquals(1L,MathUtils.copySign(1L,0L));Assert.assertEquals(-1L,MathUtils.copySign(1L,-2L));}
@Test public void testIndicatorShort(){Assert.assertEquals((short)1,MathUtils.copySign((short)1,(short)2));Assert.assertEquals((short)1,MathUtils.copySign((short)1,(short)0));Assert.assertEquals((short)(-1),MathUtils.copySign((short)1,(short)(-2)));}
@Test public void testNormalizeAngle(){for (double a=-15.0;a <= 15.0;a+=0.1){for (double b=-15.0;b <= 15.0;b+=0.2){double c=MathUtils.normalizeAngle(a,b);Assert.assertTrue((b - FastMath.PI)<= c);Assert.assertTrue(c <= (b + FastMath.PI));double twoK=FastMath.rint((a - c)/ FastMath.PI);Assert.assertEquals(c,a - twoK * FastMath.PI,1.0e-14);}}}
@Test public void testReduce(){final double period=-12.222;final double offset=13;final double delta=1.5;double orig=offset + 122456789 * period + delta;double expected=delta;Assert.assertEquals(expected,MathUtils.reduce(orig,period,offset),1e-7);Assert.assertEquals(expected,MathUtils.reduce(orig,-period,offset),1e-7);orig=offset - 123356789 * period - delta;expected=Math.abs(period)- delta;Assert.assertEquals(expected,MathUtils.reduce(orig,period,offset),1e-6);Assert.assertEquals(expected,MathUtils.reduce(orig,-period,offset),1e-6);orig=offset - 123446789 * period + delta;expected=delta;Assert.assertEquals(expected,MathUtils.reduce(orig,period,offset),1e-6);Assert.assertEquals(expected,MathUtils.reduce(orig,-period,offset),1e-6);Assert.assertTrue(Double.isNaN(MathUtils.reduce(orig,Double.NaN,offset)));Assert.assertTrue(Double.isNaN(MathUtils.reduce(Double.NaN,period,offset)));Assert.assertTrue(Double.isNaN(MathUtils.reduce(orig,period,Double.NaN)));Assert.assertTrue(Double.isNaN(MathUtils.reduce(orig,period,Double.POSITIVE_INFINITY)));Assert.assertTrue(Double.isNaN(MathUtils.reduce(Double.POSITIVE_INFINITY,period,offset)));Assert.assertTrue(Double.isNaN(MathUtils.reduce(orig,Double.POSITIVE_INFINITY,offset)));Assert.assertTrue(Double.isNaN(MathUtils.reduce(orig,Double.POSITIVE_INFINITY,Double.POSITIVE_INFINITY)));Assert.assertTrue(Double.isNaN(MathUtils.reduce(Double.POSITIVE_INFINITY,period,Double.POSITIVE_INFINITY)));Assert.assertTrue(Double.isNaN(MathUtils.reduce(Double.POSITIVE_INFINITY,Double.POSITIVE_INFINITY,offset)));Assert.assertTrue(Double.isNaN(MathUtils.reduce(Double.POSITIVE_INFINITY,Double.POSITIVE_INFINITY,Double.POSITIVE_INFINITY)));}
@Test public void testReduceComparedWithNormalizeAngle(){final double tol=Math.ulp(1d);final double period=2 * Math.PI;for (double a=-15;a <= 15;a+=0.5){for (double center=-15;center <= 15;center+=1){final double nA=MathUtils.normalizeAngle(a,center);final double offset=center - Math.PI;final double r=MathUtils.reduce(a,period,offset);Assert.assertEquals(nA,r + offset,tol);}}}
@Test public void testSignByte(){Assert.assertEquals((byte)1,MathUtils.sign((byte)2));Assert.assertEquals((byte)0,MathUtils.sign((byte)0));Assert.assertEquals((byte)(-1),MathUtils.sign((byte)(-2)));}
@Test public void testSignInt(){Assert.assertEquals(1,MathUtils.sign(2));Assert.assertEquals(0,MathUtils.sign(0));Assert.assertEquals((-1),MathUtils.sign((-2)));}
@Test public void testSignLong(){Assert.assertEquals(1L,MathUtils.sign(2L));Assert.assertEquals(0L,MathUtils.sign(0L));Assert.assertEquals(-1L,MathUtils.sign(-2L));}
@Test public void testSignShort(){Assert.assertEquals((short)1,MathUtils.sign((short)2));Assert.assertEquals((short)0,MathUtils.sign((short)0));Assert.assertEquals((short)(-1),MathUtils.sign((short)(-2)));}
@Test public void testCheckFinite(){try {MathUtils.checkFinite(Double.POSITIVE_INFINITY);Assert.fail("an exception should have been thrown");}catch(NotFiniteNumberException e){}try {MathUtils.checkFinite(Double.NEGATIVE_INFINITY);Assert.fail("an exception should have been thrown");}catch(NotFiniteNumberException e){}try {MathUtils.checkFinite(Double.NaN);Assert.fail("an exception should have been thrown");}catch(NotFiniteNumberException e){}try {MathUtils.checkFinite(new double[]{0,-1,Double.POSITIVE_INFINITY,-2,3});Assert.fail("an exception should have been thrown");}catch(NotFiniteNumberException e){}try {MathUtils.checkFinite(new double[]{1,Double.NEGATIVE_INFINITY,-2,3});Assert.fail("an exception should have been thrown");}catch(NotFiniteNumberException e){}try {MathUtils.checkFinite(new double[]{4,3,-1,Double.NaN,-2,1});Assert.fail("an exception should have been thrown");}catch(NotFiniteNumberException e){}}
@Test public void testCheckNotNull1(){try {Object obj=null;MathUtils.checkNotNull(obj);}catch(NullArgumentException e){}}
@Test public void testCheckNotNull2(){try {double[]array=null;MathUtils.checkNotNull(array,LocalizedFormats.INPUT_ARRAY);}catch(NullArgumentException e){}}
@Test public void testCopySignByte(){byte a=MathUtils.copySign(Byte.MIN_VALUE,(byte)-1);Assert.assertEquals(Byte.MIN_VALUE,a);final byte minValuePlusOne=Byte.MIN_VALUE + (byte)1;a=MathUtils.copySign(minValuePlusOne,(byte)1);Assert.assertEquals(Byte.MAX_VALUE,a);a=MathUtils.copySign(Byte.MAX_VALUE,(byte)-1);Assert.assertEquals(minValuePlusOne,a);final byte one=1;byte val=-2;a=MathUtils.copySign(val,one);Assert.assertEquals(-val,a);final byte minusOne=-one;val=2;a=MathUtils.copySign(val,minusOne);Assert.assertEquals(-val,a);val=0;a=MathUtils.copySign(val,minusOne);Assert.assertEquals(val,a);val=0;a=MathUtils.copySign(val,one);Assert.assertEquals(val,a);}
@Test(expected=MathArithmeticException.class)public void testCopySignByte2(){MathUtils.copySign(Byte.MIN_VALUE,(byte)1);}
@Test(expected=NullArgumentException.class)public void testPreconditions1(){new StepFunction(null,new double[]{0,-1,-2});}
@Test(expected=NullArgumentException.class)public void testPreconditions2(){new StepFunction(new double[]{0,1},null);}
@Test(expected=NoDataException.class)public void testPreconditions3(){new StepFunction(new double[]{0},new double[]{});}
@Test(expected=NoDataException.class)public void testPreconditions4(){new StepFunction(new double[]{},new double[]{0});}
@Test(expected=DimensionMismatchException.class)public void testPreconditions5(){new StepFunction(new double[]{0,1},new double[]{0,-1,-2});}
@Test(expected=NonMonotonicSequenceException.class)public void testPreconditions6(){new StepFunction(new double[]{1,0,1},new double[]{0,-1,-2});}
@Test public void testSomeValues(){final double[]x={-2,-0.5,0,1.9,7.4,21.3};final double[]y={4,-1,-5.5,0.4,5.8,51.2};final UnivariateFunction f=new StepFunction(x,y);Assert.assertEquals(4,f.value(Double.NEGATIVE_INFINITY),EPS);Assert.assertEquals(4,f.value(-10),EPS);Assert.assertEquals(-1,f.value(-0.4),EPS);Assert.assertEquals(-5.5,f.value(0),EPS);Assert.assertEquals(0.4,f.value(2),EPS);Assert.assertEquals(5.8,f.value(10),EPS);Assert.assertEquals(51.2,f.value(30),EPS);Assert.assertEquals(51.2,f.value(Double.POSITIVE_INFINITY),EPS);}
@Test public void testEndpointBehavior(){final double[]x={0,1,2,3};final double[]xp={-8,1,2,3};final double[]y={1,2,3,4};final UnivariateFunction f=new StepFunction(x,y);final UnivariateFunction fp=new StepFunction(xp,y);Assert.assertEquals(f.value(-8),fp.value(-8),EPS);Assert.assertEquals(f.value(-10),fp.value(-10),EPS);Assert.assertEquals(f.value(0),fp.value(0),EPS);Assert.assertEquals(f.value(0.5),fp.value(0.5),EPS);for (int i=0;i < x.length;i++){Assert.assertEquals(y[i],f.value(x[i]),EPS);if (i > 0){Assert.assertEquals(y[i - 1],f.value(x[i]- 0.5),EPS);}else {Assert.assertEquals(y[0],f.value(x[i]- 0.5),EPS);}}}
@Test public void testHeaviside(){final UnivariateFunction h=new StepFunction(new double[]{-1,0},new double[]{0,1});Assert.assertEquals(0,h.value(Double.NEGATIVE_INFINITY),0);Assert.assertEquals(0,h.value(-Double.MAX_VALUE),0);Assert.assertEquals(0,h.value(-2),0);Assert.assertEquals(0,h.value(-Double.MIN_VALUE),0);Assert.assertEquals(1,h.value(0),0);Assert.assertEquals(1,h.value(2),0);Assert.assertEquals(1,h.value(Double.POSITIVE_INFINITY),0);}
@Test public void testSine(){final int n=30;final double[]xval=new double[n];final double[]yval=new double[n];final double period=12.3;final double offset=45.67;double delta=0;for (int i=0;i < n;i++){delta+=rng.nextDouble()* period / n;xval[i]=offset + delta;yval[i]=FastMath.sin(xval[i]);}final UnivariateRealInterpolator inter=new LinearInterpolator();final UnivariateFunction f=inter.interpolate(xval,yval);final UnivariateRealInterpolator interP=new UnivariateRealPeriodicInterpolator(new LinearInterpolator(),period,1);final UnivariateFunction fP=interP.interpolate(xval,yval);final double xMin=xval[0];final double xMax=xval[n - 1];for (int i=0;i < n;i++){final double x=xMin + (xMax - xMin)* rng.nextDouble();final double y=f.value(x);final double yP=fP.value(x);Assert.assertEquals("x=" + x,y,yP,Math.ulp(1d));}for (int i=0;i < n;i++){final double xIn=offset + rng.nextDouble()* period;final double xOut=xIn + rng.nextInt(123456789)* period;final double yIn=fP.value(xIn);final double yOut=fP.value(xOut);Assert.assertEquals(yIn,yOut,1e-7);}}
@Test public void testLessThanOnePeriodCoverage(){final int n=30;final double[]xval=new double[n];final double[]yval=new double[n];final double period=12.3;final double offset=45.67;double delta=period / 2;for (int i=0;i < n;i++){delta+=period / (2 * n)* rng.nextDouble();xval[i]=offset + delta;yval[i]=FastMath.sin(xval[i]);}final UnivariateRealInterpolator interP=new UnivariateRealPeriodicInterpolator(new LinearInterpolator(),period,1);final UnivariateFunction fP=interP.interpolate(xval,yval);for (int i=0;i < n;i++){final double xIn=offset + rng.nextDouble()* period;final double xOut=xIn + rng.nextInt(123456789)* period;final double yIn=fP.value(xIn);final double yOut=fP.value(xOut);Assert.assertEquals(yIn,yOut,1e-7);}}
@Test public void testMoreThanOnePeriodCoverage(){final int n=30;final double[]xval=new double[n];final double[]yval=new double[n];final double period=12.3;final double offset=45.67;double delta=period / 2;for (int i=0;i < n;i++){delta+=10 * period / n * rng.nextDouble();xval[i]=offset + delta;yval[i]=FastMath.sin(xval[i]);}final UnivariateRealInterpolator interP=new UnivariateRealPeriodicInterpolator(new LinearInterpolator(),period,1);final UnivariateFunction fP=interP.interpolate(xval,yval);for (int i=0;i < n;i++){final double xIn=offset + rng.nextDouble()* period;final double xOut=xIn + rng.nextInt(123456789)* period;final double yIn=fP.value(xIn);final double yOut=fP.value(xOut);Assert.assertEquals(yIn,yOut,1e-6);}}
@Test(expected=NumberIsTooSmallException.class)public void testTooFewSamples(){final double[]xval={2,3,7};final double[]yval={1,6,5};final double period=10;final UnivariateRealInterpolator interpolator=new UnivariateRealPeriodicInterpolator(new LinearInterpolator(),period);interpolator.interpolate(xval,yval);}
@Test(expected=NonMonotonicSequenceException.class)public void testUnsortedSamples(){final double[]xval={2,3,7,4,6};final double[]yval={1,6,5,-1,-2};final double period=10;final UnivariateRealInterpolator interpolator=new UnivariateRealPeriodicInterpolator(new LinearInterpolator(),period);interpolator.interpolate(xval,yval);}
@Test public void testMinimize1(){SimplexOptimizer optimizer=new SimplexOptimizer(1e-10,1e-30);optimizer.setSimplex(new NelderMeadSimplex(new double[]{0.2,0.2}));final FourExtrema fourExtrema=new FourExtrema();final RealPointValuePair optimum=optimizer.optimize(100,fourExtrema,GoalType.MINIMIZE,new double[]{-3,0});Assert.assertEquals(fourExtrema.xM,optimum.getPoint()[0],2e-7);Assert.assertEquals(fourExtrema.yP,optimum.getPoint()[1],2e-5);Assert.assertEquals(fourExtrema.valueXmYp,optimum.getValue(),6e-12);Assert.assertTrue(optimizer.getEvaluations()> 60);Assert.assertTrue(optimizer.getEvaluations()< 90);}
@Test public void testMinimize2(){SimplexOptimizer optimizer=new SimplexOptimizer(1e-10,1e-30);optimizer.setSimplex(new NelderMeadSimplex(new double[]{0.2,0.2}));final FourExtrema fourExtrema=new FourExtrema();final RealPointValuePair optimum=optimizer.optimize(100,fourExtrema,GoalType.MINIMIZE,new double[]{1,0});Assert.assertEquals(fourExtrema.xP,optimum.getPoint()[0],5e-6);Assert.assertEquals(fourExtrema.yM,optimum.getPoint()[1],6e-6);Assert.assertEquals(fourExtrema.valueXpYm,optimum.getValue(),1e-11);Assert.assertTrue(optimizer.getEvaluations()> 60);Assert.assertTrue(optimizer.getEvaluations()< 90);}
@Test public void testMaximize1(){SimplexOptimizer optimizer=new SimplexOptimizer(1e-10,1e-30);optimizer.setSimplex(new NelderMeadSimplex(new double[]{0.2,0.2}));final FourExtrema fourExtrema=new FourExtrema();final RealPointValuePair optimum=optimizer.optimize(100,fourExtrema,GoalType.MAXIMIZE,new double[]{-3,0});Assert.assertEquals(fourExtrema.xM,optimum.getPoint()[0],1e-5);Assert.assertEquals(fourExtrema.yM,optimum.getPoint()[1],3e-6);Assert.assertEquals(fourExtrema.valueXmYm,optimum.getValue(),3e-12);Assert.assertTrue(optimizer.getEvaluations()> 60);Assert.assertTrue(optimizer.getEvaluations()< 90);}
@Test public void testMaximize2(){SimplexOptimizer optimizer=new SimplexOptimizer(1e-10,1e-30);optimizer.setSimplex(new NelderMeadSimplex(new double[]{0.2,0.2}));final FourExtrema fourExtrema=new FourExtrema();final RealPointValuePair optimum=optimizer.optimize(100,fourExtrema,GoalType.MAXIMIZE,new double[]{1,0});Assert.assertEquals(fourExtrema.xP,optimum.getPoint()[0],4e-6);Assert.assertEquals(fourExtrema.yP,optimum.getPoint()[1],5e-6);Assert.assertEquals(fourExtrema.valueXpYp,optimum.getValue(),7e-12);Assert.assertTrue(optimizer.getEvaluations()> 60);Assert.assertTrue(optimizer.getEvaluations()< 90);}
@Test public void testRosenbrock(){Rosenbrock rosenbrock=new Rosenbrock();SimplexOptimizer optimizer=new SimplexOptimizer(-1,1e-3);optimizer.setSimplex(new NelderMeadSimplex(new double[][]{{-1.2,1},{0.9,1.2},{3.5,-2.3}}));RealPointValuePair optimum=optimizer.optimize(100,rosenbrock,GoalType.MINIMIZE,new double[]{-1.2,1});Assert.assertEquals(rosenbrock.getCount(),optimizer.getEvaluations());Assert.assertTrue(optimizer.getEvaluations()> 40);Assert.assertTrue(optimizer.getEvaluations()< 50);Assert.assertTrue(optimum.getValue()< 8e-4);}
@Test public void testPowell(){Powell powell=new Powell();SimplexOptimizer optimizer=new SimplexOptimizer(-1,1e-3);optimizer.setSimplex(new NelderMeadSimplex(4));RealPointValuePair optimum=optimizer.optimize(200,powell,GoalType.MINIMIZE,new double[]{3,-1,0,1});Assert.assertEquals(powell.getCount(),optimizer.getEvaluations());Assert.assertTrue(optimizer.getEvaluations()> 110);Assert.assertTrue(optimizer.getEvaluations()< 130);Assert.assertTrue(optimum.getValue()< 2e-3);}
@Test public void testLeastSquares1(){final RealMatrix factors=new Array2DRowRealMatrix(new double[][]{{1,0},{0,1}},false);LeastSquaresConverter ls=new LeastSquaresConverter(new MultivariateVectorFunction(){public double[]value(double[]variables){return factors.operate(variables);}},new double[]{2.0,-3.0});SimplexOptimizer optimizer=new SimplexOptimizer(-1,1e-6);optimizer.setSimplex(new NelderMeadSimplex(2));RealPointValuePair optimum=optimizer.optimize(200,ls,GoalType.MINIMIZE,new double[]{10,10});Assert.assertEquals(2,optimum.getPointRef()[0],3e-5);Assert.assertEquals(-3,optimum.getPointRef()[1],4e-4);Assert.assertTrue(optimizer.getEvaluations()> 60);Assert.assertTrue(optimizer.getEvaluations()< 80);Assert.assertTrue(optimum.getValue()< 1.0e-6);}
@Test public void testLeastSquares2(){final RealMatrix factors=new Array2DRowRealMatrix(new double[][]{{1,0},{0,1}},false);LeastSquaresConverter ls=new LeastSquaresConverter(new MultivariateVectorFunction(){public double[]value(double[]variables){return factors.operate(variables);}},new double[]{2,-3},new double[]{10,0.1});SimplexOptimizer optimizer=new SimplexOptimizer(-1,1e-6);optimizer.setSimplex(new NelderMeadSimplex(2));RealPointValuePair optimum=optimizer.optimize(200,ls,GoalType.MINIMIZE,new double[]{10,10});Assert.assertEquals(2,optimum.getPointRef()[0],5e-5);Assert.assertEquals(-3,optimum.getPointRef()[1],8e-4);Assert.assertTrue(optimizer.getEvaluations()> 60);Assert.assertTrue(optimizer.getEvaluations()< 80);Assert.assertTrue(optimum.getValue()< 1e-6);}
@Test public void testLeastSquares3(){final RealMatrix factors=new Array2DRowRealMatrix(new double[][]{{1,0},{0,1}},false);LeastSquaresConverter ls=new LeastSquaresConverter(new MultivariateVectorFunction(){public double[]value(double[]variables){return factors.operate(variables);}},new double[]{2,-3},new Array2DRowRealMatrix(new double[][]{{1,1.2},{1.2,2}}));SimplexOptimizer optimizer=new SimplexOptimizer(-1,1e-6);optimizer.setSimplex(new NelderMeadSimplex(2));RealPointValuePair optimum=optimizer.optimize(200,ls,GoalType.MINIMIZE,new double[]{10,10});Assert.assertEquals(2,optimum.getPointRef()[0],2e-3);Assert.assertEquals(-3,optimum.getPointRef()[1],8e-4);Assert.assertTrue(optimizer.getEvaluations()> 60);Assert.assertTrue(optimizer.getEvaluations()< 80);Assert.assertTrue(optimum.getValue()< 1e-6);}
@Test(expected=TooManyEvaluationsException.class)public void testMaxIterations(){Powell powell=new Powell();SimplexOptimizer optimizer=new SimplexOptimizer(-1,1e-3);optimizer.setSimplex(new NelderMeadSimplex(4));optimizer.optimize(20,powell,GoalType.MINIMIZE,new double[]{3,-1,0,1});}
@Test public void testDormandPrince(){double tEnd=test(1);assertEquals(10.0,tEnd,1e-7);}
@Test public void testGragg(){double tEnd=test(2);assertEquals(10.0,tEnd,1e-7);}
public double test(int integratorType){double e=1e-15;FirstOrderIntegrator integrator;integrator=(integratorType == 1)? new DormandPrince853Integrator(e,100.0,1e-7,1e-7): new GraggBulirschStoerIntegrator(e,100.0,1e-7,1e-7);PegasusSolver rootSolver=new PegasusSolver(e,e);integrator.addEventHandler(new Event(),0.1,e,1000,rootSolver);double t0=6.0;double tEnd=10.0;double[]y={2.0,2.0,2.0,4.0,2.0,7.0,15.0};return integrator.integrate(new Ode(),t0,y,tEnd,y);}
@Test public void testDefault(){NaturalRanking ranking=new NaturalRanking();double[]ranks=ranking.rank(exampleData);double[]correctRanks={5,3,6,7,3,8,9,1,3};TestUtils.assertEquals(correctRanks,ranks,0d);ranks=ranking.rank(tiesFirst);correctRanks=new double[]{1.5,1.5,4,3,5};TestUtils.assertEquals(correctRanks,ranks,0d);ranks=ranking.rank(tiesLast);correctRanks=new double[]{3.5,3.5,2,1};TestUtils.assertEquals(correctRanks,ranks,0d);ranks=ranking.rank(multipleNaNs);correctRanks=new double[]{1,2,3.5,3.5};TestUtils.assertEquals(correctRanks,ranks,0d);ranks=ranking.rank(multipleTies);correctRanks=new double[]{3,2,4.5,4.5,6.5,6.5,1};TestUtils.assertEquals(correctRanks,ranks,0d);ranks=ranking.rank(allSame);correctRanks=new double[]{2.5,2.5,2.5,2.5};TestUtils.assertEquals(correctRanks,ranks,0d);}
@Test public void testNaNsMaximalTiesMinimum(){NaturalRanking ranking=new NaturalRanking(TiesStrategy.MINIMUM);double[]ranks=ranking.rank(exampleData);double[]correctRanks={5,2,6,7,2,8,9,1,2};TestUtils.assertEquals(correctRanks,ranks,0d);ranks=ranking.rank(tiesFirst);correctRanks=new double[]{1,1,4,3,5};TestUtils.assertEquals(correctRanks,ranks,0d);ranks=ranking.rank(tiesLast);correctRanks=new double[]{3,3,2,1};TestUtils.assertEquals(correctRanks,ranks,0d);ranks=ranking.rank(multipleNaNs);correctRanks=new double[]{1,2,3,3};TestUtils.assertEquals(correctRanks,ranks,0d);ranks=ranking.rank(multipleTies);correctRanks=new double[]{3,2,4,4,6,6,1};TestUtils.assertEquals(correctRanks,ranks,0d);ranks=ranking.rank(allSame);correctRanks=new double[]{1,1,1,1};TestUtils.assertEquals(correctRanks,ranks,0d);}
@Test public void testNaNsRemovedTiesSequential(){NaturalRanking ranking=new NaturalRanking(NaNStrategy.REMOVED,TiesStrategy.SEQUENTIAL);double[]ranks=ranking.rank(exampleData);double[]correctRanks={5,2,6,7,3,8,1,4};TestUtils.assertEquals(correctRanks,ranks,0d);ranks=ranking.rank(tiesFirst);correctRanks=new double[]{1,2,4,3,5};TestUtils.assertEquals(correctRanks,ranks,0d);ranks=ranking.rank(tiesLast);correctRanks=new double[]{3,4,2,1};TestUtils.assertEquals(correctRanks,ranks,0d);ranks=ranking.rank(multipleNaNs);correctRanks=new double[]{1,2};TestUtils.assertEquals(correctRanks,ranks,0d);ranks=ranking.rank(multipleTies);correctRanks=new double[]{3,2,4,5,6,7,1};TestUtils.assertEquals(correctRanks,ranks,0d);ranks=ranking.rank(allSame);correctRanks=new double[]{1,2,3,4};TestUtils.assertEquals(correctRanks,ranks,0d);}
@Test public void testNaNsMinimalTiesMaximum(){NaturalRanking ranking=new NaturalRanking(NaNStrategy.MINIMAL,TiesStrategy.MAXIMUM);double[]ranks=ranking.rank(exampleData);double[]correctRanks={6,5,7,8,5,9,2,2,5};TestUtils.assertEquals(correctRanks,ranks,0d);ranks=ranking.rank(tiesFirst);correctRanks=new double[]{2,2,4,3,5};TestUtils.assertEquals(correctRanks,ranks,0d);ranks=ranking.rank(tiesLast);correctRanks=new double[]{4,4,2,1};TestUtils.assertEquals(correctRanks,ranks,0d);ranks=ranking.rank(multipleNaNs);correctRanks=new double[]{3,4,2,2};TestUtils.assertEquals(correctRanks,ranks,0d);ranks=ranking.rank(multipleTies);correctRanks=new double[]{3,2,5,5,7,7,1};TestUtils.assertEquals(correctRanks,ranks,0d);ranks=ranking.rank(allSame);correctRanks=new double[]{4,4,4,4};TestUtils.assertEquals(correctRanks,ranks,0d);}
@Test public void testNaNsMinimalTiesAverage(){NaturalRanking ranking=new NaturalRanking(NaNStrategy.MINIMAL);double[]ranks=ranking.rank(exampleData);double[]correctRanks={6,4,7,8,4,9,1.5,1.5,4};TestUtils.assertEquals(correctRanks,ranks,0d);ranks=ranking.rank(tiesFirst);correctRanks=new double[]{1.5,1.5,4,3,5};TestUtils.assertEquals(correctRanks,ranks,0d);ranks=ranking.rank(tiesLast);correctRanks=new double[]{3.5,3.5,2,1};TestUtils.assertEquals(correctRanks,ranks,0d);ranks=ranking.rank(multipleNaNs);correctRanks=new double[]{3,4,1.5,1.5};TestUtils.assertEquals(correctRanks,ranks,0d);ranks=ranking.rank(multipleTies);correctRanks=new double[]{3,2,4.5,4.5,6.5,6.5,1};TestUtils.assertEquals(correctRanks,ranks,0d);ranks=ranking.rank(allSame);correctRanks=new double[]{2.5,2.5,2.5,2.5};TestUtils.assertEquals(correctRanks,ranks,0d);}
@Test public void testNaNsFixedTiesRandom(){RandomGenerator randomGenerator=new JDKRandomGenerator();randomGenerator.setSeed(1000);NaturalRanking ranking=new NaturalRanking(NaNStrategy.FIXED,randomGenerator);double[]ranks=ranking.rank(exampleData);double[]correctRanks={5,4,6,7,3,8,Double.NaN,1,4};TestUtils.assertEquals(correctRanks,ranks,0d);ranks=ranking.rank(tiesFirst);correctRanks=new double[]{1,1,4,3,5};TestUtils.assertEquals(correctRanks,ranks,0d);ranks=ranking.rank(tiesLast);correctRanks=new double[]{3,4,2,1};TestUtils.assertEquals(correctRanks,ranks,0d);ranks=ranking.rank(multipleNaNs);correctRanks=new double[]{1,2,Double.NaN,Double.NaN};TestUtils.assertEquals(correctRanks,ranks,0d);ranks=ranking.rank(multipleTies);correctRanks=new double[]{3,2,5,5,7,6,1};TestUtils.assertEquals(correctRanks,ranks,0d);ranks=ranking.rank(allSame);correctRanks=new double[]{1,3,4,4};TestUtils.assertEquals(correctRanks,ranks,0d);}
@Test public void testNaNsAndInfs(){double[]data={0,Double.POSITIVE_INFINITY,Double.NaN,Double.NEGATIVE_INFINITY};NaturalRanking ranking=new NaturalRanking(NaNStrategy.MAXIMAL);double[]ranks=ranking.rank(data);double[]correctRanks=new double[]{2,3.5,3.5,1};TestUtils.assertEquals(correctRanks,ranks,0d);ranking=new NaturalRanking(NaNStrategy.MINIMAL);ranks=ranking.rank(data);correctRanks=new double[]{3,4,1.5,1.5};TestUtils.assertEquals(correctRanks,ranks,0d);}
@Test public void testAccessors(){final MaxCountExceededException e=new MaxCountExceededException(10);Assert.assertEquals(10,e.getMax());}
@Test(expected=IllegalArgumentException.class)public void testConstructor1(){new DummyRandomKey(new Double[]{0.2,0.3,1.2});}
@Test(expected=IllegalArgumentException.class)public void testConstructor2(){new DummyRandomKey(new Double[]{0.2,0.3,-0.2});}
@Test public void testIsSame(){DummyRandomKey drk1=new DummyRandomKey(new Double[]{0.4,0.1,0.5,0.8,0.2});DummyRandomKey drk2=new DummyRandomKey(new Double[]{0.4,0.1,0.5,0.8,0.2});DummyRandomKey drk3=new DummyRandomKey(new Double[]{0.4,0.15,0.5,0.8,0.2});DummyRandomKey drk4=new DummyRandomKey(new Double[]{0.4,0.25,0.5,0.8,0.2});DummyRandomKey drk5=new DummyRandomKey(new Double[]{0.4,0.25,0.5,0.8,0.2,0.5});Assert.assertTrue(drk1.isSame(drk2));Assert.assertTrue(drk2.isSame(drk3));Assert.assertFalse(drk3.isSame(drk4));Assert.assertFalse(drk4.isSame(drk5));}
@Test public void testDecode(){DummyRandomKey drk=new DummyRandomKey(new Double[]{0.4,0.1,0.5,0.8,0.2});List<String> decoded=drk.decode(Arrays.asList(new String[]{"a","b","c","d","e"}));Assert.assertEquals("b",decoded.get(0));Assert.assertEquals("e",decoded.get(1));Assert.assertEquals("a",decoded.get(2));Assert.assertEquals("c",decoded.get(3));Assert.assertEquals("d",decoded.get(4));}
@Test(expected=IllegalArgumentException.class)public void testInvalidRepresentation(){new DummyRandomKey(new Double[]{0.1,0.1,2d,0.8,0.2});}
@Test public void testRandomPermutation(){for (int i=0;i < 10;i++){DummyRandomKey drk=new DummyRandomKey(RandomKey.randomPermutation(20));Assert.assertNotNull(drk);}}
@Test public void testIdentityPermutation(){DummyRandomKey drk=new DummyRandomKey(RandomKey.identityPermutation(5));List<String> decoded=drk.decode(Arrays.asList(new String[]{"a","b","c","d","e"}));Assert.assertEquals("a",decoded.get(0));Assert.assertEquals("b",decoded.get(1));Assert.assertEquals("c",decoded.get(2));Assert.assertEquals("d",decoded.get(3));Assert.assertEquals("e",decoded.get(4));}
@Test public void testComparatorPermutation(){List<String> data=Arrays.asList(new String[]{"x","b","c","z","b"});List<Double> permutation=RandomKey.comparatorPermutation(data,new Comparator<String>(){public int compare(String o1,String o2){return o1.compareTo(o2);}});Double[]permArr=new Double[data.size()];permArr=permutation.toArray(permArr);Assert.assertArrayEquals(new Double[]{0.6,0.0,0.4,0.8,0.2},permArr);List<String> decodedData=new DummyRandomKey(permutation).decode(data);Assert.assertEquals("b",decodedData.get(0));Assert.assertEquals("b",decodedData.get(1));Assert.assertEquals("c",decodedData.get(2));Assert.assertEquals("x",decodedData.get(3));Assert.assertEquals("z",decodedData.get(4));permutation=RandomKey.comparatorPermutation(data,new Comparator<String>(){public int compare(String o1,String o2){return o2.compareTo(o1);}});permArr=new Double[data.size()];permArr=permutation.toArray(permArr);Assert.assertArrayEquals(new Double[]{0.2,0.6,0.4,0.0,0.8},permArr);decodedData=new DummyRandomKey(permutation).decode(data);Assert.assertEquals("z",decodedData.get(0));Assert.assertEquals("x",decodedData.get(1));Assert.assertEquals("c",decodedData.get(2));Assert.assertEquals("b",decodedData.get(3));Assert.assertEquals("b",decodedData.get(4));}
@Test public void testInducedPermutation(){List<String> origData=Arrays.asList(new String[]{"a","b","c","d","d"});List<String> permutedData=Arrays.asList(new String[]{"d","b","c","a","d"});DummyRandomKey drk=new DummyRandomKey(RandomKey.inducedPermutation(origData,permutedData));List<String> decoded=drk.decode(origData);Assert.assertEquals("d",decoded.get(0));Assert.assertEquals("b",decoded.get(1));Assert.assertEquals("c",decoded.get(2));Assert.assertEquals("a",decoded.get(3));Assert.assertEquals("d",decoded.get(4));try {RandomKey.inducedPermutation(Arrays.asList(new String[]{"a","b","c","d","d"}),Arrays.asList(new String[]{"a","b","c","d"}));Assert.fail("Uncaught exception");}catch(IllegalArgumentException e){}try {RandomKey.inducedPermutation(Arrays.asList(new String[]{"a","b","c","d","d"}),Arrays.asList(new String[]{"a","b","c","d","f"}));Assert.fail("Uncaught exception");}catch(IllegalArgumentException e){}}
@Test public void testEqualRepr(){DummyRandomKey drk=new DummyRandomKey(new Double[]{0.2,0.2,0.5});List<String> decodedData=drk.decode(Arrays.asList(new String[]{"a","b","c"}));Assert.assertEquals("a",decodedData.get(0));Assert.assertEquals("b",decodedData.get(1));Assert.assertEquals("c",decodedData.get(2));}
@Test public void testSetterInjection(){DescriptiveStatistics stats=createDescriptiveStatistics();stats.addValue(1);stats.addValue(3);Assert.assertEquals(2,stats.getMean(),1E-10);stats.setMeanImpl(new deepMean());Assert.assertEquals(42,stats.getMean(),1E-10);}
@Test public void testCopy(){DescriptiveStatistics stats=createDescriptiveStatistics();stats.addValue(1);stats.addValue(3);DescriptiveStatistics copy=new DescriptiveStatistics(stats);Assert.assertEquals(2,copy.getMean(),1E-10);stats.setMeanImpl(new deepMean());copy=stats.copy();Assert.assertEquals(42,copy.getMean(),1E-10);}
@Test public void testWindowSize(){DescriptiveStatistics stats=createDescriptiveStatistics();stats.setWindowSize(300);for (int i=0;i < 100;++i){stats.addValue(i + 1);}int refSum=(100 * 101)/ 2;Assert.assertEquals(refSum / 100.0,stats.getMean(),1E-10);Assert.assertEquals(300,stats.getWindowSize());try {stats.setWindowSize(-3);Assert.fail("an exception should have been thrown");}catch(IllegalArgumentException iae){}Assert.assertEquals(300,stats.getWindowSize());stats.setWindowSize(50);Assert.assertEquals(50,stats.getWindowSize());int refSum2=refSum - (50 * 51)/ 2;Assert.assertEquals(refSum2 / 50.0,stats.getMean(),1E-10);}
@Test public void testGetValues(){DescriptiveStatistics stats=createDescriptiveStatistics();for (int i=100;i > 0;--i){stats.addValue(i);}int refSum=(100 * 101)/ 2;Assert.assertEquals(refSum / 100.0,stats.getMean(),1E-10);double[]v=stats.getValues();for (int i=0;i < v.length;++i){Assert.assertEquals(100.0 - i,v[i],1.0e-10);}double[]s=stats.getSortedValues();for (int i=0;i < s.length;++i){Assert.assertEquals(i + 1.0,s[i],1.0e-10);}Assert.assertEquals(12.0,stats.getElement(88),1.0e-10);}
@Test public void testToString(){DescriptiveStatistics stats=createDescriptiveStatistics();stats.addValue(1);stats.addValue(2);stats.addValue(3);Locale d=Locale.getDefault();Locale.setDefault(Locale.US);Assert.assertEquals("DescriptiveStatistics:\n" + "n: 3\n" + "min: 1.0\n"+ "max: 3.0\n"+ "mean: 2.0\n"+ "std dev: 1.0\n"+ "median: 2.0\n"+ "skewness: 0.0\n"+ "kurtosis: NaN\n",stats.toString());Locale.setDefault(d);}
@Test public void testShuffledStatistics(){DescriptiveStatistics reference=createDescriptiveStatistics();DescriptiveStatistics shuffled=createDescriptiveStatistics();UnivariateStatistic tmp=shuffled.getGeometricMeanImpl();shuffled.setGeometricMeanImpl(shuffled.getMeanImpl());shuffled.setMeanImpl(shuffled.getKurtosisImpl());shuffled.setKurtosisImpl(shuffled.getSkewnessImpl());shuffled.setSkewnessImpl(shuffled.getVarianceImpl());shuffled.setVarianceImpl(shuffled.getMaxImpl());shuffled.setMaxImpl(shuffled.getMinImpl());shuffled.setMinImpl(shuffled.getSumImpl());shuffled.setSumImpl(shuffled.getSumsqImpl());shuffled.setSumsqImpl(tmp);for (int i=100;i > 0;--i){reference.addValue(i);shuffled.addValue(i);}Assert.assertEquals(reference.getMean(),shuffled.getGeometricMean(),1.0e-10);Assert.assertEquals(reference.getKurtosis(),shuffled.getMean(),1.0e-10);Assert.assertEquals(reference.getSkewness(),shuffled.getKurtosis(),1.0e-10);Assert.assertEquals(reference.getVariance(),shuffled.getSkewness(),1.0e-10);Assert.assertEquals(reference.getMax(),shuffled.getVariance(),1.0e-10);Assert.assertEquals(reference.getMin(),shuffled.getMax(),1.0e-10);Assert.assertEquals(reference.getSum(),shuffled.getMin(),1.0e-10);Assert.assertEquals(reference.getSumsq(),shuffled.getSum(),1.0e-10);Assert.assertEquals(reference.getGeometricMean(),shuffled.getSumsq(),1.0e-10);}
@Test public void testPercentileSetter()throws Exception {DescriptiveStatistics stats=createDescriptiveStatistics();stats.addValue(1);stats.addValue(2);stats.addValue(3);Assert.assertEquals(2,stats.getPercentile(50.0),1E-10);stats.setPercentileImpl(new goodPercentile());Assert.assertEquals(2,stats.getPercentile(50.0),1E-10);stats.setPercentileImpl(new subPercentile());Assert.assertEquals(10.0,stats.getPercentile(10.0),1E-10);try {stats.setPercentileImpl(new badPercentile());Assert.fail("Expecting IllegalArgumentException");}catch(IllegalArgumentException ex){}}
@Test public void test20090720(){DescriptiveStatistics descriptiveStatistics=new DescriptiveStatistics(100);for (int i=0;i < 161;i++){descriptiveStatistics.addValue(1.2);}descriptiveStatistics.clear();descriptiveStatistics.addValue(1.2);Assert.assertEquals(1,descriptiveStatistics.getN());}
@Test public void testRemoval(){final DescriptiveStatistics dstat=createDescriptiveStatistics();checkremoval(dstat,1,6.0,0.0,Double.NaN);checkremoval(dstat,3,5.0,3.0,4.5);checkremoval(dstat,6,3.5,2.5,3.0);checkremoval(dstat,9,3.5,2.5,3.0);checkremoval(dstat,DescriptiveStatistics.INFINITE_WINDOW,3.5,2.5,3.0);}
@Test public void testSummaryConsistency(){final DescriptiveStatistics dstats=new DescriptiveStatistics();final SummaryStatistics sstats=new SummaryStatistics();final int windowSize=5;dstats.setWindowSize(windowSize);final double tol=1E-12;for (int i=0;i < 20;i++){dstats.addValue(i);sstats.clear();double[]values=dstats.getValues();for (int j=0;j < values.length;j++){sstats.addValue(values[j]);}TestUtils.assertEquals(dstats.getMean(),sstats.getMean(),tol);TestUtils.assertEquals(new Mean().evaluate(values),dstats.getMean(),tol);TestUtils.assertEquals(dstats.getMax(),sstats.getMax(),tol);TestUtils.assertEquals(new Max().evaluate(values),dstats.getMax(),tol);TestUtils.assertEquals(dstats.getGeometricMean(),sstats.getGeometricMean(),tol);TestUtils.assertEquals(new GeometricMean().evaluate(values),dstats.getGeometricMean(),tol);TestUtils.assertEquals(dstats.getMin(),sstats.getMin(),tol);TestUtils.assertEquals(new Min().evaluate(values),dstats.getMin(),tol);TestUtils.assertEquals(dstats.getStandardDeviation(),sstats.getStandardDeviation(),tol);TestUtils.assertEquals(dstats.getVariance(),sstats.getVariance(),tol);TestUtils.assertEquals(new Variance().evaluate(values),dstats.getVariance(),tol);TestUtils.assertEquals(dstats.getSum(),sstats.getSum(),tol);TestUtils.assertEquals(new Sum().evaluate(values),dstats.getSum(),tol);TestUtils.assertEquals(dstats.getSumsq(),sstats.getSumsq(),tol);TestUtils.assertEquals(new SumOfSquares().evaluate(values),dstats.getSumsq(),tol);TestUtils.assertEquals(dstats.getPopulationVariance(),sstats.getPopulationVariance(),tol);TestUtils.assertEquals(new Variance(false).evaluate(values),dstats.getPopulationVariance(),tol);}}
/** * test dimensions */@Test public void testDimensions(){RealMatrix matrix=MatrixUtils.createRealMatrix(testData);LUDecomposition LU=new LUDecomposition(matrix);Assert.assertEquals(testData.length,LU.getL().getRowDimension());Assert.assertEquals(testData.length,LU.getL().getColumnDimension());Assert.assertEquals(testData.length,LU.getU().getRowDimension());Assert.assertEquals(testData.length,LU.getU().getColumnDimension());Assert.assertEquals(testData.length,LU.getP().getRowDimension());Assert.assertEquals(testData.length,LU.getP().getColumnDimension());}
/** * test non-square matrix */@Test public void testNonSquare(){try {new LUDecomposition(MatrixUtils.createRealMatrix(new double[3][2]));Assert.fail("Expecting NonSquareMatrixException");}catch(NonSquareMatrixException ime){}}
/** * test PA = LU */@Test public void testPAEqualLU(){RealMatrix matrix=MatrixUtils.createRealMatrix(testData);LUDecomposition lu=new LUDecomposition(matrix);RealMatrix l=lu.getL();RealMatrix u=lu.getU();RealMatrix p=lu.getP();double norm=l.multiply(u).subtract(p.multiply(matrix)).getNorm();Assert.assertEquals(0,norm,normTolerance);matrix=MatrixUtils.createRealMatrix(testDataMinus);lu=new LUDecomposition(matrix);l=lu.getL();u=lu.getU();p=lu.getP();norm=l.multiply(u).subtract(p.multiply(matrix)).getNorm();Assert.assertEquals(0,norm,normTolerance);matrix=MatrixUtils.createRealIdentityMatrix(17);lu=new LUDecomposition(matrix);l=lu.getL();u=lu.getU();p=lu.getP();norm=l.multiply(u).subtract(p.multiply(matrix)).getNorm();Assert.assertEquals(0,norm,normTolerance);matrix=MatrixUtils.createRealMatrix(singular);lu=new LUDecomposition(matrix);Assert.assertFalse(lu.getSolver().isNonSingular());Assert.assertNull(lu.getL());Assert.assertNull(lu.getU());Assert.assertNull(lu.getP());matrix=MatrixUtils.createRealMatrix(bigSingular);lu=new LUDecomposition(matrix);Assert.assertFalse(lu.getSolver().isNonSingular());Assert.assertNull(lu.getL());Assert.assertNull(lu.getU());Assert.assertNull(lu.getP());}
/** * test that L is lower triangular with unit diagonal */@Test public void testLLowerTriangular(){RealMatrix matrix=MatrixUtils.createRealMatrix(testData);RealMatrix l=new LUDecomposition(matrix).getL();for (int i=0;i < l.getRowDimension();i++){Assert.assertEquals(l.getEntry(i,i),1,entryTolerance);for (int j=i + 1;j < l.getColumnDimension();j++){Assert.assertEquals(l.getEntry(i,j),0,entryTolerance);}}}
/** * test that U is upper triangular */@Test public void testUUpperTriangular(){RealMatrix matrix=MatrixUtils.createRealMatrix(testData);RealMatrix u=new LUDecomposition(matrix).getU();for (int i=0;i < u.getRowDimension();i++){for (int j=0;j < i;j++){Assert.assertEquals(u.getEntry(i,j),0,entryTolerance);}}}
/** * test that P is a permutation matrix */@Test public void testPPermutation(){RealMatrix matrix=MatrixUtils.createRealMatrix(testData);RealMatrix p=new LUDecomposition(matrix).getP();RealMatrix ppT=p.multiply(p.transpose());RealMatrix id=MatrixUtils.createRealIdentityMatrix(p.getRowDimension());Assert.assertEquals(0,ppT.subtract(id).getNorm(),normTolerance);for (int i=0;i < p.getRowDimension();i++){int zeroCount=0;int oneCount=0;int otherCount=0;for (int j=0;j < p.getColumnDimension();j++){final double e=p.getEntry(i,j);if (e == 0){++zeroCount;}else       if (e == 1){++oneCount;}else {++otherCount;}}Assert.assertEquals(p.getColumnDimension()- 1,zeroCount);Assert.assertEquals(1,oneCount);Assert.assertEquals(0,otherCount);}for (int j=0;j < p.getColumnDimension();j++){int zeroCount=0;int oneCount=0;int otherCount=0;for (int i=0;i < p.getRowDimension();i++){final double e=p.getEntry(i,j);if (e == 0){++zeroCount;}else       if (e == 1){++oneCount;}else {++otherCount;}}Assert.assertEquals(p.getRowDimension()- 1,zeroCount);Assert.assertEquals(1,oneCount);Assert.assertEquals(0,otherCount);}}
/** * test singular */@Test public void testSingular(){LUDecomposition lu=new LUDecomposition(MatrixUtils.createRealMatrix(testData));Assert.assertTrue(lu.getSolver().isNonSingular());lu=new LUDecomposition(MatrixUtils.createRealMatrix(singular));Assert.assertFalse(lu.getSolver().isNonSingular());lu=new LUDecomposition(MatrixUtils.createRealMatrix(bigSingular));Assert.assertFalse(lu.getSolver().isNonSingular());}
/** * test matrices values */@Test public void testMatricesValues1(){LUDecomposition lu=new LUDecomposition(MatrixUtils.createRealMatrix(testData));RealMatrix lRef=MatrixUtils.createRealMatrix(new double[][]{{1.0,0.0,0.0},{0.5,1.0,0.0},{0.5,0.2,1.0}});RealMatrix uRef=MatrixUtils.createRealMatrix(new double[][]{{2.0,5.0,3.0},{0.0,-2.5,6.5},{0.0,0.0,0.2}});RealMatrix pRef=MatrixUtils.createRealMatrix(new double[][]{{0.0,1.0,0.0},{0.0,0.0,1.0},{1.0,0.0,0.0}});int[]pivotRef={1,2,0};RealMatrix l=lu.getL();Assert.assertEquals(0,l.subtract(lRef).getNorm(),1.0e-13);RealMatrix u=lu.getU();Assert.assertEquals(0,u.subtract(uRef).getNorm(),1.0e-13);RealMatrix p=lu.getP();Assert.assertEquals(0,p.subtract(pRef).getNorm(),1.0e-13);int[]pivot=lu.getPivot();for (int i=0;i < pivotRef.length;++i){Assert.assertEquals(pivotRef[i],pivot[i]);}Assert.assertTrue(l == lu.getL());Assert.assertTrue(u == lu.getU());Assert.assertTrue(p == lu.getP());}
/** * test matrices values */@Test public void testMatricesValues2(){LUDecomposition lu=new LUDecomposition(MatrixUtils.createRealMatrix(luData));RealMatrix lRef=MatrixUtils.createRealMatrix(new double[][]{{1.0,0.0,0.0},{0.0,1.0,0.0},{1.0 / 3.0,0.0,1.0}});RealMatrix uRef=MatrixUtils.createRealMatrix(new double[][]{{6.0,9.0,8.0},{0.0,5.0,7.0},{0.0,0.0,1.0 / 3.0}});RealMatrix pRef=MatrixUtils.createRealMatrix(new double[][]{{0.0,0.0,1.0},{0.0,1.0,0.0},{1.0,0.0,0.0}});int[]pivotRef={2,1,0};RealMatrix l=lu.getL();Assert.assertEquals(0,l.subtract(lRef).getNorm(),1.0e-13);RealMatrix u=lu.getU();Assert.assertEquals(0,u.subtract(uRef).getNorm(),1.0e-13);RealMatrix p=lu.getP();Assert.assertEquals(0,p.subtract(pRef).getNorm(),1.0e-13);int[]pivot=lu.getPivot();for (int i=0;i < pivotRef.length;++i){Assert.assertEquals(pivotRef[i],pivot[i]);}Assert.assertTrue(l == lu.getL());Assert.assertTrue(u == lu.getU());Assert.assertTrue(p == lu.getP());}
/** * Test of solver for the sine function.*/@Test public void testSinFunction(){UnivariateFunction f=new SinFunction();UnivariateRealSolver solver=new RiddersSolver();double min,max,expected,result,tolerance;min=3.0;max=4.0;expected=FastMath.PI;tolerance=FastMath.max(solver.getAbsoluteAccuracy(),FastMath.abs(expected * solver.getRelativeAccuracy()));result=solver.solve(100,f,min,max);Assert.assertEquals(expected,result,tolerance);min=-1.0;max=1.5;expected=0.0;tolerance=FastMath.max(solver.getAbsoluteAccuracy(),FastMath.abs(expected * solver.getRelativeAccuracy()));result=solver.solve(100,f,min,max);Assert.assertEquals(expected,result,tolerance);}
/** * Test of solver for the quintic function.*/@Test public void testQuinticFunction(){UnivariateFunction f=new QuinticFunction();UnivariateRealSolver solver=new RiddersSolver();double min,max,expected,result,tolerance;min=-0.4;max=0.2;expected=0.0;tolerance=FastMath.max(solver.getAbsoluteAccuracy(),FastMath.abs(expected * solver.getRelativeAccuracy()));result=solver.solve(100,f,min,max);Assert.assertEquals(expected,result,tolerance);min=0.75;max=1.5;expected=1.0;tolerance=FastMath.max(solver.getAbsoluteAccuracy(),FastMath.abs(expected * solver.getRelativeAccuracy()));result=solver.solve(100,f,min,max);Assert.assertEquals(expected,result,tolerance);min=-0.9;max=-0.2;expected=-0.5;tolerance=FastMath.max(solver.getAbsoluteAccuracy(),FastMath.abs(expected * solver.getRelativeAccuracy()));result=solver.solve(100,f,min,max);Assert.assertEquals(expected,result,tolerance);}
/** * Test of solver for the exponential function.*/@Test public void testExpm1Function(){UnivariateFunction f=new Expm1Function();UnivariateRealSolver solver=new RiddersSolver();double min,max,expected,result,tolerance;min=-1.0;max=2.0;expected=0.0;tolerance=FastMath.max(solver.getAbsoluteAccuracy(),FastMath.abs(expected * solver.getRelativeAccuracy()));result=solver.solve(100,f,min,max);Assert.assertEquals(expected,result,tolerance);min=-20.0;max=10.0;expected=0.0;tolerance=FastMath.max(solver.getAbsoluteAccuracy(),FastMath.abs(expected * solver.getRelativeAccuracy()));result=solver.solve(100,f,min,max);Assert.assertEquals(expected,result,tolerance);min=-50.0;max=100.0;expected=0.0;tolerance=FastMath.max(solver.getAbsoluteAccuracy(),FastMath.abs(expected * solver.getRelativeAccuracy()));result=solver.solve(100,f,min,max);Assert.assertEquals(expected,result,tolerance);}
/** * Test of parameters for the solver.*/@Test public void testParameters(){UnivariateFunction f=new SinFunction();UnivariateRealSolver solver=new RiddersSolver();try {solver.solve(100,f,1,-1);Assert.fail("Expecting NumberIsTooLargeException - bad interval");}catch(NumberIsTooLargeException ex){}try {solver.solve(100,f,2,3);Assert.fail("Expecting NoBracketingException - no bracketing");}catch(NoBracketingException ex){}}
/** * test threshold impact */@Test public void testThreshold(){final RealMatrix matrix=MatrixUtils.createRealMatrix(new double[][]{{1.0,2.0,3.0},{2.0,5.0,3.0},{4.000001,9.0,9.0}});Assert.assertFalse(new LUDecomposition(matrix,1.0e-5).getSolver().isNonSingular());Assert.assertTrue(new LUDecomposition(matrix,1.0e-10).getSolver().isNonSingular());}
/** * test singular */@Test public void testSingular(){DecompositionSolver solver=new LUDecomposition(MatrixUtils.createRealMatrix(testData)).getSolver();Assert.assertTrue(solver.isNonSingular());solver=new LUDecomposition(MatrixUtils.createRealMatrix(singular)).getSolver();Assert.assertFalse(solver.isNonSingular());solver=new LUDecomposition(MatrixUtils.createRealMatrix(bigSingular)).getSolver();Assert.assertFalse(solver.isNonSingular());}
/** * test solve dimension errors */@Test public void testSolveDimensionErrors(){DecompositionSolver solver=new LUDecomposition(MatrixUtils.createRealMatrix(testData)).getSolver();RealMatrix b=MatrixUtils.createRealMatrix(new double[2][2]);try {solver.solve(b);Assert.fail("an exception should have been thrown");}catch(MathIllegalArgumentException iae){}try {solver.solve(b.getColumnVector(0));Assert.fail("an exception should have been thrown");}catch(MathIllegalArgumentException iae){}try {solver.solve(new ArrayRealVectorTest.RealVectorTestImpl(b.getColumn(0)));Assert.fail("an exception should have been thrown");}catch(MathIllegalArgumentException iae){}}
/** * test solve singularity errors */@Test public void testSolveSingularityErrors(){DecompositionSolver solver=new LUDecomposition(MatrixUtils.createRealMatrix(singular)).getSolver();RealMatrix b=MatrixUtils.createRealMatrix(new double[2][2]);try {solver.solve(b);Assert.fail("an exception should have been thrown");}catch(SingularMatrixException ime){}try {solver.solve(b.getColumnVector(0));Assert.fail("an exception should have been thrown");}catch(SingularMatrixException ime){}try {solver.solve(new ArrayRealVectorTest.RealVectorTestImpl(b.getColumn(0)));Assert.fail("an exception should have been thrown");}catch(SingularMatrixException ime){}}
/** * test solve */@Test public void testSolve(){DecompositionSolver solver=new LUDecomposition(MatrixUtils.createRealMatrix(testData)).getSolver();RealMatrix b=MatrixUtils.createRealMatrix(new double[][]{{1,0},{2,-5},{3,1}});RealMatrix xRef=MatrixUtils.createRealMatrix(new double[][]{{19,-71},{-6,22},{-2,9}});Assert.assertEquals(0,solver.solve(b).subtract(xRef).getNorm(),1.0e-13);for (int i=0;i < b.getColumnDimension();++i){Assert.assertEquals(0,solver.solve(b.getColumnVector(i)).subtract(xRef.getColumnVector(i)).getNorm(),1.0e-13);}for (int i=0;i < b.getColumnDimension();++i){ArrayRealVectorTest.RealVectorTestImpl v=new ArrayRealVectorTest.RealVectorTestImpl(b.getColumn(i));Assert.assertEquals(0,solver.solve(v).subtract(xRef.getColumnVector(i)).getNorm(),1.0e-13);}}
/** * test determinant */@Test public void testDeterminant(){Assert.assertEquals(-1,getDeterminant(MatrixUtils.createRealMatrix(testData)),1.0e-15);Assert.assertEquals(-10,getDeterminant(MatrixUtils.createRealMatrix(luData)),1.0e-14);Assert.assertEquals(0,getDeterminant(MatrixUtils.createRealMatrix(singular)),1.0e-17);Assert.assertEquals(0,getDeterminant(MatrixUtils.createRealMatrix(bigSingular)),1.0e-10);}
@Test public void test1()throws Exception {setupMethodCall(mathMethod,fastMethod,types,valueArrays);}
@Test public void testSinMin(){UnivariateFunction f=new SinFunction();UnivariateRealOptimizer optimizer=new BrentOptimizer(1e-10,1e-14);Assert.assertEquals(3 * Math.PI / 2,optimizer.optimize(200,f,GoalType.MINIMIZE,4,5).getPoint(),1e-8);Assert.assertTrue(optimizer.getEvaluations()<= 50);Assert.assertEquals(200,optimizer.getMaxEvaluations());Assert.assertEquals(3 * Math.PI / 2,optimizer.optimize(200,f,GoalType.MINIMIZE,1,5).getPoint(),1e-8);Assert.assertTrue(optimizer.getEvaluations()<= 100);Assert.assertTrue(optimizer.getEvaluations()>= 15);try {optimizer.optimize(10,f,GoalType.MINIMIZE,4,5);Assert.fail("an exception should have been thrown");}catch(TooManyEvaluationsException fee){}}
@Test public void testQuinticMin(){UnivariateFunction f=new QuinticFunction();UnivariateRealOptimizer optimizer=new BrentOptimizer(1e-10,1e-14);Assert.assertEquals(-0.27195613,optimizer.optimize(200,f,GoalType.MINIMIZE,-0.3,-0.2).getPoint(),1.0e-8);Assert.assertEquals(0.82221643,optimizer.optimize(200,f,GoalType.MINIMIZE,0.3,0.9).getPoint(),1.0e-8);Assert.assertTrue(optimizer.getEvaluations()<= 50);Assert.assertEquals(-0.27195613,optimizer.optimize(200,f,GoalType.MINIMIZE,-1.0,0.2).getPoint(),1.0e-8);Assert.assertTrue(optimizer.getEvaluations()<= 50);}
@Test public void testQuinticMinStatistics(){UnivariateFunction f=new QuinticFunction();UnivariateRealOptimizer optimizer=new BrentOptimizer(1e-11,1e-14);final DescriptiveStatistics[]stat=new DescriptiveStatistics[2];for (int i=0;i < stat.length;i++){stat[i]=new DescriptiveStatistics();}final double min=-0.75;final double max=0.25;final int nSamples=200;final double delta=(max - min)/ nSamples;for (int i=0;i < nSamples;i++){final double start=min + i * delta;stat[0].addValue(optimizer.optimize(40,f,GoalType.MINIMIZE,min,max,start).getPoint());stat[1].addValue(optimizer.getEvaluations());}final double meanOptValue=stat[0].getMean();final double medianEval=stat[1].getPercentile(50);Assert.assertTrue(meanOptValue > -0.2719561281);Assert.assertTrue(meanOptValue < -0.2719561280);Assert.assertEquals(23,(int)medianEval);}
@Test public void testQuinticMax(){UnivariateFunction f=new QuinticFunction();UnivariateRealOptimizer optimizer=new BrentOptimizer(1e-12,1e-14);Assert.assertEquals(0.27195613,optimizer.optimize(100,f,GoalType.MAXIMIZE,0.2,0.3).getPoint(),1e-8);try {optimizer.optimize(5,f,GoalType.MAXIMIZE,0.2,0.3);Assert.fail("an exception should have been thrown");}catch(TooManyEvaluationsException miee){}}
@Test public void testMinEndpoints(){UnivariateFunction f=new SinFunction();UnivariateRealOptimizer optimizer=new BrentOptimizer(1e-8,1e-14);double result=optimizer.optimize(50,f,GoalType.MINIMIZE,3 * Math.PI / 2,5).getPoint();Assert.assertEquals(3 * Math.PI / 2,result,1e-6);result=optimizer.optimize(50,f,GoalType.MINIMIZE,4,3 * Math.PI / 2).getPoint();Assert.assertEquals(3 * Math.PI / 2,result,1e-6);}
@Test(expected=IllegalArgumentException.class)public void cannotAddSampleDataWithSizeMismatch(){double[]y=new double[]{1.0,2.0};double[][]x=new double[1][];x[0]=new double[]{1.0,0};createRegression().newSampleData(y,x);}
@Test public void testPerfectFit()throws Exception {double[]betaHat=regression.estimateRegressionParameters();TestUtils.assertEquals(betaHat,new double[]{11.0,1.0 / 2.0,2.0 / 3.0,3.0 / 4.0,4.0 / 5.0,5.0 / 6.0},1e-14);double[]residuals=regression.estimateResiduals();TestUtils.assertEquals(residuals,new double[]{0d,0d,0d,0d,0d,0d},1e-14);RealMatrix errors=new Array2DRowRealMatrix(regression.estimateRegressionParametersVariance(),false);final double[]s={1.0,-1.0 / 2.0,-1.0 / 3.0,-1.0 / 4.0,-1.0 / 5.0,-1.0 / 6.0};RealMatrix referenceVariance=new Array2DRowRealMatrix(s.length,s.length);referenceVariance.walkInOptimizedOrder(new DefaultRealMatrixChangingVisitor(){@Override public double visit(int row,int column,double value){if (row == 0){return s[column];}double x=s[row]* s[column];return (row == column)? 2 * x : x;}});Assert.assertEquals(0.0,errors.subtract(referenceVariance).getNorm(),5.0e-16 * referenceVariance.getNorm());Assert.assertEquals(1,((OLSMultipleLinearRegression)regression).calculateRSquared(),1E-12);}
/** * Test Longley dataset against certified values provided by NIST. Data Source: J. Longley (1967)"An Appraisal of Least Squares Programs for the Electronic Computer from the Point of View of the User" Journal of the American Statistical Association,vol. 62. September,pp. 819-841. Certified values (and data)are from NIST: http://www.itl.nist.gov/div898/strd/lls/data/LINKS/DATA/Longley.dat*/@Test public void testLongly()throws Exception {double[]design=new double[]{60323,83.0,234289,2356,1590,107608,1947,61122,88.5,259426,2325,1456,108632,1948,60171,88.2,258054,3682,1616,109773,1949,61187,89.5,284599,3351,1650,110929,1950,63221,96.2,328975,2099,3099,112075,1951,63639,98.1,346999,1932,3594,113270,1952,64989,99.0,365385,1870,3547,115094,1953,63761,100.0,363112,3578,3350,116219,1954,66019,101.2,397469,2904,3048,117388,1955,67857,104.6,419180,2822,2857,118734,1956,68169,108.4,442769,2936,2798,120445,1957,66513,110.8,444546,4681,2637,121950,1958,68655,112.6,482704,3813,2552,123366,1959,69564,114.2,502601,3931,2514,125368,1960,69331,115.7,518173,4806,2572,127852,1961,70551,116.9,554894,4007,2827,130081,1962};final int nobs=16;final int nvars=6;OLSMultipleLinearRegression model=new OLSMultipleLinearRegression();model.newSampleData(design,nobs,nvars);double[]betaHat=model.estimateRegressionParameters();TestUtils.assertEquals(betaHat,new double[]{-3482258.63459582,15.0618722713733,-0.358191792925910E-01,-2.02022980381683,-1.03322686717359,-0.511041056535807E-01,1829.15146461355},2E-8);double[]residuals=model.estimateResiduals();TestUtils.assertEquals(residuals,new double[]{267.340029759711,-94.0139423988359,46.28716775752924,-410.114621930906,309.7145907602313,-249.3112153297231,-164.0489563956039,-13.18035686637081,14.30477260005235,455.394094551857,-17.26892711483297,-39.0550425226967,-155.5499735953195,-85.6713080421283,341.9315139607727,-206.7578251937366},1E-8);double[]errors=model.estimateRegressionParametersStandardErrors();TestUtils.assertEquals(new double[]{890420.383607373,84.9149257747669,0.334910077722432E-01,0.488399681651699,0.214274163161675,0.226073200069370,455.478499142212},errors,1E-6);Assert.assertEquals(304.8540735619638,model.estimateRegressionStandardError(),1E-10);Assert.assertEquals(0.995479004577296,model.calculateRSquared(),1E-12);Assert.assertEquals(0.992465007628826,model.calculateAdjustedRSquared(),1E-12);checkVarianceConsistency(model);model.setNoIntercept(true);model.newSampleData(design,nobs,nvars);betaHat=model.estimateRegressionParameters();TestUtils.assertEquals(betaHat,new double[]{-52.99357013868291,0.07107319907358,-0.42346585566399,-0.57256866841929,-0.41420358884978,48.41786562001326},1E-11);errors=model.estimateRegressionParametersStandardErrors();TestUtils.assertEquals(new double[]{129.54486693117232,0.03016640003786,0.41773654056612,0.27899087467676,0.32128496193363,17.68948737819961},errors,1E-11);residuals=model.estimateResiduals();TestUtils.assertEquals(residuals,new double[]{279.90274927293092,-130.32465380836874,90.73228661967445,-401.31252201634948,-440.46768772620027,-543.54512853774793,201.32111639536299,215.90889365977932,73.09368242049943,913.21694494481869,424.82484953610174,-8.56475876776709,-361.32974610842876,27.34560497213464,151.28955976355002,-492.49937355336846},1E-10);Assert.assertEquals(475.1655079819517,model.estimateRegressionStandardError(),1E-10);Assert.assertEquals(0.9999670130706,model.calculateRSquared(),1E-12);Assert.assertEquals(0.999947220913,model.calculateAdjustedRSquared(),1E-12);}
/** * Test R Swiss fertility dataset against R. Data Source: R datasets package*/@Test public void testSwissFertility()throws Exception {double[]design=new double[]{80.2,17.0,15,12,9.96,83.1,45.1,6,9,84.84,92.5,39.7,5,5,93.40,85.8,36.5,12,7,33.77,76.9,43.5,17,15,5.16,76.1,35.3,9,7,90.57,83.8,70.2,16,7,92.85,92.4,67.8,14,8,97.16,82.4,53.3,12,7,97.67,82.9,45.2,16,13,91.38,87.1,64.5,14,6,98.61,64.1,62.0,21,12,8.52,66.9,67.5,14,7,2.27,68.9,60.7,19,12,4.43,61.7,69.3,22,5,2.82,68.3,72.6,18,2,24.20,71.7,34.0,17,8,3.30,55.7,19.4,26,28,12.11,54.3,15.2,31,20,2.15,65.1,73.0,19,9,2.84,65.5,59.8,22,10,5.23,65.0,55.1,14,3,4.52,56.6,50.9,22,12,15.14,57.4,54.1,20,6,4.20,72.5,71.2,12,1,2.40,74.2,58.1,14,8,5.23,72.0,63.5,6,3,2.56,60.5,60.8,16,10,7.72,58.3,26.8,25,19,18.46,65.4,49.5,15,8,6.10,75.5,85.9,3,2,99.71,69.3,84.9,7,6,99.68,77.3,89.7,5,2,100.00,70.5,78.2,12,6,98.96,79.4,64.9,7,3,98.22,65.0,75.9,9,9,99.06,92.2,84.6,3,3,99.46,79.3,63.1,13,13,96.83,70.4,38.4,26,12,5.62,65.7,7.7,29,11,13.79,72.7,16.7,22,13,11.22,64.4,17.6,35,32,16.92,77.6,37.6,15,7,4.97,67.6,18.7,25,7,8.65,35.0,1.2,37,53,42.34,44.7,46.6,16,29,50.43,42.8,27.7,22,29,58.33};final int nobs=47;final int nvars=4;OLSMultipleLinearRegression model=new OLSMultipleLinearRegression();model.newSampleData(design,nobs,nvars);double[]betaHat=model.estimateRegressionParameters();TestUtils.assertEquals(betaHat,new double[]{91.05542390271397,-0.22064551045715,-0.26058239824328,-0.96161238456030,0.12441843147162},1E-12);double[]residuals=model.estimateResiduals();TestUtils.assertEquals(residuals,new double[]{7.1044267859730512,1.6580347433531366,4.6944952770029644,8.4548022690166160,13.6547432343186212,-9.3586864458500774,7.5822446330520386,15.5568995563859289,0.8113090736598980,7.1186762732484308,7.4251378771228724,2.6761316873234109,0.8351584810309354,7.1769991119615177,-3.8746753206299553,-3.1337779476387251,-0.1412575244091504,1.1186809170469780,-6.3588097346816594,3.4039270429434074,2.3374058329820175,-7.9272368576900503,-7.8361010968497959,-11.2597369269357070,0.9445333697827101,6.6544245101380328,-0.9146136301118665,-4.3152449403848570,-4.3536932047009183,-3.8907885169304661,-6.3027643926302188,-7.8308982189289091,-3.1792280015332750,-6.7167298771158226,-4.8469946718041754,-10.6335664353633685,11.1031134362036958,6.0084032641811733,5.4326230830188482,-7.2375578629692230,2.1671550814448222,15.0147574652763112,4.8625103516321015,-7.1597256413907706,-0.4515205619767598,-10.2916870903837587,-15.7812984571900063},1E-12);double[]errors=model.estimateRegressionParametersStandardErrors();TestUtils.assertEquals(new double[]{6.94881329475087,0.07360008972340,0.27410957467466,0.19454551679325,0.03726654773803},errors,1E-10);Assert.assertEquals(7.73642194433223,model.estimateRegressionStandardError(),1E-12);Assert.assertEquals(0.649789742860228,model.calculateRSquared(),1E-12);Assert.assertEquals(0.6164363850373927,model.calculateAdjustedRSquared(),1E-12);checkVarianceConsistency(model);model=new OLSMultipleLinearRegression();model.setNoIntercept(true);model.newSampleData(design,nobs,nvars);betaHat=model.estimateRegressionParameters();TestUtils.assertEquals(betaHat,new double[]{0.52191832900513,2.36588087917963,-0.94770353802795,0.30851985863609},1E-12);residuals=model.estimateResiduals();TestUtils.assertEquals(residuals,new double[]{44.138759883538249,27.720705122356215,35.873200836126799,34.574619581211977,26.600168342080213,15.074636243026923,-12.704904871199814,1.497443824078134,2.691972687079431,5.582798774291231,-4.422986561283165,-9.198581600334345,4.481765170730647,2.273520207553216,-22.649827853221336,-17.747900013943308,20.298314638496436,6.861405135329779,-8.684712790954924,-10.298639278062371,-9.896618896845819,4.568568616351242,-15.313570491727944,-13.762961360873966,7.156100301980509,16.722282219843990,26.716200609071898,-1.991466398777079,-2.523342564719335,9.776486693095093,-5.297535127628603,-16.639070567471094,-10.302057295211819,-23.549487860816846,1.506624392156384,-17.939174438345930,13.105792202765040,-1.943329906928462,-1.516005841666695,-0.759066561832886,20.793137744128977,-2.485236153005426,27.588238710486976,2.658333257106881,-15.998337823623046,-5.550742066720694,-14.219077806826615},1E-12);errors=model.estimateRegressionParametersStandardErrors();TestUtils.assertEquals(new double[]{0.10470063765677,0.41684100584290,0.43370143099691,0.07694953606522},errors,1E-10);Assert.assertEquals(17.24710630547,model.estimateRegressionStandardError(),1E-10);Assert.assertEquals(0.946350722085,model.calculateRSquared(),1E-12);Assert.assertEquals(0.9413600915813,model.calculateAdjustedRSquared(),1E-12);}
/** * Test hat matrix computation* @throws Exception*/@Test public void testHat()throws Exception {double[]design=new double[]{11.14,.499,11.1,12.74,.558,8.9,13.13,.604,8.8,11.51,.441,8.9,12.38,.550,8.8,12.60,.528,9.9,11.13,.418,10.7,11.7,.480,10.5,11.02,.406,10.5,11.41,.467,10.7};int nobs=10;int nvars=2;OLSMultipleLinearRegression model=new OLSMultipleLinearRegression();model.newSampleData(design,nobs,nvars);RealMatrix hat=model.calculateHat();double[]referenceData=new double[]{.418,-.002,.079,-.274,-.046,.181,.128,.222,.050,.242,.242,.292,.136,.243,.128,-.041,.033,-.035,.004,.417,-.019,.273,.187,-.126,.044,-.153,.004,.604,.197,-.038,.168,-.022,.275,-.028,.252,.111,-.030,.019,-.010,-.010,.148,.042,.117,.012,.111,.262,.145,.277,.174,.154,.120,.168,.315,.148,.187};int k=0;for (int i=0;i < 10;i++){for (int j=i;j < 10;j++){Assert.assertEquals(referenceData[k],hat.getEntry(i,j),10e-3);Assert.assertEquals(hat.getEntry(i,j),hat.getEntry(j,i),10e-12);k++;}}double[]residuals=model.estimateResiduals();RealMatrix I=MatrixUtils.createRealIdentityMatrix(10);double[]hatResiduals=I.subtract(hat).operate(model.Y).toArray();TestUtils.assertEquals(residuals,hatResiduals,10e-12);}
/** * test calculateYVariance*/@Test public void testYVariance(){OLSMultipleLinearRegression model=new OLSMultipleLinearRegression();model.newSampleData(y,x);TestUtils.assertEquals(model.calculateYVariance(),3.5,0);}
/** * Verifies that setting X and Y separately has the same effect as newSample(X,Y).*/@Test public void testNewSample2()throws Exception {double[]y=new double[]{1,2,3,4};double[][]x=new double[][]{{19,22,33},{20,30,40},{25,35,45},{27,37,47}};OLSMultipleLinearRegression regression=new OLSMultipleLinearRegression();regression.newSampleData(y,x);RealMatrix combinedX=regression.X.copy();RealVector combinedY=regression.Y.copy();regression.newXSampleData(x);regression.newYSampleData(y);Assert.assertEquals(combinedX,regression.X);Assert.assertEquals(combinedY,regression.Y);regression.setNoIntercept(true);regression.newSampleData(y,x);combinedX=regression.X.copy();combinedY=regression.Y.copy();regression.newXSampleData(x);regression.newYSampleData(y);Assert.assertEquals(combinedX,regression.X);Assert.assertEquals(combinedY,regression.Y);}
@Test(expected=IllegalArgumentException.class)public void testNewSampleDataYNull(){createRegression().newSampleData(null,new double[][]{});}
@Test(expected=IllegalArgumentException.class)public void testNewSampleDataXNull(){createRegression().newSampleData(new double[]{},null);}
@Test public void testWampler1()throws Exception {double[]data=new double[]{1,0,6,1,63,2,364,3,1365,4,3906,5,9331,6,19608,7,37449,8,66430,9,111111,10,177156,11,271453,12,402234,13,579195,14,813616,15,1118481,16,1508598,17,2000719,18,2613660,19,3368421,20};OLSMultipleLinearRegression model=new OLSMultipleLinearRegression();final int nvars=5;final int nobs=21;double[]tmp=new double[(nvars + 1)* nobs];int off=0;int off2=0;for (int i=0;i < nobs;i++){tmp[off2]=data[off];tmp[off2 + 1]=data[off + 1];tmp[off2 + 2]=tmp[off2 + 1]* tmp[off2 + 1];tmp[off2 + 3]=tmp[off2 + 1]* tmp[off2 + 2];tmp[off2 + 4]=tmp[off2 + 1]* tmp[off2 + 3];tmp[off2 + 5]=tmp[off2 + 1]* tmp[off2 + 4];off2+=(nvars + 1);off+=2;}model.newSampleData(tmp,nobs,nvars);double[]betaHat=model.estimateRegressionParameters();TestUtils.assertEquals(betaHat,new double[]{1.0,1.0,1.0,1.0,1.0,1.0},1E-8);double[]se=model.estimateRegressionParametersStandardErrors();TestUtils.assertEquals(se,new double[]{0.0,0.0,0.0,0.0,0.0,0.0},1E-8);TestUtils.assertEquals(1.0,model.calculateRSquared(),1.0e-10);TestUtils.assertEquals(0,model.estimateErrorVariance(),1.0e-7);TestUtils.assertEquals(0.00,model.calculateResidualSumOfSquares(),1.0e-6);return;}
@Test public void testWampler2()throws Exception {double[]data=new double[]{1.00000,0,1.11111,1,1.24992,2,1.42753,3,1.65984,4,1.96875,5,2.38336,6,2.94117,7,3.68928,8,4.68559,9,6.00000,10,7.71561,11,9.92992,12,12.75603,13,16.32384,14,20.78125,15,26.29536,16,33.05367,17,41.26528,18,51.16209,19,63.00000,20};OLSMultipleLinearRegression model=new OLSMultipleLinearRegression();final int nvars=5;final int nobs=21;double[]tmp=new double[(nvars + 1)* nobs];int off=0;int off2=0;for (int i=0;i < nobs;i++){tmp[off2]=data[off];tmp[off2 + 1]=data[off + 1];tmp[off2 + 2]=tmp[off2 + 1]* tmp[off2 + 1];tmp[off2 + 3]=tmp[off2 + 1]* tmp[off2 + 2];tmp[off2 + 4]=tmp[off2 + 1]* tmp[off2 + 3];tmp[off2 + 5]=tmp[off2 + 1]* tmp[off2 + 4];off2+=(nvars + 1);off+=2;}model.newSampleData(tmp,nobs,nvars);double[]betaHat=model.estimateRegressionParameters();TestUtils.assertEquals(betaHat,new double[]{1.0,1.0e-1,1.0e-2,1.0e-3,1.0e-4,1.0e-5},1E-8);double[]se=model.estimateRegressionParametersStandardErrors();TestUtils.assertEquals(se,new double[]{0.0,0.0,0.0,0.0,0.0,0.0},1E-8);TestUtils.assertEquals(1.0,model.calculateRSquared(),1.0e-10);TestUtils.assertEquals(0,model.estimateErrorVariance(),1.0e-7);TestUtils.assertEquals(0.00,model.calculateResidualSumOfSquares(),1.0e-6);return;}
@Test public void testWampler3()throws Exception {double[]data=new double[]{760,0,-2042,1,2111,2,-1684,3,3888,4,1858,5,11379,6,17560,7,39287,8,64382,9,113159,10,175108,11,273291,12,400186,13,581243,14,811568,15,1121004,16,1506550,17,2002767,18,2611612,19,3369180,20};OLSMultipleLinearRegression model=new OLSMultipleLinearRegression();final int nvars=5;final int nobs=21;double[]tmp=new double[(nvars + 1)* nobs];int off=0;int off2=0;for (int i=0;i < nobs;i++){tmp[off2]=data[off];tmp[off2 + 1]=data[off + 1];tmp[off2 + 2]=tmp[off2 + 1]* tmp[off2 + 1];tmp[off2 + 3]=tmp[off2 + 1]* tmp[off2 + 2];tmp[off2 + 4]=tmp[off2 + 1]* tmp[off2 + 3];tmp[off2 + 5]=tmp[off2 + 1]* tmp[off2 + 4];off2+=(nvars + 1);off+=2;}model.newSampleData(tmp,nobs,nvars);double[]betaHat=model.estimateRegressionParameters();TestUtils.assertEquals(betaHat,new double[]{1.0,1.0,1.0,1.0,1.0,1.0},1E-8);double[]se=model.estimateRegressionParametersStandardErrors();TestUtils.assertEquals(se,new double[]{2152.32624678170,2363.55173469681,779.343524331583,101.475507550350,5.64566512170752,0.112324854679312},1E-8);TestUtils.assertEquals(.999995559025820,model.calculateRSquared(),1.0e-10);TestUtils.assertEquals(5570284.53333333,model.estimateErrorVariance(),1.0e-6);TestUtils.assertEquals(83554268.0000000,model.calculateResidualSumOfSquares(),1.0e-5);return;}
@Test public void testWampler4()throws Exception {double[]data=new double[]{75901,0,-204794,1,204863,2,-204436,3,253665,4,-200894,5,214131,6,-185192,7,221249,8,-138370,9,315911,10,-27644,11,455253,12,197434,13,783995,14,608816,15,1370781,16,1303798,17,2205519,18,2408860,19,3444321,20};OLSMultipleLinearRegression model=new OLSMultipleLinearRegression();final int nvars=5;final int nobs=21;double[]tmp=new double[(nvars + 1)* nobs];int off=0;int off2=0;for (int i=0;i < nobs;i++){tmp[off2]=data[off];tmp[off2 + 1]=data[off + 1];tmp[off2 + 2]=tmp[off2 + 1]* tmp[off2 + 1];tmp[off2 + 3]=tmp[off2 + 1]* tmp[off2 + 2];tmp[off2 + 4]=tmp[off2 + 1]* tmp[off2 + 3];tmp[off2 + 5]=tmp[off2 + 1]* tmp[off2 + 4];off2+=(nvars + 1);off+=2;}model.newSampleData(tmp,nobs,nvars);double[]betaHat=model.estimateRegressionParameters();TestUtils.assertEquals(betaHat,new double[]{1.0,1.0,1.0,1.0,1.0,1.0},1E-6);double[]se=model.estimateRegressionParametersStandardErrors();TestUtils.assertEquals(se,new double[]{215232.624678170,236355.173469681,77934.3524331583,10147.5507550350,564.566512170752,11.2324854679312},1E-8);TestUtils.assertEquals(.957478440825662,model.calculateRSquared(),1.0e-10);TestUtils.assertEquals(55702845333.3333,model.estimateErrorVariance(),1.0e-4);TestUtils.assertEquals(835542680000.000,model.calculateResidualSumOfSquares(),1.0e-3);return;}
@Test public void testIdentity(){Rotation r=Rotation.IDENTITY;checkVector(r.applyTo(Vector3D.PLUS_I),Vector3D.PLUS_I);checkVector(r.applyTo(Vector3D.PLUS_J),Vector3D.PLUS_J);checkVector(r.applyTo(Vector3D.PLUS_K),Vector3D.PLUS_K);checkAngle(r.getAngle(),0);r=new Rotation(-1,0,0,0,false);checkVector(r.applyTo(Vector3D.PLUS_I),Vector3D.PLUS_I);checkVector(r.applyTo(Vector3D.PLUS_J),Vector3D.PLUS_J);checkVector(r.applyTo(Vector3D.PLUS_K),Vector3D.PLUS_K);checkAngle(r.getAngle(),0);r=new Rotation(42,0,0,0,true);checkVector(r.applyTo(Vector3D.PLUS_I),Vector3D.PLUS_I);checkVector(r.applyTo(Vector3D.PLUS_J),Vector3D.PLUS_J);checkVector(r.applyTo(Vector3D.PLUS_K),Vector3D.PLUS_K);checkAngle(r.getAngle(),0);}
@Test public void testAxisAngle(){Rotation r=new Rotation(new Vector3D(10,10,10),2 * FastMath.PI / 3);checkVector(r.applyTo(Vector3D.PLUS_I),Vector3D.PLUS_J);checkVector(r.applyTo(Vector3D.PLUS_J),Vector3D.PLUS_K);checkVector(r.applyTo(Vector3D.PLUS_K),Vector3D.PLUS_I);double s=1 / FastMath.sqrt(3);checkVector(r.getAxis(),new Vector3D(s,s,s));checkAngle(r.getAngle(),2 * FastMath.PI / 3);try {new Rotation(new Vector3D(0,0,0),2 * FastMath.PI / 3);Assert.fail("an exception should have been thrown");}catch(MathIllegalArgumentException e){}r=new Rotation(Vector3D.PLUS_K,1.5 * FastMath.PI);checkVector(r.getAxis(),new Vector3D(0,0,-1));checkAngle(r.getAngle(),0.5 * FastMath.PI);r=new Rotation(Vector3D.PLUS_J,FastMath.PI);checkVector(r.getAxis(),Vector3D.PLUS_J);checkAngle(r.getAngle(),FastMath.PI);checkVector(Rotation.IDENTITY.getAxis(),Vector3D.PLUS_I);}
@Test public void testRevert(){Rotation r=new Rotation(0.001,0.36,0.48,0.8,true);Rotation reverted=r.revert();checkRotation(r.applyTo(reverted),1,0,0,0);checkRotation(reverted.applyTo(r),1,0,0,0);Assert.assertEquals(r.getAngle(),reverted.getAngle(),1.0e-12);Assert.assertEquals(-1,Vector3D.dotProduct(r.getAxis(),reverted.getAxis()),1.0e-12);}
@Test public void testVectorOnePair(){Vector3D u=new Vector3D(3,2,1);Vector3D v=new Vector3D(-4,2,2);Rotation r=new Rotation(u,v);checkVector(r.applyTo(u.scalarMultiply(v.getNorm())),v.scalarMultiply(u.getNorm()));checkAngle(new Rotation(u,u.negate()).getAngle(),FastMath.PI);try {new Rotation(u,Vector3D.ZERO);Assert.fail("an exception should have been thrown");}catch(IllegalArgumentException e){}}
@Test public void testVectorTwoPairs(){Vector3D u1=new Vector3D(3,0,0);Vector3D u2=new Vector3D(0,5,0);Vector3D v1=new Vector3D(0,0,2);Vector3D v2=new Vector3D(-2,0,2);Rotation r=new Rotation(u1,u2,v1,v2);checkVector(r.applyTo(Vector3D.PLUS_I),Vector3D.PLUS_K);checkVector(r.applyTo(Vector3D.PLUS_J),Vector3D.MINUS_I);r=new Rotation(u1,u2,u1.negate(),u2.negate());Vector3D axis=r.getAxis();if (Vector3D.dotProduct(axis,Vector3D.PLUS_K)> 0){checkVector(axis,Vector3D.PLUS_K);}else {checkVector(axis,Vector3D.MINUS_K);}checkAngle(r.getAngle(),FastMath.PI);double sqrt=FastMath.sqrt(2)/ 2;r=new Rotation(Vector3D.PLUS_I,Vector3D.PLUS_J,new Vector3D(0.5,0.5,sqrt),new Vector3D(0.5,0.5,-sqrt));checkRotation(r,sqrt,0.5,0.5,0);r=new Rotation(u1,u2,u1,Vector3D.crossProduct(u1,u2));checkRotation(r,sqrt,-sqrt,0,0);checkRotation(new Rotation(u1,u2,u1,u2),1,0,0,0);try {new Rotation(u1,u2,Vector3D.ZERO,v2);Assert.fail("an exception should have been thrown");}catch(IllegalArgumentException e){}}
@Test public void testMatrix()throws NotARotationMatrixException {try {new Rotation(new double[][]{{0.0,1.0,0.0},{1.0,0.0,0.0}},1.0e-7);Assert.fail("Expecting NotARotationMatrixException");}catch(NotARotationMatrixException nrme){}try {new Rotation(new double[][]{{0.445888,0.797184,-0.407040},{0.821760,-0.184320,0.539200},{-0.354816,0.574912,0.737280}},1.0e-7);Assert.fail("Expecting NotARotationMatrixException");}catch(NotARotationMatrixException nrme){}try {new Rotation(new double[][]{{0.4,0.8,-0.4},{-0.4,0.6,0.7},{0.8,-0.2,0.5}},1.0e-15);Assert.fail("Expecting NotARotationMatrixException");}catch(NotARotationMatrixException nrme){}checkRotation(new Rotation(new double[][]{{0.445888,0.797184,-0.407040},{-0.354816,0.574912,0.737280},{0.821760,-0.184320,0.539200}},1.0e-10),0.8,0.288,0.384,0.36);checkRotation(new Rotation(new double[][]{{0.539200,0.737280,0.407040},{0.184320,-0.574912,0.797184},{0.821760,-0.354816,-0.445888}},1.0e-10),0.36,0.8,0.288,0.384);checkRotation(new Rotation(new double[][]{{-0.445888,0.797184,-0.407040},{0.354816,0.574912,0.737280},{0.821760,0.184320,-0.539200}},1.0e-10),0.384,0.36,0.8,0.288);checkRotation(new Rotation(new double[][]{{-0.539200,0.737280,0.407040},{-0.184320,-0.574912,0.797184},{0.821760,0.354816,0.445888}},1.0e-10),0.288,0.384,0.36,0.8);double[][]m1={{0.0,1.0,0.0},{0.0,0.0,1.0},{1.0,0.0,0.0}};Rotation r=new Rotation(m1,1.0e-7);checkVector(r.applyTo(Vector3D.PLUS_I),Vector3D.PLUS_K);checkVector(r.applyTo(Vector3D.PLUS_J),Vector3D.PLUS_I);checkVector(r.applyTo(Vector3D.PLUS_K),Vector3D.PLUS_J);double[][]m2={{0.83203,-0.55012,-0.07139},{0.48293,0.78164,-0.39474},{0.27296,0.29396,0.91602}};r=new Rotation(m2,1.0e-12);double[][]m3=r.getMatrix();double d00=m2[0][0]- m3[0][0];double d01=m2[0][1]- m3[0][1];double d02=m2[0][2]- m3[0][2];double d10=m2[1][0]- m3[1][0];double d11=m2[1][1]- m3[1][1];double d12=m2[1][2]- m3[1][2];double d20=m2[2][0]- m3[2][0];double d21=m2[2][1]- m3[2][1];double d22=m2[2][2]- m3[2][2];Assert.assertTrue(FastMath.abs(d00)< 6.0e-6);Assert.assertTrue(FastMath.abs(d01)< 6.0e-6);Assert.assertTrue(FastMath.abs(d02)< 6.0e-6);Assert.assertTrue(FastMath.abs(d10)< 6.0e-6);Assert.assertTrue(FastMath.abs(d11)< 6.0e-6);Assert.assertTrue(FastMath.abs(d12)< 6.0e-6);Assert.assertTrue(FastMath.abs(d20)< 6.0e-6);Assert.assertTrue(FastMath.abs(d21)< 6.0e-6);Assert.assertTrue(FastMath.abs(d22)< 6.0e-6);Assert.assertTrue(FastMath.abs(d00)> 4.0e-7);Assert.assertTrue(FastMath.abs(d01)> 4.0e-7);Assert.assertTrue(FastMath.abs(d02)> 4.0e-7);Assert.assertTrue(FastMath.abs(d10)> 4.0e-7);Assert.assertTrue(FastMath.abs(d11)> 4.0e-7);Assert.assertTrue(FastMath.abs(d12)> 4.0e-7);Assert.assertTrue(FastMath.abs(d20)> 4.0e-7);Assert.assertTrue(FastMath.abs(d21)> 4.0e-7);Assert.assertTrue(FastMath.abs(d22)> 4.0e-7);for (int i=0;i < 3;++i){for (int j=0;j < 3;++j){double m3tm3=m3[i][0]* m3[j][0]+ m3[i][1]* m3[j][1]+ m3[i][2]* m3[j][2];if (i == j){Assert.assertTrue(FastMath.abs(m3tm3 - 1.0)< 1.0e-10);}else {Assert.assertTrue(FastMath.abs(m3tm3)< 1.0e-10);}}}checkVector(r.applyTo(Vector3D.PLUS_I),new Vector3D(m3[0][0],m3[1][0],m3[2][0]));checkVector(r.applyTo(Vector3D.PLUS_J),new Vector3D(m3[0][1],m3[1][1],m3[2][1]));checkVector(r.applyTo(Vector3D.PLUS_K),new Vector3D(m3[0][2],m3[1][2],m3[2][2]));double[][]m4={{1.0,0.0,0.0},{0.0,-1.0,0.0},{0.0,0.0,-1.0}};r=new Rotation(m4,1.0e-7);checkAngle(r.getAngle(),FastMath.PI);try {double[][]m5={{0.0,0.0,1.0},{0.0,1.0,0.0},{1.0,0.0,0.0}};r=new Rotation(m5,1.0e-7);Assert.fail("got " + r + ",should have caught an exception");}catch(NotARotationMatrixException e){}}
@Test public void testAngles()throws CardanEulerSingularityException {RotationOrder[]CardanOrders={RotationOrder.XYZ,RotationOrder.XZY,RotationOrder.YXZ,RotationOrder.YZX,RotationOrder.ZXY,RotationOrder.ZYX};for (int i=0;i < CardanOrders.length;++i){for (double alpha1=0.1;alpha1 < 6.2;alpha1+=0.3){for (double alpha2=-1.55;alpha2 < 1.55;alpha2+=0.3){for (double alpha3=0.1;alpha3 < 6.2;alpha3+=0.3){Rotation r=new Rotation(CardanOrders[i],alpha1,alpha2,alpha3);double[]angles=r.getAngles(CardanOrders[i]);checkAngle(angles[0],alpha1);checkAngle(angles[1],alpha2);checkAngle(angles[2],alpha3);}}}}RotationOrder[]EulerOrders={RotationOrder.XYX,RotationOrder.XZX,RotationOrder.YXY,RotationOrder.YZY,RotationOrder.ZXZ,RotationOrder.ZYZ};for (int i=0;i < EulerOrders.length;++i){for (double alpha1=0.1;alpha1 < 6.2;alpha1+=0.3){for (double alpha2=0.05;alpha2 < 3.1;alpha2+=0.3){for (double alpha3=0.1;alpha3 < 6.2;alpha3+=0.3){Rotation r=new Rotation(EulerOrders[i],alpha1,alpha2,alpha3);double[]angles=r.getAngles(EulerOrders[i]);checkAngle(angles[0],alpha1);checkAngle(angles[1],alpha2);checkAngle(angles[2],alpha3);}}}}}
@Test public void testSingularities(){RotationOrder[]CardanOrders={RotationOrder.XYZ,RotationOrder.XZY,RotationOrder.YXZ,RotationOrder.YZX,RotationOrder.ZXY,RotationOrder.ZYX};double[]singularCardanAngle={FastMath.PI / 2,-FastMath.PI / 2};for (int i=0;i < CardanOrders.length;++i){for (int j=0;j < singularCardanAngle.length;++j){Rotation r=new Rotation(CardanOrders[i],0.1,singularCardanAngle[j],0.3);try {r.getAngles(CardanOrders[i]);Assert.fail("an exception should have been caught");}catch(CardanEulerSingularityException cese){}}}RotationOrder[]EulerOrders={RotationOrder.XYX,RotationOrder.XZX,RotationOrder.YXY,RotationOrder.YZY,RotationOrder.ZXZ,RotationOrder.ZYZ};double[]singularEulerAngle={0,FastMath.PI};for (int i=0;i < EulerOrders.length;++i){for (int j=0;j < singularEulerAngle.length;++j){Rotation r=new Rotation(EulerOrders[i],0.1,singularEulerAngle[j],0.3);try {r.getAngles(EulerOrders[i]);Assert.fail("an exception should have been caught");}catch(CardanEulerSingularityException cese){}}}}
@Test public void testQuaternion(){Rotation r1=new Rotation(new Vector3D(2,-3,5),1.7);double n=23.5;Rotation r2=new Rotation(n * r1.getQ0(),n * r1.getQ1(),n * r1.getQ2(),n * r1.getQ3(),true);for (double x=-0.9;x < 0.9;x+=0.2){for (double y=-0.9;y < 0.9;y+=0.2){for (double z=-0.9;z < 0.9;z+=0.2){Vector3D u=new Vector3D(x,y,z);checkVector(r2.applyTo(u),r1.applyTo(u));}}}r1=new Rotation(0.288,0.384,0.36,0.8,false);checkRotation(r1,-r1.getQ0(),-r1.getQ1(),-r1.getQ2(),-r1.getQ3());}
@Test public void testCompose(){Rotation r1=new Rotation(new Vector3D(2,-3,5),1.7);Rotation r2=new Rotation(new Vector3D(-1,3,2),0.3);Rotation r3=r2.applyTo(r1);for (double x=-0.9;x < 0.9;x+=0.2){for (double y=-0.9;y < 0.9;y+=0.2){for (double z=-0.9;z < 0.9;z+=0.2){Vector3D u=new Vector3D(x,y,z);checkVector(r2.applyTo(r1.applyTo(u)),r3.applyTo(u));}}}}
@Test public void testComposeInverse(){Rotation r1=new Rotation(new Vector3D(2,-3,5),1.7);Rotation r2=new Rotation(new Vector3D(-1,3,2),0.3);Rotation r3=r2.applyInverseTo(r1);for (double x=-0.9;x < 0.9;x+=0.2){for (double y=-0.9;y < 0.9;y+=0.2){for (double z=-0.9;z < 0.9;z+=0.2){Vector3D u=new Vector3D(x,y,z);checkVector(r2.applyInverseTo(r1.applyTo(u)),r3.applyTo(u));}}}}
@Test public void testArray(){Rotation r=new Rotation(new Vector3D(2,-3,5),1.7);for (double x=-0.9;x < 0.9;x+=0.2){for (double y=-0.9;y < 0.9;y+=0.2){for (double z=-0.9;z < 0.9;z+=0.2){Vector3D u=new Vector3D(x,y,z);Vector3D v=r.applyTo(u);double[]inOut=new double[]{x,y,z};r.applyTo(inOut,inOut);Assert.assertEquals(v.getX(),inOut[0],1.0e-10);Assert.assertEquals(v.getY(),inOut[1],1.0e-10);Assert.assertEquals(v.getZ(),inOut[2],1.0e-10);r.applyInverseTo(inOut,inOut);Assert.assertEquals(u.getX(),inOut[0],1.0e-10);Assert.assertEquals(u.getY(),inOut[1],1.0e-10);Assert.assertEquals(u.getZ(),inOut[2],1.0e-10);}}}}
@Test public void testApplyInverseTo(){Rotation r=new Rotation(new Vector3D(2,-3,5),1.7);for (double lambda=0;lambda < 6.2;lambda+=0.2){for (double phi=-1.55;phi < 1.55;phi+=0.2){Vector3D u=new Vector3D(FastMath.cos(lambda)* FastMath.cos(phi),FastMath.sin(lambda)* FastMath.cos(phi),FastMath.sin(phi));r.applyInverseTo(r.applyTo(u));checkVector(u,r.applyInverseTo(r.applyTo(u)));checkVector(u,r.applyTo(r.applyInverseTo(u)));}}r=Rotation.IDENTITY;for (double lambda=0;lambda < 6.2;lambda+=0.2){for (double phi=-1.55;phi < 1.55;phi+=0.2){Vector3D u=new Vector3D(FastMath.cos(lambda)* FastMath.cos(phi),FastMath.sin(lambda)* FastMath.cos(phi),FastMath.sin(phi));checkVector(u,r.applyInverseTo(r.applyTo(u)));checkVector(u,r.applyTo(r.applyInverseTo(u)));}}r=new Rotation(Vector3D.PLUS_K,FastMath.PI);for (double lambda=0;lambda < 6.2;lambda+=0.2){for (double phi=-1.55;phi < 1.55;phi+=0.2){Vector3D u=new Vector3D(FastMath.cos(lambda)* FastMath.cos(phi),FastMath.sin(lambda)* FastMath.cos(phi),FastMath.sin(phi));checkVector(u,r.applyInverseTo(r.applyTo(u)));checkVector(u,r.applyTo(r.applyInverseTo(u)));}}}
@Test public void testIssue639(){Vector3D u1=new Vector3D(-1321008684645961.0 / 268435456.0,-5774608829631843.0 / 268435456.0,-3822921525525679.0 / 4294967296.0);Vector3D u2=new Vector3D(-5712344449280879.0 / 2097152.0,-2275058564560979.0 / 1048576.0,4423475992255071.0 / 65536.0);Rotation rot=new Rotation(u1,u2,Vector3D.PLUS_I,Vector3D.PLUS_K);Assert.assertEquals(0.6228370359608200639829222,rot.getQ0(),1.0e-15);Assert.assertEquals(0.0257707621456498790029987,rot.getQ1(),1.0e-15);Assert.assertEquals(-0.0000000002503012255839931,rot.getQ2(),1.0e-15);Assert.assertEquals(-0.7819270390861109450724902,rot.getQ3(),1.0e-15);}
@Test public void testCubicMin(){final BracketFinder bFind=new BracketFinder();final UnivariateFunction func=new UnivariateFunction(){public double value(double x){if (x < -2){return value(-2);}else {return (x - 1)* (x + 2)* (x + 3);}}};bFind.search(func,GoalType.MINIMIZE,-2,-1);final double tol=1e-15;Assert.assertEquals(-2,bFind.getLo(),tol);Assert.assertEquals(-1,bFind.getMid(),tol);Assert.assertEquals(0.61803399999999997,bFind.getHi(),tol);}
@Test public void testCubicMax(){final BracketFinder bFind=new BracketFinder();final UnivariateFunction func=new UnivariateFunction(){public double value(double x){if (x < -2){return value(-2);}else {return -(x - 1)* (x + 2)* (x + 3);}}};bFind.search(func,GoalType.MAXIMIZE,-2,-1);final double tol=1e-15;Assert.assertEquals(-2,bFind.getLo(),tol);Assert.assertEquals(-1,bFind.getMid(),tol);Assert.assertEquals(0.61803399999999997,bFind.getHi(),tol);}
@Test public void testMinimumIsOnIntervalBoundary(){final UnivariateFunction func=new UnivariateFunction(){public double value(double x){return x * x;}};final BracketFinder bFind=new BracketFinder();bFind.search(func,GoalType.MINIMIZE,0,1);Assert.assertTrue(bFind.getLo()<= 0);Assert.assertTrue(0 <= bFind.getHi());bFind.search(func,GoalType.MINIMIZE,-1,0);Assert.assertTrue(bFind.getLo()<= 0);Assert.assertTrue(0 <= bFind.getHi());}
@Test public void testIntervalBoundsOrdering(){final UnivariateFunction func=new UnivariateFunction(){public double value(double x){return x * x;}};final BracketFinder bFind=new BracketFinder();bFind.search(func,GoalType.MINIMIZE,-1,1);Assert.assertTrue(bFind.getLo()<= 0);Assert.assertTrue(0 <= bFind.getHi());bFind.search(func,GoalType.MINIMIZE,1,-1);Assert.assertTrue(bFind.getLo()<= 0);Assert.assertTrue(0 <= bFind.getHi());bFind.search(func,GoalType.MINIMIZE,1,2);Assert.assertTrue(bFind.getLo()<= 0);Assert.assertTrue(0 <= bFind.getHi());bFind.search(func,GoalType.MINIMIZE,2,1);Assert.assertTrue(bFind.getLo()<= 0);Assert.assertTrue(0 <= bFind.getHi());}
/** * test stats */@Test public void testStats(){SummaryStatistics u=createSummaryStatistics();Assert.assertEquals("total count",0,u.getN(),tolerance);u.addValue(one);u.addValue(twoF);u.addValue(twoL);u.addValue(three);Assert.assertEquals("N",n,u.getN(),tolerance);Assert.assertEquals("sum",sum,u.getSum(),tolerance);Assert.assertEquals("sumsq",sumSq,u.getSumsq(),tolerance);Assert.assertEquals("var",var,u.getVariance(),tolerance);Assert.assertEquals("population var",popVar,u.getPopulationVariance(),tolerance);Assert.assertEquals("std",std,u.getStandardDeviation(),tolerance);Assert.assertEquals("mean",mean,u.getMean(),tolerance);Assert.assertEquals("min",min,u.getMin(),tolerance);Assert.assertEquals("max",max,u.getMax(),tolerance);u.clear();Assert.assertEquals("total count",0,u.getN(),tolerance);}
@Test public void testN0andN1Conditions()throws Exception {SummaryStatistics u=createSummaryStatistics();Assert.assertTrue("Mean of n = 0 set should be NaN",Double.isNaN(u.getMean()));Assert.assertTrue("Standard Deviation of n = 0 set should be NaN",Double.isNaN(u.getStandardDeviation()));Assert.assertTrue("Variance of n = 0 set should be NaN",Double.isNaN(u.getVariance()));u.addValue(one);Assert.assertTrue("mean should be one (n = 1)",u.getMean()== one);Assert.assertTrue("geometric should be one (n = 1)instead it is " + u.getGeometricMean(),u.getGeometricMean()== one);Assert.assertTrue("Std should be zero (n = 1)",u.getStandardDeviation()== 0.0);Assert.assertTrue("variance should be zero (n = 1)",u.getVariance()== 0.0);u.addValue(twoF);Assert.assertTrue("Std should not be zero (n = 2)",u.getStandardDeviation()!= 0.0);Assert.assertTrue("variance should not be zero (n = 2)",u.getVariance()!= 0.0);}
@Test public void testProductAndGeometricMean()throws Exception {SummaryStatistics u=createSummaryStatistics();u.addValue(1.0);u.addValue(2.0);u.addValue(3.0);u.addValue(4.0);Assert.assertEquals("Geometric mean not expected",2.213364,u.getGeometricMean(),0.00001);}
@Test public void testNaNContracts(){SummaryStatistics u=createSummaryStatistics();Assert.assertTrue("mean not NaN",Double.isNaN(u.getMean()));Assert.assertTrue("min not NaN",Double.isNaN(u.getMin()));Assert.assertTrue("std dev not NaN",Double.isNaN(u.getStandardDeviation()));Assert.assertTrue("var not NaN",Double.isNaN(u.getVariance()));Assert.assertTrue("geom mean not NaN",Double.isNaN(u.getGeometricMean()));u.addValue(1.0);Assert.assertEquals("mean not expected",1.0,u.getMean(),Double.MIN_VALUE);Assert.assertEquals("variance not expected",0.0,u.getVariance(),Double.MIN_VALUE);Assert.assertEquals("geometric mean not expected",1.0,u.getGeometricMean(),Double.MIN_VALUE);u.addValue(-1.0);Assert.assertTrue("geom mean not NaN",Double.isNaN(u.getGeometricMean()));u.addValue(0.0);Assert.assertTrue("geom mean not NaN",Double.isNaN(u.getGeometricMean()));}
@Test public void testGetSummary(){SummaryStatistics u=createSummaryStatistics();StatisticalSummary summary=u.getSummary();verifySummary(u,summary);u.addValue(1d);summary=u.getSummary();verifySummary(u,summary);u.addValue(2d);summary=u.getSummary();verifySummary(u,summary);u.addValue(2d);summary=u.getSummary();verifySummary(u,summary);}
@Test public void testSerialization(){SummaryStatistics u=createSummaryStatistics();TestUtils.checkSerializedEquality(u);SummaryStatistics s=(SummaryStatistics)TestUtils.serializeAndRecover(u);StatisticalSummary summary=s.getSummary();verifySummary(u,summary);u.addValue(2d);u.addValue(1d);u.addValue(3d);u.addValue(4d);u.addValue(5d);TestUtils.checkSerializedEquality(u);s=(SummaryStatistics)TestUtils.serializeAndRecover(u);summary=s.getSummary();verifySummary(u,summary);}
@Test public void testEqualsAndHashCode(){SummaryStatistics u=createSummaryStatistics();SummaryStatistics t=null;int emptyHash=u.hashCode();Assert.assertTrue("reflexive",u.equals(u));Assert.assertFalse("non-null compared to null",u.equals(t));Assert.assertFalse("wrong type",u.equals(Double.valueOf(0)));t=createSummaryStatistics();Assert.assertTrue("empty instances should be equal",t.equals(u));Assert.assertTrue("empty instances should be equal",u.equals(t));Assert.assertEquals("empty hash code",emptyHash,t.hashCode());u.addValue(2d);u.addValue(1d);u.addValue(3d);u.addValue(4d);Assert.assertFalse("different n's should make instances not equal",t.equals(u));Assert.assertFalse("different n's should make instances not equal",u.equals(t));Assert.assertTrue("different n's should make hashcodes different",u.hashCode()!= t.hashCode());t.addValue(2d);t.addValue(1d);t.addValue(3d);t.addValue(4d);Assert.assertTrue("summaries based on same data should be equal",t.equals(u));Assert.assertTrue("summaries based on same data should be equal",u.equals(t));Assert.assertEquals("summaries based on same data should have same hashcodes",u.hashCode(),t.hashCode());u.clear();t.clear();Assert.assertTrue("empty instances should be equal",t.equals(u));Assert.assertTrue("empty instances should be equal",u.equals(t));Assert.assertEquals("empty hash code",emptyHash,t.hashCode());Assert.assertEquals("empty hash code",emptyHash,u.hashCode());}
@Test public void testCopy()throws Exception {SummaryStatistics u=createSummaryStatistics();u.addValue(2d);u.addValue(1d);u.addValue(3d);u.addValue(4d);SummaryStatistics v=new SummaryStatistics(u);Assert.assertEquals(u,v);Assert.assertEquals(v,u);Assert.assertTrue(v.geoMean == v.getGeoMeanImpl());Assert.assertTrue(v.mean == v.getMeanImpl());Assert.assertTrue(v.min == v.getMinImpl());Assert.assertTrue(v.max == v.getMaxImpl());Assert.assertTrue(v.sum == v.getSumImpl());Assert.assertTrue(v.sumsq == v.getSumsqImpl());Assert.assertTrue(v.sumLog == v.getSumLogImpl());Assert.assertTrue(v.variance == v.getVarianceImpl());u.addValue(7d);u.addValue(9d);u.addValue(11d);u.addValue(23d);v.addValue(7d);v.addValue(9d);v.addValue(11d);v.addValue(23d);Assert.assertEquals(u,v);Assert.assertEquals(v,u);u.clear();u.setSumImpl(new Sum());SummaryStatistics.copy(u,v);Assert.assertEquals(u.sum,v.sum);Assert.assertEquals(u.getSumImpl(),v.getSumImpl());}
@Test public void testSetterInjection()throws Exception {SummaryStatistics u=createSummaryStatistics();u.setMeanImpl(new Sum());u.setSumLogImpl(new Sum());u.addValue(1);u.addValue(3);Assert.assertEquals(4,u.getMean(),1E-14);Assert.assertEquals(4,u.getSumOfLogs(),1E-14);Assert.assertEquals(FastMath.exp(2),u.getGeometricMean(),1E-14);u.clear();u.addValue(1);u.addValue(2);Assert.assertEquals(3,u.getMean(),1E-14);u.clear();u.setMeanImpl(new Mean());}
@Test public void testSetterIllegalState()throws Exception {SummaryStatistics u=createSummaryStatistics();u.addValue(1);u.addValue(3);try {u.setMeanImpl(new Sum());Assert.fail("Expecting IllegalStateException");}catch(IllegalStateException ex){}}
/** * JIRA: MATH-691*/@Test public void testOverrideVarianceWithMathClass()throws Exception {double[]scores={1,2,3,4};SummaryStatistics stats=new SummaryStatistics();stats.setVarianceImpl(new Variance(false));for(double i : scores){stats.addValue(i);}Assert.assertEquals((new Variance(false)).evaluate(scores),stats.getVariance(),0);}
@Test public void testOverrideMeanWithMathClass()throws Exception {double[]scores={1,2,3,4};SummaryStatistics stats=new SummaryStatistics();stats.setMeanImpl(new Mean());for(double i : scores){stats.addValue(i);}Assert.assertEquals((new Mean()).evaluate(scores),stats.getMean(),0);}
@Test public void testOverrideGeoMeanWithMathClass()throws Exception {double[]scores={1,2,3,4};SummaryStatistics stats=new SummaryStatistics();stats.setGeoMeanImpl(new GeometricMean());for(double i : scores){stats.addValue(i);}Assert.assertEquals((new GeometricMean()).evaluate(scores),stats.getGeometricMean(),0);}
@Test public void testCumulativeDensityFunction()throws Exception {KolmogorovSmirnovDistribution dist;dist=new KolmogorovSmirnovDistribution(200);Assert.assertEquals(4.907829957616471622388047046469198862537e-86,dist.cdf(0.005,false),TOLERANCE);dist=new KolmogorovSmirnovDistribution(200);Assert.assertEquals(5.151982014280041957199687829849210629618e-06,dist.cdf(0.02,false),TOLERANCE);dist=new KolmogorovSmirnovDistribution(200);Assert.assertEquals(0.01291614648162886340443389343590752105229,dist.cdf(0.031111,false),TOLERANCE);dist=new KolmogorovSmirnovDistribution(200);Assert.assertEquals(0.1067137011362679355208626930107129737735,dist.cdf(0.04,false),TOLERANCE);dist=new KolmogorovSmirnovDistribution(341);Assert.assertEquals(1.914734701559404553985102395145063418825e-53,dist.cdf(0.005,false),TOLERANCE);dist=new KolmogorovSmirnovDistribution(341);Assert.assertEquals(0.001171328985781981343872182321774744195864,dist.cdf(0.02,false),TOLERANCE);dist=new KolmogorovSmirnovDistribution(341);Assert.assertEquals(0.1142955196267499418105728636874118819833,dist.cdf(0.031111,false),TOLERANCE);dist=new KolmogorovSmirnovDistribution(341);Assert.assertEquals(0.3685529520496805266915885113121476024389,dist.cdf(0.04,false),TOLERANCE);dist=new KolmogorovSmirnovDistribution(389);Assert.assertEquals(1.810657144595055888918455512707637574637e-47,dist.cdf(0.005,false),TOLERANCE);dist=new KolmogorovSmirnovDistribution(389);Assert.assertEquals(0.003068542559702356568168690742481885536108,dist.cdf(0.02,false),TOLERANCE);dist=new KolmogorovSmirnovDistribution(389);Assert.assertEquals(0.1658291700122746237244797384846606291831,dist.cdf(0.031111,false),TOLERANCE);dist=new KolmogorovSmirnovDistribution(389);Assert.assertEquals(0.4513143712128902529379104180407011881471,dist.cdf(0.04,false),TOLERANCE);}
/** * test singular */@Test public void testSingular(){FieldDecompositionSolver<Fraction> solver;solver=new FieldLUDecomposition<Fraction>(createFractionMatrix(testData)).getSolver();Assert.assertTrue(solver.isNonSingular());solver=new FieldLUDecomposition<Fraction>(createFractionMatrix(singular)).getSolver();Assert.assertFalse(solver.isNonSingular());solver=new FieldLUDecomposition<Fraction>(createFractionMatrix(bigSingular)).getSolver();Assert.assertFalse(solver.isNonSingular());}
/** * test solve dimension errors */@Test public void testSolveDimensionErrors(){FieldDecompositionSolver<Fraction> solver;solver=new FieldLUDecomposition<Fraction>(createFractionMatrix(testData)).getSolver();FieldMatrix<Fraction> b=createFractionMatrix(new int[2][2]);try {solver.solve(b);Assert.fail("an exception should have been thrown");}catch(MathIllegalArgumentException iae){}try {solver.solve(b.getColumnVector(0));Assert.fail("an exception should have been thrown");}catch(MathIllegalArgumentException iae){}}
/** * test solve singularity errors */@Test public void testSolveSingularityErrors(){FieldDecompositionSolver<Fraction> solver;solver=new FieldLUDecomposition<Fraction>(createFractionMatrix(singular)).getSolver();FieldMatrix<Fraction> b=createFractionMatrix(new int[2][2]);try {solver.solve(b);Assert.fail("an exception should have been thrown");}catch(SingularMatrixException ime){}try {solver.solve(b.getColumnVector(0));Assert.fail("an exception should have been thrown");}catch(SingularMatrixException ime){}}
/** * test solve */@Test public void testSolve(){FieldDecompositionSolver<Fraction> solver;solver=new FieldLUDecomposition<Fraction>(createFractionMatrix(testData)).getSolver();FieldMatrix<Fraction> b=createFractionMatrix(new int[][]{{1,0},{2,-5},{3,1}});FieldMatrix<Fraction> xRef=createFractionMatrix(new int[][]{{19,-71},{-6,22},{-2,9}});FieldMatrix<Fraction> x=solver.solve(b);for (int i=0;i < x.getRowDimension();i++){for (int j=0;j < x.getColumnDimension();j++){Assert.assertEquals("(" + i + ","+ j+ ")",xRef.getEntry(i,j),x.getEntry(i,j));}}for (int j=0;j < b.getColumnDimension();j++){final FieldVector<Fraction> xj=solver.solve(b.getColumnVector(j));for (int i=0;i < xj.getDimension();i++){Assert.assertEquals("(" + i + ","+ j+ ")",xRef.getEntry(i,j),xj.getEntry(i));}}for (int j=0;j < b.getColumnDimension();j++){final SparseFieldVector<Fraction> bj;bj=new SparseFieldVector<Fraction>(FractionField.getInstance(),b.getColumn(j));final FieldVector<Fraction> xj=solver.solve(bj);for (int i=0;i < xj.getDimension();i++){Assert.assertEquals("(" + i + ","+ j+ ")",xRef.getEntry(i,j),xj.getEntry(i));}}}
/** * test determinant */@Test public void testDeterminant(){Assert.assertEquals(-1,getDeterminant(createFractionMatrix(testData)),1E-15);Assert.assertEquals(-10,getDeterminant(createFractionMatrix(luData)),1E-14);Assert.assertEquals(0,getDeterminant(createFractionMatrix(singular)),1E-15);Assert.assertEquals(0,getDeterminant(createFractionMatrix(bigSingular)),1E-15);}
@Test public void testConstructors(){OpenMapRealVector v0=new OpenMapRealVector();Assert.assertEquals("testData len",0,v0.getDimension());OpenMapRealVector v1=new OpenMapRealVector(7);Assert.assertEquals("testData len",7,v1.getDimension());Assert.assertEquals("testData is 0.0 ",0.0,v1.getEntry(6),0);OpenMapRealVector v3=new OpenMapRealVector(vec1);Assert.assertEquals("testData len",3,v3.getDimension());Assert.assertEquals("testData is 2.0 ",2.0,v3.getEntry(1),0);RealVector v5_i=new OpenMapRealVector(dvec1);Assert.assertEquals("testData len",9,v5_i.getDimension());Assert.assertEquals("testData is 9.0 ",9.0,v5_i.getEntry(8),0);OpenMapRealVector v5=new OpenMapRealVector(dvec1);Assert.assertEquals("testData len",9,v5.getDimension());Assert.assertEquals("testData is 9.0 ",9.0,v5.getEntry(8),0);OpenMapRealVector v7=new OpenMapRealVector(v1);Assert.assertEquals("testData len",7,v7.getDimension());Assert.assertEquals("testData is 0.0 ",0.0,v7.getEntry(6),0);SparseRealVectorTestImpl v7_i=new SparseRealVectorTestImpl(vec1);OpenMapRealVector v7_2=new OpenMapRealVector(v7_i);Assert.assertEquals("testData len",3,v7_2.getDimension());Assert.assertEquals("testData is 0.0 ",2.0d,v7_2.getEntry(1),0);OpenMapRealVector v8=new OpenMapRealVector(v1);Assert.assertEquals("testData len",7,v8.getDimension());Assert.assertEquals("testData is 0.0 ",0.0,v8.getEntry(6),0);}
@Test public void testDataInOut(){OpenMapRealVector v1=new OpenMapRealVector(vec1);OpenMapRealVector v2=new OpenMapRealVector(vec2);OpenMapRealVector v4=new OpenMapRealVector(vec4);SparseRealVectorTestImpl v2_t=new SparseRealVectorTestImpl(vec2);RealVector v_append_1=v1.append(v2);Assert.assertEquals("testData len",6,v_append_1.getDimension());Assert.assertEquals("testData is 4.0 ",4.0,v_append_1.getEntry(3),0);RealVector v_append_2=v1.append(2.0);Assert.assertEquals("testData len",4,v_append_2.getDimension());Assert.assertEquals("testData is 2.0 ",2.0,v_append_2.getEntry(3),0);RealVector v_append_4=v1.append(v2_t);Assert.assertEquals("testData len",6,v_append_4.getDimension());Assert.assertEquals("testData is 4.0 ",4.0,v_append_4.getEntry(3),0);RealVector vout5=v4.getSubVector(3,3);Assert.assertEquals("testData len",3,vout5.getDimension());Assert.assertEquals("testData is 4.0 ",5.0,vout5.getEntry(1),0);try {v4.getSubVector(3,7);Assert.fail("OutOfRangeException expected");}catch(OutOfRangeException ex){}OpenMapRealVector v_set1=v1.copy();v_set1.setEntry(1,11.0);Assert.assertEquals("testData is 11.0 ",11.0,v_set1.getEntry(1),0);try {v_set1.setEntry(3,11.0);Assert.fail("OutOfRangeException expected");}catch(OutOfRangeException ex){}OpenMapRealVector v_set2=v4.copy();v_set2.setSubVector(3,v1);Assert.assertEquals("testData is 1.0 ",1.0,v_set2.getEntry(3),0);Assert.assertEquals("testData is 7.0 ",7.0,v_set2.getEntry(6),0);try {v_set2.setSubVector(7,v1);Assert.fail("OutOfRangeException expected");}catch(OutOfRangeException ex){}OpenMapRealVector v_set3=v1.copy();v_set3.set(13.0);Assert.assertEquals("testData is 13.0 ",13.0,v_set3.getEntry(2),0);try {v_set3.getEntry(23);Assert.fail("OutOfRangeException expected");}catch(OutOfRangeException ex){}OpenMapRealVector v_set4=v4.copy();v_set4.setSubVector(3,v2_t);Assert.assertEquals("testData is 1.0 ",4.0,v_set4.getEntry(3),0);Assert.assertEquals("testData is 7.0 ",7.0,v_set4.getEntry(6),0);try {v_set4.setSubVector(7,v2_t);Assert.fail("OutOfRangeException expected");}catch(OutOfRangeException ex){}}
@Test public void testMapFunctions(){OpenMapRealVector v1=new OpenMapRealVector(vec1);RealVector v_mapAdd=v1.mapAdd(2.0d);double[]result_mapAdd={3d,4d,5d};assertClose("compare vectors",result_mapAdd,v_mapAdd.toArray(),normTolerance);RealVector v_mapAddToSelf=v1.copy();v_mapAddToSelf.mapAddToSelf(2.0d);double[]result_mapAddToSelf={3d,4d,5d};assertClose("compare vectors",result_mapAddToSelf,v_mapAddToSelf.toArray(),normTolerance);RealVector v_mapSubtract=v1.mapSubtract(2.0d);double[]result_mapSubtract={-1d,0d,1d};assertClose("compare vectors",result_mapSubtract,v_mapSubtract.toArray(),normTolerance);RealVector v_mapSubtractToSelf=v1.copy();v_mapSubtractToSelf.mapSubtractToSelf(2.0d);double[]result_mapSubtractToSelf={-1d,0d,1d};assertClose("compare vectors",result_mapSubtractToSelf,v_mapSubtractToSelf.toArray(),normTolerance);RealVector v_mapMultiply=v1.mapMultiply(2.0d);double[]result_mapMultiply={2d,4d,6d};assertClose("compare vectors",result_mapMultiply,v_mapMultiply.toArray(),normTolerance);RealVector v_mapMultiplyToSelf=v1.copy();v_mapMultiplyToSelf.mapMultiplyToSelf(2.0d);double[]result_mapMultiplyToSelf={2d,4d,6d};assertClose("compare vectors",result_mapMultiplyToSelf,v_mapMultiplyToSelf.toArray(),normTolerance);RealVector v_mapDivide=v1.mapDivide(2.0d);double[]result_mapDivide={.5d,1d,1.5d};assertClose("compare vectors",result_mapDivide,v_mapDivide.toArray(),normTolerance);RealVector v_mapDivideToSelf=v1.copy();v_mapDivideToSelf.mapDivideToSelf(2.0d);double[]result_mapDivideToSelf={.5d,1d,1.5d};assertClose("compare vectors",result_mapDivideToSelf,v_mapDivideToSelf.toArray(),normTolerance);RealVector v_mapPow=v1.map(new Power(2));double[]result_mapPow={1d,4d,9d};assertClose("compare vectors",result_mapPow,v_mapPow.toArray(),normTolerance);RealVector v_mapPowToSelf=v1.copy();v_mapPowToSelf.mapToSelf(new Power(2));double[]result_mapPowToSelf={1d,4d,9d};assertClose("compare vectors",result_mapPowToSelf,v_mapPowToSelf.toArray(),normTolerance);RealVector v_mapExp=v1.map(new Exp());double[]result_mapExp={2.718281828459045e+00d,7.389056098930650e+00d,2.008553692318767e+01d};assertClose("compare vectors",result_mapExp,v_mapExp.toArray(),normTolerance);RealVector v_mapExpToSelf=v1.copy();v_mapExpToSelf.mapToSelf(new Exp());double[]result_mapExpToSelf={2.718281828459045e+00d,7.389056098930650e+00d,2.008553692318767e+01d};assertClose("compare vectors",result_mapExpToSelf,v_mapExpToSelf.toArray(),normTolerance);RealVector v_mapExpm1=v1.map(new Expm1());double[]result_mapExpm1={1.718281828459045d,6.38905609893065d,19.085536923187668d};assertClose("compare vectors",result_mapExpm1,v_mapExpm1.toArray(),normTolerance);RealVector v_mapExpm1ToSelf=v1.copy();v_mapExpm1ToSelf.mapToSelf(new Expm1());double[]result_mapExpm1ToSelf={1.718281828459045d,6.38905609893065d,19.085536923187668d};assertClose("compare vectors",result_mapExpm1ToSelf,v_mapExpm1ToSelf.toArray(),normTolerance);RealVector v_mapLog=v1.map(new Log());double[]result_mapLog={0d,6.931471805599453e-01d,1.098612288668110e+00d};assertClose("compare vectors",result_mapLog,v_mapLog.toArray(),normTolerance);RealVector v_mapLogToSelf=v1.copy();v_mapLogToSelf.mapToSelf(new Log());double[]result_mapLogToSelf={0d,6.931471805599453e-01d,1.098612288668110e+00d};assertClose("compare vectors",result_mapLogToSelf,v_mapLogToSelf.toArray(),normTolerance);RealVector v_mapLog10=v1.map(new Log10());double[]result_mapLog10={0d,3.010299956639812e-01d,4.771212547196624e-01d};assertClose("compare vectors",result_mapLog10,v_mapLog10.toArray(),normTolerance);RealVector v_mapLog10ToSelf=v1.copy();v_mapLog10ToSelf.mapToSelf(new Log10());double[]result_mapLog10ToSelf={0d,3.010299956639812e-01d,4.771212547196624e-01d};assertClose("compare vectors",result_mapLog10ToSelf,v_mapLog10ToSelf.toArray(),normTolerance);RealVector v_mapLog1p=v1.map(new Log1p());double[]result_mapLog1p={0.6931471805599453d,1.0986122886681096d,1.3862943611198906d};assertClose("compare vectors",result_mapLog1p,v_mapLog1p.toArray(),normTolerance);RealVector v_mapLog1pToSelf=v1.copy();v_mapLog1pToSelf.mapToSelf(new Log1p());double[]result_mapLog1pToSelf={0.6931471805599453d,1.0986122886681096d,1.3862943611198906d};assertClose("compare vectors",result_mapLog1pToSelf,v_mapLog1pToSelf.toArray(),normTolerance);RealVector v_mapCosh=v1.map(new Cosh());double[]result_mapCosh={1.543080634815244e+00d,3.762195691083631e+00d,1.006766199577777e+01d};assertClose("compare vectors",result_mapCosh,v_mapCosh.toArray(),normTolerance);RealVector v_mapCoshToSelf=v1.copy();v_mapCoshToSelf.mapToSelf(new Cosh());double[]result_mapCoshToSelf={1.543080634815244e+00d,3.762195691083631e+00d,1.006766199577777e+01d};assertClose("compare vectors",result_mapCoshToSelf,v_mapCoshToSelf.toArray(),normTolerance);RealVector v_mapSinh=v1.map(new Sinh());double[]result_mapSinh={1.175201193643801e+00d,3.626860407847019e+00d,1.001787492740990e+01d};assertClose("compare vectors",result_mapSinh,v_mapSinh.toArray(),normTolerance);RealVector v_mapSinhToSelf=v1.copy();v_mapSinhToSelf.mapToSelf(new Sinh());double[]result_mapSinhToSelf={1.175201193643801e+00d,3.626860407847019e+00d,1.001787492740990e+01d};assertClose("compare vectors",result_mapSinhToSelf,v_mapSinhToSelf.toArray(),normTolerance);RealVector v_mapTanh=v1.map(new Tanh());double[]result_mapTanh={7.615941559557649e-01d,9.640275800758169e-01d,9.950547536867305e-01d};assertClose("compare vectors",result_mapTanh,v_mapTanh.toArray(),normTolerance);RealVector v_mapTanhToSelf=v1.copy();v_mapTanhToSelf.mapToSelf(new Tanh());double[]result_mapTanhToSelf={7.615941559557649e-01d,9.640275800758169e-01d,9.950547536867305e-01d};assertClose("compare vectors",result_mapTanhToSelf,v_mapTanhToSelf.toArray(),normTolerance);RealVector v_mapCos=v1.map(new Cos());double[]result_mapCos={5.403023058681398e-01d,-4.161468365471424e-01d,-9.899924966004454e-01d};assertClose("compare vectors",result_mapCos,v_mapCos.toArray(),normTolerance);RealVector v_mapCosToSelf=v1.copy();v_mapCosToSelf.mapToSelf(new Cos());double[]result_mapCosToSelf={5.403023058681398e-01d,-4.161468365471424e-01d,-9.899924966004454e-01d};assertClose("compare vectors",result_mapCosToSelf,v_mapCosToSelf.toArray(),normTolerance);RealVector v_mapSin=v1.map(new Sin());double[]result_mapSin={8.414709848078965e-01d,9.092974268256817e-01d,1.411200080598672e-01d};assertClose("compare vectors",result_mapSin,v_mapSin.toArray(),normTolerance);RealVector v_mapSinToSelf=v1.copy();v_mapSinToSelf.mapToSelf(new Sin());double[]result_mapSinToSelf={8.414709848078965e-01d,9.092974268256817e-01d,1.411200080598672e-01d};assertClose("compare vectors",result_mapSinToSelf,v_mapSinToSelf.toArray(),normTolerance);RealVector v_mapTan=v1.map(new Tan());double[]result_mapTan={1.557407724654902e+00d,-2.185039863261519e+00d,-1.425465430742778e-01d};assertClose("compare vectors",result_mapTan,v_mapTan.toArray(),normTolerance);RealVector v_mapTanToSelf=v1.copy();v_mapTanToSelf.mapToSelf(new Tan());double[]result_mapTanToSelf={1.557407724654902e+00d,-2.185039863261519e+00d,-1.425465430742778e-01d};assertClose("compare vectors",result_mapTanToSelf,v_mapTanToSelf.toArray(),normTolerance);double[]vat_a={0d,0.5d,1.0d};OpenMapRealVector vat=new OpenMapRealVector(vat_a);RealVector v_mapAcos=vat.map(new Acos());double[]result_mapAcos={1.570796326794897e+00d,1.047197551196598e+00d,0.0d};assertClose("compare vectors",result_mapAcos,v_mapAcos.toArray(),normTolerance);RealVector v_mapAcosToSelf=vat.copy();v_mapAcosToSelf.mapToSelf(new Acos());double[]result_mapAcosToSelf={1.570796326794897e+00d,1.047197551196598e+00d,0.0d};assertClose("compare vectors",result_mapAcosToSelf,v_mapAcosToSelf.toArray(),normTolerance);RealVector v_mapAsin=vat.map(new Asin());double[]result_mapAsin={0.0d,5.235987755982989e-01d,1.570796326794897e+00d};assertClose("compare vectors",result_mapAsin,v_mapAsin.toArray(),normTolerance);RealVector v_mapAsinToSelf=vat.copy();v_mapAsinToSelf.mapToSelf(new Asin());double[]result_mapAsinToSelf={0.0d,5.235987755982989e-01d,1.570796326794897e+00d};assertClose("compare vectors",result_mapAsinToSelf,v_mapAsinToSelf.toArray(),normTolerance);RealVector v_mapAtan=vat.map(new Atan());double[]result_mapAtan={0.0d,4.636476090008061e-01d,7.853981633974483e-01d};assertClose("compare vectors",result_mapAtan,v_mapAtan.toArray(),normTolerance);RealVector v_mapAtanToSelf=vat.copy();v_mapAtanToSelf.mapToSelf(new Atan());double[]result_mapAtanToSelf={0.0d,4.636476090008061e-01d,7.853981633974483e-01d};assertClose("compare vectors",result_mapAtanToSelf,v_mapAtanToSelf.toArray(),normTolerance);RealVector v_mapInv=v1.map(new Inverse());double[]result_mapInv={1d,0.5d,3.333333333333333e-01d};assertClose("compare vectors",result_mapInv,v_mapInv.toArray(),normTolerance);RealVector v_mapInvToSelf=v1.copy();v_mapInvToSelf.mapToSelf(new Inverse());double[]result_mapInvToSelf={1d,0.5d,3.333333333333333e-01d};assertClose("compare vectors",result_mapInvToSelf,v_mapInvToSelf.toArray(),normTolerance);double[]abs_a={-1.0d,0.0d,1.0d};OpenMapRealVector abs_v=new OpenMapRealVector(abs_a);RealVector v_mapAbs=abs_v.map(new Abs());double[]result_mapAbs={1d,0d,1d};assertClose("compare vectors",result_mapAbs,v_mapAbs.toArray(),normTolerance);RealVector v_mapAbsToSelf=abs_v.copy();v_mapAbsToSelf.mapToSelf(new Abs());double[]result_mapAbsToSelf={1d,0d,1d};assertClose("compare vectors",result_mapAbsToSelf,v_mapAbsToSelf.toArray(),normTolerance);RealVector v_mapSqrt=v1.map(new Sqrt());double[]result_mapSqrt={1d,1.414213562373095e+00d,1.732050807568877e+00d};assertClose("compare vectors",result_mapSqrt,v_mapSqrt.toArray(),normTolerance);RealVector v_mapSqrtToSelf=v1.copy();v_mapSqrtToSelf.mapToSelf(new Sqrt());double[]result_mapSqrtToSelf={1d,1.414213562373095e+00d,1.732050807568877e+00d};assertClose("compare vectors",result_mapSqrtToSelf,v_mapSqrtToSelf.toArray(),normTolerance);double[]cbrt_a={-2.0d,0.0d,2.0d};OpenMapRealVector cbrt_v=new OpenMapRealVector(cbrt_a);RealVector v_mapCbrt=cbrt_v.map(new Cbrt());double[]result_mapCbrt={-1.2599210498948732d,0d,1.2599210498948732d};assertClose("compare vectors",result_mapCbrt,v_mapCbrt.toArray(),normTolerance);RealVector v_mapCbrtToSelf=cbrt_v.copy();v_mapCbrtToSelf.mapToSelf(new Cbrt());double[]result_mapCbrtToSelf={-1.2599210498948732d,0d,1.2599210498948732d};assertClose("compare vectors",result_mapCbrtToSelf,v_mapCbrtToSelf.toArray(),normTolerance);double[]ceil_a={-1.1d,0.9d,1.1d};OpenMapRealVector ceil_v=new OpenMapRealVector(ceil_a);RealVector v_mapCeil=ceil_v.map(new Ceil());double[]result_mapCeil={-1d,1d,2d};assertClose("compare vectors",result_mapCeil,v_mapCeil.toArray(),normTolerance);RealVector v_mapCeilToSelf=ceil_v.copy();v_mapCeilToSelf.mapToSelf(new Ceil());double[]result_mapCeilToSelf={-1d,1d,2d};assertClose("compare vectors",result_mapCeilToSelf,v_mapCeilToSelf.toArray(),normTolerance);RealVector v_mapFloor=ceil_v.map(new Floor());double[]result_mapFloor={-2d,0d,1d};assertClose("compare vectors",result_mapFloor,v_mapFloor.toArray(),normTolerance);RealVector v_mapFloorToSelf=ceil_v.copy();v_mapFloorToSelf.mapToSelf(new Floor());double[]result_mapFloorToSelf={-2d,0d,1d};assertClose("compare vectors",result_mapFloorToSelf,v_mapFloorToSelf.toArray(),normTolerance);RealVector v_mapRint=ceil_v.map(new Rint());double[]result_mapRint={-1d,1d,1d};assertClose("compare vectors",result_mapRint,v_mapRint.toArray(),normTolerance);RealVector v_mapRintToSelf=ceil_v.copy();v_mapRintToSelf.mapToSelf(new Rint());double[]result_mapRintToSelf={-1d,1d,1d};assertClose("compare vectors",result_mapRintToSelf,v_mapRintToSelf.toArray(),normTolerance);RealVector v_mapSignum=ceil_v.map(new Signum());double[]result_mapSignum={-1d,1d,1d};assertClose("compare vectors",result_mapSignum,v_mapSignum.toArray(),normTolerance);RealVector v_mapSignumToSelf=ceil_v.copy();v_mapSignumToSelf.mapToSelf(new Signum());double[]result_mapSignumToSelf={-1d,1d,1d};assertClose("compare vectors",result_mapSignumToSelf,v_mapSignumToSelf.toArray(),normTolerance);RealVector v_mapUlp=ceil_v.map(new Ulp());double[]result_mapUlp={2.220446049250313E-16d,1.1102230246251565E-16d,2.220446049250313E-16d};assertClose("compare vectors",result_mapUlp,v_mapUlp.toArray(),normTolerance);RealVector v_mapUlpToSelf=ceil_v.copy();v_mapUlpToSelf.mapToSelf(new Ulp());double[]result_mapUlpToSelf={2.220446049250313E-16d,1.1102230246251565E-16d,2.220446049250313E-16d};assertClose("compare vectors",result_mapUlpToSelf,v_mapUlpToSelf.toArray(),normTolerance);}
@Test public void testBasicFunctions(){OpenMapRealVector v1=new OpenMapRealVector(vec1);OpenMapRealVector v2=new OpenMapRealVector(vec2);OpenMapRealVector v5=new OpenMapRealVector(vec5);OpenMapRealVector v_null=new OpenMapRealVector(vec_null);SparseRealVectorTestImpl v2_t=new SparseRealVectorTestImpl(vec2);double d_getNorm=v5.getNorm();Assert.assertEquals("compare values  ",8.4261497731763586307,d_getNorm,normTolerance);double d_getL1Norm=v5.getL1Norm();Assert.assertEquals("compare values  ",17.0,d_getL1Norm,normTolerance);double d_getLInfNorm=v5.getLInfNorm();Assert.assertEquals("compare values  ",6.0,d_getLInfNorm,normTolerance);double dist=v1.getDistance(v2);Assert.assertEquals("compare values  ",v1.subtract(v2).getNorm(),dist,normTolerance);double dist_2=v1.getDistance(v2_t);Assert.assertEquals("compare values  ",v1.subtract(v2).getNorm(),dist_2,normTolerance);double d_getL1Distance=v1.getL1Distance(v2);Assert.assertEquals("compare values  ",9d,d_getL1Distance,normTolerance);double d_getL1Distance_2=v1.getL1Distance(v2_t);Assert.assertEquals("compare values  ",9d,d_getL1Distance_2,normTolerance);double d_getLInfDistance=v1.getLInfDistance(v2);Assert.assertEquals("compare values  ",3d,d_getLInfDistance,normTolerance);double d_getLInfDistance_2=v1.getLInfDistance(v2_t);Assert.assertEquals("compare values  ",3d,d_getLInfDistance_2,normTolerance);OpenMapRealVector v_add=v1.add(v2);double[]result_add={5d,7d,9d};assertClose("compare vect",v_add.toArray(),result_add,normTolerance);SparseRealVectorTestImpl vt2=new SparseRealVectorTestImpl(vec2);RealVector v_add_i=v1.add(vt2);double[]result_add_i={5d,7d,9d};assertClose("compare vect",v_add_i.toArray(),result_add_i,normTolerance);OpenMapRealVector v_subtract=v1.subtract(v2);double[]result_subtract={-3d,-3d,-3d};assertClose("compare vect",v_subtract.toArray(),result_subtract,normTolerance);RealVector v_subtract_i=v1.subtract(vt2);double[]result_subtract_i={-3d,-3d,-3d};assertClose("compare vect",v_subtract_i.toArray(),result_subtract_i,normTolerance);RealVector v_ebeMultiply=v1.ebeMultiply(v2);double[]result_ebeMultiply={4d,10d,18d};assertClose("compare vect",v_ebeMultiply.toArray(),result_ebeMultiply,normTolerance);RealVector v_ebeMultiply_2=v1.ebeMultiply(v2_t);double[]result_ebeMultiply_2={4d,10d,18d};assertClose("compare vect",v_ebeMultiply_2.toArray(),result_ebeMultiply_2,normTolerance);RealVector v_ebeDivide=v1.ebeDivide(v2);double[]result_ebeDivide={0.25d,0.4d,0.5d};assertClose("compare vect",v_ebeDivide.toArray(),result_ebeDivide,normTolerance);RealVector v_ebeDivide_2=v1.ebeDivide(v2_t);double[]result_ebeDivide_2={0.25d,0.4d,0.5d};assertClose("compare vect",v_ebeDivide_2.toArray(),result_ebeDivide_2,normTolerance);double dot=v1.dotProduct(v2);Assert.assertEquals("compare val ",32d,dot,normTolerance);double dot_2=v1.dotProduct(v2_t);Assert.assertEquals("compare val ",32d,dot_2,normTolerance);RealMatrix m_outerProduct=v1.outerProduct(v2);Assert.assertEquals("compare val ",4d,m_outerProduct.getEntry(0,0),normTolerance);RealMatrix m_outerProduct_2=v1.outerProduct(v2_t);Assert.assertEquals("compare val ",4d,m_outerProduct_2.getEntry(0,0),normTolerance);RealVector v_unitVector=v1.unitVector();RealVector v_unitVector_2=v1.mapDivide(v1.getNorm());assertClose("compare vect",v_unitVector.toArray(),v_unitVector_2.toArray(),normTolerance);try {v_null.unitVector();Assert.fail("Expecting MathArithmeticException");}catch(MathArithmeticException ex){}OpenMapRealVector v_unitize=v1.copy();v_unitize.unitize();assertClose("compare vect",v_unitVector_2.toArray(),v_unitize.toArray(),normTolerance);try {v_null.unitize();Assert.fail("Expecting MathArithmeticException");}catch(MathArithmeticException ex){}RealVector v_projection=v1.projection(v2);double[]result_projection={1.662337662337662,2.0779220779220777,2.493506493506493};assertClose("compare vect",v_projection.toArray(),result_projection,normTolerance);RealVector v_projection_2=v1.projection(v2_t);double[]result_projection_2={1.662337662337662,2.0779220779220777,2.493506493506493};assertClose("compare vect",v_projection_2.toArray(),result_projection_2,normTolerance);}
@Test public void testOuterProduct(){final OpenMapRealVector u=new OpenMapRealVector(new double[]{1,2,-3});final OpenMapRealVector v=new OpenMapRealVector(new double[]{4,-2});final RealMatrix uv=u.outerProduct(v);final double tol=Math.ulp(1d);Assert.assertEquals(4,uv.getEntry(0,0),tol);Assert.assertEquals(-2,uv.getEntry(0,1),tol);Assert.assertEquals(8,uv.getEntry(1,0),tol);Assert.assertEquals(-4,uv.getEntry(1,1),tol);Assert.assertEquals(-12,uv.getEntry(2,0),tol);Assert.assertEquals(6,uv.getEntry(2,1),tol);}
@Test public void testMisc(){OpenMapRealVector v1=new OpenMapRealVector(vec1);String out1=v1.toString();Assert.assertTrue("some output ",out1.length()!= 0);try {v1.checkVectorDimensions(2);Assert.fail("MathIllegalArgumentException expected");}catch(MathIllegalArgumentException ex){}}
@Test public void testPredicates(){OpenMapRealVector v=new OpenMapRealVector(new double[]{0,1,2});Assert.assertFalse(v.isNaN());v.setEntry(1,Double.NaN);Assert.assertTrue(v.isNaN());Assert.assertFalse(v.isInfinite());v.setEntry(0,Double.POSITIVE_INFINITY);Assert.assertFalse(v.isInfinite());v.setEntry(1,1);Assert.assertTrue(v.isInfinite());v.setEntry(0,0);Assert.assertEquals(v,new OpenMapRealVector(new double[]{0,1,2}));Assert.assertNotSame(v,new OpenMapRealVector(new double[]{0,1,2 + FastMath.ulp(2)}));Assert.assertNotSame(v,new OpenMapRealVector(new double[]{0,1,2,3}));}
@Test public void testSerial(){OpenMapRealVector v=new OpenMapRealVector(new double[]{0,1,2});Assert.assertEquals(v,TestUtils.serializeAndRecover(v));}
@Test public void testConcurrentModification(){final RealVector u=new OpenMapRealVector(3,1e-6);u.setEntry(0,1);u.setEntry(1,0);u.setEntry(2,2);final RealVector v1=new OpenMapRealVector(3,1e-6);v1.setEntry(0,0);v1.setEntry(1,3);v1.setEntry(2,0);u.ebeMultiply(v1);u.ebeDivide(v1);}
@Test public void testMissedEndEvent(){final double t0=1878250320.0000029;final double tEvent=1878250379.9999986;final double[]k={1.0e-4,1.0e-5,1.0e-6};FirstOrderDifferentialEquations ode=new FirstOrderDifferentialEquations(){public int getDimension(){return k.length;}public void computeDerivatives(double t,double[]y,double[]yDot){for (int i=0;i < y.length;++i){yDot[i]=k[i]* y[i];}}};DormandPrince853Integrator integrator=new DormandPrince853Integrator(0.0,100.0,1.0e-10,1.0e-10);double[]y0=new double[k.length];for (int i=0;i < y0.length;++i){y0[i]=i + 1;}double[]y=new double[k.length];integrator.setInitialStepSize(60.0);double finalT=integrator.integrate(ode,t0,y0,tEvent,y);Assert.assertEquals(tEvent,finalT,5.0e-6);for (int i=0;i < y.length;++i){Assert.assertEquals(y0[i]* FastMath.exp(k[i]* (finalT - t0)),y[i],1.0e-9);}integrator.setInitialStepSize(60.0);integrator.addEventHandler(new EventHandler(){public void init(double t0,double[]y0,double t){}public void resetState(double t,double[]y){}public double g(double t,double[]y){return t - tEvent;}public Action eventOccurred(double t,double[]y,boolean increasing){Assert.assertEquals(tEvent,t,5.0e-6);return Action.CONTINUE;}},Double.POSITIVE_INFINITY,1.0e-20,100);finalT=integrator.integrate(ode,t0,y0,tEvent + 120,y);Assert.assertEquals(tEvent + 120,finalT,5.0e-6);for (int i=0;i < y.length;++i){Assert.assertEquals(y0[i]* FastMath.exp(k[i]* (finalT - t0)),y[i],1.0e-9);}}
@Test(expected=DimensionMismatchException.class)public void testDimensionCheck(){TestProblem1 pb=new TestProblem1();DormandPrince853Integrator integrator=new DormandPrince853Integrator(0.0,1.0,1.0e-10,1.0e-10);integrator.integrate(pb,0.0,new double[pb.getDimension()+ 10],1.0,new double[pb.getDimension()+ 10]);Assert.fail("an exception should have been thrown");}
@Test(expected=NumberIsTooSmallException.class)public void testNullIntervalCheck(){TestProblem1 pb=new TestProblem1();DormandPrince853Integrator integrator=new DormandPrince853Integrator(0.0,1.0,1.0e-10,1.0e-10);integrator.integrate(pb,0.0,new double[pb.getDimension()],0.0,new double[pb.getDimension()]);Assert.fail("an exception should have been thrown");}
@Test(expected=NumberIsTooSmallException.class)public void testMinStep(){TestProblem1 pb=new TestProblem1();double minStep=0.1 * (pb.getFinalTime()- pb.getInitialTime());double maxStep=pb.getFinalTime()- pb.getInitialTime();double[]vecAbsoluteTolerance={1.0e-15,1.0e-16};double[]vecRelativeTolerance={1.0e-15,1.0e-16};FirstOrderIntegrator integ=new DormandPrince853Integrator(minStep,maxStep,vecAbsoluteTolerance,vecRelativeTolerance);TestProblemHandler handler=new TestProblemHandler(pb,integ);integ.addStepHandler(handler);integ.integrate(pb,pb.getInitialTime(),pb.getInitialState(),pb.getFinalTime(),new double[pb.getDimension()]);Assert.fail("an exception should have been thrown");}
@Test public void testIncreasingTolerance(){int previousCalls=Integer.MAX_VALUE;AdaptiveStepsizeIntegrator integ=new DormandPrince853Integrator(0,Double.POSITIVE_INFINITY,Double.NaN,Double.NaN);for (int i=-12;i < -2;++i){TestProblem1 pb=new TestProblem1();double minStep=0;double maxStep=pb.getFinalTime()- pb.getInitialTime();double scalAbsoluteTolerance=FastMath.pow(10.0,i);double scalRelativeTolerance=0.01 * scalAbsoluteTolerance;integ.setStepSizeControl(minStep,maxStep,scalAbsoluteTolerance,scalRelativeTolerance);TestProblemHandler handler=new TestProblemHandler(pb,integ);integ.addStepHandler(handler);integ.integrate(pb,pb.getInitialTime(),pb.getInitialState(),pb.getFinalTime(),new double[pb.getDimension()]);Assert.assertTrue(handler.getMaximalValueError()< (1.3 * scalAbsoluteTolerance));Assert.assertEquals(0,handler.getMaximalTimeError(),1.0e-12);int calls=pb.getCalls();Assert.assertEquals(integ.getEvaluations(),calls);Assert.assertTrue(calls <= previousCalls);previousCalls=calls;}}
@Test public void testBackward(){TestProblem5 pb=new TestProblem5();double minStep=0;double maxStep=pb.getFinalTime()- pb.getInitialTime();double scalAbsoluteTolerance=1.0e-8;double scalRelativeTolerance=0.01 * scalAbsoluteTolerance;FirstOrderIntegrator integ=new DormandPrince853Integrator(minStep,maxStep,scalAbsoluteTolerance,scalRelativeTolerance);TestProblemHandler handler=new TestProblemHandler(pb,integ);integ.addStepHandler(handler);integ.integrate(pb,pb.getInitialTime(),pb.getInitialState(),pb.getFinalTime(),new double[pb.getDimension()]);Assert.assertTrue(handler.getLastError()< 1.1e-7);Assert.assertTrue(handler.getMaximalValueError()< 1.1e-7);Assert.assertEquals(0,handler.getMaximalTimeError(),1.0e-12);Assert.assertEquals("Dormand-Prince 8 (5,3)",integ.getName());}
@Test public void testEvents(){TestProblem4 pb=new TestProblem4();double minStep=0;double maxStep=pb.getFinalTime()- pb.getInitialTime();double scalAbsoluteTolerance=1.0e-9;double scalRelativeTolerance=0.01 * scalAbsoluteTolerance;FirstOrderIntegrator integ=new DormandPrince853Integrator(minStep,maxStep,scalAbsoluteTolerance,scalRelativeTolerance);TestProblemHandler handler=new TestProblemHandler(pb,integ);integ.addStepHandler(handler);EventHandler[]functions=pb.getEventsHandlers();double convergence=1.0e-8 * maxStep;for (int l=0;l < functions.length;++l){integ.addEventHandler(functions[l],Double.POSITIVE_INFINITY,convergence,1000);}Assert.assertEquals(functions.length,integ.getEventHandlers().size());integ.integrate(pb,pb.getInitialTime(),pb.getInitialState(),pb.getFinalTime(),new double[pb.getDimension()]);Assert.assertEquals(0,handler.getMaximalValueError(),2.1e-7);Assert.assertEquals(0,handler.getMaximalTimeError(),convergence);Assert.assertEquals(12.0,handler.getLastTime(),convergence);integ.clearEventHandlers();Assert.assertEquals(0,integ.getEventHandlers().size());}
@Test public void testKepler(){final TestProblem3 pb=new TestProblem3(0.9);double minStep=0;double maxStep=pb.getFinalTime()- pb.getInitialTime();double scalAbsoluteTolerance=1.0e-8;double scalRelativeTolerance=scalAbsoluteTolerance;FirstOrderIntegrator integ=new DormandPrince853Integrator(minStep,maxStep,scalAbsoluteTolerance,scalRelativeTolerance);integ.addStepHandler(new KeplerHandler(pb));integ.integrate(pb,pb.getInitialTime(),pb.getInitialState(),pb.getFinalTime(),new double[pb.getDimension()]);Assert.assertEquals(integ.getEvaluations(),pb.getCalls());Assert.assertTrue(pb.getCalls()< 3300);}
@Test public void testVariableSteps(){final TestProblem3 pb=new TestProblem3(0.9);double minStep=0;double maxStep=pb.getFinalTime()- pb.getInitialTime();double scalAbsoluteTolerance=1.0e-8;double scalRelativeTolerance=scalAbsoluteTolerance;FirstOrderIntegrator integ=new DormandPrince853Integrator(minStep,maxStep,scalAbsoluteTolerance,scalRelativeTolerance);integ.addStepHandler(new VariableHandler());double stopTime=integ.integrate(pb,pb.getInitialTime(),pb.getInitialState(),pb.getFinalTime(),new double[pb.getDimension()]);Assert.assertEquals(pb.getFinalTime(),stopTime,1.0e-10);Assert.assertEquals("Dormand-Prince 8 (5,3)",integ.getName());}
@Test public void testUnstableDerivative(){final StepProblem stepProblem=new StepProblem(0.0,1.0,2.0);FirstOrderIntegrator integ=new DormandPrince853Integrator(0.1,10,1.0e-12,0.0);integ.addEventHandler(stepProblem,1.0,1.0e-12,1000);double[]y={Double.NaN};integ.integrate(stepProblem,0.0,new double[]{0.0},10.0,y);Assert.assertEquals(8.0,y[0],1.0e-12);}
@Test public void testConstructor(){MathException ex=new MathException();Assert.assertNull(ex.getCause());Assert.assertEquals("",ex.getMessage());Assert.assertEquals("",ex.getMessage(Locale.FRENCH));}
@Test public void testConstructorCause(){String inMsg="inner message";Exception cause=new Exception(inMsg);MathException ex=new MathException(cause);Assert.assertEquals(cause,ex.getCause());}
/** * Tests the printStackTrace()operation.*/@Test public void testPrintStackTrace(){Localizable outMsg=new DummyLocalizable("outer message");Localizable inMsg=new DummyLocalizable("inner message");MathIllegalStateException cause=new MathIllegalStateException(LocalizedFormats.SIMPLE_MESSAGE,inMsg);MathException ex=new MathException(cause,outMsg);ByteArrayOutputStream baos=new ByteArrayOutputStream();PrintStream ps=new PrintStream(baos);ex.printStackTrace(ps);String stack=baos.toString();String outerMsg="org.apache.commons.math.MathException: outer message";String innerMsg="Caused by: " + "org.apache.commons.math.exception.MathIllegalStateException: inner message";Assert.assertTrue(stack.startsWith(outerMsg));Assert.assertTrue(stack.indexOf(innerMsg)> 0);PrintWriter pw=new PrintWriter(ps,true);ex.printStackTrace(pw);stack=baos.toString();Assert.assertTrue(stack.startsWith(outerMsg));Assert.assertTrue(stack.indexOf(innerMsg)> 0);}
/** * Test serialization*/@Test public void testSerialization(){Localizable outMsg=new DummyLocalizable("outer message");Localizable inMsg=new DummyLocalizable("inner message");MathIllegalStateException cause=new MathIllegalStateException(LocalizedFormats.SIMPLE_MESSAGE,inMsg);MathException ex=new MathException(cause,outMsg);MathException image=(MathException)TestUtils.serializeAndRecover(ex);ByteArrayOutputStream baos=new ByteArrayOutputStream();PrintStream ps=new PrintStream(baos);ex.printStackTrace(ps);String stack=baos.toString();ByteArrayOutputStream baos2=new ByteArrayOutputStream();PrintStream ps2=new PrintStream(baos2);image.printStackTrace(ps2);String stack2=baos2.toString();boolean jdkSupportsNesting=false;try {Throwable.class.getDeclaredMethod("getCause",new Class[0]);jdkSupportsNesting=true;}catch(NoSuchMethodException e){jdkSupportsNesting=false;}if (jdkSupportsNesting){Assert.assertEquals(stack,stack2);}else {Assert.assertTrue(stack2.indexOf(inMsg.getSourceString())!= -1);Assert.assertTrue(stack2.indexOf("MathConfigurationException")!= -1);}}
@Test public void testMutate(){BinaryMutation mutation=new BinaryMutation();for (int i=0;i < 20;i++){DummyBinaryChromosome original=new DummyBinaryChromosome(BinaryChromosome.randomBinaryRepresentation(10));DummyBinaryChromosome mutated=(DummyBinaryChromosome)mutation.mutate(original);int numDifferent=0;for (int j=0;j < original.getRepresentation().size();j++){if (original.getRepresentation().get(j)!= mutated.getRepresentation().get(j))numDifferent++;}Assert.assertEquals(1,numDifferent);}}
@Test public void testIsSatisfied(){FixedGenerationCount fgc=new FixedGenerationCount(20);int cnt=0;Population pop=new Population(){public void addChromosome(Chromosome chromosome){}public Chromosome getFittestChromosome(){return null;}public int getPopulationLimit(){return 0;}public int getPopulationSize(){return 0;}public Population nextGeneration(){return null;}public Iterator<Chromosome> iterator(){return null;}};while (!fgc.isSatisfied(pop)){cnt++;}Assert.assertEquals(20,cnt);}
@Test public void testSimpleNoDecimals(){Complex c=new Complex(1,2);String expected="1 + 2i";String actual=complexFormat.format(c);Assert.assertEquals(expected,actual);}
@Test public void testTrimOneImaginary(){final ComplexFormat fmt=ComplexFormat.getInstance(getLocale());fmt.getImaginaryFormat().setMaximumFractionDigits(1);Complex c=new Complex(1,1.04);String expected="1 + i";String actual=fmt.format(c);Assert.assertEquals(expected,actual);c=new Complex(1,1.09);expected="1 + 1" + getDecimalCharacter()+ "1i";actual=fmt.format(c);Assert.assertEquals(expected,actual);c=new Complex(1,-1.09);expected="1 - 1" + getDecimalCharacter()+ "1i";actual=fmt.format(c);Assert.assertEquals(expected,actual);c=new Complex(1,-1.04);expected="1 - i";actual=fmt.format(c);Assert.assertEquals(expected,actual);}
@Test public void testSimpleWithDecimals(){Complex c=new Complex(1.23,1.43);String expected="1" + getDecimalCharacter()+ "23 + 1"+ getDecimalCharacter()+ "43i";String actual=complexFormat.format(c);Assert.assertEquals(expected,actual);}
@Test public void testSimpleWithDecimalsTrunc(){Complex c=new Complex(1.2323,1.4343);String expected="1" + getDecimalCharacter()+ "23 + 1"+ getDecimalCharacter()+ "43i";String actual=complexFormat.format(c);Assert.assertEquals(expected,actual);}
@Test public void testNegativeReal(){Complex c=new Complex(-1.2323,1.4343);String expected="-1" + getDecimalCharacter()+ "23 + 1"+ getDecimalCharacter()+ "43i";String actual=complexFormat.format(c);Assert.assertEquals(expected,actual);}
@Test public void testNegativeImaginary(){Complex c=new Complex(1.2323,-1.4343);String expected="1" + getDecimalCharacter()+ "23 - 1"+ getDecimalCharacter()+ "43i";String actual=complexFormat.format(c);Assert.assertEquals(expected,actual);}
@Test public void testNegativeBoth(){Complex c=new Complex(-1.2323,-1.4343);String expected="-1" + getDecimalCharacter()+ "23 - 1"+ getDecimalCharacter()+ "43i";String actual=complexFormat.format(c);Assert.assertEquals(expected,actual);}
@Test public void testZeroReal(){Complex c=new Complex(0.0,-1.4343);String expected="0 - 1" + getDecimalCharacter()+ "43i";String actual=complexFormat.format(c);Assert.assertEquals(expected,actual);}
@Test public void testZeroImaginary(){Complex c=new Complex(30.233,0);String expected="30" + getDecimalCharacter()+ "23";String actual=complexFormat.format(c);Assert.assertEquals(expected,actual);}
@Test public void testDifferentImaginaryChar(){Complex c=new Complex(1,1);String expected="1 + j";String actual=complexFormatJ.format(c);Assert.assertEquals(expected,actual);}
@Test public void testDefaultFormatComplex(){Locale defaultLocal=Locale.getDefault();Locale.setDefault(getLocale());Complex c=new Complex(232.222,-342.33);String expected="232" + getDecimalCharacter()+ "22 - 342"+ getDecimalCharacter()+ "33i";String actual=(new ComplexFormat()).format(c);Assert.assertEquals(expected,actual);Locale.setDefault(defaultLocal);}
@Test public void testNan(){Complex c=new Complex(Double.NaN,Double.NaN);String expected="(NaN)+ (NaN)i";String actual=complexFormat.format(c);Assert.assertEquals(expected,actual);}
@Test public void testPositiveInfinity(){Complex c=new Complex(Double.POSITIVE_INFINITY,Double.POSITIVE_INFINITY);String expected="(Infinity)+ (Infinity)i";String actual=complexFormat.format(c);Assert.assertEquals(expected,actual);}
@Test public void testNegativeInfinity(){Complex c=new Complex(Double.NEGATIVE_INFINITY,Double.NEGATIVE_INFINITY);String expected="(-Infinity)- (Infinity)i";String actual=complexFormat.format(c);Assert.assertEquals(expected,actual);}
@Test public void testParseSimpleNoDecimals(){String source="1 + 1i";Complex expected=new Complex(1,1);Complex actual=complexFormat.parse(source);Assert.assertEquals(expected,actual);}
@Test public void testParseSimpleWithDecimals(){String source="1" + getDecimalCharacter()+ "23 + 1"+ getDecimalCharacter()+ "43i";Complex expected=new Complex(1.23,1.43);Complex actual=complexFormat.parse(source);Assert.assertEquals(expected,actual);}
@Test public void testParseSimpleWithDecimalsTrunc(){String source="1" + getDecimalCharacter()+ "2323 + 1"+ getDecimalCharacter()+ "4343i";Complex expected=new Complex(1.2323,1.4343);Complex actual=complexFormat.parse(source);Assert.assertEquals(expected,actual);}
@Test public void testParseNegativeReal(){String source="-1" + getDecimalCharacter()+ "2323 + 1"+ getDecimalCharacter()+ "4343i";Complex expected=new Complex(-1.2323,1.4343);Complex actual=complexFormat.parse(source);Assert.assertEquals(expected,actual);}
@Test public void testParseNegativeImaginary(){String source="1" + getDecimalCharacter()+ "2323 - 1"+ getDecimalCharacter()+ "4343i";Complex expected=new Complex(1.2323,-1.4343);Complex actual=complexFormat.parse(source);Assert.assertEquals(expected,actual);}
@Test public void testParseNegativeBoth(){String source="-1" + getDecimalCharacter()+ "2323 - 1"+ getDecimalCharacter()+ "4343i";Complex expected=new Complex(-1.2323,-1.4343);Complex actual=complexFormat.parse(source);Assert.assertEquals(expected,actual);}
@Test public void testParseZeroReal(){String source="0" + getDecimalCharacter()+ "0 - 1"+ getDecimalCharacter()+ "4343i";Complex expected=new Complex(0.0,-1.4343);Complex actual=complexFormat.parse(source);Assert.assertEquals(expected,actual);}
@Test public void testParseZeroImaginary(){String source="-1" + getDecimalCharacter()+ "2323";Complex expected=new Complex(-1.2323,0);Complex actual=complexFormat.parse(source);Assert.assertEquals(expected,actual);}
@Test public void testParseDifferentImaginaryChar(){String source="-1" + getDecimalCharacter()+ "2323 - 1"+ getDecimalCharacter()+ "4343j";Complex expected=new Complex(-1.2323,-1.4343);Complex actual=complexFormatJ.parse(source);Assert.assertEquals(expected,actual);}
@Test public void testParseNan(){String source="(NaN)+ (NaN)i";Complex expected=new Complex(Double.NaN,Double.NaN);Complex actual=complexFormat.parse(source);Assert.assertEquals(expected,actual);}
@Test public void testParsePositiveInfinity(){String source="(Infinity)+ (Infinity)i";Complex expected=new Complex(Double.POSITIVE_INFINITY,Double.POSITIVE_INFINITY);Complex actual=complexFormat.parse(source);Assert.assertEquals(expected,actual);}
@Test public void testPaseNegativeInfinity(){String source="(-Infinity)- (Infinity)i";Complex expected=new Complex(Double.NEGATIVE_INFINITY,Double.NEGATIVE_INFINITY);Complex actual=complexFormat.parse(source);Assert.assertEquals(expected,actual);}
@Test public void testConstructorSingleFormat(){NumberFormat nf=NumberFormat.getInstance();ComplexFormat cf=new ComplexFormat(nf);Assert.assertNotNull(cf);Assert.assertEquals(nf,cf.getRealFormat());}
@Test public void testGetImaginaryFormat(){NumberFormat nf=NumberFormat.getInstance();ComplexFormat cf=new ComplexFormat(nf);Assert.assertSame(nf,cf.getImaginaryFormat());}
@Test public void testGetRealFormat(){NumberFormat nf=NumberFormat.getInstance();ComplexFormat cf=new ComplexFormat(nf);Assert.assertSame(nf,cf.getRealFormat());}
@Test public void testFormatNumber(){ComplexFormat cf=ComplexFormat.getInstance(getLocale());Double pi=Double.valueOf(FastMath.PI);String text=cf.format(pi);Assert.assertEquals("3" + getDecimalCharacter()+ "14",text);}
@Test public void testForgottenImaginaryCharacter(){ParsePosition pos=new ParsePosition(0);Assert.assertNull(new ComplexFormat().parse("1 + 1",pos));Assert.assertEquals(5,pos.getErrorIndex());}
@Test public void testSumSinc(){final MultivariateFunction func=new SumSincFunction(-1);int dim=2;final double[]minPoint=new double[dim];for (int i=0;i < dim;i++){minPoint[i]=0;}double[]init=new double[dim];for (int i=0;i < dim;i++){init[i]=minPoint[i];}doTest(func,minPoint,init,GoalType.MINIMIZE,1e-9,1e-7);for (int i=0;i < dim;i++){init[i]=minPoint[i]+ 3;}doTest(func,minPoint,init,GoalType.MINIMIZE,1e-9,1e-7);}
@Test public void testQuadratic(){final MultivariateFunction func=new MultivariateFunction(){public double value(double[]x){final double a=x[0]- 1;final double b=x[1]- 1;return a * a + b * b + 1;}};int dim=2;final double[]minPoint=new double[dim];for (int i=0;i < dim;i++){minPoint[i]=1;}double[]init=new double[dim];for (int i=0;i < dim;i++){init[i]=minPoint[i];}doTest(func,minPoint,init,GoalType.MINIMIZE,1e-9,1e-8);for (int i=0;i < dim;i++){init[i]=minPoint[i]- 20;}doTest(func,minPoint,init,GoalType.MINIMIZE,1e-9,1e-8);}
@Test public void testMaximizeQuadratic(){final MultivariateFunction func=new MultivariateFunction(){public double value(double[]x){final double a=x[0]- 1;final double b=x[1]- 1;return -a * a - b * b + 1;}};int dim=2;final double[]maxPoint=new double[dim];for (int i=0;i < dim;i++){maxPoint[i]=1;}double[]init=new double[dim];for (int i=0;i < dim;i++){init[i]=maxPoint[i];}doTest(func,maxPoint,init,GoalType.MAXIMIZE,1e-9,1e-8);for (int i=0;i < dim;i++){init[i]=maxPoint[i]- 20;}doTest(func,maxPoint,init,GoalType.MAXIMIZE,1e-9,1e-8);}
@Test public void testFitnessCaching(){GeneticAlgorithm ga=new GeneticAlgorithm(new OnePointCrossover<Integer>(),CROSSOVER_RATE,new BinaryMutation(),MUTATION_RATE,new TournamentSelection(TOURNAMENT_ARITY));Population initial=randomPopulation();StoppingCondition stopCond=new FixedGenerationCount(NUM_GENERATIONS);ga.evolve(initial,stopCond);int neededCalls=POPULATION_SIZE + (NUM_GENERATIONS - 1)* (int)(POPULATION_SIZE * (1.0 - ELITISM_RATE));Assert.assertTrue(fitnessCalls <= neededCalls);}
@Test public void testByteConstructor(){Assert.assertEquals("0.",new Dfp(field,(byte)0).toString());Assert.assertEquals("1.",new Dfp(field,(byte)1).toString());Assert.assertEquals("-1.",new Dfp(field,(byte)-1).toString());Assert.assertEquals("-128.",new Dfp(field,Byte.MIN_VALUE).toString());Assert.assertEquals("127.",new Dfp(field,Byte.MAX_VALUE).toString());}
@Test public void testIntConstructor(){Assert.assertEquals("0.",new Dfp(field,0).toString());Assert.assertEquals("1.",new Dfp(field,1).toString());Assert.assertEquals("-1.",new Dfp(field,-1).toString());Assert.assertEquals("1234567890.",new Dfp(field,1234567890).toString());Assert.assertEquals("-1234567890.",new Dfp(field,-1234567890).toString());Assert.assertEquals("-2147483648.",new Dfp(field,Integer.MIN_VALUE).toString());Assert.assertEquals("2147483647.",new Dfp(field,Integer.MAX_VALUE).toString());}
@Test public void testLongConstructor(){Assert.assertEquals("0.",new Dfp(field,0l).toString());Assert.assertEquals("1.",new Dfp(field,1l).toString());Assert.assertEquals("-1.",new Dfp(field,-1l).toString());Assert.assertEquals("1234567890.",new Dfp(field,1234567890l).toString());Assert.assertEquals("-1234567890.",new Dfp(field,-1234567890l).toString());Assert.assertEquals("-9223372036854775808.",new Dfp(field,Long.MIN_VALUE).toString());Assert.assertEquals("9223372036854775807.",new Dfp(field,Long.MAX_VALUE).toString());}
@Test public void testAdd(){test(field.newDfp("1").add(field.newDfp("1")),field.newDfp("2"),0,"Add #1");test(field.newDfp("1").add(field.newDfp("-1")),field.newDfp("0"),0,"Add #2");test(field.newDfp("-1").add(field.newDfp("1")),field.newDfp("0"),0,"Add #3");test(field.newDfp("-1").add(field.newDfp("-1")),field.newDfp("-2"),0,"Add #4");test(field.newDfp("1").add(field.newDfp("1e-16")),field.newDfp("1.0000000000000001"),0,"Add #5");test(field.newDfp("1").add(field.newDfp("1e-17")),field.newDfp("1"),DfpField.FLAG_INEXACT,"Add #6");test(field.newDfp("0.90999999999999999999").add(field.newDfp("0.1")),field.newDfp("1.01"),DfpField.FLAG_INEXACT,"Add #7");test(field.newDfp(".10000000000000005000").add(field.newDfp(".9")),field.newDfp("1."),DfpField.FLAG_INEXACT,"Add #8");test(field.newDfp(".10000000000000015000").add(field.newDfp(".9")),field.newDfp("1.0000000000000002"),DfpField.FLAG_INEXACT,"Add #9");test(field.newDfp(".10000000000000014999").add(field.newDfp(".9")),field.newDfp("1.0000000000000001"),DfpField.FLAG_INEXACT,"Add #10");test(field.newDfp(".10000000000000015001").add(field.newDfp(".9")),field.newDfp("1.0000000000000002"),DfpField.FLAG_INEXACT,"Add #11");test(field.newDfp(".11111111111111111111").add(field.newDfp("11.1111111111111111")),field.newDfp("11.22222222222222222222"),DfpField.FLAG_INEXACT,"Add #12");test(field.newDfp(".11111111111111111111").add(field.newDfp("1111111111111111.1111")),field.newDfp("1111111111111111.2222"),DfpField.FLAG_INEXACT,"Add #13");test(field.newDfp(".11111111111111111111").add(field.newDfp("11111111111111111111")),field.newDfp("11111111111111111111"),DfpField.FLAG_INEXACT,"Add #14");test(field.newDfp("9.9999999999999999999e131071").add(field.newDfp("-1e131052")),field.newDfp("9.9999999999999999998e131071"),0,"Add #15");test(field.newDfp("9.9999999999999999999e131071").add(field.newDfp("1e131052")),pinf,DfpField.FLAG_OVERFLOW,"Add #16");test(field.newDfp("-9.9999999999999999999e131071").add(field.newDfp("-1e131052")),ninf,DfpField.FLAG_OVERFLOW,"Add #17");test(field.newDfp("-9.9999999999999999999e131071").add(field.newDfp("1e131052")),field.newDfp("-9.9999999999999999998e131071"),0,"Add #18");test(field.newDfp("1e-131072").add(field.newDfp("1e-131072")),field.newDfp("2e-131072"),0,"Add #19");test(field.newDfp("1.0000000000000001e-131057").add(field.newDfp("-1e-131057")),field.newDfp("1e-131073"),DfpField.FLAG_UNDERFLOW,"Add #20");test(field.newDfp("1.1e-131072").add(field.newDfp("-1e-131072")),field.newDfp("1e-131073"),DfpField.FLAG_UNDERFLOW,"Add #21");test(field.newDfp("1.0000000000000001e-131072").add(field.newDfp("-1e-131072")),field.newDfp("1e-131088"),DfpField.FLAG_UNDERFLOW,"Add #22");test(field.newDfp("1.0000000000000001e-131078").add(field.newDfp("-1e-131078")),field.newDfp("0"),DfpField.FLAG_UNDERFLOW,"Add #23");test(field.newDfp("1.0").add(field.newDfp("-1e-20")),field.newDfp("0.99999999999999999999"),0,"Add #23.1");test(field.newDfp("-0.99999999999999999999").add(field.newDfp("1")),field.newDfp("0.00000000000000000001"),0,"Add #23.2");test(field.newDfp("1").add(field.newDfp("0")),field.newDfp("1"),0,"Add #24");test(field.newDfp("0").add(field.newDfp("0")),field.newDfp("0"),0,"Add #25");test(field.newDfp("-0").add(field.newDfp("0")),field.newDfp("0"),0,"Add #26");test(field.newDfp("0").add(field.newDfp("-0")),field.newDfp("0"),0,"Add #27");test(field.newDfp("-0").add(field.newDfp("-0")),field.newDfp("-0"),0,"Add #28");test(field.newDfp("1e-20").add(field.newDfp("0")),field.newDfp("1e-20"),0,"Add #29");test(field.newDfp("1e-40").add(field.newDfp("0")),field.newDfp("1e-40"),0,"Add #30");test(pinf.add(ninf),nan,DfpField.FLAG_INVALID,"Add #31");test(ninf.add(pinf),nan,DfpField.FLAG_INVALID,"Add #32");test(ninf.add(ninf),ninf,0,"Add #33");test(pinf.add(pinf),pinf,0,"Add #34");test(pinf.add(field.newDfp("0")),pinf,0,"Add #35");test(pinf.add(field.newDfp("-1e131071")),pinf,0,"Add #36");test(pinf.add(field.newDfp("1e131071")),pinf,0,"Add #37");test(field.newDfp("0").add(pinf),pinf,0,"Add #38");test(field.newDfp("-1e131071").add(pinf),pinf,0,"Add #39");test(field.newDfp("1e131071").add(pinf),pinf,0,"Add #40");test(ninf.add(field.newDfp("0")),ninf,0,"Add #41");test(ninf.add(field.newDfp("-1e131071")),ninf,0,"Add #42");test(ninf.add(field.newDfp("1e131071")),ninf,0,"Add #43");test(field.newDfp("0").add(ninf),ninf,0,"Add #44");test(field.newDfp("-1e131071").add(ninf),ninf,0,"Add #45");test(field.newDfp("1e131071").add(ninf),ninf,0,"Add #46");test(field.newDfp("9.9999999999999999999e131071").add(field.newDfp("5e131051")),pinf,DfpField.FLAG_OVERFLOW,"Add #47");test(field.newDfp("9.9999999999999999999e131071").add(field.newDfp("4.9999999999999999999e131051")),field.newDfp("9.9999999999999999999e131071"),DfpField.FLAG_INEXACT,"Add #48");test(nan.add(field.newDfp("1")),nan,0,"Add #49");test(field.newDfp("1").add(nan),nan,0,"Add #50");test(field.newDfp("12345678123456781234").add(field.newDfp("0.12345678123456781234")),field.newDfp("12345678123456781234"),DfpField.FLAG_INEXACT,"Add #51");test(field.newDfp("12345678123456781234").add(field.newDfp("123.45678123456781234")),field.newDfp("12345678123456781357"),DfpField.FLAG_INEXACT,"Add #52");test(field.newDfp("123.45678123456781234").add(field.newDfp("12345678123456781234")),field.newDfp("12345678123456781357"),DfpField.FLAG_INEXACT,"Add #53");test(field.newDfp("12345678123456781234").add(field.newDfp(".00001234567812345678")),field.newDfp("12345678123456781234"),DfpField.FLAG_INEXACT,"Add #54");test(field.newDfp("12345678123456781234").add(field.newDfp(".00000000123456781234")),field.newDfp("12345678123456781234"),DfpField.FLAG_INEXACT,"Add #55");test(field.newDfp("-0").add(field.newDfp("-0")),field.newDfp("-0"),0,"Add #56");test(field.newDfp("0").add(field.newDfp("-0")),field.newDfp("0"),0,"Add #57");test(field.newDfp("-0").add(field.newDfp("0")),field.newDfp("0"),0,"Add #58");test(field.newDfp("0").add(field.newDfp("0")),field.newDfp("0"),0,"Add #59");}
@Test public void testCompare(){field.clearIEEEFlags();cmptst(field.newDfp("0"),field.newDfp("0"),"equal",true,1);cmptst(field.newDfp("0"),field.newDfp("-0"),"equal",true,2);cmptst(field.newDfp("-0"),field.newDfp("-0"),"equal",true,3);cmptst(field.newDfp("-0"),field.newDfp("0"),"equal",true,4);cmptst(field.newDfp("0"),field.newDfp("1"),"equal",false,5);cmptst(field.newDfp("1"),field.newDfp("0"),"equal",false,6);cmptst(field.newDfp("-1"),field.newDfp("0"),"equal",false,7);cmptst(field.newDfp("0"),field.newDfp("-1"),"equal",false,8);cmptst(field.newDfp("0"),field.newDfp("1e-131072"),"equal",false,9);if (field.getIEEEFlags()!= 0)Assert.fail("assersion failed.  compare flags = " + field.getIEEEFlags());cmptst(field.newDfp("0"),field.newDfp("1e-131078"),"equal",false,10);if (field.getIEEEFlags()!= DfpField.FLAG_UNDERFLOW)Assert.fail("assersion failed.  compare flags = " + field.getIEEEFlags());field.clearIEEEFlags();cmptst(field.newDfp("0"),field.newDfp("1e+131071"),"equal",false,11);cmptst(field.newDfp("0"),pinf,"equal",false,12);cmptst(field.newDfp("0"),ninf,"equal",false,13);cmptst(field.newDfp("-0"),pinf,"equal",false,14);cmptst(field.newDfp("-0"),ninf,"equal",false,15);cmptst(pinf,field.newDfp("0"),"equal",false,16);cmptst(ninf,field.newDfp("0"),"equal",false,17);cmptst(pinf,field.newDfp("-0"),"equal",false,18);cmptst(ninf,field.newDfp("-0"),"equal",false,19);cmptst(ninf,pinf,"equal",false,19.10);cmptst(pinf,ninf,"equal",false,19.11);cmptst(pinf,pinf,"equal",true,19.12);cmptst(ninf,ninf,"equal",true,19.13);cmptst(field.newDfp("1"),field.newDfp("1"),"equal",true,20);cmptst(field.newDfp("1"),field.newDfp("-1"),"equal",false,21);cmptst(field.newDfp("-1"),field.newDfp("-1"),"equal",true,22);cmptst(field.newDfp("1"),field.newDfp("1.0000000000000001"),"equal",false,23);cmptst(field.newDfp("1e20"),field.newDfp("1.0000000000000001"),"equal",false,24);if (field.getIEEEFlags()!= 0)Assert.fail("assersion failed.  compare flags = " + field.getIEEEFlags());cmptst(field.newDfp("0.000001"),field.newDfp("1e-6"),"equal",true,25);cmptst(snan,snan,"equal",false,27);cmptst(qnan,qnan,"equal",false,28);cmptst(snan,qnan,"equal",false,29);cmptst(qnan,snan,"equal",false,30);cmptst(qnan,field.newDfp("0"),"equal",false,31);cmptst(snan,field.newDfp("0"),"equal",false,32);cmptst(field.newDfp("0"),snan,"equal",false,33);cmptst(field.newDfp("0"),qnan,"equal",false,34);cmptst(qnan,pinf,"equal",false,35);cmptst(snan,pinf,"equal",false,36);cmptst(pinf,snan,"equal",false,37);cmptst(pinf,qnan,"equal",false,38);cmptst(qnan,ninf,"equal",false,39);cmptst(snan,ninf,"equal",false,40);cmptst(ninf,snan,"equal",false,41);cmptst(ninf,qnan,"equal",false,42);cmptst(qnan,field.newDfp("-1"),"equal",false,43);cmptst(snan,field.newDfp("-1"),"equal",false,44);cmptst(field.newDfp("-1"),snan,"equal",false,45);cmptst(field.newDfp("-1"),qnan,"equal",false,46);cmptst(qnan,field.newDfp("1"),"equal",false,47);cmptst(snan,field.newDfp("1"),"equal",false,48);cmptst(field.newDfp("1"),snan,"equal",false,49);cmptst(field.newDfp("1"),qnan,"equal",false,50);cmptst(snan.negate(),snan,"equal",false,51);cmptst(qnan.negate(),qnan,"equal",false,52);cmptst(field.newDfp("0"),field.newDfp("0"),"unequal",false,1);cmptst(field.newDfp("0"),field.newDfp("-0"),"unequal",false,2);cmptst(field.newDfp("-0"),field.newDfp("-0"),"unequal",false,3);cmptst(field.newDfp("-0"),field.newDfp("0"),"unequal",false,4);cmptst(field.newDfp("0"),field.newDfp("1"),"unequal",true,5);cmptst(field.newDfp("1"),field.newDfp("0"),"unequal",true,6);cmptst(field.newDfp("-1"),field.newDfp("0"),"unequal",true,7);cmptst(field.newDfp("0"),field.newDfp("-1"),"unequal",true,8);cmptst(field.newDfp("0"),field.newDfp("1e-131072"),"unequal",true,9);if (field.getIEEEFlags()!= 0)Assert.fail("assersion failed.  compare flags = " + field.getIEEEFlags());cmptst(field.newDfp("0"),field.newDfp("1e-131078"),"unequal",true,10);if (field.getIEEEFlags()!= DfpField.FLAG_UNDERFLOW)Assert.fail("assersion failed.  compare flags = " + field.getIEEEFlags());field.clearIEEEFlags();cmptst(field.newDfp("0"),field.newDfp("1e+131071"),"unequal",true,11);cmptst(field.newDfp("0"),pinf,"unequal",true,12);cmptst(field.newDfp("0"),ninf,"unequal",true,13);cmptst(field.newDfp("-0"),pinf,"unequal",true,14);cmptst(field.newDfp("-0"),ninf,"unequal",true,15);cmptst(pinf,field.newDfp("0"),"unequal",true,16);cmptst(ninf,field.newDfp("0"),"unequal",true,17);cmptst(pinf,field.newDfp("-0"),"unequal",true,18);cmptst(ninf,field.newDfp("-0"),"unequal",true,19);cmptst(ninf,pinf,"unequal",true,19.10);cmptst(pinf,ninf,"unequal",true,19.11);cmptst(pinf,pinf,"unequal",false,19.12);cmptst(ninf,ninf,"unequal",false,19.13);cmptst(field.newDfp("1"),field.newDfp("1"),"unequal",false,20);cmptst(field.newDfp("1"),field.newDfp("-1"),"unequal",true,21);cmptst(field.newDfp("-1"),field.newDfp("-1"),"unequal",false,22);cmptst(field.newDfp("1"),field.newDfp("1.0000000000000001"),"unequal",true,23);cmptst(field.newDfp("1e20"),field.newDfp("1.0000000000000001"),"unequal",true,24);if (field.getIEEEFlags()!= 0)Assert.fail("assersion failed.  compare flags = " + field.getIEEEFlags());cmptst(field.newDfp("0.000001"),field.newDfp("1e-6"),"unequal",false,25);cmptst(snan,snan,"unequal",false,27);cmptst(qnan,qnan,"unequal",false,28);cmptst(snan,qnan,"unequal",false,29);cmptst(qnan,snan,"unequal",false,30);cmptst(qnan,field.newDfp("0"),"unequal",false,31);cmptst(snan,field.newDfp("0"),"unequal",false,32);cmptst(field.newDfp("0"),snan,"unequal",false,33);cmptst(field.newDfp("0"),qnan,"unequal",false,34);cmptst(qnan,pinf,"unequal",false,35);cmptst(snan,pinf,"unequal",false,36);cmptst(pinf,snan,"unequal",false,37);cmptst(pinf,qnan,"unequal",false,38);cmptst(qnan,ninf,"unequal",false,39);cmptst(snan,ninf,"unequal",false,40);cmptst(ninf,snan,"unequal",false,41);cmptst(ninf,qnan,"unequal",false,42);cmptst(qnan,field.newDfp("-1"),"unequal",false,43);cmptst(snan,field.newDfp("-1"),"unequal",false,44);cmptst(field.newDfp("-1"),snan,"unequal",false,45);cmptst(field.newDfp("-1"),qnan,"unequal",false,46);cmptst(qnan,field.newDfp("1"),"unequal",false,47);cmptst(snan,field.newDfp("1"),"unequal",false,48);cmptst(field.newDfp("1"),snan,"unequal",false,49);cmptst(field.newDfp("1"),qnan,"unequal",false,50);cmptst(snan.negate(),snan,"unequal",false,51);cmptst(qnan.negate(),qnan,"unequal",false,52);if (field.getIEEEFlags()!= 0)Assert.fail("assersion failed.  compare unequal flags = " + field.getIEEEFlags());cmptst(field.newDfp("0"),field.newDfp("0"),"lessThan",false,1);cmptst(field.newDfp("0"),field.newDfp("-0"),"lessThan",false,2);cmptst(field.newDfp("-0"),field.newDfp("-0"),"lessThan",false,3);cmptst(field.newDfp("-0"),field.newDfp("0"),"lessThan",false,4);cmptst(field.newDfp("0"),field.newDfp("1"),"lessThan",true,5);cmptst(field.newDfp("1"),field.newDfp("0"),"lessThan",false,6);cmptst(field.newDfp("-1"),field.newDfp("0"),"lessThan",true,7);cmptst(field.newDfp("0"),field.newDfp("-1"),"lessThan",false,8);cmptst(field.newDfp("0"),field.newDfp("1e-131072"),"lessThan",true,9);if (field.getIEEEFlags()!= 0)Assert.fail("assersion failed.  compare flags = " + field.getIEEEFlags());cmptst(field.newDfp("0"),field.newDfp("1e-131078"),"lessThan",true,10);if (field.getIEEEFlags()!= DfpField.FLAG_UNDERFLOW)Assert.fail("assersion failed.  compare flags = " + field.getIEEEFlags());field.clearIEEEFlags();cmptst(field.newDfp("0"),field.newDfp("1e+131071"),"lessThan",true,11);cmptst(field.newDfp("0"),pinf,"lessThan",true,12);cmptst(field.newDfp("0"),ninf,"lessThan",false,13);cmptst(field.newDfp("-0"),pinf,"lessThan",true,14);cmptst(field.newDfp("-0"),ninf,"lessThan",false,15);cmptst(pinf,field.newDfp("0"),"lessThan",false,16);cmptst(ninf,field.newDfp("0"),"lessThan",true,17);cmptst(pinf,field.newDfp("-0"),"lessThan",false,18);cmptst(ninf,field.newDfp("-0"),"lessThan",true,19);cmptst(ninf,pinf,"lessThan",true,19.10);cmptst(pinf,ninf,"lessThan",false,19.11);cmptst(pinf,pinf,"lessThan",false,19.12);cmptst(ninf,ninf,"lessThan",false,19.13);cmptst(field.newDfp("1"),field.newDfp("1"),"lessThan",false,20);cmptst(field.newDfp("1"),field.newDfp("-1"),"lessThan",false,21);cmptst(field.newDfp("-1"),field.newDfp("-1"),"lessThan",false,22);cmptst(field.newDfp("1"),field.newDfp("1.0000000000000001"),"lessThan",true,23);cmptst(field.newDfp("1e20"),field.newDfp("1.0000000000000001"),"lessThan",false,24);if (field.getIEEEFlags()!= 0)Assert.fail("assersion failed.  compare flags = " + field.getIEEEFlags());cmptst(field.newDfp("0.000001"),field.newDfp("1e-6"),"lessThan",false,25);cmptst(snan,snan,"lessThan",false,27);cmptst(qnan,qnan,"lessThan",false,28);cmptst(snan,qnan,"lessThan",false,29);cmptst(qnan,snan,"lessThan",false,30);cmptst(qnan,field.newDfp("0"),"lessThan",false,31);cmptst(snan,field.newDfp("0"),"lessThan",false,32);cmptst(field.newDfp("0"),snan,"lessThan",false,33);cmptst(field.newDfp("0"),qnan,"lessThan",false,34);cmptst(qnan,pinf,"lessThan",false,35);cmptst(snan,pinf,"lessThan",false,36);cmptst(pinf,snan,"lessThan",false,37);cmptst(pinf,qnan,"lessThan",false,38);cmptst(qnan,ninf,"lessThan",false,39);cmptst(snan,ninf,"lessThan",false,40);cmptst(ninf,snan,"lessThan",false,41);cmptst(ninf,qnan,"lessThan",false,42);cmptst(qnan,field.newDfp("-1"),"lessThan",false,43);cmptst(snan,field.newDfp("-1"),"lessThan",false,44);cmptst(field.newDfp("-1"),snan,"lessThan",false,45);cmptst(field.newDfp("-1"),qnan,"lessThan",false,46);cmptst(qnan,field.newDfp("1"),"lessThan",false,47);cmptst(snan,field.newDfp("1"),"lessThan",false,48);cmptst(field.newDfp("1"),snan,"lessThan",false,49);cmptst(field.newDfp("1"),qnan,"lessThan",false,50);cmptst(snan.negate(),snan,"lessThan",false,51);cmptst(qnan.negate(),qnan,"lessThan",false,52);if (field.getIEEEFlags()!= DfpField.FLAG_INVALID)Assert.fail("assersion failed.  compare lessThan flags = " + field.getIEEEFlags());field.clearIEEEFlags();cmptst(field.newDfp("0"),field.newDfp("0"),"greaterThan",false,1);cmptst(field.newDfp("0"),field.newDfp("-0"),"greaterThan",false,2);cmptst(field.newDfp("-0"),field.newDfp("-0"),"greaterThan",false,3);cmptst(field.newDfp("-0"),field.newDfp("0"),"greaterThan",false,4);cmptst(field.newDfp("0"),field.newDfp("1"),"greaterThan",false,5);cmptst(field.newDfp("1"),field.newDfp("0"),"greaterThan",true,6);cmptst(field.newDfp("-1"),field.newDfp("0"),"greaterThan",false,7);cmptst(field.newDfp("0"),field.newDfp("-1"),"greaterThan",true,8);cmptst(field.newDfp("0"),field.newDfp("1e-131072"),"greaterThan",false,9);if (field.getIEEEFlags()!= 0)Assert.fail("assersion failed.  compare flags = " + field.getIEEEFlags());cmptst(field.newDfp("0"),field.newDfp("1e-131078"),"greaterThan",false,10);if (field.getIEEEFlags()!= DfpField.FLAG_UNDERFLOW)Assert.fail("assersion failed.  compare flags = " + field.getIEEEFlags());field.clearIEEEFlags();cmptst(field.newDfp("0"),field.newDfp("1e+131071"),"greaterThan",false,11);cmptst(field.newDfp("0"),pinf,"greaterThan",false,12);cmptst(field.newDfp("0"),ninf,"greaterThan",true,13);cmptst(field.newDfp("-0"),pinf,"greaterThan",false,14);cmptst(field.newDfp("-0"),ninf,"greaterThan",true,15);cmptst(pinf,field.newDfp("0"),"greaterThan",true,16);cmptst(ninf,field.newDfp("0"),"greaterThan",false,17);cmptst(pinf,field.newDfp("-0"),"greaterThan",true,18);cmptst(ninf,field.newDfp("-0"),"greaterThan",false,19);cmptst(ninf,pinf,"greaterThan",false,19.10);cmptst(pinf,ninf,"greaterThan",true,19.11);cmptst(pinf,pinf,"greaterThan",false,19.12);cmptst(ninf,ninf,"greaterThan",false,19.13);cmptst(field.newDfp("1"),field.newDfp("1"),"greaterThan",false,20);cmptst(field.newDfp("1"),field.newDfp("-1"),"greaterThan",true,21);cmptst(field.newDfp("-1"),field.newDfp("-1"),"greaterThan",false,22);cmptst(field.newDfp("1"),field.newDfp("1.0000000000000001"),"greaterThan",false,23);cmptst(field.newDfp("1e20"),field.newDfp("1.0000000000000001"),"greaterThan",true,24);if (field.getIEEEFlags()!= 0)Assert.fail("assersion failed.  compare flags = " + field.getIEEEFlags());cmptst(field.newDfp("0.000001"),field.newDfp("1e-6"),"greaterThan",false,25);cmptst(snan,snan,"greaterThan",false,27);cmptst(qnan,qnan,"greaterThan",false,28);cmptst(snan,qnan,"greaterThan",false,29);cmptst(qnan,snan,"greaterThan",false,30);cmptst(qnan,field.newDfp("0"),"greaterThan",false,31);cmptst(snan,field.newDfp("0"),"greaterThan",false,32);cmptst(field.newDfp("0"),snan,"greaterThan",false,33);cmptst(field.newDfp("0"),qnan,"greaterThan",false,34);cmptst(qnan,pinf,"greaterThan",false,35);cmptst(snan,pinf,"greaterThan",false,36);cmptst(pinf,snan,"greaterThan",false,37);cmptst(pinf,qnan,"greaterThan",false,38);cmptst(qnan,ninf,"greaterThan",false,39);cmptst(snan,ninf,"greaterThan",false,40);cmptst(ninf,snan,"greaterThan",false,41);cmptst(ninf,qnan,"greaterThan",false,42);cmptst(qnan,field.newDfp("-1"),"greaterThan",false,43);cmptst(snan,field.newDfp("-1"),"greaterThan",false,44);cmptst(field.newDfp("-1"),snan,"greaterThan",false,45);cmptst(field.newDfp("-1"),qnan,"greaterThan",false,46);cmptst(qnan,field.newDfp("1"),"greaterThan",false,47);cmptst(snan,field.newDfp("1"),"greaterThan",false,48);cmptst(field.newDfp("1"),snan,"greaterThan",false,49);cmptst(field.newDfp("1"),qnan,"greaterThan",false,50);cmptst(snan.negate(),snan,"greaterThan",false,51);cmptst(qnan.negate(),qnan,"greaterThan",false,52);if (field.getIEEEFlags()!= DfpField.FLAG_INVALID)Assert.fail("assersion failed.  compare greaterThan flags = " + field.getIEEEFlags());field.clearIEEEFlags();}
@Test public void testMultiply(){test(field.newDfp("1").multiply(field.newDfp("1")),field.newDfp("1"),0,"Multiply #1");test(field.newDfp("1").multiply(1),field.newDfp("1"),0,"Multiply #2");test(field.newDfp("-1").multiply(field.newDfp("1")),field.newDfp("-1"),0,"Multiply #3");test(field.newDfp("-1").multiply(1),field.newDfp("-1"),0,"Multiply #4");test(field.newDfp("2").multiply(field.newDfp("3")),field.newDfp("6"),0,"Multiply #5");test(field.newDfp("2").multiply(3),field.newDfp("6"),0,"Multiply #6");test(field.newDfp("-2").multiply(field.newDfp("3")),field.newDfp("-6"),0,"Multiply #7");test(field.newDfp("-2").multiply(3),field.newDfp("-6"),0,"Multiply #8");test(field.newDfp("2").multiply(field.newDfp("-3")),field.newDfp("-6"),0,"Multiply #9");test(field.newDfp("-2").multiply(field.newDfp("-3")),field.newDfp("6"),0,"Multiply #10");test(field.newDfp("-2").multiply(field.newDfp("0")),field.newDfp("-0"),0,"Multiply #11");test(field.newDfp("-2").multiply(0),field.newDfp("-0"),0,"Multiply #12");test(field.newDfp("2").multiply(field.newDfp("0")),field.newDfp("0"),0,"Multiply #13");test(field.newDfp("2").multiply(0),field.newDfp("0"),0,"Multiply #14");test(field.newDfp("2").multiply(pinf),pinf,0,"Multiply #15");test(field.newDfp("2").multiply(ninf),ninf,0,"Multiply #16");test(field.newDfp("-2").multiply(pinf),ninf,0,"Multiply #17");test(field.newDfp("-2").multiply(ninf),pinf,0,"Multiply #18");test(ninf.multiply(field.newDfp("-2")),pinf,0,"Multiply #18.1");test(field.newDfp("5e131071").multiply(2),pinf,DfpField.FLAG_OVERFLOW,"Multiply #19");test(field.newDfp("5e131071").multiply(field.newDfp("1.999999999999999")),field.newDfp("9.9999999999999950000e131071"),0,"Multiply #20");test(field.newDfp("-5e131071").multiply(2),ninf,DfpField.FLAG_OVERFLOW,"Multiply #22");test(field.newDfp("-5e131071").multiply(field.newDfp("1.999999999999999")),field.newDfp("-9.9999999999999950000e131071"),0,"Multiply #23");test(field.newDfp("1e-65539").multiply(field.newDfp("1e-65539")),field.newDfp("1e-131078"),DfpField.FLAG_UNDERFLOW,"Multiply #24");test(field.newDfp("1").multiply(nan),nan,0,"Multiply #25");test(nan.multiply(field.newDfp("1")),nan,0,"Multiply #26");test(nan.multiply(pinf),nan,0,"Multiply #27");test(pinf.multiply(nan),nan,0,"Multiply #27");test(pinf.multiply(field.newDfp("0")),nan,DfpField.FLAG_INVALID,"Multiply #28");test(field.newDfp("0").multiply(pinf),nan,DfpField.FLAG_INVALID,"Multiply #29");test(pinf.multiply(pinf),pinf,0,"Multiply #30");test(ninf.multiply(pinf),ninf,0,"Multiply #31");test(pinf.multiply(ninf),ninf,0,"Multiply #32");test(ninf.multiply(ninf),pinf,0,"Multiply #33");test(pinf.multiply(1),pinf,0,"Multiply #34");test(pinf.multiply(0),nan,DfpField.FLAG_INVALID,"Multiply #35");test(nan.multiply(1),nan,0,"Multiply #36");test(field.newDfp("1").multiply(10000),nan,DfpField.FLAG_INVALID,"Multiply #37");test(field.newDfp("1").multiply(-1),nan,DfpField.FLAG_INVALID,"Multiply #38");}
@Test public void testDivide(){test(field.newDfp("1").divide(nan),nan,0,"Divide #1");test(nan.divide(field.newDfp("1")),nan,0,"Divide #2");test(pinf.divide(field.newDfp("1")),pinf,0,"Divide #3");test(pinf.divide(field.newDfp("-1")),ninf,0,"Divide #4");test(pinf.divide(pinf),nan,DfpField.FLAG_INVALID,"Divide #5");test(ninf.divide(pinf),nan,DfpField.FLAG_INVALID,"Divide #6");test(pinf.divide(ninf),nan,DfpField.FLAG_INVALID,"Divide #7");test(ninf.divide(ninf),nan,DfpField.FLAG_INVALID,"Divide #8");test(field.newDfp("0").divide(field.newDfp("0")),nan,DfpField.FLAG_DIV_ZERO,"Divide #9");test(field.newDfp("1").divide(field.newDfp("0")),pinf,DfpField.FLAG_DIV_ZERO,"Divide #10");test(field.newDfp("1").divide(field.newDfp("-0")),ninf,DfpField.FLAG_DIV_ZERO,"Divide #11");test(field.newDfp("-1").divide(field.newDfp("0")),ninf,DfpField.FLAG_DIV_ZERO,"Divide #12");test(field.newDfp("-1").divide(field.newDfp("-0")),pinf,DfpField.FLAG_DIV_ZERO,"Divide #13");test(field.newDfp("1").divide(field.newDfp("3")),field.newDfp("0.33333333333333333333"),DfpField.FLAG_INEXACT,"Divide #14");test(field.newDfp("1").divide(field.newDfp("6")),field.newDfp("0.16666666666666666667"),DfpField.FLAG_INEXACT,"Divide #15");test(field.newDfp("10").divide(field.newDfp("6")),field.newDfp("1.6666666666666667"),DfpField.FLAG_INEXACT,"Divide #16");test(field.newDfp("100").divide(field.newDfp("6")),field.newDfp("16.6666666666666667"),DfpField.FLAG_INEXACT,"Divide #17");test(field.newDfp("1000").divide(field.newDfp("6")),field.newDfp("166.6666666666666667"),DfpField.FLAG_INEXACT,"Divide #18");test(field.newDfp("10000").divide(field.newDfp("6")),field.newDfp("1666.6666666666666667"),DfpField.FLAG_INEXACT,"Divide #19");test(field.newDfp("1").divide(field.newDfp("1")),field.newDfp("1"),0,"Divide #20");test(field.newDfp("1").divide(field.newDfp("-1")),field.newDfp("-1"),0,"Divide #21");test(field.newDfp("-1").divide(field.newDfp("1")),field.newDfp("-1"),0,"Divide #22");test(field.newDfp("-1").divide(field.newDfp("-1")),field.newDfp("1"),0,"Divide #23");test(field.newDfp("1e-65539").divide(field.newDfp("1e65539")),field.newDfp("1e-131078"),DfpField.FLAG_UNDERFLOW,"Divide #24");test(field.newDfp("1e65539").divide(field.newDfp("1e-65539")),pinf,DfpField.FLAG_OVERFLOW,"Divide #24");test(field.newDfp("2").divide(field.newDfp("1.5")),field.newDfp("1.3333333333333333"),DfpField.FLAG_INEXACT,"Divide #25");test(field.newDfp("2").divide(pinf),field.newDfp("0"),0,"Divide #26");test(field.newDfp("2").divide(ninf),field.newDfp("-0"),0,"Divide #27");test(field.newDfp("0").divide(field.newDfp("1")),field.newDfp("0"),0,"Divide #28");}
@Test public void testReciprocal(){test(nan.reciprocal(),nan,0,"Reciprocal #1");test(field.newDfp("0").reciprocal(),pinf,DfpField.FLAG_DIV_ZERO,"Reciprocal #2");test(field.newDfp("-0").reciprocal(),ninf,DfpField.FLAG_DIV_ZERO,"Reciprocal #3");test(field.newDfp("3").reciprocal(),field.newDfp("0.33333333333333333333"),DfpField.FLAG_INEXACT,"Reciprocal #4");test(field.newDfp("6").reciprocal(),field.newDfp("0.16666666666666666667"),DfpField.FLAG_INEXACT,"Reciprocal #5");test(field.newDfp("1").reciprocal(),field.newDfp("1"),0,"Reciprocal #6");test(field.newDfp("-1").reciprocal(),field.newDfp("-1"),0,"Reciprocal #7");test(pinf.reciprocal(),field.newDfp("0"),0,"Reciprocal #8");test(ninf.reciprocal(),field.newDfp("-0"),0,"Reciprocal #9");}
@Test public void testDivideInt(){test(nan.divide(1),nan,0,"DivideInt #1");test(pinf.divide(1),pinf,0,"DivideInt #2");test(field.newDfp("0").divide(0),nan,DfpField.FLAG_DIV_ZERO,"DivideInt #3");test(field.newDfp("1").divide(0),pinf,DfpField.FLAG_DIV_ZERO,"DivideInt #4");test(field.newDfp("-1").divide(0),ninf,DfpField.FLAG_DIV_ZERO,"DivideInt #5");test(field.newDfp("1").divide(3),field.newDfp("0.33333333333333333333"),DfpField.FLAG_INEXACT,"DivideInt #6");test(field.newDfp("1").divide(6),field.newDfp("0.16666666666666666667"),DfpField.FLAG_INEXACT,"DivideInt #7");test(field.newDfp("10").divide(6),field.newDfp("1.6666666666666667"),DfpField.FLAG_INEXACT,"DivideInt #8");test(field.newDfp("100").divide(6),field.newDfp("16.6666666666666667"),DfpField.FLAG_INEXACT,"DivideInt #9");test(field.newDfp("1000").divide(6),field.newDfp("166.6666666666666667"),DfpField.FLAG_INEXACT,"DivideInt #10");test(field.newDfp("10000").divide(6),field.newDfp("1666.6666666666666667"),DfpField.FLAG_INEXACT,"DivideInt #20");test(field.newDfp("1").divide(1),field.newDfp("1"),0,"DivideInt #21");test(field.newDfp("1e-131077").divide(10),field.newDfp("1e-131078"),DfpField.FLAG_UNDERFLOW,"DivideInt #22");test(field.newDfp("0").divide(1),field.newDfp("0"),0,"DivideInt #23");test(field.newDfp("1").divide(10000),nan,DfpField.FLAG_INVALID,"DivideInt #24");test(field.newDfp("1").divide(-1),nan,DfpField.FLAG_INVALID,"DivideInt #25");}
@Test public void testNextAfter(){test(field.newDfp("1").nextAfter(pinf),field.newDfp("1.0000000000000001"),0,"NextAfter #1");test(field.newDfp("1.0000000000000001").nextAfter(ninf),field.newDfp("1"),0,"NextAfter #1.5");test(field.newDfp("1").nextAfter(ninf),field.newDfp("0.99999999999999999999"),0,"NextAfter #2");test(field.newDfp("0.99999999999999999999").nextAfter(field.newDfp("2")),field.newDfp("1"),0,"NextAfter #3");test(field.newDfp("-1").nextAfter(ninf),field.newDfp("-1.0000000000000001"),0,"NextAfter #4");test(field.newDfp("-1").nextAfter(pinf),field.newDfp("-0.99999999999999999999"),0,"NextAfter #5");test(field.newDfp("-0.99999999999999999999").nextAfter(field.newDfp("-2")),field.newDfp("-1"),0,"NextAfter #6");test(field.newDfp("2").nextAfter(field.newDfp("2")),field.newDfp("2"),0,"NextAfter #7");test(field.newDfp("0").nextAfter(field.newDfp("0")),field.newDfp("0"),0,"NextAfter #8");test(field.newDfp("-2").nextAfter(field.newDfp("-2")),field.newDfp("-2"),0,"NextAfter #9");test(field.newDfp("0").nextAfter(field.newDfp("1")),field.newDfp("1e-131092"),DfpField.FLAG_UNDERFLOW,"NextAfter #10");test(field.newDfp("0").nextAfter(field.newDfp("-1")),field.newDfp("-1e-131092"),DfpField.FLAG_UNDERFLOW,"NextAfter #11");test(field.newDfp("-1e-131092").nextAfter(pinf),field.newDfp("-0"),DfpField.FLAG_UNDERFLOW | DfpField.FLAG_INEXACT,"Next After #12");test(field.newDfp("1e-131092").nextAfter(ninf),field.newDfp("0"),DfpField.FLAG_UNDERFLOW | DfpField.FLAG_INEXACT,"Next After #13");test(field.newDfp("9.9999999999999999999e131078").nextAfter(pinf),pinf,DfpField.FLAG_OVERFLOW | DfpField.FLAG_INEXACT,"Next After #14");}
@Test public void testToString(){Assert.assertEquals("toString #1","Infinity",pinf.toString());Assert.assertEquals("toString #2","-Infinity",ninf.toString());Assert.assertEquals("toString #3","NaN",nan.toString());Assert.assertEquals("toString #4","NaN",field.newDfp((byte)1,Dfp.QNAN).toString());Assert.assertEquals("toString #5","NaN",field.newDfp((byte)1,Dfp.SNAN).toString());Assert.assertEquals("toString #6","1.2300000000000000e100",field.newDfp("1.23e100").toString());Assert.assertEquals("toString #7","-1.2300000000000000e100",field.newDfp("-1.23e100").toString());Assert.assertEquals("toString #8","12345678.1234",field.newDfp("12345678.1234").toString());Assert.assertEquals("toString #9","0.00001234",field.newDfp("0.00001234").toString());}
@Test public void testRound(){field.setRoundingMode(DfpField.RoundingMode.ROUND_DOWN);test(field.newDfp("12345678901234567890").add(field.newDfp("0.9")),field.newDfp("12345678901234567890"),DfpField.FLAG_INEXACT,"Round #1");test(field.newDfp("12345678901234567890").add(field.newDfp("0.99999999")),field.newDfp("12345678901234567890"),DfpField.FLAG_INEXACT,"Round #2");test(field.newDfp("-12345678901234567890").add(field.newDfp("-0.99999999")),field.newDfp("-12345678901234567890"),DfpField.FLAG_INEXACT,"Round #3");field.setRoundingMode(DfpField.RoundingMode.ROUND_UP);test(field.newDfp("12345678901234567890").add(field.newDfp("0.1")),field.newDfp("12345678901234567891"),DfpField.FLAG_INEXACT,"Round #4");test(field.newDfp("12345678901234567890").add(field.newDfp("0.0001")),field.newDfp("12345678901234567891"),DfpField.FLAG_INEXACT,"Round #5");test(field.newDfp("-12345678901234567890").add(field.newDfp("-0.1")),field.newDfp("-12345678901234567891"),DfpField.FLAG_INEXACT,"Round #6");test(field.newDfp("-12345678901234567890").add(field.newDfp("-0.0001")),field.newDfp("-12345678901234567891"),DfpField.FLAG_INEXACT,"Round #7");field.setRoundingMode(DfpField.RoundingMode.ROUND_HALF_UP);test(field.newDfp("12345678901234567890").add(field.newDfp("0.4999")),field.newDfp("12345678901234567890"),DfpField.FLAG_INEXACT,"Round #8");test(field.newDfp("12345678901234567890").add(field.newDfp("0.5000")),field.newDfp("12345678901234567891"),DfpField.FLAG_INEXACT,"Round #9");test(field.newDfp("-12345678901234567890").add(field.newDfp("-0.4999")),field.newDfp("-12345678901234567890"),DfpField.FLAG_INEXACT,"Round #10");test(field.newDfp("-12345678901234567890").add(field.newDfp("-0.5000")),field.newDfp("-12345678901234567891"),DfpField.FLAG_INEXACT,"Round #11");field.setRoundingMode(DfpField.RoundingMode.ROUND_HALF_DOWN);test(field.newDfp("12345678901234567890").add(field.newDfp("0.5001")),field.newDfp("12345678901234567891"),DfpField.FLAG_INEXACT,"Round #12");test(field.newDfp("12345678901234567890").add(field.newDfp("0.5000")),field.newDfp("12345678901234567890"),DfpField.FLAG_INEXACT,"Round #13");test(field.newDfp("-12345678901234567890").add(field.newDfp("-0.5001")),field.newDfp("-12345678901234567891"),DfpField.FLAG_INEXACT,"Round #14");test(field.newDfp("-12345678901234567890").add(field.newDfp("-0.5000")),field.newDfp("-12345678901234567890"),DfpField.FLAG_INEXACT,"Round #15");field.setRoundingMode(DfpField.RoundingMode.ROUND_HALF_ODD);test(field.newDfp("12345678901234567890").add(field.newDfp("0.5000")),field.newDfp("12345678901234567891"),DfpField.FLAG_INEXACT,"Round #16");test(field.newDfp("12345678901234567891").add(field.newDfp("0.5000")),field.newDfp("12345678901234567891"),DfpField.FLAG_INEXACT,"Round #17");test(field.newDfp("-12345678901234567890").add(field.newDfp("-0.5000")),field.newDfp("-12345678901234567891"),DfpField.FLAG_INEXACT,"Round #18");test(field.newDfp("-12345678901234567891").add(field.newDfp("-0.5000")),field.newDfp("-12345678901234567891"),DfpField.FLAG_INEXACT,"Round #19");field.setRoundingMode(DfpField.RoundingMode.ROUND_CEIL);test(field.newDfp("12345678901234567890").add(field.newDfp("0.0001")),field.newDfp("12345678901234567891"),DfpField.FLAG_INEXACT,"Round #20");test(field.newDfp("-12345678901234567890").add(field.newDfp("-0.9999")),field.newDfp("-12345678901234567890"),DfpField.FLAG_INEXACT,"Round #21");field.setRoundingMode(DfpField.RoundingMode.ROUND_FLOOR);test(field.newDfp("12345678901234567890").add(field.newDfp("0.9999")),field.newDfp("12345678901234567890"),DfpField.FLAG_INEXACT,"Round #22");test(field.newDfp("-12345678901234567890").add(field.newDfp("-0.0001")),field.newDfp("-12345678901234567891"),DfpField.FLAG_INEXACT,"Round #23");field.setRoundingMode(DfpField.RoundingMode.ROUND_HALF_EVEN);}
@Test public void testCeil(){test(field.newDfp("1234.0000000000000001").ceil(),field.newDfp("1235"),DfpField.FLAG_INEXACT,"Ceil #1");}
@Test public void testFloor(){test(field.newDfp("1234.9999999999999999").floor(),field.newDfp("1234"),DfpField.FLAG_INEXACT,"Floor #1");}
@Test public void testRint(){test(field.newDfp("1234.50000000001").rint(),field.newDfp("1235"),DfpField.FLAG_INEXACT,"Rint #1");test(field.newDfp("1234.5000").rint(),field.newDfp("1234"),DfpField.FLAG_INEXACT,"Rint #2");test(field.newDfp("1235.5000").rint(),field.newDfp("1236"),DfpField.FLAG_INEXACT,"Rint #3");}
@Test public void testCopySign(){test(Dfp.copysign(field.newDfp("1234."),field.newDfp("-1")),field.newDfp("-1234"),0,"CopySign #1");test(Dfp.copysign(field.newDfp("-1234."),field.newDfp("-1")),field.newDfp("-1234"),0,"CopySign #2");test(Dfp.copysign(field.newDfp("-1234."),field.newDfp("1")),field.newDfp("1234"),0,"CopySign #3");test(Dfp.copysign(field.newDfp("1234."),field.newDfp("1")),field.newDfp("1234"),0,"CopySign #4");}
@Test public void testIntValue(){Assert.assertEquals("intValue #1",1234,field.newDfp("1234").intValue());Assert.assertEquals("intValue #2",-1234,field.newDfp("-1234").intValue());Assert.assertEquals("intValue #3",1234,field.newDfp("1234.5").intValue());Assert.assertEquals("intValue #4",1235,field.newDfp("1234.500001").intValue());Assert.assertEquals("intValue #5",2147483647,field.newDfp("1e1000").intValue());Assert.assertEquals("intValue #6",-2147483648,field.newDfp("-1e1000").intValue());}
@Test public void testLog10K(){Assert.assertEquals("log10K #1",1,field.newDfp("123456").log10K());Assert.assertEquals("log10K #2",2,field.newDfp("123456789").log10K());Assert.assertEquals("log10K #3",0,field.newDfp("2").log10K());Assert.assertEquals("log10K #3",0,field.newDfp("1").log10K());Assert.assertEquals("log10K #4",-1,field.newDfp("0.1").log10K());}
@Test public void testPower10K(){Dfp d=field.newDfp();test(d.power10K(0),field.newDfp("1"),0,"Power10 #1");test(d.power10K(1),field.newDfp("10000"),0,"Power10 #2");test(d.power10K(2),field.newDfp("100000000"),0,"Power10 #3");test(d.power10K(-1),field.newDfp("0.0001"),0,"Power10 #4");test(d.power10K(-2),field.newDfp("0.00000001"),0,"Power10 #5");test(d.power10K(-3),field.newDfp("0.000000000001"),0,"Power10 #6");}
@Test public void testLog10(){Assert.assertEquals("log10 #1",1,field.newDfp("12").log10());Assert.assertEquals("log10 #2",2,field.newDfp("123").log10());Assert.assertEquals("log10 #3",3,field.newDfp("1234").log10());Assert.assertEquals("log10 #4",4,field.newDfp("12345").log10());Assert.assertEquals("log10 #5",5,field.newDfp("123456").log10());Assert.assertEquals("log10 #6",6,field.newDfp("1234567").log10());Assert.assertEquals("log10 #6",7,field.newDfp("12345678").log10());Assert.assertEquals("log10 #7",8,field.newDfp("123456789").log10());Assert.assertEquals("log10 #8",9,field.newDfp("1234567890").log10());Assert.assertEquals("log10 #9",10,field.newDfp("12345678901").log10());Assert.assertEquals("log10 #10",11,field.newDfp("123456789012").log10());Assert.assertEquals("log10 #11",12,field.newDfp("1234567890123").log10());Assert.assertEquals("log10 #12",0,field.newDfp("2").log10());Assert.assertEquals("log10 #13",0,field.newDfp("1").log10());Assert.assertEquals("log10 #14",-1,field.newDfp("0.12").log10());Assert.assertEquals("log10 #15",-2,field.newDfp("0.012").log10());}
@Test public void testPower10(){Dfp d=field.newDfp();test(d.power10(0),field.newDfp("1"),0,"Power10 #1");test(d.power10(1),field.newDfp("10"),0,"Power10 #2");test(d.power10(2),field.newDfp("100"),0,"Power10 #3");test(d.power10(3),field.newDfp("1000"),0,"Power10 #4");test(d.power10(4),field.newDfp("10000"),0,"Power10 #5");test(d.power10(5),field.newDfp("100000"),0,"Power10 #6");test(d.power10(6),field.newDfp("1000000"),0,"Power10 #7");test(d.power10(7),field.newDfp("10000000"),0,"Power10 #8");test(d.power10(8),field.newDfp("100000000"),0,"Power10 #9");test(d.power10(9),field.newDfp("1000000000"),0,"Power10 #10");test(d.power10(-1),field.newDfp(".1"),0,"Power10 #11");test(d.power10(-2),field.newDfp(".01"),0,"Power10 #12");test(d.power10(-3),field.newDfp(".001"),0,"Power10 #13");test(d.power10(-4),field.newDfp(".0001"),0,"Power10 #14");test(d.power10(-5),field.newDfp(".00001"),0,"Power10 #15");test(d.power10(-6),field.newDfp(".000001"),0,"Power10 #16");test(d.power10(-7),field.newDfp(".0000001"),0,"Power10 #17");test(d.power10(-8),field.newDfp(".00000001"),0,"Power10 #18");test(d.power10(-9),field.newDfp(".000000001"),0,"Power10 #19");test(d.power10(-10),field.newDfp(".0000000001"),0,"Power10 #20");}
@Test public void testRemainder(){test(field.newDfp("10").remainder(field.newDfp("3")),field.newDfp("1"),DfpField.FLAG_INEXACT,"Remainder #1");test(field.newDfp("9").remainder(field.newDfp("3")),field.newDfp("0"),0,"Remainder #2");test(field.newDfp("-9").remainder(field.newDfp("3")),field.newDfp("-0"),0,"Remainder #3");}
@Test public void testSqrt(){test(field.newDfp("0").sqrt(),field.newDfp("0"),0,"Sqrt #1");test(field.newDfp("-0").sqrt(),field.newDfp("-0"),0,"Sqrt #2");test(field.newDfp("1").sqrt(),field.newDfp("1"),0,"Sqrt #3");test(field.newDfp("2").sqrt(),field.newDfp("1.4142135623730950"),DfpField.FLAG_INEXACT,"Sqrt #4");test(field.newDfp("3").sqrt(),field.newDfp("1.7320508075688773"),DfpField.FLAG_INEXACT,"Sqrt #5");test(field.newDfp("5").sqrt(),field.newDfp("2.2360679774997897"),DfpField.FLAG_INEXACT,"Sqrt #6");test(field.newDfp("500").sqrt(),field.newDfp("22.3606797749978970"),DfpField.FLAG_INEXACT,"Sqrt #6.2");test(field.newDfp("50000").sqrt(),field.newDfp("223.6067977499789696"),DfpField.FLAG_INEXACT,"Sqrt #6.3");test(field.newDfp("-1").sqrt(),nan,DfpField.FLAG_INVALID,"Sqrt #7");test(pinf.sqrt(),pinf,0,"Sqrt #8");test(field.newDfp((byte)1,Dfp.QNAN).sqrt(),nan,0,"Sqrt #9");test(field.newDfp((byte)1,Dfp.SNAN).sqrt(),nan,DfpField.FLAG_INVALID,"Sqrt #9");}
@Test public void testIssue567(){DfpField field=new DfpField(100);Assert.assertEquals(0.0,field.getZero().toDouble(),Precision.SAFE_MIN);Assert.assertEquals(0.0,field.newDfp(0.0).toDouble(),Precision.SAFE_MIN);Assert.assertEquals(-1,FastMath.copySign(1,field.newDfp(-0.0).toDouble()),Precision.EPSILON);Assert.assertEquals(+1,FastMath.copySign(1,field.newDfp(+0.0).toDouble()),Precision.EPSILON);}
@Test public void testIsZero(){Assert.assertTrue(field.getZero().isZero());Assert.assertTrue(field.getZero().negate().isZero());Assert.assertTrue(field.newDfp(+0.0).isZero());Assert.assertTrue(field.newDfp(-0.0).isZero());Assert.assertFalse(field.newDfp(1.0e-90).isZero());Assert.assertFalse(nan.isZero());Assert.assertFalse(nan.negate().isZero());Assert.assertFalse(pinf.isZero());Assert.assertFalse(pinf.negate().isZero());Assert.assertFalse(ninf.isZero());Assert.assertFalse(ninf.negate().isZero());}
@Test public void testSignPredicates(){Assert.assertTrue(field.getZero().negativeOrNull());Assert.assertTrue(field.getZero().positiveOrNull());Assert.assertFalse(field.getZero().strictlyNegative());Assert.assertFalse(field.getZero().strictlyPositive());Assert.assertTrue(field.getZero().negate().negativeOrNull());Assert.assertTrue(field.getZero().negate().positiveOrNull());Assert.assertFalse(field.getZero().negate().strictlyNegative());Assert.assertFalse(field.getZero().negate().strictlyPositive());Assert.assertFalse(field.getOne().negativeOrNull());Assert.assertTrue(field.getOne().positiveOrNull());Assert.assertFalse(field.getOne().strictlyNegative());Assert.assertTrue(field.getOne().strictlyPositive());Assert.assertTrue(field.getOne().negate().negativeOrNull());Assert.assertFalse(field.getOne().negate().positiveOrNull());Assert.assertTrue(field.getOne().negate().strictlyNegative());Assert.assertFalse(field.getOne().negate().strictlyPositive());Assert.assertFalse(nan.negativeOrNull());Assert.assertFalse(nan.positiveOrNull());Assert.assertFalse(nan.strictlyNegative());Assert.assertFalse(nan.strictlyPositive());Assert.assertFalse(nan.negate().negativeOrNull());Assert.assertFalse(nan.negate().positiveOrNull());Assert.assertFalse(nan.negate().strictlyNegative());Assert.assertFalse(nan.negate().strictlyPositive());Assert.assertFalse(pinf.negativeOrNull());Assert.assertTrue(pinf.positiveOrNull());Assert.assertFalse(pinf.strictlyNegative());Assert.assertTrue(pinf.strictlyPositive());Assert.assertTrue(pinf.negate().negativeOrNull());Assert.assertFalse(pinf.negate().positiveOrNull());Assert.assertTrue(pinf.negate().strictlyNegative());Assert.assertFalse(pinf.negate().strictlyPositive());Assert.assertTrue(ninf.negativeOrNull());Assert.assertFalse(ninf.positiveOrNull());Assert.assertTrue(ninf.strictlyNegative());Assert.assertFalse(ninf.strictlyPositive());Assert.assertFalse(ninf.negate().negativeOrNull());Assert.assertTrue(ninf.negate().positiveOrNull());Assert.assertFalse(ninf.negate().strictlyNegative());Assert.assertTrue(ninf.negate().strictlyPositive());}
@Test public void testName(){RotationOrder[]orders={RotationOrder.XYZ,RotationOrder.XZY,RotationOrder.YXZ,RotationOrder.YZX,RotationOrder.ZXY,RotationOrder.ZYX,RotationOrder.XYX,RotationOrder.XZX,RotationOrder.YXY,RotationOrder.YZY,RotationOrder.ZXZ,RotationOrder.ZYZ};for (int i=0;i < orders.length;++i){Assert.assertEquals(getFieldName(orders[i]),orders[i].toString());}}
/** * @see <a href="http://issues.apache.org/bugzilla/show_bug.cgi?id=27243">*      Bug report that prompted this unit test.</a>*/@Test public void testCumulativeProbabilityAgainstStackOverflow()throws Exception {TDistribution td=new TDistribution(5.);td.cumulativeProbability(.1);td.cumulativeProbability(.01);}
@Test public void testSmallDf()throws Exception {setDistribution(new TDistribution(1d));setCumulativeTestPoints(new double[]{-318.308838986,-31.8205159538,-12.7062047362,-6.31375151468,-3.07768353718,318.308838986,31.8205159538,12.7062047362,6.31375151468,3.07768353718});setDensityTestValues(new double[]{3.14158231817e-06,0.000314055924703,0.00195946145194,0.00778959736375,0.0303958893917,3.14158231817e-06,0.000314055924703,0.00195946145194,0.00778959736375,0.0303958893917});setInverseCumulativeTestValues(getCumulativeTestPoints());verifyCumulativeProbabilities();verifyInverseCumulativeProbabilities();verifyDensities();}
@Test public void testInverseCumulativeProbabilityExtremes()throws Exception {setInverseCumulativeTestPoints(new double[]{0,1});setInverseCumulativeTestValues(new double[]{Double.NEGATIVE_INFINITY,Double.POSITIVE_INFINITY});verifyInverseCumulativeProbabilities();}
@Test public void testDfAccessors(){TDistribution dist=(TDistribution)getDistribution();Assert.assertEquals(5d,dist.getDegreesOfFreedom(),Double.MIN_VALUE);}
@Test(expected=NotStrictlyPositiveException.class)public void testPreconditions(){new TDistribution(0);}
@Test public void testMoments(){final double tol=1e-9;TDistribution dist;dist=new TDistribution(1);Assert.assertTrue(Double.isNaN(dist.getNumericalMean()));Assert.assertTrue(Double.isNaN(dist.getNumericalVariance()));dist=new TDistribution(1.5);Assert.assertEquals(dist.getNumericalMean(),0,tol);Assert.assertTrue(Double.isInfinite(dist.getNumericalVariance()));dist=new TDistribution(5);Assert.assertEquals(dist.getNumericalMean(),0,tol);Assert.assertEquals(dist.getNumericalVariance(),5d / (5d - 2d),tol);}
@Test public void nistData(){double[]prob=new double[]{0.10,0.05,0.025,0.01,0.005,0.001};double[]args2=new double[]{1.886,2.920,4.303,6.965,9.925,22.327};double[]args10=new double[]{1.372,1.812,2.228,2.764,3.169,4.143};double[]args30=new double[]{1.310,1.697,2.042,2.457,2.750,3.385};double[]args100=new double[]{1.290,1.660,1.984,2.364,2.626,3.174};TestUtils.assertEquals(prob,makeNistResults(args2,2),1.0e-4);TestUtils.assertEquals(prob,makeNistResults(args10,10),1.0e-4);TestUtils.assertEquals(prob,makeNistResults(args30,30),1.0e-4);TestUtils.assertEquals(prob,makeNistResults(args100,100),1.0e-4);return;}
/** * Verifies that cumulative probability density calculations match expected values using default test instance data*/@Test public void testCumulativeProbabilities()throws Exception {verifyCumulativeProbabilities();}
/** * Verifies that inverse cumulative probability density calculations match expected values using default test instance data*/@Test public void testInverseCumulativeProbabilities()throws Exception {verifyInverseCumulativeProbabilities();}
/** * Verifies that density calculations return expected values for default test instance data*/@Test public void testDensities()throws Exception {verifyDensities();}
/** * Verifies that probability computations are consistent*/@Test public void testConsistency()throws Exception {for (int i=1;i < cumulativeTestPoints.length;i++){TestUtils.assertEquals(0d,distribution.cumulativeProbability(cumulativeTestPoints[i],cumulativeTestPoints[i]),tolerance);double upper=FastMath.max(cumulativeTestPoints[i],cumulativeTestPoints[i - 1]);double lower=FastMath.min(cumulativeTestPoints[i],cumulativeTestPoints[i - 1]);double diff=distribution.cumulativeProbability(upper)- distribution.cumulativeProbability(lower);double direct=distribution.cumulativeProbability(lower,upper);TestUtils.assertEquals("Inconsistent cumulative probabilities for (" + lower + ","+ upper+ ")",diff,direct,tolerance);}}
/** * Verifies that illegal arguments are correctly handled*/@Test public void testIllegalArguments()throws Exception {try {distribution.cumulativeProbability(1,0);Assert.fail("Expecting MathIllegalArgumentException for bad cumulativeProbability interval");}catch(MathIllegalArgumentException ex){}try {distribution.inverseCumulativeProbability(-1);Assert.fail("Expecting MathIllegalArgumentException for p = -1");}catch(MathIllegalArgumentException ex){}try {distribution.inverseCumulativeProbability(2);Assert.fail("Expecting MathIllegalArgumentException for p = 2");}catch(MathIllegalArgumentException ex){}}
/** * Test sampling*/@Test public void testSampling()throws Exception {AbstractContinuousDistribution dist=(AbstractContinuousDistribution)makeDistribution();final int sampleSize=1000;dist.reseedRandomGenerator(1000);double[]sample=dist.sample(sampleSize);double[]quartiles=TestUtils.getDistributionQuartiles(dist);double[]expected={250,250,250,250};long[]counts=new long[4];for (int i=0;i < sampleSize;i++){TestUtils.updateCounts(sample[i],counts,quartiles);}TestUtils.assertChiSquareAccept(expected,counts,0.001);}
@Test public void testSinZero(){UnivariateFunction f=new SinFunction();double result;UnivariateRealSolver solver=new BrentSolver();result=solver.solve(100,f,3,4);Assert.assertEquals(result,FastMath.PI,solver.getAbsoluteAccuracy());Assert.assertTrue(solver.getEvaluations()<= 7);result=solver.solve(100,f,1,4);Assert.assertEquals(result,FastMath.PI,solver.getAbsoluteAccuracy());Assert.assertTrue(solver.getEvaluations()<= 8);}
@Test public void testQuinticZero(){UnivariateFunction f=new QuinticFunction();double result;UnivariateRealSolver solver=new BrentSolver();result=solver.solve(100,f,-0.2,0.2);Assert.assertEquals(result,0,solver.getAbsoluteAccuracy());Assert.assertTrue(solver.getEvaluations()<= 3);result=solver.solve(100,f,-0.1,0.3);Assert.assertEquals(result,0,solver.getAbsoluteAccuracy());Assert.assertTrue(solver.getEvaluations()<= 7);result=solver.solve(100,f,-0.3,0.45);Assert.assertEquals(result,0,solver.getAbsoluteAccuracy());Assert.assertTrue(solver.getEvaluations()<= 8);result=solver.solve(100,f,0.3,0.7);Assert.assertEquals(result,0.5,solver.getAbsoluteAccuracy());Assert.assertTrue(solver.getEvaluations()<= 9);result=solver.solve(100,f,0.2,0.6);Assert.assertEquals(result,0.5,solver.getAbsoluteAccuracy());Assert.assertTrue(solver.getEvaluations()<= 10);result=solver.solve(100,f,0.05,0.95);Assert.assertEquals(result,0.5,solver.getAbsoluteAccuracy());Assert.assertTrue(solver.getEvaluations()<= 11);result=solver.solve(100,f,0.85,1.25);Assert.assertEquals(result,1.0,solver.getAbsoluteAccuracy());Assert.assertTrue(solver.getEvaluations()<= 11);result=solver.solve(100,f,0.8,1.2);Assert.assertEquals(result,1.0,solver.getAbsoluteAccuracy());Assert.assertTrue(solver.getEvaluations()<= 11);result=solver.solve(100,f,0.85,1.75);Assert.assertEquals(result,1.0,solver.getAbsoluteAccuracy());Assert.assertTrue(solver.getEvaluations()<= 13);result=solver.solve(100,f,0.55,1.45);Assert.assertEquals(result,1.0,solver.getAbsoluteAccuracy());Assert.assertTrue(solver.getEvaluations()<= 10);result=solver.solve(100,f,0.85,5);Assert.assertEquals(result,1.0,solver.getAbsoluteAccuracy());Assert.assertTrue(solver.getEvaluations()<= 15);try {result=solver.solve(5,f,0.85,5);Assert.fail("Expected TooManyEvaluationsException");}catch(TooManyEvaluationsException e){}}
@Test public void testRootEndpoints(){UnivariateFunction f=new SinFunction();BrentSolver solver=new BrentSolver();double result=solver.solve(100,f,FastMath.PI,4);Assert.assertEquals(FastMath.PI,result,solver.getAbsoluteAccuracy());result=solver.solve(100,f,3,FastMath.PI);Assert.assertEquals(FastMath.PI,result,solver.getAbsoluteAccuracy());result=solver.solve(100,f,FastMath.PI,4,3.5);Assert.assertEquals(FastMath.PI,result,solver.getAbsoluteAccuracy());result=solver.solve(100,f,3,FastMath.PI,3.07);Assert.assertEquals(FastMath.PI,result,solver.getAbsoluteAccuracy());}
@Test public void testBadEndpoints(){UnivariateFunction f=new SinFunction();BrentSolver solver=new BrentSolver();try {solver.solve(100,f,1,-1);Assert.fail("Expecting NumberIsTooLargeException - bad interval");}catch(NumberIsTooLargeException ex){}try {solver.solve(100,f,1,1.5);Assert.fail("Expecting NoBracketingException - non-bracketing");}catch(NoBracketingException ex){}try {solver.solve(100,f,1,1.5,1.2);Assert.fail("Expecting NoBracketingException - non-bracketing");}catch(NoBracketingException ex){}}
@Test public void testInitialGuess(){MonitoredFunction f=new MonitoredFunction(new QuinticFunction());BrentSolver solver=new BrentSolver();double result;result=solver.solve(100,f,0.6,7.0);Assert.assertEquals(result,1.0,solver.getAbsoluteAccuracy());int referenceCallsCount=f.getCallsCount();Assert.assertTrue(referenceCallsCount >= 13);try {result=solver.solve(100,f,0.6,7.0,0.0);Assert.fail("a NumberIsTooLargeException was expected");}catch(NumberIsTooLargeException iae){}f.setCallsCount(0);result=solver.solve(100,f,0.6,7.0,0.61);Assert.assertEquals(result,1.0,solver.getAbsoluteAccuracy());Assert.assertTrue(f.getCallsCount()> referenceCallsCount);f.setCallsCount(0);result=solver.solve(100,f,0.6,7.0,0.999999);Assert.assertEquals(result,1.0,solver.getAbsoluteAccuracy());Assert.assertTrue(f.getCallsCount()< referenceCallsCount);f.setCallsCount(0);result=solver.solve(100,f,0.6,7.0,1.0);Assert.assertEquals(result,1.0,solver.getAbsoluteAccuracy());Assert.assertEquals(1,solver.getEvaluations());Assert.assertEquals(1,f.getCallsCount());}
@Test public void testConstructor(){Complex z=new Complex(3.0,4.0);Assert.assertEquals(3.0,z.getReal(),1.0e-5);Assert.assertEquals(4.0,z.getImaginary(),1.0e-5);}
@Test public void testConstructorNaN(){Complex z=new Complex(3.0,Double.NaN);Assert.assertTrue(z.isNaN());z=new Complex(nan,4.0);Assert.assertTrue(z.isNaN());z=new Complex(3.0,4.0);Assert.assertFalse(z.isNaN());}
@Test public void testAbs(){Complex z=new Complex(3.0,4.0);Assert.assertEquals(5.0,z.abs(),1.0e-5);}
@Test public void testAbsNaN(){Assert.assertTrue(Double.isNaN(Complex.NaN.abs()));Complex z=new Complex(inf,nan);Assert.assertTrue(Double.isNaN(z.abs()));}
@Test public void testAbsInfinite(){Complex z=new Complex(inf,0);Assert.assertEquals(inf,z.abs(),0);z=new Complex(0,neginf);Assert.assertEquals(inf,z.abs(),0);z=new Complex(inf,neginf);Assert.assertEquals(inf,z.abs(),0);}
@Test public void testAdd(){Complex x=new Complex(3.0,4.0);Complex y=new Complex(5.0,6.0);Complex z=x.add(y);Assert.assertEquals(8.0,z.getReal(),1.0e-5);Assert.assertEquals(10.0,z.getImaginary(),1.0e-5);}
@Test public void testAddNaN(){Complex x=new Complex(3.0,4.0);Complex z=x.add(Complex.NaN);Assert.assertSame(Complex.NaN,z);z=new Complex(1,nan);Complex w=x.add(z);Assert.assertSame(Complex.NaN,w);}
@Test public void testAddInf(){Complex x=new Complex(1,1);Complex z=new Complex(inf,0);Complex w=x.add(z);Assert.assertEquals(w.getImaginary(),1,0);Assert.assertEquals(inf,w.getReal(),0);x=new Complex(neginf,0);Assert.assertTrue(Double.isNaN(x.add(z).getReal()));}
@Test public void testScalarAdd(){Complex x=new Complex(3.0,4.0);double yDouble=2.0;Complex yComplex=new Complex(yDouble);Assert.assertEquals(x.add(yComplex),x.add(yDouble));}
@Test public void testScalarAddNaN(){Complex x=new Complex(3.0,4.0);double yDouble=Double.NaN;Complex yComplex=new Complex(yDouble);Assert.assertEquals(x.add(yComplex),x.add(yDouble));}
@Test public void testScalarAddInf(){Complex x=new Complex(1,1);double yDouble=Double.POSITIVE_INFINITY;Complex yComplex=new Complex(yDouble);Assert.assertEquals(x.add(yComplex),x.add(yDouble));x=new Complex(neginf,0);Assert.assertEquals(x.add(yComplex),x.add(yDouble));}
@Test public void testConjugate(){Complex x=new Complex(3.0,4.0);Complex z=x.conjugate();Assert.assertEquals(3.0,z.getReal(),1.0e-5);Assert.assertEquals(-4.0,z.getImaginary(),1.0e-5);}
@Test public void testConjugateNaN(){Complex z=Complex.NaN.conjugate();Assert.assertTrue(z.isNaN());}
@Test public void testConjugateInfiinite(){Complex z=new Complex(0,inf);Assert.assertEquals(neginf,z.conjugate().getImaginary(),0);z=new Complex(0,neginf);Assert.assertEquals(inf,z.conjugate().getImaginary(),0);}
@Test public void testDivide(){Complex x=new Complex(3.0,4.0);Complex y=new Complex(5.0,6.0);Complex z=x.divide(y);Assert.assertEquals(39.0 / 61.0,z.getReal(),1.0e-5);Assert.assertEquals(2.0 / 61.0,z.getImaginary(),1.0e-5);}
@Test public void testDivideReal(){Complex x=new Complex(2d,3d);Complex y=new Complex(2d,0d);Assert.assertEquals(new Complex(1d,1.5),x.divide(y));}
@Test public void testDivideImaginary(){Complex x=new Complex(2d,3d);Complex y=new Complex(0d,2d);Assert.assertEquals(new Complex(1.5d,-1d),x.divide(y));}
@Test public void testDivideInf(){Complex x=new Complex(3,4);Complex w=new Complex(neginf,inf);Assert.assertTrue(x.divide(w).equals(Complex.ZERO));Complex z=w.divide(x);Assert.assertTrue(Double.isNaN(z.getReal()));Assert.assertEquals(inf,z.getImaginary(),0);w=new Complex(inf,inf);z=w.divide(x);Assert.assertTrue(Double.isNaN(z.getImaginary()));Assert.assertEquals(inf,z.getReal(),0);w=new Complex(1,inf);z=w.divide(w);Assert.assertTrue(Double.isNaN(z.getReal()));Assert.assertTrue(Double.isNaN(z.getImaginary()));}
@Test public void testDivideZero(){Complex x=new Complex(3.0,4.0);Complex z=x.divide(Complex.ZERO);Assert.assertEquals(z,Complex.NaN);}
@Test public void testDivideZeroZero(){Complex x=new Complex(0.0,0.0);Complex z=x.divide(Complex.ZERO);Assert.assertEquals(z,Complex.NaN);}
@Test public void testDivideNaN(){Complex x=new Complex(3.0,4.0);Complex z=x.divide(Complex.NaN);Assert.assertTrue(z.isNaN());}
@Test public void testDivideNaNInf(){Complex z=oneInf.divide(Complex.ONE);Assert.assertTrue(Double.isNaN(z.getReal()));Assert.assertEquals(inf,z.getImaginary(),0);z=negInfNegInf.divide(oneNaN);Assert.assertTrue(Double.isNaN(z.getReal()));Assert.assertTrue(Double.isNaN(z.getImaginary()));z=negInfInf.divide(Complex.ONE);Assert.assertTrue(Double.isNaN(z.getReal()));Assert.assertTrue(Double.isNaN(z.getImaginary()));}
@Test public void testScalarDivide(){Complex x=new Complex(3.0,4.0);double yDouble=2.0;Complex yComplex=new Complex(yDouble);Assert.assertEquals(x.divide(yComplex),x.divide(yDouble));}
@Test public void testScalarDivideNaN(){Complex x=new Complex(3.0,4.0);double yDouble=Double.NaN;Complex yComplex=new Complex(yDouble);Assert.assertEquals(x.divide(yComplex),x.divide(yDouble));}
@Test public void testScalarDivideInf(){Complex x=new Complex(1,1);double yDouble=Double.POSITIVE_INFINITY;Complex yComplex=new Complex(yDouble);TestUtils.assertEquals(x.divide(yComplex),x.divide(yDouble),0);yDouble=Double.NEGATIVE_INFINITY;yComplex=new Complex(yDouble);TestUtils.assertEquals(x.divide(yComplex),x.divide(yDouble),0);x=new Complex(1,Double.NEGATIVE_INFINITY);TestUtils.assertEquals(x.divide(yComplex),x.divide(yDouble),0);}
@Test public void testScalarDivideZero(){Complex x=new Complex(1,1);TestUtils.assertEquals(x.divide(Complex.ZERO),x.divide(0),0);}
@Test public void testReciprocal(){Complex z=new Complex(5.0,6.0);Complex act=z.reciprocal();double expRe=5.0 / 61.0;double expIm=-6.0 / 61.0;Assert.assertEquals(expRe,act.getReal(),FastMath.ulp(expRe));Assert.assertEquals(expIm,act.getImaginary(),FastMath.ulp(expIm));}
@Test public void testReciprocalReal(){Complex z=new Complex(-2.0,0.0);Assert.assertEquals(new Complex(-0.5,0.0),z.reciprocal());}
@Test public void testReciprocalImaginary(){Complex z=new Complex(0.0,-2.0);Assert.assertEquals(new Complex(0.0,0.5),z.reciprocal());}
@Test public void testReciprocalInf(){Complex z=new Complex(neginf,inf);Assert.assertTrue(z.reciprocal().equals(Complex.ZERO));z=new Complex(1,inf).reciprocal();Assert.assertEquals(z,Complex.ZERO);}
@Test public void testReciprocalZero(){Assert.assertEquals(Complex.ZERO.reciprocal(),Complex.NaN);}
@Test public void testReciprocalNaN(){Assert.assertTrue(Complex.NaN.reciprocal().isNaN());}
@Test public void testMultiply(){Complex x=new Complex(3.0,4.0);Complex y=new Complex(5.0,6.0);Complex z=x.multiply(y);Assert.assertEquals(-9.0,z.getReal(),1.0e-5);Assert.assertEquals(38.0,z.getImaginary(),1.0e-5);}
@Test public void testMultiplyNaN(){Complex x=new Complex(3.0,4.0);Complex z=x.multiply(Complex.NaN);Assert.assertSame(Complex.NaN,z);z=Complex.NaN.multiply(5);Assert.assertSame(Complex.NaN,z);}
@Test public void testMultiplyInfInf(){Assert.assertTrue(infInf.multiply(infInf).isInfinite());}
@Test public void testMultiplyNaNInf(){Complex z=new Complex(1,1);Complex w=z.multiply(infOne);Assert.assertEquals(w.getReal(),inf,0);Assert.assertEquals(w.getImaginary(),inf,0);Assert.assertTrue(new Complex(1,0).multiply(infInf).equals(Complex.INF));Assert.assertTrue(new Complex(-1,0).multiply(infInf).equals(Complex.INF));Assert.assertTrue(new Complex(1,0).multiply(negInfZero).equals(Complex.INF));w=oneInf.multiply(oneNegInf);Assert.assertEquals(w.getReal(),inf,0);Assert.assertEquals(w.getImaginary(),inf,0);w=negInfNegInf.multiply(oneNaN);Assert.assertTrue(Double.isNaN(w.getReal()));Assert.assertTrue(Double.isNaN(w.getImaginary()));z=new Complex(1,neginf);Assert.assertSame(Complex.INF,z.multiply(z));}
@Test public void testScalarMultiply(){Complex x=new Complex(3.0,4.0);double yDouble=2.0;Complex yComplex=new Complex(yDouble);Assert.assertEquals(x.multiply(yComplex),x.multiply(yDouble));int zInt=-5;Complex zComplex=new Complex(zInt);Assert.assertEquals(x.multiply(zComplex),x.multiply(zInt));}
@Test public void testScalarMultiplyNaN(){Complex x=new Complex(3.0,4.0);double yDouble=Double.NaN;Complex yComplex=new Complex(yDouble);Assert.assertEquals(x.multiply(yComplex),x.multiply(yDouble));}
@Test public void testScalarMultiplyInf(){Complex x=new Complex(1,1);double yDouble=Double.POSITIVE_INFINITY;Complex yComplex=new Complex(yDouble);Assert.assertEquals(x.multiply(yComplex),x.multiply(yDouble));yDouble=Double.NEGATIVE_INFINITY;yComplex=new Complex(yDouble);Assert.assertEquals(x.multiply(yComplex),x.multiply(yDouble));}
@Test public void testNegate(){Complex x=new Complex(3.0,4.0);Complex z=x.negate();Assert.assertEquals(-3.0,z.getReal(),1.0e-5);Assert.assertEquals(-4.0,z.getImaginary(),1.0e-5);}
@Test public void testNegateNaN(){Complex z=Complex.NaN.negate();Assert.assertTrue(z.isNaN());}
@Test public void testSubtract(){Complex x=new Complex(3.0,4.0);Complex y=new Complex(5.0,6.0);Complex z=x.subtract(y);Assert.assertEquals(-2.0,z.getReal(),1.0e-5);Assert.assertEquals(-2.0,z.getImaginary(),1.0e-5);}
@Test public void testSubtractNaN(){Complex x=new Complex(3.0,4.0);Complex z=x.subtract(Complex.NaN);Assert.assertSame(Complex.NaN,z);z=new Complex(1,nan);Complex w=x.subtract(z);Assert.assertSame(Complex.NaN,w);}
@Test public void testSubtractInf(){Complex x=new Complex(1,1);Complex z=new Complex(neginf,0);Complex w=x.subtract(z);Assert.assertEquals(w.getImaginary(),1,0);Assert.assertEquals(inf,w.getReal(),0);x=new Complex(neginf,0);Assert.assertTrue(Double.isNaN(x.subtract(z).getReal()));}
@Test public void testScalarSubtract(){Complex x=new Complex(3.0,4.0);double yDouble=2.0;Complex yComplex=new Complex(yDouble);Assert.assertEquals(x.subtract(yComplex),x.subtract(yDouble));}
@Test public void testScalarSubtractNaN(){Complex x=new Complex(3.0,4.0);double yDouble=Double.NaN;Complex yComplex=new Complex(yDouble);Assert.assertEquals(x.subtract(yComplex),x.subtract(yDouble));}
@Test public void testScalarSubtractInf(){Complex x=new Complex(1,1);double yDouble=Double.POSITIVE_INFINITY;Complex yComplex=new Complex(yDouble);Assert.assertEquals(x.subtract(yComplex),x.subtract(yDouble));x=new Complex(neginf,0);Assert.assertEquals(x.subtract(yComplex),x.subtract(yDouble));}
@Test public void testEqualsNull(){Complex x=new Complex(3.0,4.0);Assert.assertFalse(x.equals(null));}
@Test public void testEqualsClass(){Complex x=new Complex(3.0,4.0);Assert.assertFalse(x.equals(this));}
@Test public void testEqualsSame(){Complex x=new Complex(3.0,4.0);Assert.assertTrue(x.equals(x));}
@Test public void testEqualsTrue(){Complex x=new Complex(3.0,4.0);Complex y=new Complex(3.0,4.0);Assert.assertTrue(x.equals(y));}
@Test public void testEqualsRealDifference(){Complex x=new Complex(0.0,0.0);Complex y=new Complex(0.0 + Double.MIN_VALUE,0.0);Assert.assertFalse(x.equals(y));}
@Test public void testEqualsImaginaryDifference(){Complex x=new Complex(0.0,0.0);Complex y=new Complex(0.0,0.0 + Double.MIN_VALUE);Assert.assertFalse(x.equals(y));}
@Test public void testEqualsNaN(){Complex realNaN=new Complex(Double.NaN,0.0);Complex imaginaryNaN=new Complex(0.0,Double.NaN);Complex complexNaN=Complex.NaN;Assert.assertTrue(realNaN.equals(imaginaryNaN));Assert.assertTrue(imaginaryNaN.equals(complexNaN));Assert.assertTrue(realNaN.equals(complexNaN));}
@Test public void testHashCode(){Complex x=new Complex(0.0,0.0);Complex y=new Complex(0.0,0.0 + Double.MIN_VALUE);Assert.assertFalse(x.hashCode()== y.hashCode());y=new Complex(0.0 + Double.MIN_VALUE,0.0);Assert.assertFalse(x.hashCode()== y.hashCode());Complex realNaN=new Complex(Double.NaN,0.0);Complex imaginaryNaN=new Complex(0.0,Double.NaN);Assert.assertEquals(realNaN.hashCode(),imaginaryNaN.hashCode());Assert.assertEquals(imaginaryNaN.hashCode(),Complex.NaN.hashCode());}
@Test public void testAcos(){Complex z=new Complex(3,4);Complex expected=new Complex(0.936812,-2.30551);TestUtils.assertEquals(expected,z.acos(),1.0e-5);TestUtils.assertEquals(new Complex(FastMath.acos(0),0),Complex.ZERO.acos(),1.0e-12);}
@Test public void testAcosInf(){TestUtils.assertSame(Complex.NaN,oneInf.acos());TestUtils.assertSame(Complex.NaN,oneNegInf.acos());TestUtils.assertSame(Complex.NaN,infOne.acos());TestUtils.assertSame(Complex.NaN,negInfOne.acos());TestUtils.assertSame(Complex.NaN,infInf.acos());TestUtils.assertSame(Complex.NaN,infNegInf.acos());TestUtils.assertSame(Complex.NaN,negInfInf.acos());TestUtils.assertSame(Complex.NaN,negInfNegInf.acos());}
@Test public void testAcosNaN(){Assert.assertTrue(Complex.NaN.acos().isNaN());}
@Test public void testAsin(){Complex z=new Complex(3,4);Complex expected=new Complex(0.633984,2.30551);TestUtils.assertEquals(expected,z.asin(),1.0e-5);}
@Test public void testAsinNaN(){Assert.assertTrue(Complex.NaN.asin().isNaN());}
@Test public void testAsinInf(){TestUtils.assertSame(Complex.NaN,oneInf.asin());TestUtils.assertSame(Complex.NaN,oneNegInf.asin());TestUtils.assertSame(Complex.NaN,infOne.asin());TestUtils.assertSame(Complex.NaN,negInfOne.asin());TestUtils.assertSame(Complex.NaN,infInf.asin());TestUtils.assertSame(Complex.NaN,infNegInf.asin());TestUtils.assertSame(Complex.NaN,negInfInf.asin());TestUtils.assertSame(Complex.NaN,negInfNegInf.asin());}
@Test public void testAtan(){Complex z=new Complex(3,4);Complex expected=new Complex(1.44831,0.158997);TestUtils.assertEquals(expected,z.atan(),1.0e-5);}
@Test public void testAtanInf(){TestUtils.assertSame(Complex.NaN,oneInf.atan());TestUtils.assertSame(Complex.NaN,oneNegInf.atan());TestUtils.assertSame(Complex.NaN,infOne.atan());TestUtils.assertSame(Complex.NaN,negInfOne.atan());TestUtils.assertSame(Complex.NaN,infInf.atan());TestUtils.assertSame(Complex.NaN,infNegInf.atan());TestUtils.assertSame(Complex.NaN,negInfInf.atan());TestUtils.assertSame(Complex.NaN,negInfNegInf.atan());}
@Test public void testAtanI(){Assert.assertTrue(Complex.I.atan().isNaN());}
@Test public void testAtanNaN(){Assert.assertTrue(Complex.NaN.atan().isNaN());}
@Test public void testCos(){Complex z=new Complex(3,4);Complex expected=new Complex(-27.03495,-3.851153);TestUtils.assertEquals(expected,z.cos(),1.0e-5);}
@Test public void testCosNaN(){Assert.assertTrue(Complex.NaN.cos().isNaN());}
@Test public void testCosInf(){TestUtils.assertSame(infNegInf,oneInf.cos());TestUtils.assertSame(infInf,oneNegInf.cos());TestUtils.assertSame(Complex.NaN,infOne.cos());TestUtils.assertSame(Complex.NaN,negInfOne.cos());TestUtils.assertSame(Complex.NaN,infInf.cos());TestUtils.assertSame(Complex.NaN,infNegInf.cos());TestUtils.assertSame(Complex.NaN,negInfInf.cos());TestUtils.assertSame(Complex.NaN,negInfNegInf.cos());}
@Test public void testCosh(){Complex z=new Complex(3,4);Complex expected=new Complex(-6.58066,-7.58155);TestUtils.assertEquals(expected,z.cosh(),1.0e-5);}
@Test public void testCoshNaN(){Assert.assertTrue(Complex.NaN.cosh().isNaN());}
@Test public void testCoshInf(){TestUtils.assertSame(Complex.NaN,oneInf.cosh());TestUtils.assertSame(Complex.NaN,oneNegInf.cosh());TestUtils.assertSame(infInf,infOne.cosh());TestUtils.assertSame(infNegInf,negInfOne.cosh());TestUtils.assertSame(Complex.NaN,infInf.cosh());TestUtils.assertSame(Complex.NaN,infNegInf.cosh());TestUtils.assertSame(Complex.NaN,negInfInf.cosh());TestUtils.assertSame(Complex.NaN,negInfNegInf.cosh());}
@Test public void testExp(){Complex z=new Complex(3,4);Complex expected=new Complex(-13.12878,-15.20078);TestUtils.assertEquals(expected,z.exp(),1.0e-5);TestUtils.assertEquals(Complex.ONE,Complex.ZERO.exp(),10e-12);Complex iPi=Complex.I.multiply(new Complex(pi,0));TestUtils.assertEquals(Complex.ONE.negate(),iPi.exp(),10e-12);}
@Test public void testExpNaN(){Assert.assertTrue(Complex.NaN.exp().isNaN());}
@Test public void testExpInf(){TestUtils.assertSame(Complex.NaN,oneInf.exp());TestUtils.assertSame(Complex.NaN,oneNegInf.exp());TestUtils.assertSame(infInf,infOne.exp());TestUtils.assertSame(Complex.ZERO,negInfOne.exp());TestUtils.assertSame(Complex.NaN,infInf.exp());TestUtils.assertSame(Complex.NaN,infNegInf.exp());TestUtils.assertSame(Complex.NaN,negInfInf.exp());TestUtils.assertSame(Complex.NaN,negInfNegInf.exp());}
@Test public void testLog(){Complex z=new Complex(3,4);Complex expected=new Complex(1.60944,0.927295);TestUtils.assertEquals(expected,z.log(),1.0e-5);}
@Test public void testLogNaN(){Assert.assertTrue(Complex.NaN.log().isNaN());}
@Test public void testLogInf(){TestUtils.assertEquals(new Complex(inf,pi / 2),oneInf.log(),10e-12);TestUtils.assertEquals(new Complex(inf,-pi / 2),oneNegInf.log(),10e-12);TestUtils.assertEquals(infZero,infOne.log(),10e-12);TestUtils.assertEquals(new Complex(inf,pi),negInfOne.log(),10e-12);TestUtils.assertEquals(new Complex(inf,pi / 4),infInf.log(),10e-12);TestUtils.assertEquals(new Complex(inf,-pi / 4),infNegInf.log(),10e-12);TestUtils.assertEquals(new Complex(inf,3d * pi / 4),negInfInf.log(),10e-12);TestUtils.assertEquals(new Complex(inf,-3d * pi / 4),negInfNegInf.log(),10e-12);}
@Test public void testLogZero(){TestUtils.assertSame(negInfZero,Complex.ZERO.log());}
@Test public void testPow(){Complex x=new Complex(3,4);Complex y=new Complex(5,6);Complex expected=new Complex(-1.860893,11.83677);TestUtils.assertEquals(expected,x.pow(y),1.0e-5);}
@Test public void testPowNaNBase(){Complex x=new Complex(3,4);Assert.assertTrue(Complex.NaN.pow(x).isNaN());}
@Test public void testPowNaNExponent(){Complex x=new Complex(3,4);Assert.assertTrue(x.pow(Complex.NaN).isNaN());}
@Test public void testPowInf(){TestUtils.assertSame(Complex.NaN,Complex.ONE.pow(oneInf));TestUtils.assertSame(Complex.NaN,Complex.ONE.pow(oneNegInf));TestUtils.assertSame(Complex.NaN,Complex.ONE.pow(infOne));TestUtils.assertSame(Complex.NaN,Complex.ONE.pow(infInf));TestUtils.assertSame(Complex.NaN,Complex.ONE.pow(infNegInf));TestUtils.assertSame(Complex.NaN,Complex.ONE.pow(negInfInf));TestUtils.assertSame(Complex.NaN,Complex.ONE.pow(negInfNegInf));TestUtils.assertSame(Complex.NaN,infOne.pow(Complex.ONE));TestUtils.assertSame(Complex.NaN,negInfOne.pow(Complex.ONE));TestUtils.assertSame(Complex.NaN,infInf.pow(Complex.ONE));TestUtils.assertSame(Complex.NaN,infNegInf.pow(Complex.ONE));TestUtils.assertSame(Complex.NaN,negInfInf.pow(Complex.ONE));TestUtils.assertSame(Complex.NaN,negInfNegInf.pow(Complex.ONE));TestUtils.assertSame(Complex.NaN,negInfNegInf.pow(infNegInf));TestUtils.assertSame(Complex.NaN,negInfNegInf.pow(negInfNegInf));TestUtils.assertSame(Complex.NaN,negInfNegInf.pow(infInf));TestUtils.assertSame(Complex.NaN,infInf.pow(infNegInf));TestUtils.assertSame(Complex.NaN,infInf.pow(negInfNegInf));TestUtils.assertSame(Complex.NaN,infInf.pow(infInf));TestUtils.assertSame(Complex.NaN,infNegInf.pow(infNegInf));TestUtils.assertSame(Complex.NaN,infNegInf.pow(negInfNegInf));TestUtils.assertSame(Complex.NaN,infNegInf.pow(infInf));}
@Test public void testPowZero(){TestUtils.assertSame(Complex.NaN,Complex.ZERO.pow(Complex.ONE));TestUtils.assertSame(Complex.NaN,Complex.ZERO.pow(Complex.ZERO));TestUtils.assertSame(Complex.NaN,Complex.ZERO.pow(Complex.I));TestUtils.assertEquals(Complex.ONE,Complex.ONE.pow(Complex.ZERO),10e-12);TestUtils.assertEquals(Complex.ONE,Complex.I.pow(Complex.ZERO),10e-12);TestUtils.assertEquals(Complex.ONE,new Complex(-1,3).pow(Complex.ZERO),10e-12);}
@Test public void testScalarPow(){Complex x=new Complex(3,4);double yDouble=5.0;Complex yComplex=new Complex(yDouble);Assert.assertEquals(x.pow(yComplex),x.pow(yDouble));}
@Test public void testScalarPowNaNBase(){Complex x=Complex.NaN;double yDouble=5.0;Complex yComplex=new Complex(yDouble);Assert.assertEquals(x.pow(yComplex),x.pow(yDouble));}
@Test public void testScalarPowNaNExponent(){Complex x=new Complex(3,4);double yDouble=Double.NaN;Complex yComplex=new Complex(yDouble);Assert.assertEquals(x.pow(yComplex),x.pow(yDouble));}
@Test public void testScalarPowInf(){TestUtils.assertSame(Complex.NaN,Complex.ONE.pow(Double.POSITIVE_INFINITY));TestUtils.assertSame(Complex.NaN,Complex.ONE.pow(Double.NEGATIVE_INFINITY));TestUtils.assertSame(Complex.NaN,infOne.pow(1.0));TestUtils.assertSame(Complex.NaN,negInfOne.pow(1.0));TestUtils.assertSame(Complex.NaN,infInf.pow(1.0));TestUtils.assertSame(Complex.NaN,infNegInf.pow(1.0));TestUtils.assertSame(Complex.NaN,negInfInf.pow(10));TestUtils.assertSame(Complex.NaN,negInfNegInf.pow(1.0));TestUtils.assertSame(Complex.NaN,negInfNegInf.pow(Double.POSITIVE_INFINITY));TestUtils.assertSame(Complex.NaN,negInfNegInf.pow(Double.POSITIVE_INFINITY));TestUtils.assertSame(Complex.NaN,infInf.pow(Double.POSITIVE_INFINITY));TestUtils.assertSame(Complex.NaN,infInf.pow(Double.NEGATIVE_INFINITY));TestUtils.assertSame(Complex.NaN,infNegInf.pow(Double.NEGATIVE_INFINITY));TestUtils.assertSame(Complex.NaN,infNegInf.pow(Double.POSITIVE_INFINITY));}
@Test public void testScalarPowZero(){TestUtils.assertSame(Complex.NaN,Complex.ZERO.pow(1.0));TestUtils.assertSame(Complex.NaN,Complex.ZERO.pow(0.0));TestUtils.assertEquals(Complex.ONE,Complex.ONE.pow(0.0),10e-12);TestUtils.assertEquals(Complex.ONE,Complex.I.pow(0.0),10e-12);TestUtils.assertEquals(Complex.ONE,new Complex(-1,3).pow(0.0),10e-12);}
@Test(expected=NullArgumentException.class)public void testpowNull(){Complex.ONE.pow(null);}
@Test public void testSin(){Complex z=new Complex(3,4);Complex expected=new Complex(3.853738,-27.01681);TestUtils.assertEquals(expected,z.sin(),1.0e-5);}
@Test public void testSinInf(){TestUtils.assertSame(infInf,oneInf.sin());TestUtils.assertSame(infNegInf,oneNegInf.sin());TestUtils.assertSame(Complex.NaN,infOne.sin());TestUtils.assertSame(Complex.NaN,negInfOne.sin());TestUtils.assertSame(Complex.NaN,infInf.sin());TestUtils.assertSame(Complex.NaN,infNegInf.sin());TestUtils.assertSame(Complex.NaN,negInfInf.sin());TestUtils.assertSame(Complex.NaN,negInfNegInf.sin());}
@Test public void testSinNaN(){Assert.assertTrue(Complex.NaN.sin().isNaN());}
@Test public void testSinh(){Complex z=new Complex(3,4);Complex expected=new Complex(-6.54812,-7.61923);TestUtils.assertEquals(expected,z.sinh(),1.0e-5);}
@Test public void testSinhNaN(){Assert.assertTrue(Complex.NaN.sinh().isNaN());}
@Test public void testSinhInf(){TestUtils.assertSame(Complex.NaN,oneInf.sinh());TestUtils.assertSame(Complex.NaN,oneNegInf.sinh());TestUtils.assertSame(infInf,infOne.sinh());TestUtils.assertSame(negInfInf,negInfOne.sinh());TestUtils.assertSame(Complex.NaN,infInf.sinh());TestUtils.assertSame(Complex.NaN,infNegInf.sinh());TestUtils.assertSame(Complex.NaN,negInfInf.sinh());TestUtils.assertSame(Complex.NaN,negInfNegInf.sinh());}
@Test public void testSqrtRealPositive(){Complex z=new Complex(3,4);Complex expected=new Complex(2,1);TestUtils.assertEquals(expected,z.sqrt(),1.0e-5);}
@Test public void testSqrtRealZero(){Complex z=new Complex(0.0,4);Complex expected=new Complex(1.41421,1.41421);TestUtils.assertEquals(expected,z.sqrt(),1.0e-5);}
@Test public void testSqrtRealNegative(){Complex z=new Complex(-3.0,4);Complex expected=new Complex(1,2);TestUtils.assertEquals(expected,z.sqrt(),1.0e-5);}
@Test public void testSqrtImaginaryZero(){Complex z=new Complex(-3.0,0.0);Complex expected=new Complex(0.0,1.73205);TestUtils.assertEquals(expected,z.sqrt(),1.0e-5);}
@Test public void testSqrtImaginaryNegative(){Complex z=new Complex(-3.0,-4.0);Complex expected=new Complex(1.0,-2.0);TestUtils.assertEquals(expected,z.sqrt(),1.0e-5);}
@Test public void testSqrtPolar(){double r=1;for (int i=0;i < 5;i++){r+=i;double theta=0;for (int j=0;j < 11;j++){theta+=pi / 12;Complex z=ComplexUtils.polar2Complex(r,theta);Complex sqrtz=ComplexUtils.polar2Complex(FastMath.sqrt(r),theta / 2);TestUtils.assertEquals(sqrtz,z.sqrt(),10e-12);}}}
@Test public void testSqrtNaN(){Assert.assertTrue(Complex.NaN.sqrt().isNaN());}
@Test public void testSqrtInf(){TestUtils.assertSame(infNaN,oneInf.sqrt());TestUtils.assertSame(infNaN,oneNegInf.sqrt());TestUtils.assertSame(infZero,infOne.sqrt());TestUtils.assertSame(zeroInf,negInfOne.sqrt());TestUtils.assertSame(infNaN,infInf.sqrt());TestUtils.assertSame(infNaN,infNegInf.sqrt());TestUtils.assertSame(nanInf,negInfInf.sqrt());TestUtils.assertSame(nanNegInf,negInfNegInf.sqrt());}
@Test public void testSqrt1z(){Complex z=new Complex(3,4);Complex expected=new Complex(4.08033,-2.94094);TestUtils.assertEquals(expected,z.sqrt1z(),1.0e-5);}
@Test public void testSqrt1zNaN(){Assert.assertTrue(Complex.NaN.sqrt1z().isNaN());}
@Test public void testTan(){Complex z=new Complex(3,4);Complex expected=new Complex(-0.000187346,0.999356);TestUtils.assertEquals(expected,z.tan(),1.0e-5);}
@Test public void testTanNaN(){Assert.assertTrue(Complex.NaN.tan().isNaN());}
@Test public void testTanInf(){TestUtils.assertSame(zeroNaN,oneInf.tan());TestUtils.assertSame(zeroNaN,oneNegInf.tan());TestUtils.assertSame(Complex.NaN,infOne.tan());TestUtils.assertSame(Complex.NaN,negInfOne.tan());TestUtils.assertSame(Complex.NaN,infInf.tan());TestUtils.assertSame(Complex.NaN,infNegInf.tan());TestUtils.assertSame(Complex.NaN,negInfInf.tan());TestUtils.assertSame(Complex.NaN,negInfNegInf.tan());}
@Test public void testTanCritical(){TestUtils.assertSame(infNaN,new Complex(pi / 2,0).tan());TestUtils.assertSame(negInfNaN,new Complex(-pi / 2,0).tan());}
@Test public void testTanh(){Complex z=new Complex(3,4);Complex expected=new Complex(1.00071,0.00490826);TestUtils.assertEquals(expected,z.tanh(),1.0e-5);}
@Test public void testTanhNaN(){Assert.assertTrue(Complex.NaN.tanh().isNaN());}
@Test public void testTanhInf(){TestUtils.assertSame(Complex.NaN,oneInf.tanh());TestUtils.assertSame(Complex.NaN,oneNegInf.tanh());TestUtils.assertSame(nanZero,infOne.tanh());TestUtils.assertSame(nanZero,negInfOne.tanh());TestUtils.assertSame(Complex.NaN,infInf.tanh());TestUtils.assertSame(Complex.NaN,infNegInf.tanh());TestUtils.assertSame(Complex.NaN,negInfInf.tanh());TestUtils.assertSame(Complex.NaN,negInfNegInf.tanh());}
@Test public void testTanhCritical(){TestUtils.assertSame(nanInf,new Complex(0,pi / 2).tanh());}
/** * test issue MATH-221 */@Test public void testMath221(){Assert.assertEquals(new Complex(0,-1),new Complex(0,1).multiply(new Complex(-1,0)));}
/** * Test: computing <b>third roots</b> of z. <pre> <code> <b>z = -2 + 2 * i</b> => z_0 =  1      +          i => z_1 = -1.3660 + 0.3660 * i => z_2 =  0.3660 - 1.3660 * i </code> </pre>*/@Test public void testNthRoot_normal_thirdRoot(){Complex z=new Complex(-2,2);Complex[]thirdRootsOfZ=z.nthRoot(3).toArray(new Complex[0]);Assert.assertEquals(3,thirdRootsOfZ.length);Assert.assertEquals(1.0,thirdRootsOfZ[0].getReal(),1.0e-5);Assert.assertEquals(1.0,thirdRootsOfZ[0].getImaginary(),1.0e-5);Assert.assertEquals(-1.3660254037844386,thirdRootsOfZ[1].getReal(),1.0e-5);Assert.assertEquals(0.36602540378443843,thirdRootsOfZ[1].getImaginary(),1.0e-5);Assert.assertEquals(0.366025403784439,thirdRootsOfZ[2].getReal(),1.0e-5);Assert.assertEquals(-1.3660254037844384,thirdRootsOfZ[2].getImaginary(),1.0e-5);}
/** * Test: computing <b>fourth roots</b> of z. <pre> <code> <b>z = 5 - 2 * i</b> => z_0 =  1.5164 - 0.1446 * i => z_1 =  0.1446 + 1.5164 * i => z_2 = -1.5164 + 0.1446 * i => z_3 = -1.5164 - 0.1446 * i </code> </pre>*/@Test public void testNthRoot_normal_fourthRoot(){Complex z=new Complex(5,-2);Complex[]fourthRootsOfZ=z.nthRoot(4).toArray(new Complex[0]);Assert.assertEquals(4,fourthRootsOfZ.length);Assert.assertEquals(1.5164629308487783,fourthRootsOfZ[0].getReal(),1.0e-5);Assert.assertEquals(-0.14469266210702247,fourthRootsOfZ[0].getImaginary(),1.0e-5);Assert.assertEquals(0.14469266210702256,fourthRootsOfZ[1].getReal(),1.0e-5);Assert.assertEquals(1.5164629308487783,fourthRootsOfZ[1].getImaginary(),1.0e-5);Assert.assertEquals(-1.5164629308487783,fourthRootsOfZ[2].getReal(),1.0e-5);Assert.assertEquals(0.14469266210702267,fourthRootsOfZ[2].getImaginary(),1.0e-5);Assert.assertEquals(-0.14469266210702275,fourthRootsOfZ[3].getReal(),1.0e-5);Assert.assertEquals(-1.5164629308487783,fourthRootsOfZ[3].getImaginary(),1.0e-5);}
/** * Test: computing <b>third roots</b> of z. <pre> <code> <b>z = 8</b> => z_0 =  2 => z_1 = -1 + 1.73205 * i => z_2 = -1 - 1.73205 * i </code> </pre>*/@Test public void testNthRoot_cornercase_thirdRoot_imaginaryPartEmpty(){Complex z=new Complex(8,0);Complex[]thirdRootsOfZ=z.nthRoot(3).toArray(new Complex[0]);Assert.assertEquals(3,thirdRootsOfZ.length);Assert.assertEquals(2.0,thirdRootsOfZ[0].getReal(),1.0e-5);Assert.assertEquals(0.0,thirdRootsOfZ[0].getImaginary(),1.0e-5);Assert.assertEquals(-1.0,thirdRootsOfZ[1].getReal(),1.0e-5);Assert.assertEquals(1.7320508075688774,thirdRootsOfZ[1].getImaginary(),1.0e-5);Assert.assertEquals(-1.0,thirdRootsOfZ[2].getReal(),1.0e-5);Assert.assertEquals(-1.732050807568877,thirdRootsOfZ[2].getImaginary(),1.0e-5);}
/** * Test: computing <b>third roots</b> of z with real part 0. <pre> <code> <b>z = 2 * i</b> => z_0 =  1.0911 + 0.6299 * i => z_1 = -1.0911 + 0.6299 * i => z_2 = -2.3144 - 1.2599 * i </code> </pre>*/@Test public void testNthRoot_cornercase_thirdRoot_realPartZero(){Complex z=new Complex(0,2);Complex[]thirdRootsOfZ=z.nthRoot(3).toArray(new Complex[0]);Assert.assertEquals(3,thirdRootsOfZ.length);Assert.assertEquals(1.0911236359717216,thirdRootsOfZ[0].getReal(),1.0e-5);Assert.assertEquals(0.6299605249474365,thirdRootsOfZ[0].getImaginary(),1.0e-5);Assert.assertEquals(-1.0911236359717216,thirdRootsOfZ[1].getReal(),1.0e-5);Assert.assertEquals(0.6299605249474365,thirdRootsOfZ[1].getImaginary(),1.0e-5);Assert.assertEquals(-2.3144374213981936E-16,thirdRootsOfZ[2].getReal(),1.0e-5);Assert.assertEquals(-1.2599210498948732,thirdRootsOfZ[2].getImaginary(),1.0e-5);}
/** * Test cornercases with NaN and Infinity.*/@Test public void testNthRoot_cornercase_NAN_Inf(){List<Complex> roots=oneNaN.nthRoot(3);Assert.assertEquals(1,roots.size());Assert.assertEquals(Complex.NaN,roots.get(0));roots=nanZero.nthRoot(3);Assert.assertEquals(1,roots.size());Assert.assertEquals(Complex.NaN,roots.get(0));roots=nanInf.nthRoot(3);Assert.assertEquals(1,roots.size());Assert.assertEquals(Complex.NaN,roots.get(0));roots=oneInf.nthRoot(3);Assert.assertEquals(1,roots.size());Assert.assertEquals(Complex.INF,roots.get(0));roots=negInfInf.nthRoot(3);Assert.assertEquals(1,roots.size());Assert.assertEquals(Complex.INF,roots.get(0));}
/** * Test standard values*/@Test public void testGetArgument(){Complex z=new Complex(1,0);Assert.assertEquals(0.0,z.getArgument(),1.0e-12);z=new Complex(1,1);Assert.assertEquals(FastMath.PI / 4,z.getArgument(),1.0e-12);z=new Complex(0,1);Assert.assertEquals(FastMath.PI / 2,z.getArgument(),1.0e-12);z=new Complex(-1,1);Assert.assertEquals(3 * FastMath.PI / 4,z.getArgument(),1.0e-12);z=new Complex(-1,0);Assert.assertEquals(FastMath.PI,z.getArgument(),1.0e-12);z=new Complex(-1,-1);Assert.assertEquals(-3 * FastMath.PI / 4,z.getArgument(),1.0e-12);z=new Complex(0,-1);Assert.assertEquals(-FastMath.PI / 2,z.getArgument(),1.0e-12);z=new Complex(1,-1);Assert.assertEquals(-FastMath.PI / 4,z.getArgument(),1.0e-12);}
/** * Verify atan2-style handling of infinite parts*/@Test public void testGetArgumentInf(){Assert.assertEquals(FastMath.PI / 4,infInf.getArgument(),1.0e-12);Assert.assertEquals(FastMath.PI / 2,oneInf.getArgument(),1.0e-12);Assert.assertEquals(0.0,infOne.getArgument(),1.0e-12);Assert.assertEquals(FastMath.PI / 2,zeroInf.getArgument(),1.0e-12);Assert.assertEquals(0.0,infZero.getArgument(),1.0e-12);Assert.assertEquals(FastMath.PI,negInfOne.getArgument(),1.0e-12);Assert.assertEquals(-3.0 * FastMath.PI / 4,negInfNegInf.getArgument(),1.0e-12);Assert.assertEquals(-FastMath.PI / 2,oneNegInf.getArgument(),1.0e-12);}
/** * Verify that either part NaN results in NaN*/@Test public void testGetArgumentNaN(){Assert.assertTrue(Double.isNaN(nanZero.getArgument()));Assert.assertTrue(Double.isNaN(zeroNaN.getArgument()));Assert.assertTrue(Double.isNaN(Complex.NaN.getArgument()));}
@Test public void testSerial(){Complex z=new Complex(3.0,4.0);Assert.assertEquals(z,TestUtils.serializeAndRecover(z));Complex ncmplx=(Complex)TestUtils.serializeAndRecover(oneNaN);Assert.assertEquals(nanZero,ncmplx);Assert.assertTrue(ncmplx.isNaN());Complex infcmplx=(Complex)TestUtils.serializeAndRecover(infInf);Assert.assertEquals(infInf,infcmplx);Assert.assertTrue(infcmplx.isInfinite());TestComplex tz=new TestComplex(3.0,4.0);Assert.assertEquals(tz,TestUtils.serializeAndRecover(tz));TestComplex ntcmplx=(TestComplex)TestUtils.serializeAndRecover(new TestComplex(oneNaN));Assert.assertEquals(nanZero,ntcmplx);Assert.assertTrue(ntcmplx.isNaN());TestComplex inftcmplx=(TestComplex)TestUtils.serializeAndRecover(new TestComplex(infInf));Assert.assertEquals(infInf,inftcmplx);Assert.assertTrue(inftcmplx.isInfinite());}
@Test public void testFormat(){Fraction c=new Fraction(1,2);String expected="1 / 2";String actual=properFormat.format(c);Assert.assertEquals(expected,actual);actual=improperFormat.format(c);Assert.assertEquals(expected,actual);}
@Test public void testFormatNegative(){Fraction c=new Fraction(-1,2);String expected="-1 / 2";String actual=properFormat.format(c);Assert.assertEquals(expected,actual);actual=improperFormat.format(c);Assert.assertEquals(expected,actual);}
@Test public void testFormatZero(){Fraction c=new Fraction(0,1);String expected="0 / 1";String actual=properFormat.format(c);Assert.assertEquals(expected,actual);actual=improperFormat.format(c);Assert.assertEquals(expected,actual);}
@Test public void testFormatImproper(){Fraction c=new Fraction(5,3);String actual=properFormat.format(c);Assert.assertEquals("1 2 / 3",actual);actual=improperFormat.format(c);Assert.assertEquals("5 / 3",actual);}
@Test public void testFormatImproperNegative(){Fraction c=new Fraction(-5,3);String actual=properFormat.format(c);Assert.assertEquals("-1 2 / 3",actual);actual=improperFormat.format(c);Assert.assertEquals("-5 / 3",actual);}
@Test public void testParse(){String source="1 / 2";try {Fraction c=properFormat.parse(source);Assert.assertNotNull(c);Assert.assertEquals(1,c.getNumerator());Assert.assertEquals(2,c.getDenominator());c=improperFormat.parse(source);Assert.assertNotNull(c);Assert.assertEquals(1,c.getNumerator());Assert.assertEquals(2,c.getDenominator());}catch(MathParseException ex){Assert.fail(ex.getMessage());}}
@Test public void testParseInteger(){String source="10";{Fraction c=properFormat.parse(source);Assert.assertNotNull(c);Assert.assertEquals(10,c.getNumerator());Assert.assertEquals(1,c.getDenominator());}{Fraction c=improperFormat.parse(source);Assert.assertNotNull(c);Assert.assertEquals(10,c.getNumerator());Assert.assertEquals(1,c.getDenominator());}}
@Test public void testParseInvalid(){String source="a";String msg="should not be able to parse '10 / a'.";try {properFormat.parse(source);Assert.fail(msg);}catch(MathParseException ex){}try {improperFormat.parse(source);Assert.fail(msg);}catch(MathParseException ex){}}
@Test public void testParseInvalidDenominator(){String source="10 / a";String msg="should not be able to parse '10 / a'.";try {properFormat.parse(source);Assert.fail(msg);}catch(MathParseException ex){}try {improperFormat.parse(source);Assert.fail(msg);}catch(MathParseException ex){}}
@Test public void testParseNegative(){{String source="-1 / 2";Fraction c=properFormat.parse(source);Assert.assertNotNull(c);Assert.assertEquals(-1,c.getNumerator());Assert.assertEquals(2,c.getDenominator());c=improperFormat.parse(source);Assert.assertNotNull(c);Assert.assertEquals(-1,c.getNumerator());Assert.assertEquals(2,c.getDenominator());source="1 / -2";c=properFormat.parse(source);Assert.assertNotNull(c);Assert.assertEquals(-1,c.getNumerator());Assert.assertEquals(2,c.getDenominator());c=improperFormat.parse(source);Assert.assertNotNull(c);Assert.assertEquals(-1,c.getNumerator());Assert.assertEquals(2,c.getDenominator());}}
@Test public void testParseProper(){String source="1 2 / 3";{Fraction c=properFormat.parse(source);Assert.assertNotNull(c);Assert.assertEquals(5,c.getNumerator());Assert.assertEquals(3,c.getDenominator());}try {improperFormat.parse(source);Assert.fail("invalid improper fraction.");}catch(MathParseException ex){}}
@Test public void testParseProperNegative(){String source="-1 2 / 3";{Fraction c=properFormat.parse(source);Assert.assertNotNull(c);Assert.assertEquals(-5,c.getNumerator());Assert.assertEquals(3,c.getDenominator());}try {improperFormat.parse(source);Assert.fail("invalid improper fraction.");}catch(MathParseException ex){}}
@Test public void testParseProperInvalidMinus(){String source="2 -2 / 3";try {properFormat.parse(source);Assert.fail("invalid minus in improper fraction.");}catch(MathParseException ex){}source="2 2 / -3";try {properFormat.parse(source);Assert.fail("invalid minus in improper fraction.");}catch(MathParseException ex){}}
@Test public void testNumeratorFormat(){NumberFormat old=properFormat.getNumeratorFormat();NumberFormat nf=NumberFormat.getInstance();nf.setParseIntegerOnly(true);properFormat.setNumeratorFormat(nf);Assert.assertEquals(nf,properFormat.getNumeratorFormat());properFormat.setNumeratorFormat(old);old=improperFormat.getNumeratorFormat();nf=NumberFormat.getInstance();nf.setParseIntegerOnly(true);improperFormat.setNumeratorFormat(nf);Assert.assertEquals(nf,improperFormat.getNumeratorFormat());improperFormat.setNumeratorFormat(old);}
@Test public void testDenominatorFormat(){NumberFormat old=properFormat.getDenominatorFormat();NumberFormat nf=NumberFormat.getInstance();nf.setParseIntegerOnly(true);properFormat.setDenominatorFormat(nf);Assert.assertEquals(nf,properFormat.getDenominatorFormat());properFormat.setDenominatorFormat(old);old=improperFormat.getDenominatorFormat();nf=NumberFormat.getInstance();nf.setParseIntegerOnly(true);improperFormat.setDenominatorFormat(nf);Assert.assertEquals(nf,improperFormat.getDenominatorFormat());improperFormat.setDenominatorFormat(old);}
@Test public void testWholeFormat(){ProperFractionFormat format=(ProperFractionFormat)properFormat;NumberFormat old=format.getWholeFormat();NumberFormat nf=NumberFormat.getInstance();nf.setParseIntegerOnly(true);format.setWholeFormat(nf);Assert.assertEquals(nf,format.getWholeFormat());format.setWholeFormat(old);}
@Test public void testLongFormat(){Assert.assertEquals("10 / 1",improperFormat.format(10l));}
@Test public void testDoubleFormat(){Assert.assertEquals("355 / 113",improperFormat.format(FastMath.PI));}
/** * test dimensions */@Test public void testDimensions(){FieldMatrix<Fraction> matrix=new Array2DRowFieldMatrix<Fraction>(FractionField.getInstance(),testData);FieldLUDecomposition<Fraction> LU=new FieldLUDecomposition<Fraction>(matrix);Assert.assertEquals(testData.length,LU.getL().getRowDimension());Assert.assertEquals(testData.length,LU.getL().getColumnDimension());Assert.assertEquals(testData.length,LU.getU().getRowDimension());Assert.assertEquals(testData.length,LU.getU().getColumnDimension());Assert.assertEquals(testData.length,LU.getP().getRowDimension());Assert.assertEquals(testData.length,LU.getP().getColumnDimension());}
/** * test non-square matrix */@Test public void testNonSquare(){try {new FieldLUDecomposition<Fraction>(new Array2DRowFieldMatrix<Fraction>(new Fraction[][]{{Fraction.ZERO,Fraction.ZERO},{Fraction.ZERO,Fraction.ZERO},{Fraction.ZERO,Fraction.ZERO}}));Assert.fail("Expected NonSquareMatrixException");}catch(NonSquareMatrixException ime){}}
/** * test PA = LU */@Test public void testPAEqualLU(){FieldMatrix<Fraction> matrix=new Array2DRowFieldMatrix<Fraction>(FractionField.getInstance(),testData);FieldLUDecomposition<Fraction> lu=new FieldLUDecomposition<Fraction>(matrix);FieldMatrix<Fraction> l=lu.getL();FieldMatrix<Fraction> u=lu.getU();FieldMatrix<Fraction> p=lu.getP();TestUtils.assertEquals(p.multiply(matrix),l.multiply(u));matrix=new Array2DRowFieldMatrix<Fraction>(FractionField.getInstance(),testDataMinus);lu=new FieldLUDecomposition<Fraction>(matrix);l=lu.getL();u=lu.getU();p=lu.getP();TestUtils.assertEquals(p.multiply(matrix),l.multiply(u));matrix=new Array2DRowFieldMatrix<Fraction>(FractionField.getInstance(),17,17);for (int i=0;i < matrix.getRowDimension();++i){matrix.setEntry(i,i,Fraction.ONE);}lu=new FieldLUDecomposition<Fraction>(matrix);l=lu.getL();u=lu.getU();p=lu.getP();TestUtils.assertEquals(p.multiply(matrix),l.multiply(u));matrix=new Array2DRowFieldMatrix<Fraction>(FractionField.getInstance(),singular);lu=new FieldLUDecomposition<Fraction>(matrix);Assert.assertFalse(lu.getSolver().isNonSingular());Assert.assertNull(lu.getL());Assert.assertNull(lu.getU());Assert.assertNull(lu.getP());matrix=new Array2DRowFieldMatrix<Fraction>(FractionField.getInstance(),bigSingular);lu=new FieldLUDecomposition<Fraction>(matrix);Assert.assertFalse(lu.getSolver().isNonSingular());Assert.assertNull(lu.getL());Assert.assertNull(lu.getU());Assert.assertNull(lu.getP());}
/** * test that L is lower triangular with unit diagonal */@Test public void testLLowerTriangular(){FieldMatrix<Fraction> matrix=new Array2DRowFieldMatrix<Fraction>(FractionField.getInstance(),testData);FieldMatrix<Fraction> l=new FieldLUDecomposition<Fraction>(matrix).getL();for (int i=0;i < l.getRowDimension();i++){Assert.assertEquals(Fraction.ONE,l.getEntry(i,i));for (int j=i + 1;j < l.getColumnDimension();j++){Assert.assertEquals(Fraction.ZERO,l.getEntry(i,j));}}}
/** * test that U is upper triangular */@Test public void testUUpperTriangular(){FieldMatrix<Fraction> matrix=new Array2DRowFieldMatrix<Fraction>(FractionField.getInstance(),testData);FieldMatrix<Fraction> u=new FieldLUDecomposition<Fraction>(matrix).getU();for (int i=0;i < u.getRowDimension();i++){for (int j=0;j < i;j++){Assert.assertEquals(Fraction.ZERO,u.getEntry(i,j));}}}
/** * test that P is a permutation matrix */@Test public void testPPermutation(){FieldMatrix<Fraction> matrix=new Array2DRowFieldMatrix<Fraction>(FractionField.getInstance(),testData);FieldMatrix<Fraction> p=new FieldLUDecomposition<Fraction>(matrix).getP();FieldMatrix<Fraction> ppT=p.multiply(p.transpose());FieldMatrix<Fraction> id=new Array2DRowFieldMatrix<Fraction>(FractionField.getInstance(),p.getRowDimension(),p.getRowDimension());for (int i=0;i < id.getRowDimension();++i){id.setEntry(i,i,Fraction.ONE);}TestUtils.assertEquals(id,ppT);for (int i=0;i < p.getRowDimension();i++){int zeroCount=0;int oneCount=0;int otherCount=0;for (int j=0;j < p.getColumnDimension();j++){final Fraction e=p.getEntry(i,j);if (e.equals(Fraction.ZERO)){++zeroCount;}else       if (e.equals(Fraction.ONE)){++oneCount;}else {++otherCount;}}Assert.assertEquals(p.getColumnDimension()- 1,zeroCount);Assert.assertEquals(1,oneCount);Assert.assertEquals(0,otherCount);}for (int j=0;j < p.getColumnDimension();j++){int zeroCount=0;int oneCount=0;int otherCount=0;for (int i=0;i < p.getRowDimension();i++){final Fraction e=p.getEntry(i,j);if (e.equals(Fraction.ZERO)){++zeroCount;}else       if (e.equals(Fraction.ONE)){++oneCount;}else {++otherCount;}}Assert.assertEquals(p.getRowDimension()- 1,zeroCount);Assert.assertEquals(1,oneCount);Assert.assertEquals(0,otherCount);}}
/** * test singular */@Test public void testSingular(){FieldLUDecomposition<Fraction> lu=new FieldLUDecomposition<Fraction>(new Array2DRowFieldMatrix<Fraction>(FractionField.getInstance(),testData));Assert.assertTrue(lu.getSolver().isNonSingular());lu=new FieldLUDecomposition<Fraction>(new Array2DRowFieldMatrix<Fraction>(FractionField.getInstance(),singular));Assert.assertFalse(lu.getSolver().isNonSingular());lu=new FieldLUDecomposition<Fraction>(new Array2DRowFieldMatrix<Fraction>(FractionField.getInstance(),bigSingular));Assert.assertFalse(lu.getSolver().isNonSingular());}
/** * test matrices values */@Test public void testMatricesValues1(){FieldLUDecomposition<Fraction> lu=new FieldLUDecomposition<Fraction>(new Array2DRowFieldMatrix<Fraction>(FractionField.getInstance(),testData));FieldMatrix<Fraction> lRef=new Array2DRowFieldMatrix<Fraction>(FractionField.getInstance(),new Fraction[][]{{new Fraction(1),new Fraction(0),new Fraction(0)},{new Fraction(2),new Fraction(1),new Fraction(0)},{new Fraction(1),new Fraction(-2),new Fraction(1)}});FieldMatrix<Fraction> uRef=new Array2DRowFieldMatrix<Fraction>(FractionField.getInstance(),new Fraction[][]{{new Fraction(1),new Fraction(2),new Fraction(3)},{new Fraction(0),new Fraction(1),new Fraction(-3)},{new Fraction(0),new Fraction(0),new Fraction(-1)}});FieldMatrix<Fraction> pRef=new Array2DRowFieldMatrix<Fraction>(FractionField.getInstance(),new Fraction[][]{{new Fraction(1),new Fraction(0),new Fraction(0)},{new Fraction(0),new Fraction(1),new Fraction(0)},{new Fraction(0),new Fraction(0),new Fraction(1)}});int[]pivotRef={0,1,2};FieldMatrix<Fraction> l=lu.getL();TestUtils.assertEquals(lRef,l);FieldMatrix<Fraction> u=lu.getU();TestUtils.assertEquals(uRef,u);FieldMatrix<Fraction> p=lu.getP();TestUtils.assertEquals(pRef,p);int[]pivot=lu.getPivot();for (int i=0;i < pivotRef.length;++i){Assert.assertEquals(pivotRef[i],pivot[i]);}Assert.assertTrue(l == lu.getL());Assert.assertTrue(u == lu.getU());Assert.assertTrue(p == lu.getP());}
/** * test matrices values */@Test public void testMatricesValues2(){FieldLUDecomposition<Fraction> lu=new FieldLUDecomposition<Fraction>(new Array2DRowFieldMatrix<Fraction>(FractionField.getInstance(),luData));FieldMatrix<Fraction> lRef=new Array2DRowFieldMatrix<Fraction>(FractionField.getInstance(),new Fraction[][]{{new Fraction(1),new Fraction(0),new Fraction(0)},{new Fraction(3),new Fraction(1),new Fraction(0)},{new Fraction(1),new Fraction(0),new Fraction(1)}});FieldMatrix<Fraction> uRef=new Array2DRowFieldMatrix<Fraction>(FractionField.getInstance(),new Fraction[][]{{new Fraction(2),new Fraction(3),new Fraction(3)},{new Fraction(0),new Fraction(-3),new Fraction(-1)},{new Fraction(0),new Fraction(0),new Fraction(4)}});FieldMatrix<Fraction> pRef=new Array2DRowFieldMatrix<Fraction>(FractionField.getInstance(),new Fraction[][]{{new Fraction(1),new Fraction(0),new Fraction(0)},{new Fraction(0),new Fraction(0),new Fraction(1)},{new Fraction(0),new Fraction(1),new Fraction(0)}});int[]pivotRef={0,2,1};FieldMatrix<Fraction> l=lu.getL();TestUtils.assertEquals(lRef,l);FieldMatrix<Fraction> u=lu.getU();TestUtils.assertEquals(uRef,u);FieldMatrix<Fraction> p=lu.getP();TestUtils.assertEquals(pRef,p);int[]pivot=lu.getPivot();for (int i=0;i < pivotRef.length;++i){Assert.assertEquals(pivotRef[i],pivot[i]);}Assert.assertTrue(l == lu.getL());Assert.assertTrue(u == lu.getU());Assert.assertTrue(p == lu.getP());}
@Test public void testSelect(){TournamentSelection ts=new TournamentSelection(2);ElitisticListPopulation pop=new ElitisticListPopulation(100,0.203);for (int i=0;i < pop.getPopulationLimit();i++){pop.addChromosome(new DummyChromosome());}for (int i=0;i < 20;i++){ChromosomePair pair=ts.select(pop);Assert.assertTrue(pair.getFirst().getFitness()> 0);Assert.assertTrue(pair.getSecond().getFitness()> 0);}}
@Test public void testConstructors(){ArrayFieldVector<Fraction> v0=new ArrayFieldVector<Fraction>(FractionField.getInstance());Assert.assertEquals(0,v0.getDimension());ArrayFieldVector<Fraction> v1=new ArrayFieldVector<Fraction>(FractionField.getInstance(),7);Assert.assertEquals(7,v1.getDimension());Assert.assertEquals(new Fraction(0),v1.getEntry(6));ArrayFieldVector<Fraction> v2=new ArrayFieldVector<Fraction>(5,new Fraction(123,100));Assert.assertEquals(5,v2.getDimension());Assert.assertEquals(new Fraction(123,100),v2.getEntry(4));ArrayFieldVector<Fraction> v3=new ArrayFieldVector<Fraction>(FractionField.getInstance(),vec1);Assert.assertEquals(3,v3.getDimension());Assert.assertEquals(new Fraction(2),v3.getEntry(1));ArrayFieldVector<Fraction> v4=new ArrayFieldVector<Fraction>(FractionField.getInstance(),vec4,3,2);Assert.assertEquals(2,v4.getDimension());Assert.assertEquals(new Fraction(4),v4.getEntry(0));try {new ArrayFieldVector<Fraction>(vec4,8,3);Assert.fail("MathIllegalArgumentException expected");}catch(MathIllegalArgumentException ex){}FieldVector<Fraction> v5_i=new ArrayFieldVector<Fraction>(dvec1);Assert.assertEquals(9,v5_i.getDimension());Assert.assertEquals(new Fraction(9),v5_i.getEntry(8));ArrayFieldVector<Fraction> v5=new ArrayFieldVector<Fraction>(dvec1);Assert.assertEquals(9,v5.getDimension());Assert.assertEquals(new Fraction(9),v5.getEntry(8));ArrayFieldVector<Fraction> v6=new ArrayFieldVector<Fraction>(dvec1,3,2);Assert.assertEquals(2,v6.getDimension());Assert.assertEquals(new Fraction(4),v6.getEntry(0));try {new ArrayFieldVector<Fraction>(dvec1,8,3);Assert.fail("MathIllegalArgumentException expected");}catch(MathIllegalArgumentException ex){}ArrayFieldVector<Fraction> v7=new ArrayFieldVector<Fraction>(v1);Assert.assertEquals(7,v7.getDimension());Assert.assertEquals(new Fraction(0),v7.getEntry(6));FieldVectorTestImpl<Fraction> v7_i=new FieldVectorTestImpl<Fraction>(vec1);ArrayFieldVector<Fraction> v7_2=new ArrayFieldVector<Fraction>(v7_i);Assert.assertEquals(3,v7_2.getDimension());Assert.assertEquals(new Fraction(2),v7_2.getEntry(1));ArrayFieldVector<Fraction> v8=new ArrayFieldVector<Fraction>(v1,true);Assert.assertEquals(7,v8.getDimension());Assert.assertEquals(new Fraction(0),v8.getEntry(6));Assert.assertNotSame("testData not same object ",v1.data,v8.data);ArrayFieldVector<Fraction> v8_2=new ArrayFieldVector<Fraction>(v1,false);Assert.assertEquals(7,v8_2.getDimension());Assert.assertEquals(new Fraction(0),v8_2.getEntry(6));Assert.assertArrayEquals(v1.data,v8_2.data);ArrayFieldVector<Fraction> v9=new ArrayFieldVector<Fraction>(v1,v3);Assert.assertEquals(10,v9.getDimension());Assert.assertEquals(new Fraction(1),v9.getEntry(7));}
@Test public void testDataInOut(){ArrayFieldVector<Fraction> v1=new ArrayFieldVector<Fraction>(vec1);ArrayFieldVector<Fraction> v2=new ArrayFieldVector<Fraction>(vec2);ArrayFieldVector<Fraction> v4=new ArrayFieldVector<Fraction>(vec4);FieldVectorTestImpl<Fraction> v2_t=new FieldVectorTestImpl<Fraction>(vec2);FieldVector<Fraction> v_append_1=v1.append(v2);Assert.assertEquals(6,v_append_1.getDimension());Assert.assertEquals(new Fraction(4),v_append_1.getEntry(3));FieldVector<Fraction> v_append_2=v1.append(new Fraction(2));Assert.assertEquals(4,v_append_2.getDimension());Assert.assertEquals(new Fraction(2),v_append_2.getEntry(3));FieldVector<Fraction> v_append_4=v1.append(v2_t);Assert.assertEquals(6,v_append_4.getDimension());Assert.assertEquals(new Fraction(4),v_append_4.getEntry(3));FieldVector<Fraction> v_copy=v1.copy();Assert.assertEquals(3,v_copy.getDimension());Assert.assertNotSame("testData not same object ",v1.data,v_copy.getData());Fraction[]a_frac=v1.toArray();Assert.assertEquals(3,a_frac.length);Assert.assertNotSame("testData not same object ",v1.data,a_frac);FieldVector<Fraction> vout5=v4.getSubVector(3,3);Assert.assertEquals(3,vout5.getDimension());Assert.assertEquals(new Fraction(5),vout5.getEntry(1));try {v4.getSubVector(3,7);Assert.fail("OutOfRangeException expected");}catch(OutOfRangeException ex){}ArrayFieldVector<Fraction> v_set1=(ArrayFieldVector<Fraction>)v1.copy();v_set1.setEntry(1,new Fraction(11));Assert.assertEquals(new Fraction(11),v_set1.getEntry(1));try {v_set1.setEntry(3,new Fraction(11));Assert.fail("OutOfRangeException expected");}catch(OutOfRangeException ex){}ArrayFieldVector<Fraction> v_set2=(ArrayFieldVector<Fraction>)v4.copy();v_set2.set(3,v1);Assert.assertEquals(new Fraction(1),v_set2.getEntry(3));Assert.assertEquals(new Fraction(7),v_set2.getEntry(6));try {v_set2.set(7,v1);Assert.fail("OutOfRangeException expected");}catch(OutOfRangeException ex){}ArrayFieldVector<Fraction> v_set3=(ArrayFieldVector<Fraction>)v1.copy();v_set3.set(new Fraction(13));Assert.assertEquals(new Fraction(13),v_set3.getEntry(2));try {v_set3.getEntry(23);Assert.fail("ArrayIndexOutOfBoundsException expected");}catch(ArrayIndexOutOfBoundsException ex){}ArrayFieldVector<Fraction> v_set4=(ArrayFieldVector<Fraction>)v4.copy();v_set4.setSubVector(3,v2_t);Assert.assertEquals(new Fraction(4),v_set4.getEntry(3));Assert.assertEquals(new Fraction(7),v_set4.getEntry(6));try {v_set4.setSubVector(7,v2_t);Assert.fail("OutOfRangeException expected");}catch(OutOfRangeException ex){}ArrayFieldVector<Fraction> vout10=(ArrayFieldVector<Fraction>)v1.copy();ArrayFieldVector<Fraction> vout10_2=(ArrayFieldVector<Fraction>)v1.copy();Assert.assertEquals(vout10,vout10_2);vout10_2.setEntry(0,new Fraction(11,10));Assert.assertNotSame(vout10,vout10_2);}
@Test public void testMapFunctions(){ArrayFieldVector<Fraction> v1=new ArrayFieldVector<Fraction>(vec1);FieldVector<Fraction> v_mapAdd=v1.mapAdd(new Fraction(2));Fraction[]result_mapAdd={new Fraction(3),new Fraction(4),new Fraction(5)};checkArray("compare vectors",result_mapAdd,v_mapAdd.getData());FieldVector<Fraction> v_mapAddToSelf=v1.copy();v_mapAddToSelf.mapAddToSelf(new Fraction(2));Fraction[]result_mapAddToSelf={new Fraction(3),new Fraction(4),new Fraction(5)};checkArray("compare vectors",result_mapAddToSelf,v_mapAddToSelf.getData());FieldVector<Fraction> v_mapSubtract=v1.mapSubtract(new Fraction(2));Fraction[]result_mapSubtract={new Fraction(-1),new Fraction(0),new Fraction(1)};checkArray("compare vectors",result_mapSubtract,v_mapSubtract.getData());FieldVector<Fraction> v_mapSubtractToSelf=v1.copy();v_mapSubtractToSelf.mapSubtractToSelf(new Fraction(2));Fraction[]result_mapSubtractToSelf={new Fraction(-1),new Fraction(0),new Fraction(1)};checkArray("compare vectors",result_mapSubtractToSelf,v_mapSubtractToSelf.getData());FieldVector<Fraction> v_mapMultiply=v1.mapMultiply(new Fraction(2));Fraction[]result_mapMultiply={new Fraction(2),new Fraction(4),new Fraction(6)};checkArray("compare vectors",result_mapMultiply,v_mapMultiply.getData());FieldVector<Fraction> v_mapMultiplyToSelf=v1.copy();v_mapMultiplyToSelf.mapMultiplyToSelf(new Fraction(2));Fraction[]result_mapMultiplyToSelf={new Fraction(2),new Fraction(4),new Fraction(6)};checkArray("compare vectors",result_mapMultiplyToSelf,v_mapMultiplyToSelf.getData());FieldVector<Fraction> v_mapDivide=v1.mapDivide(new Fraction(2));Fraction[]result_mapDivide={new Fraction(1,2),new Fraction(1),new Fraction(3,2)};checkArray("compare vectors",result_mapDivide,v_mapDivide.getData());FieldVector<Fraction> v_mapDivideToSelf=v1.copy();v_mapDivideToSelf.mapDivideToSelf(new Fraction(2));Fraction[]result_mapDivideToSelf={new Fraction(1,2),new Fraction(1),new Fraction(3,2)};checkArray("compare vectors",result_mapDivideToSelf,v_mapDivideToSelf.getData());FieldVector<Fraction> v_mapInv=v1.mapInv();Fraction[]result_mapInv={new Fraction(1),new Fraction(1,2),new Fraction(1,3)};checkArray("compare vectors",result_mapInv,v_mapInv.getData());FieldVector<Fraction> v_mapInvToSelf=v1.copy();v_mapInvToSelf.mapInvToSelf();Fraction[]result_mapInvToSelf={new Fraction(1),new Fraction(1,2),new Fraction(1,3)};checkArray("compare vectors",result_mapInvToSelf,v_mapInvToSelf.getData());}
@Test public void testBasicFunctions(){ArrayFieldVector<Fraction> v1=new ArrayFieldVector<Fraction>(vec1);ArrayFieldVector<Fraction> v2=new ArrayFieldVector<Fraction>(vec2);new ArrayFieldVector<Fraction>(vec_null);FieldVectorTestImpl<Fraction> v2_t=new FieldVectorTestImpl<Fraction>(vec2);ArrayFieldVector<Fraction> v_add=v1.add(v2);Fraction[]result_add={new Fraction(5),new Fraction(7),new Fraction(9)};checkArray("compare vect",v_add.getData(),result_add);FieldVectorTestImpl<Fraction> vt2=new FieldVectorTestImpl<Fraction>(vec2);FieldVector<Fraction> v_add_i=v1.add(vt2);Fraction[]result_add_i={new Fraction(5),new Fraction(7),new Fraction(9)};checkArray("compare vect",v_add_i.getData(),result_add_i);ArrayFieldVector<Fraction> v_subtract=v1.subtract(v2);Fraction[]result_subtract={new Fraction(-3),new Fraction(-3),new Fraction(-3)};checkArray("compare vect",v_subtract.getData(),result_subtract);FieldVector<Fraction> v_subtract_i=v1.subtract(vt2);Fraction[]result_subtract_i={new Fraction(-3),new Fraction(-3),new Fraction(-3)};checkArray("compare vect",v_subtract_i.getData(),result_subtract_i);ArrayFieldVector<Fraction> v_ebeMultiply=v1.ebeMultiply(v2);Fraction[]result_ebeMultiply={new Fraction(4),new Fraction(10),new Fraction(18)};checkArray("compare vect",v_ebeMultiply.getData(),result_ebeMultiply);FieldVector<Fraction> v_ebeMultiply_2=v1.ebeMultiply(v2_t);Fraction[]result_ebeMultiply_2={new Fraction(4),new Fraction(10),new Fraction(18)};checkArray("compare vect",v_ebeMultiply_2.getData(),result_ebeMultiply_2);ArrayFieldVector<Fraction> v_ebeDivide=v1.ebeDivide(v2);Fraction[]result_ebeDivide={new Fraction(1,4),new Fraction(2,5),new Fraction(1,2)};checkArray("compare vect",v_ebeDivide.getData(),result_ebeDivide);FieldVector<Fraction> v_ebeDivide_2=v1.ebeDivide(v2_t);Fraction[]result_ebeDivide_2={new Fraction(1,4),new Fraction(2,5),new Fraction(1,2)};checkArray("compare vect",v_ebeDivide_2.getData(),result_ebeDivide_2);Fraction dot=v1.dotProduct(v2);Assert.assertEquals("compare val ",new Fraction(32),dot);Fraction dot_2=v1.dotProduct(v2_t);Assert.assertEquals("compare val ",new Fraction(32),dot_2);FieldMatrix<Fraction> m_outerProduct=v1.outerProduct(v2);Assert.assertEquals("compare val ",new Fraction(4),m_outerProduct.getEntry(0,0));FieldMatrix<Fraction> m_outerProduct_2=v1.outerProduct(v2_t);Assert.assertEquals("compare val ",new Fraction(4),m_outerProduct_2.getEntry(0,0));ArrayFieldVector<Fraction> v_projection=v1.projection(v2);Fraction[]result_projection={new Fraction(128,77),new Fraction(160,77),new Fraction(192,77)};checkArray("compare vect",v_projection.getData(),result_projection);FieldVector<Fraction> v_projection_2=v1.projection(v2_t);Fraction[]result_projection_2={new Fraction(128,77),new Fraction(160,77),new Fraction(192,77)};checkArray("compare vect",v_projection_2.getData(),result_projection_2);}
@Test public void testMisc(){ArrayFieldVector<Fraction> v1=new ArrayFieldVector<Fraction>(vec1);ArrayFieldVector<Fraction> v4=new ArrayFieldVector<Fraction>(vec4);FieldVector<Fraction> v4_2=new ArrayFieldVector<Fraction>(vec4);String out1=v1.toString();Assert.assertTrue("some output ",out1.length()!= 0);try {v1.checkVectorDimensions(2);Assert.fail("MathIllegalArgumentException expected");}catch(MathIllegalArgumentException ex){}try {v1.checkVectorDimensions(v4);Assert.fail("MathIllegalArgumentException expected");}catch(MathIllegalArgumentException ex){}try {v1.checkVectorDimensions(v4_2);Assert.fail("MathIllegalArgumentException expected");}catch(MathIllegalArgumentException ex){}}
@Test public void testSerial(){ArrayFieldVector<Fraction> v=new ArrayFieldVector<Fraction>(vec1);Assert.assertEquals(v,TestUtils.serializeAndRecover(v));}
@Test public void testZeroVectors(){try {new ArrayFieldVector<Fraction>(new Fraction[0]);Assert.fail("MathIllegalArgumentException expected");}catch(MathIllegalArgumentException ex){}try {new ArrayFieldVector<Fraction>(new Fraction[0],true);Assert.fail("MathIllegalArgumentException expected");}catch(MathIllegalArgumentException ex){}try {new ArrayFieldVector<Fraction>(new Fraction[0],false);Assert.fail("MathIllegalArgumentException expected");}catch(MathIllegalArgumentException ex){}Assert.assertEquals(0,new ArrayFieldVector<Fraction>(FractionField.getInstance(),new Fraction[0]).getDimension());Assert.assertEquals(0,new ArrayFieldVector<Fraction>(FractionField.getInstance(),new Fraction[0],true).getDimension());Assert.assertEquals(0,new ArrayFieldVector<Fraction>(FractionField.getInstance(),new Fraction[0],false).getDimension());}
@Test public void testOuterProduct(){final ArrayFieldVector<Fraction> u=new ArrayFieldVector<Fraction>(FractionField.getInstance(),new Fraction[]{new Fraction(1),new Fraction(2),new Fraction(-3)});final ArrayFieldVector<Fraction> v=new ArrayFieldVector<Fraction>(FractionField.getInstance(),new Fraction[]{new Fraction(4),new Fraction(-2)});final FieldMatrix<Fraction> uv=u.outerProduct(v);final double tol=Math.ulp(1d);Assert.assertEquals(new Fraction(4).doubleValue(),uv.getEntry(0,0).doubleValue(),tol);Assert.assertEquals(new Fraction(-2).doubleValue(),uv.getEntry(0,1).doubleValue(),tol);Assert.assertEquals(new Fraction(8).doubleValue(),uv.getEntry(1,0).doubleValue(),tol);Assert.assertEquals(new Fraction(-4).doubleValue(),uv.getEntry(1,1).doubleValue(),tol);Assert.assertEquals(new Fraction(-12).doubleValue(),uv.getEntry(2,0).doubleValue(),tol);Assert.assertEquals(new Fraction(6).doubleValue(),uv.getEntry(2,1).doubleValue(),tol);}
@Test public void testConstructor(){Assert.assertEquals(1.625,new BigReal(new BigDecimal("1.625")).doubleValue(),1.0e-15);Assert.assertEquals(-5.0,new BigReal(new BigInteger("-5")).doubleValue(),1.0e-15);Assert.assertEquals(-5.0,new BigReal(new BigInteger("-5"),MathContext.DECIMAL64).doubleValue(),1.0e-15);Assert.assertEquals(0.125,new BigReal(new BigInteger("125"),3).doubleValue(),1.0e-15);Assert.assertEquals(0.125,new BigReal(new BigInteger("125"),3,MathContext.DECIMAL64).doubleValue(),1.0e-15);Assert.assertEquals(1.625,new BigReal(new char[]{'1','.','6','2','5'}).doubleValue(),1.0e-15);Assert.assertEquals(1.625,new BigReal(new char[]{'A','A','1','.','6','2','5','9'},2,5).doubleValue(),1.0e-15);Assert.assertEquals(1.625,new BigReal(new char[]{'A','A','1','.','6','2','5','9'},2,5,MathContext.DECIMAL64).doubleValue(),1.0e-15);Assert.assertEquals(1.625,new BigReal(new char[]{'1','.','6','2','5'},MathContext.DECIMAL64).doubleValue(),1.0e-15);Assert.assertEquals(1.625,new BigReal(1.625).doubleValue(),1.0e-15);Assert.assertEquals(1.625,new BigReal(1.625,MathContext.DECIMAL64).doubleValue(),1.0e-15);Assert.assertEquals(-5.0,new BigReal(-5).doubleValue(),1.0e-15);Assert.assertEquals(-5.0,new BigReal(-5,MathContext.DECIMAL64).doubleValue(),1.0e-15);Assert.assertEquals(-5.0,new BigReal(-5l).doubleValue(),1.0e-15);Assert.assertEquals(-5.0,new BigReal(-5l,MathContext.DECIMAL64).doubleValue(),1.0e-15);Assert.assertEquals(1.625,new BigReal("1.625").doubleValue(),1.0e-15);Assert.assertEquals(1.625,new BigReal("1.625",MathContext.DECIMAL64).doubleValue(),1.0e-15);}
@Test public void testCompareTo(){BigReal first=new BigReal(1.0 / 2.0);BigReal second=new BigReal(1.0 / 3.0);BigReal third=new BigReal(1.0 / 2.0);Assert.assertEquals(0,first.compareTo(first));Assert.assertEquals(0,first.compareTo(third));Assert.assertEquals(1,first.compareTo(second));Assert.assertEquals(-1,second.compareTo(first));}
@Test public void testAdd(){BigReal a=new BigReal("1.2345678");BigReal b=new BigReal("8.7654321");Assert.assertEquals(9.9999999,a.add(b).doubleValue(),1.0e-15);}
@Test public void testSubtract(){BigReal a=new BigReal("1.2345678");BigReal b=new BigReal("8.7654321");Assert.assertEquals(-7.5308643,a.subtract(b).doubleValue(),1.0e-15);}
@Test public void testNegate(){BigReal a=new BigReal("1.2345678");BigReal zero=new BigReal("0.0000000");Assert.assertEquals(a.negate().add(a),zero);Assert.assertEquals(a.add(a.negate()),zero);Assert.assertEquals(zero,zero.negate());}
@Test public void testDivide(){BigReal a=new BigReal("1.0000000000");BigReal b=new BigReal("0.0009765625");Assert.assertEquals(1024.0,a.divide(b).doubleValue(),1.0e-15);}
@Test public void testReciprocal(){BigReal a=new BigReal("1.2345678");double eps=FastMath.pow(10.,-a.getScale());BigReal one=new BigReal("1.0000000");BigReal b=a.reciprocal();BigReal r=one.subtract(a.multiply(b));Assert.assertTrue(FastMath.abs(r.doubleValue())<= eps);r=one.subtract(b.multiply(a));Assert.assertTrue(FastMath.abs(r.doubleValue())<= eps);}
@Test public void testMultiply(){BigReal a=new BigReal("1024.0");BigReal b=new BigReal("0.0009765625");Assert.assertEquals(1.0,a.multiply(b).doubleValue(),1.0e-15);int n=1024;Assert.assertEquals(1.0,b.multiply(n).doubleValue(),1.0e-15);}
@Test public void testDoubleValue(){Assert.assertEquals(0.5,new BigReal(0.5).doubleValue(),1.0e-15);}
@Test public void testBigDecimalValue(){BigDecimal pi=new BigDecimal("3.1415926535897932384626433832795028841971693993751");Assert.assertEquals(pi,new BigReal(pi).bigDecimalValue());Assert.assertEquals(new BigDecimal(0.5),new BigReal(1.0 / 2.0).bigDecimalValue());}
@Test public void testEqualsAndHashCode(){BigReal zero=new BigReal(0.0);BigReal nullReal=null;Assert.assertTrue(zero.equals(zero));Assert.assertFalse(zero.equals(nullReal));Assert.assertFalse(zero.equals(Double.valueOf(0)));BigReal zero2=new BigReal(0.0);Assert.assertTrue(zero.equals(zero2));Assert.assertEquals(zero.hashCode(),zero2.hashCode());BigReal one=new BigReal(1.0);Assert.assertFalse((one.equals(zero)|| zero.equals(one)));Assert.assertTrue(one.equals(BigReal.ONE));}
@Test public void testSerial(){BigReal[]Reals={new BigReal(3.0),BigReal.ONE,BigReal.ZERO,new BigReal(17),new BigReal(FastMath.PI),new BigReal(-2.5)};for(BigReal Real : Reals){Assert.assertEquals(Real,TestUtils.serializeAndRecover(Real));}}
@Test public void testMinMaxDouble(){double[][]pairs={{-50.0,50.0},{Double.POSITIVE_INFINITY,1.0},{Double.NEGATIVE_INFINITY,1.0},{Double.NaN,1.0},{Double.POSITIVE_INFINITY,0.0},{Double.NEGATIVE_INFINITY,0.0},{Double.NaN,0.0},{Double.NaN,Double.NEGATIVE_INFINITY},{Double.NaN,Double.POSITIVE_INFINITY},{Precision.SAFE_MIN,Precision.EPSILON}};for(double[]pair : pairs){Assert.assertEquals("min(" + pair[0]+ ","+ pair[1]+ ")",Math.min(pair[0],pair[1]),FastMath.min(pair[0],pair[1]),Precision.EPSILON);Assert.assertEquals("min(" + pair[1]+ ","+ pair[0]+ ")",Math.min(pair[1],pair[0]),FastMath.min(pair[1],pair[0]),Precision.EPSILON);Assert.assertEquals("max(" + pair[0]+ ","+ pair[1]+ ")",Math.max(pair[0],pair[1]),FastMath.max(pair[0],pair[1]),Precision.EPSILON);Assert.assertEquals("max(" + pair[1]+ ","+ pair[0]+ ")",Math.max(pair[1],pair[0]),FastMath.max(pair[1],pair[0]),Precision.EPSILON);}}
@Test public void testMinMaxFloat(){float[][]pairs={{-50.0f,50.0f},{Float.POSITIVE_INFINITY,1.0f},{Float.NEGATIVE_INFINITY,1.0f},{Float.NaN,1.0f},{Float.POSITIVE_INFINITY,0.0f},{Float.NEGATIVE_INFINITY,0.0f},{Float.NaN,0.0f},{Float.NaN,Float.NEGATIVE_INFINITY},{Float.NaN,Float.POSITIVE_INFINITY}};for(float[]pair : pairs){Assert.assertEquals("min(" + pair[0]+ ","+ pair[1]+ ")",Math.min(pair[0],pair[1]),FastMath.min(pair[0],pair[1]),Precision.EPSILON);Assert.assertEquals("min(" + pair[1]+ ","+ pair[0]+ ")",Math.min(pair[1],pair[0]),FastMath.min(pair[1],pair[0]),Precision.EPSILON);Assert.assertEquals("max(" + pair[0]+ ","+ pair[1]+ ")",Math.max(pair[0],pair[1]),FastMath.max(pair[0],pair[1]),Precision.EPSILON);Assert.assertEquals("max(" + pair[1]+ ","+ pair[0]+ ")",Math.max(pair[1],pair[0]),FastMath.max(pair[1],pair[0]),Precision.EPSILON);}}
@Test public void testConstants(){Assert.assertEquals(Math.PI,FastMath.PI,1.0e-20);Assert.assertEquals(Math.E,FastMath.E,1.0e-20);}
@Test public void testAtan2(){double y1=1.2713504628280707e10;double x1=-5.674940885228782e-10;Assert.assertEquals(Math.atan2(y1,x1),FastMath.atan2(y1,x1),2 * Precision.EPSILON);double y2=0.0;double x2=Double.POSITIVE_INFINITY;Assert.assertEquals(Math.atan2(y2,x2),FastMath.atan2(y2,x2),Precision.SAFE_MIN);}
@Test public void testHyperbolic(){double maxErr=0;for (double x=-30;x < 30;x+=0.001){double tst=FastMath.sinh(x);double ref=Math.sinh(x);maxErr=FastMath.max(maxErr,FastMath.abs(ref - tst)/ FastMath.ulp(ref));}Assert.assertEquals(0,maxErr,2);maxErr=0;for (double x=-30;x < 30;x+=0.001){double tst=FastMath.cosh(x);double ref=Math.cosh(x);maxErr=FastMath.max(maxErr,FastMath.abs(ref - tst)/ FastMath.ulp(ref));}Assert.assertEquals(0,maxErr,2);maxErr=0;for (double x=-0.5;x < 0.5;x+=0.001){double tst=FastMath.tanh(x);double ref=Math.tanh(x);maxErr=FastMath.max(maxErr,FastMath.abs(ref - tst)/ FastMath.ulp(ref));}Assert.assertEquals(0,maxErr,4);}
@Test public void testHyperbolicInverses(){double maxErr=0;for (double x=-30;x < 30;x+=0.01){maxErr=FastMath.max(maxErr,FastMath.abs(x - FastMath.sinh(FastMath.asinh(x)))/ (2 * FastMath.ulp(x)));}Assert.assertEquals(0,maxErr,3);maxErr=0;for (double x=1;x < 30;x+=0.01){maxErr=FastMath.max(maxErr,FastMath.abs(x - FastMath.cosh(FastMath.acosh(x)))/ (2 * FastMath.ulp(x)));}Assert.assertEquals(0,maxErr,2);maxErr=0;for (double x=-1 + Precision.EPSILON;x < 1 - Precision.EPSILON;x+=0.0001){maxErr=FastMath.max(maxErr,FastMath.abs(x - FastMath.tanh(FastMath.atanh(x)))/ (2 * FastMath.ulp(x)));}Assert.assertEquals(0,maxErr,2);}
@Test public void testLogAccuracy(){double maxerrulp=0.0;for (int i=0;i < NUMBER_OF_TRIALS;i++){double x=Math.exp(generator.nextDouble()* 1416.0 - 708.0)* generator.nextDouble();double tst=FastMath.log(x);double ref=DfpMath.log(field.newDfp(x)).toDouble();double err=(tst - ref)/ ref;if (err != 0.0){double ulp=Math.abs(ref - Double.longBitsToDouble((Double.doubleToLongBits(ref)^ 1)));double errulp=field.newDfp(tst).subtract(DfpMath.log(field.newDfp(x))).divide(field.newDfp(ulp)).toDouble();maxerrulp=Math.max(maxerrulp,Math.abs(errulp));}}Assert.assertTrue("log()had errors in excess of " + MAX_ERROR_ULP + " ULP",maxerrulp < MAX_ERROR_ULP);}
@Test public void testLog10Accuracy(){double maxerrulp=0.0;for (int i=0;i < NUMBER_OF_TRIALS;i++){double x=Math.exp(generator.nextDouble()* 1416.0 - 708.0)* generator.nextDouble();double tst=FastMath.log10(x);double ref=DfpMath.log(field.newDfp(x)).divide(DfpMath.log(field.newDfp("10"))).toDouble();double err=(tst - ref)/ ref;if (err != 0.0){double ulp=Math.abs(ref - Double.longBitsToDouble((Double.doubleToLongBits(ref)^ 1)));double errulp=field.newDfp(tst).subtract(DfpMath.log(field.newDfp(x)).divide(DfpMath.log(field.newDfp("10")))).divide(field.newDfp(ulp)).toDouble();maxerrulp=Math.max(maxerrulp,Math.abs(errulp));}}Assert.assertTrue("log10()had errors in excess of " + MAX_ERROR_ULP + " ULP",maxerrulp < MAX_ERROR_ULP);}
@Test public void testLog1pAccuracy(){double maxerrulp=0.0;for (int i=0;i < NUMBER_OF_TRIALS;i++){double x=Math.exp(generator.nextDouble()* 10.0 - 5.0)* generator.nextDouble();double tst=FastMath.log1p(x);double ref=DfpMath.log(field.newDfp(x).add(field.getOne())).toDouble();double err=(tst - ref)/ ref;if (err != 0.0){double ulp=Math.abs(ref - Double.longBitsToDouble((Double.doubleToLongBits(ref)^ 1)));double errulp=field.newDfp(tst).subtract(DfpMath.log(field.newDfp(x).add(field.getOne()))).divide(field.newDfp(ulp)).toDouble();maxerrulp=Math.max(maxerrulp,Math.abs(errulp));}}Assert.assertTrue("log1p()had errors in excess of " + MAX_ERROR_ULP + " ULP",maxerrulp < MAX_ERROR_ULP);}
@Test public void testLog1pSpecialCases(){Assert.assertTrue("Logp of -1.0 should be -Inf",Double.isInfinite(FastMath.log1p(-1.0)));}
@Test public void testLogSpecialCases(){Assert.assertTrue("Log of zero should be -Inf",Double.isInfinite(FastMath.log(0.0)));Assert.assertTrue("Log of -zero should be -Inf",Double.isInfinite(FastMath.log(-0.0)));Assert.assertTrue("Log of NaN should be NaN",Double.isNaN(FastMath.log(Double.NaN)));Assert.assertTrue("Log of negative number should be NaN",Double.isNaN(FastMath.log(-1.0)));Assert.assertEquals("Log of Double.MIN_VALUE should be -744.4400719213812",-744.4400719213812,FastMath.log(Double.MIN_VALUE),Precision.EPSILON);Assert.assertTrue("Log of infinity should be infinity",Double.isInfinite(FastMath.log(Double.POSITIVE_INFINITY)));}
@Test public void testExpSpecialCases(){Assert.assertEquals(Double.MIN_VALUE,FastMath.exp(-745.1332191019411),Precision.EPSILON);Assert.assertEquals("exp(-745.1332191019412)should be 0.0",0.0,FastMath.exp(-745.1332191019412),Precision.EPSILON);Assert.assertTrue("exp of NaN should be NaN",Double.isNaN(FastMath.exp(Double.NaN)));Assert.assertTrue("exp of infinity should be infinity",Double.isInfinite(FastMath.exp(Double.POSITIVE_INFINITY)));Assert.assertEquals("exp of -infinity should be 0.0",0.0,FastMath.exp(Double.NEGATIVE_INFINITY),Precision.EPSILON);Assert.assertEquals("exp(1)should be Math.E",Math.E,FastMath.exp(1.0),Precision.EPSILON);}
@Test public void testPowSpecialCases(){Assert.assertEquals("pow(-1,0)should be 1.0",1.0,FastMath.pow(-1.0,0.0),Precision.EPSILON);Assert.assertEquals("pow(-1,-0)should be 1.0",1.0,FastMath.pow(-1.0,-0.0),Precision.EPSILON);Assert.assertEquals("pow(PI,1.0)should be PI",FastMath.PI,FastMath.pow(FastMath.PI,1.0),Precision.EPSILON);Assert.assertEquals("pow(-PI,1.0)should be -PI",-FastMath.PI,FastMath.pow(-FastMath.PI,1.0),Precision.EPSILON);Assert.assertTrue("pow(PI,NaN)should be NaN",Double.isNaN(FastMath.pow(Math.PI,Double.NaN)));Assert.assertTrue("pow(NaN,PI)should be NaN",Double.isNaN(FastMath.pow(Double.NaN,Math.PI)));Assert.assertTrue("pow(2.0,Infinity)should be Infinity",Double.isInfinite(FastMath.pow(2.0,Double.POSITIVE_INFINITY)));Assert.assertTrue("pow(0.5,-Infinity)should be Infinity",Double.isInfinite(FastMath.pow(0.5,Double.NEGATIVE_INFINITY)));Assert.assertEquals("pow(0.5,Infinity)should be 0.0",0.0,FastMath.pow(0.5,Double.POSITIVE_INFINITY),Precision.EPSILON);Assert.assertEquals("pow(2.0,-Infinity)should be 0.0",0.0,FastMath.pow(2.0,Double.NEGATIVE_INFINITY),Precision.EPSILON);Assert.assertEquals("pow(0.0,0.5)should be 0.0",0.0,FastMath.pow(0.0,0.5),Precision.EPSILON);Assert.assertEquals("pow(Infinity,-0.5)should be 0.0",0.0,FastMath.pow(Double.POSITIVE_INFINITY,-0.5),Precision.EPSILON);Assert.assertTrue("pow(0.0,-0.5)should be Inf",Double.isInfinite(FastMath.pow(0.0,-0.5)));Assert.assertTrue("pow(Inf,0.5)should be Inf",Double.isInfinite(FastMath.pow(Double.POSITIVE_INFINITY,0.5)));Assert.assertTrue("pow(-0.0,-3.0)should be -Inf",Double.isInfinite(FastMath.pow(-0.0,-3.0)));Assert.assertTrue("pow(-Inf,-3.0)should be -Inf",Double.isInfinite(FastMath.pow(Double.NEGATIVE_INFINITY,3.0)));Assert.assertTrue("pow(-0.0,-3.5)should be Inf",Double.isInfinite(FastMath.pow(-0.0,-3.5)));Assert.assertTrue("pow(Inf,3.5)should be Inf",Double.isInfinite(FastMath.pow(Double.POSITIVE_INFINITY,3.5)));Assert.assertEquals("pow(-2.0,3.0)should be -8.0",-8.0,FastMath.pow(-2.0,3.0),Precision.EPSILON);Assert.assertTrue("pow(-2.0,3.5)should be NaN",Double.isNaN(FastMath.pow(-2.0,3.5)));Assert.assertTrue("pow(+Inf,NaN)should be NaN",Double.isNaN(FastMath.pow(Double.POSITIVE_INFINITY,Double.NaN)));Assert.assertTrue("pow(1.0,+Inf)should be NaN",Double.isNaN(FastMath.pow(1.0,Double.POSITIVE_INFINITY)));Assert.assertTrue("pow(-Inf,NaN)should be NaN",Double.isNaN(FastMath.pow(Double.NEGATIVE_INFINITY,Double.NaN)));Assert.assertEquals("pow(-Inf,-1.0)should be 0.0",0.0,FastMath.pow(Double.NEGATIVE_INFINITY,-1.0),Precision.EPSILON);Assert.assertEquals("pow(-Inf,-2.0)should be 0.0",0.0,FastMath.pow(Double.NEGATIVE_INFINITY,-2.0),Precision.EPSILON);Assert.assertTrue("pow(-Inf,1.0)should be -Inf",Double.isInfinite(FastMath.pow(Double.NEGATIVE_INFINITY,1.0)));Assert.assertTrue("pow(-Inf,2.0)should be +Inf",Double.isInfinite(FastMath.pow(Double.NEGATIVE_INFINITY,2.0)));Assert.assertTrue("pow(1.0,-Inf)should be NaN",Double.isNaN(FastMath.pow(1.0,Double.NEGATIVE_INFINITY)));}
@Test public void testAtan2SpecialCases(){Assert.assertTrue("atan2(NaN,0.0)should be NaN",Double.isNaN(FastMath.atan2(Double.NaN,0.0)));Assert.assertTrue("atan2(0.0,NaN)should be NaN",Double.isNaN(FastMath.atan2(0.0,Double.NaN)));Assert.assertEquals("atan2(0.0,0.0)should be 0.0",0.0,FastMath.atan2(0.0,0.0),Precision.EPSILON);Assert.assertEquals("atan2(0.0,0.001)should be 0.0",0.0,FastMath.atan2(0.0,0.001),Precision.EPSILON);Assert.assertEquals("atan2(0.1,+Inf)should be 0.0",0.0,FastMath.atan2(0.1,Double.POSITIVE_INFINITY),Precision.EPSILON);Assert.assertEquals("atan2(-0.0,0.0)should be -0.0",-0.0,FastMath.atan2(-0.0,0.0),Precision.EPSILON);Assert.assertEquals("atan2(-0.0,0.001)should be -0.0",-0.0,FastMath.atan2(-0.0,0.001),Precision.EPSILON);Assert.assertEquals("atan2(-0.0,+Inf)should be -0.0",-0.0,FastMath.atan2(-0.1,Double.POSITIVE_INFINITY),Precision.EPSILON);Assert.assertEquals("atan2(0.0,-0.0)should be PI",FastMath.PI,FastMath.atan2(0.0,-0.0),Precision.EPSILON);Assert.assertEquals("atan2(0.1,-Inf)should be PI",FastMath.PI,FastMath.atan2(0.1,Double.NEGATIVE_INFINITY),Precision.EPSILON);Assert.assertEquals("atan2(-0.0,-0.0)should be -PI",-FastMath.PI,FastMath.atan2(-0.0,-0.0),Precision.EPSILON);Assert.assertEquals("atan2(0.1,-Inf)should be -PI",-FastMath.PI,FastMath.atan2(-0.1,Double.NEGATIVE_INFINITY),Precision.EPSILON);Assert.assertEquals("atan2(0.1,0.0)should be PI/2",FastMath.PI / 2.0,FastMath.atan2(0.1,0.0),Precision.EPSILON);Assert.assertEquals("atan2(0.1,-0.0)should be PI/2",FastMath.PI / 2.0,FastMath.atan2(0.1,-0.0),Precision.EPSILON);Assert.assertEquals("atan2(Inf,0.1)should be PI/2",FastMath.PI / 2.0,FastMath.atan2(Double.POSITIVE_INFINITY,0.1),Precision.EPSILON);Assert.assertEquals("atan2(Inf,-0.1)should be PI/2",FastMath.PI / 2.0,FastMath.atan2(Double.POSITIVE_INFINITY,-0.1),Precision.EPSILON);Assert.assertEquals("atan2(-0.1,0.0)should be -PI/2",-FastMath.PI / 2.0,FastMath.atan2(-0.1,0.0),Precision.EPSILON);Assert.assertEquals("atan2(-0.1,-0.0)should be -PI/2",-FastMath.PI / 2.0,FastMath.atan2(-0.1,-0.0),Precision.EPSILON);Assert.assertEquals("atan2(-Inf,0.1)should be -PI/2",-FastMath.PI / 2.0,FastMath.atan2(Double.NEGATIVE_INFINITY,0.1),Precision.EPSILON);Assert.assertEquals("atan2(-Inf,-0.1)should be -PI/2",-FastMath.PI / 2.0,FastMath.atan2(Double.NEGATIVE_INFINITY,-0.1),Precision.EPSILON);Assert.assertEquals("atan2(Inf,Inf)should be PI/4",FastMath.PI / 4.0,FastMath.atan2(Double.POSITIVE_INFINITY,Double.POSITIVE_INFINITY),Precision.EPSILON);Assert.assertEquals("atan2(Inf,-Inf)should be PI * 3/4",FastMath.PI * 3.0 / 4.0,FastMath.atan2(Double.POSITIVE_INFINITY,Double.NEGATIVE_INFINITY),Precision.EPSILON);Assert.assertEquals("atan2(-Inf,Inf)should be -PI/4",-FastMath.PI / 4.0,FastMath.atan2(Double.NEGATIVE_INFINITY,Double.POSITIVE_INFINITY),Precision.EPSILON);Assert.assertEquals("atan2(-Inf,-Inf)should be -PI * 3/4",-FastMath.PI * 3.0 / 4.0,FastMath.atan2(Double.NEGATIVE_INFINITY,Double.NEGATIVE_INFINITY),Precision.EPSILON);}
@Test public void testPowAccuracy(){double maxerrulp=0.0;for (int i=0;i < NUMBER_OF_TRIALS;i++){double x=(generator.nextDouble()* 2.0 + 0.25);double y=(generator.nextDouble()* 1200.0 - 600.0)* generator.nextDouble();double tst=FastMath.pow(x,y);double ref=DfpMath.pow(field.newDfp(x),field.newDfp(y)).toDouble();double err=(tst - ref)/ ref;if (err != 0){double ulp=Math.abs(ref - Double.longBitsToDouble((Double.doubleToLongBits(ref)^ 1)));double errulp=field.newDfp(tst).subtract(DfpMath.pow(field.newDfp(x),field.newDfp(y))).divide(field.newDfp(ulp)).toDouble();maxerrulp=Math.max(maxerrulp,Math.abs(errulp));}}Assert.assertTrue("pow()had errors in excess of " + MAX_ERROR_ULP + " ULP",maxerrulp < MAX_ERROR_ULP);}
@Test public void testExpAccuracy(){double maxerrulp=0.0;for (int i=0;i < NUMBER_OF_TRIALS;i++){double x=((generator.nextDouble()* 1416.0)- 708.0)* generator.nextDouble();double tst=FastMath.exp(x);double ref=DfpMath.exp(field.newDfp(x)).toDouble();double err=(tst - ref)/ ref;if (err != 0){double ulp=Math.abs(ref - Double.longBitsToDouble((Double.doubleToLongBits(ref)^ 1)));double errulp=field.newDfp(tst).subtract(DfpMath.exp(field.newDfp(x))).divide(field.newDfp(ulp)).toDouble();maxerrulp=Math.max(maxerrulp,Math.abs(errulp));}}Assert.assertTrue("exp()had errors in excess of " + MAX_ERROR_ULP + " ULP",maxerrulp < MAX_ERROR_ULP);}
@Test public void testSinAccuracy(){double maxerrulp=0.0;for (int i=0;i < NUMBER_OF_TRIALS;i++){double x=((generator.nextDouble()* Math.PI)- Math.PI / 2.0)* Math.pow(2,21)* generator.nextDouble();double tst=FastMath.sin(x);double ref=DfpMath.sin(field.newDfp(x)).toDouble();double err=(tst - ref)/ ref;if (err != 0){double ulp=Math.abs(ref - Double.longBitsToDouble((Double.doubleToLongBits(ref)^ 1)));double errulp=field.newDfp(tst).subtract(DfpMath.sin(field.newDfp(x))).divide(field.newDfp(ulp)).toDouble();maxerrulp=Math.max(maxerrulp,Math.abs(errulp));}}Assert.assertTrue("sin()had errors in excess of " + MAX_ERROR_ULP + " ULP",maxerrulp < MAX_ERROR_ULP);}
@Test public void testCosAccuracy(){double maxerrulp=0.0;for (int i=0;i < NUMBER_OF_TRIALS;i++){double x=((generator.nextDouble()* Math.PI)- Math.PI / 2.0)* Math.pow(2,21)* generator.nextDouble();double tst=FastMath.cos(x);double ref=DfpMath.cos(field.newDfp(x)).toDouble();double err=(tst - ref)/ ref;if (err != 0){double ulp=Math.abs(ref - Double.longBitsToDouble((Double.doubleToLongBits(ref)^ 1)));double errulp=field.newDfp(tst).subtract(DfpMath.cos(field.newDfp(x))).divide(field.newDfp(ulp)).toDouble();maxerrulp=Math.max(maxerrulp,Math.abs(errulp));}}Assert.assertTrue("cos()had errors in excess of " + MAX_ERROR_ULP + " ULP",maxerrulp < MAX_ERROR_ULP);}
@Test public void testTanAccuracy(){double maxerrulp=0.0;for (int i=0;i < NUMBER_OF_TRIALS;i++){double x=((generator.nextDouble()* Math.PI)- Math.PI / 2.0)* Math.pow(2,12)* generator.nextDouble();double tst=FastMath.tan(x);double ref=DfpMath.tan(field.newDfp(x)).toDouble();double err=(tst - ref)/ ref;if (err != 0){double ulp=Math.abs(ref - Double.longBitsToDouble((Double.doubleToLongBits(ref)^ 1)));double errulp=field.newDfp(tst).subtract(DfpMath.tan(field.newDfp(x))).divide(field.newDfp(ulp)).toDouble();maxerrulp=Math.max(maxerrulp,Math.abs(errulp));}}Assert.assertTrue("tan()had errors in excess of " + MAX_ERROR_ULP + " ULP",maxerrulp < MAX_ERROR_ULP);}
@Test public void testAtanAccuracy(){double maxerrulp=0.0;for (int i=0;i < NUMBER_OF_TRIALS;i++){double x=((generator.nextDouble()* 16.0)- 8.0)* generator.nextDouble();double tst=FastMath.atan(x);double ref=DfpMath.atan(field.newDfp(x)).toDouble();double err=(tst - ref)/ ref;if (err != 0){double ulp=Math.abs(ref - Double.longBitsToDouble((Double.doubleToLongBits(ref)^ 1)));double errulp=field.newDfp(tst).subtract(DfpMath.atan(field.newDfp(x))).divide(field.newDfp(ulp)).toDouble();maxerrulp=Math.max(maxerrulp,Math.abs(errulp));}}Assert.assertTrue("atan()had errors in excess of " + MAX_ERROR_ULP + " ULP",maxerrulp < MAX_ERROR_ULP);}
@Test public void testAtan2Accuracy(){double maxerrulp=0.0;for (int i=0;i < NUMBER_OF_TRIALS;i++){double x=generator.nextDouble()- 0.5;double y=generator.nextDouble()- 0.5;double tst=FastMath.atan2(y,x);Dfp refdfp=DfpMath.atan(field.newDfp(y).divide(field.newDfp(x)));if (x < 0.0){if (y > 0.0)refdfp=field.getPi().add(refdfp);else       refdfp=refdfp.subtract(field.getPi());}double ref=refdfp.toDouble();double err=(tst - ref)/ ref;if (err != 0){double ulp=Math.abs(ref - Double.longBitsToDouble((Double.doubleToLongBits(ref)^ 1)));double errulp=field.newDfp(tst).subtract(refdfp).divide(field.newDfp(ulp)).toDouble();maxerrulp=Math.max(maxerrulp,Math.abs(errulp));}}Assert.assertTrue("atan2()had errors in excess of " + MAX_ERROR_ULP + " ULP",maxerrulp < MAX_ERROR_ULP);}
@Test public void testExpm1Accuracy(){double maxerrulp=0.0;for (int i=0;i < NUMBER_OF_TRIALS;i++){double x=((generator.nextDouble()* 16.0)- 8.0)* generator.nextDouble();double tst=FastMath.expm1(x);double ref=DfpMath.exp(field.newDfp(x)).subtract(field.getOne()).toDouble();double err=(tst - ref)/ ref;if (err != 0){double ulp=Math.abs(ref - Double.longBitsToDouble((Double.doubleToLongBits(ref)^ 1)));double errulp=field.newDfp(tst).subtract(DfpMath.exp(field.newDfp(x)).subtract(field.getOne())).divide(field.newDfp(ulp)).toDouble();maxerrulp=Math.max(maxerrulp,Math.abs(errulp));}}Assert.assertTrue("expm1()had errors in excess of " + MAX_ERROR_ULP + " ULP",maxerrulp < MAX_ERROR_ULP);}
@Test public void testAsinAccuracy(){double maxerrulp=0.0;for (int i=0;i < 10000;i++){double x=((generator.nextDouble()* 2.0)- 1.0)* generator.nextDouble();double tst=FastMath.asin(x);double ref=DfpMath.asin(field.newDfp(x)).toDouble();double err=(tst - ref)/ ref;if (err != 0){double ulp=Math.abs(ref - Double.longBitsToDouble((Double.doubleToLongBits(ref)^ 1)));double errulp=field.newDfp(tst).subtract(DfpMath.asin(field.newDfp(x))).divide(field.newDfp(ulp)).toDouble();maxerrulp=Math.max(maxerrulp,Math.abs(errulp));}}Assert.assertTrue("asin()had errors in excess of " + MAX_ERROR_ULP + " ULP",maxerrulp < MAX_ERROR_ULP);}
@Test public void testAcosAccuracy(){double maxerrulp=0.0;for (int i=0;i < 10000;i++){double x=((generator.nextDouble()* 2.0)- 1.0)* generator.nextDouble();double tst=FastMath.acos(x);double ref=DfpMath.acos(field.newDfp(x)).toDouble();double err=(tst - ref)/ ref;if (err != 0){double ulp=Math.abs(ref - Double.longBitsToDouble((Double.doubleToLongBits(ref)^ 1)));double errulp=field.newDfp(tst).subtract(DfpMath.acos(field.newDfp(x))).divide(field.newDfp(ulp)).toDouble();maxerrulp=Math.max(maxerrulp,Math.abs(errulp));}}Assert.assertTrue("acos()had errors in excess of " + MAX_ERROR_ULP + " ULP",maxerrulp < MAX_ERROR_ULP);}
/** * Added tests for a 100% coverage of acos().*/@Test public void testAcosSpecialCases(){Assert.assertTrue("acos(NaN)should be NaN",Double.isNaN(FastMath.acos(Double.NaN)));Assert.assertTrue("acos(-1.1)should be NaN",Double.isNaN(FastMath.acos(-1.1)));Assert.assertTrue("acos(-1.1)should be NaN",Double.isNaN(FastMath.acos(1.1)));Assert.assertEquals("acos(-1.0)should be PI",FastMath.acos(-1.0),FastMath.PI,Precision.EPSILON);Assert.assertEquals("acos(1.0)should be 0.0",FastMath.acos(1.0),0.0,Precision.EPSILON);Assert.assertEquals("acos(0.0)should be PI/2",FastMath.acos(0.0),FastMath.PI / 2.0,Precision.EPSILON);}
/** * Added tests for a 100% coverage of asin().*/@Test public void testAsinSpecialCases(){Assert.assertTrue("asin(NaN)should be NaN",Double.isNaN(FastMath.asin(Double.NaN)));Assert.assertTrue("asin(1.1)should be NaN",Double.isNaN(FastMath.asin(1.1)));Assert.assertTrue("asin(-1.1)should be NaN",Double.isNaN(FastMath.asin(-1.1)));Assert.assertEquals("asin(1.0)should be PI/2",FastMath.asin(1.0),FastMath.PI / 2.0,Precision.EPSILON);Assert.assertEquals("asin(-1.0)should be -PI/2",FastMath.asin(-1.0),-FastMath.PI / 2.0,Precision.EPSILON);Assert.assertEquals("asin(0.0)should be 0.0",FastMath.asin(0.0),0.0,Precision.EPSILON);}
@Test public void testSinhAccuracy(){double maxerrulp=0.0;for (int i=0;i < 10000;i++){double x=((generator.nextDouble()* 16.0)- 8.0)* generator.nextDouble();double tst=FastMath.sinh(x);double ref=sinh(field.newDfp(x)).toDouble();double err=(tst - ref)/ ref;if (err != 0){double ulp=Math.abs(ref - Double.longBitsToDouble((Double.doubleToLongBits(ref)^ 1)));double errulp=field.newDfp(tst).subtract(sinh(field.newDfp(x))).divide(field.newDfp(ulp)).toDouble();maxerrulp=Math.max(maxerrulp,Math.abs(errulp));}}Assert.assertTrue("sinh()had errors in excess of " + MAX_ERROR_ULP + " ULP",maxerrulp < MAX_ERROR_ULP);}
@Test public void testCoshAccuracy(){double maxerrulp=0.0;for (int i=0;i < 10000;i++){double x=((generator.nextDouble()* 16.0)- 8.0)* generator.nextDouble();double tst=FastMath.cosh(x);double ref=cosh(field.newDfp(x)).toDouble();double err=(tst - ref)/ ref;if (err != 0){double ulp=Math.abs(ref - Double.longBitsToDouble((Double.doubleToLongBits(ref)^ 1)));double errulp=field.newDfp(tst).subtract(cosh(field.newDfp(x))).divide(field.newDfp(ulp)).toDouble();maxerrulp=Math.max(maxerrulp,Math.abs(errulp));}}Assert.assertTrue("cosh()had errors in excess of " + MAX_ERROR_ULP + " ULP",maxerrulp < MAX_ERROR_ULP);}
@Test public void testTanhAccuracy(){double maxerrulp=0.0;for (int i=0;i < 10000;i++){double x=((generator.nextDouble()* 16.0)- 8.0)* generator.nextDouble();double tst=FastMath.tanh(x);double ref=tanh(field.newDfp(x)).toDouble();double err=(tst - ref)/ ref;if (err != 0){double ulp=Math.abs(ref - Double.longBitsToDouble((Double.doubleToLongBits(ref)^ 1)));double errulp=field.newDfp(tst).subtract(tanh(field.newDfp(x))).divide(field.newDfp(ulp)).toDouble();maxerrulp=Math.max(maxerrulp,Math.abs(errulp));}}Assert.assertTrue("tanh()had errors in excess of " + MAX_ERROR_ULP + " ULP",maxerrulp < MAX_ERROR_ULP);}
@Test public void testCbrtAccuracy(){double maxerrulp=0.0;for (int i=0;i < 10000;i++){double x=((generator.nextDouble()* 200.0)- 100.0)* generator.nextDouble();double tst=FastMath.cbrt(x);double ref=cbrt(field.newDfp(x)).toDouble();double err=(tst - ref)/ ref;if (err != 0){double ulp=Math.abs(ref - Double.longBitsToDouble((Double.doubleToLongBits(ref)^ 1)));double errulp=field.newDfp(tst).subtract(cbrt(field.newDfp(x))).divide(field.newDfp(ulp)).toDouble();maxerrulp=Math.max(maxerrulp,Math.abs(errulp));}}Assert.assertTrue("cbrt()had errors in excess of " + MAX_ERROR_ULP + " ULP",maxerrulp < MAX_ERROR_ULP);}
@Test public void testToDegrees(){double maxerrulp=0.0;for (int i=0;i < NUMBER_OF_TRIALS;i++){double x=generator.nextDouble();double tst=field.newDfp(x).multiply(180).divide(field.getPi()).toDouble();double ref=FastMath.toDegrees(x);double err=(tst - ref)/ ref;if (err != 0){double ulp=Math.abs(ref - Double.longBitsToDouble((Double.doubleToLongBits(ref)^ 1)));double errulp=field.newDfp(tst).subtract(DfpMath.exp(field.newDfp(x)).subtract(field.getOne())).divide(field.newDfp(ulp)).toDouble();maxerrulp=Math.max(maxerrulp,Math.abs(errulp));}}Assert.assertTrue("toDegrees()had errors in excess of " + MAX_ERROR_ULP + " ULP",maxerrulp < MAX_ERROR_ULP);}
@Test public void testToRadians(){double maxerrulp=0.0;for (int i=0;i < NUMBER_OF_TRIALS;i++){double x=generator.nextDouble();double tst=field.newDfp(x).multiply(field.getPi()).divide(180).toDouble();double ref=FastMath.toRadians(x);double err=(tst - ref)/ ref;if (err != 0){double ulp=Math.abs(ref - Double.longBitsToDouble((Double.doubleToLongBits(ref)^ 1)));double errulp=field.newDfp(tst).subtract(DfpMath.exp(field.newDfp(x)).subtract(field.getOne())).divide(field.newDfp(ulp)).toDouble();maxerrulp=Math.max(maxerrulp,Math.abs(errulp));}}Assert.assertTrue("toRadians()had errors in excess of " + MAX_ERROR_ULP + " ULP",maxerrulp < MAX_ERROR_ULP);}
@Test public void testNextAfter(){Assert.assertEquals(16.0,FastMath.nextAfter(15.999999999999998,34.27555555555555),0.0);Assert.assertEquals(-15.999999999999996,FastMath.nextAfter(-15.999999999999998,34.27555555555555),0.0);Assert.assertEquals(15.999999999999996,FastMath.nextAfter(15.999999999999998,2.142222222222222),0.0);Assert.assertEquals(-15.999999999999996,FastMath.nextAfter(-15.999999999999998,2.142222222222222),0.0);Assert.assertEquals(8.000000000000002,FastMath.nextAfter(8.0,34.27555555555555),0.0);Assert.assertEquals(-7.999999999999999,FastMath.nextAfter(-8.0,34.27555555555555),0.0);Assert.assertEquals(7.999999999999999,FastMath.nextAfter(8.0,2.142222222222222),0.0);Assert.assertEquals(-7.999999999999999,FastMath.nextAfter(-8.0,2.142222222222222),0.0);Assert.assertEquals(2.308922399667661E-4,FastMath.nextAfter(2.3089223996676606E-4,2.308922399667661E-4),0.0);Assert.assertEquals(2.3089223996676606E-4,FastMath.nextAfter(2.3089223996676606E-4,2.3089223996676606E-4),0.0);Assert.assertEquals(2.3089223996676603E-4,FastMath.nextAfter(2.3089223996676606E-4,2.3089223996676603E-4),0.0);Assert.assertEquals(2.3089223996676603E-4,FastMath.nextAfter(2.3089223996676606E-4,-2.308922399667661E-4),0.0);Assert.assertEquals(2.3089223996676603E-4,FastMath.nextAfter(2.3089223996676606E-4,-2.3089223996676606E-4),0.0);Assert.assertEquals(2.3089223996676603E-4,FastMath.nextAfter(2.3089223996676606E-4,-2.3089223996676603E-4),0.0);Assert.assertEquals(-2.3089223996676603E-4,FastMath.nextAfter(-2.3089223996676606E-4,2.308922399667661E-4),0.0);Assert.assertEquals(-2.3089223996676603E-4,FastMath.nextAfter(-2.3089223996676606E-4,2.3089223996676606E-4),0.0);Assert.assertEquals(-2.3089223996676603E-4,FastMath.nextAfter(-2.3089223996676606E-4,2.3089223996676603E-4),0.0);Assert.assertEquals(-2.308922399667661E-4,FastMath.nextAfter(-2.3089223996676606E-4,-2.308922399667661E-4),0.0);Assert.assertEquals(-2.3089223996676606E-4,FastMath.nextAfter(-2.3089223996676606E-4,-2.3089223996676606E-4),0.0);Assert.assertEquals(-2.3089223996676603E-4,FastMath.nextAfter(-2.3089223996676606E-4,-2.3089223996676603E-4),0.0);}
@Test public void testDoubleNextAfterSpecialCases(){Assert.assertEquals(-Double.MAX_VALUE,FastMath.nextAfter(Double.NEGATIVE_INFINITY,0D),0D);Assert.assertEquals(Double.MAX_VALUE,FastMath.nextAfter(Double.POSITIVE_INFINITY,0D),0D);Assert.assertEquals(Double.NaN,FastMath.nextAfter(Double.NaN,0D),0D);Assert.assertEquals(Double.POSITIVE_INFINITY,FastMath.nextAfter(Double.MAX_VALUE,Double.POSITIVE_INFINITY),0D);Assert.assertEquals(Double.NEGATIVE_INFINITY,FastMath.nextAfter(-Double.MAX_VALUE,Double.NEGATIVE_INFINITY),0D);Assert.assertEquals(Double.MIN_VALUE,FastMath.nextAfter(0D,1D),0D);Assert.assertEquals(-Double.MIN_VALUE,FastMath.nextAfter(0D,-1D),0D);Assert.assertEquals(0D,FastMath.nextAfter(Double.MIN_VALUE,-1),0D);Assert.assertEquals(0D,FastMath.nextAfter(-Double.MIN_VALUE,1),0D);}
@Test public void testFloatNextAfterSpecialCases(){Assert.assertEquals(-Float.MAX_VALUE,FastMath.nextAfter(Float.NEGATIVE_INFINITY,0F),0F);Assert.assertEquals(Float.MAX_VALUE,FastMath.nextAfter(Float.POSITIVE_INFINITY,0F),0F);Assert.assertEquals(Float.NaN,FastMath.nextAfter(Float.NaN,0F),0F);Assert.assertEquals(Float.POSITIVE_INFINITY,FastMath.nextAfter(Float.MAX_VALUE,Float.POSITIVE_INFINITY),0F);Assert.assertEquals(Float.NEGATIVE_INFINITY,FastMath.nextAfter(-Float.MAX_VALUE,Float.NEGATIVE_INFINITY),0F);Assert.assertEquals(Float.MIN_VALUE,FastMath.nextAfter(0F,1F),0F);Assert.assertEquals(-Float.MIN_VALUE,FastMath.nextAfter(0F,-1F),0F);Assert.assertEquals(0F,FastMath.nextAfter(Float.MIN_VALUE,-1F),0F);Assert.assertEquals(0F,FastMath.nextAfter(-Float.MIN_VALUE,1F),0F);}
@Test public void testDoubleScalbSpecialCases(){Assert.assertEquals(2.5269841324701218E-175,FastMath.scalb(2.2250738585072014E-308,442),0D);Assert.assertEquals(1.307993905256674E297,FastMath.scalb(1.1102230246251565E-16,1040),0D);Assert.assertEquals(7.2520887996488946E-217,FastMath.scalb(Double.MIN_VALUE,356),0D);Assert.assertEquals(8.98846567431158E307,FastMath.scalb(Double.MIN_VALUE,2097),0D);Assert.assertEquals(Double.POSITIVE_INFINITY,FastMath.scalb(Double.MIN_VALUE,2098),0D);Assert.assertEquals(1.1125369292536007E-308,FastMath.scalb(2.225073858507201E-308,-1),0D);Assert.assertEquals(1.0E-323,FastMath.scalb(Double.MAX_VALUE,-2097),0D);Assert.assertEquals(Double.MIN_VALUE,FastMath.scalb(Double.MAX_VALUE,-2098),0D);Assert.assertEquals(0,FastMath.scalb(Double.MAX_VALUE,-2099),0D);Assert.assertEquals(Double.POSITIVE_INFINITY,FastMath.scalb(Double.POSITIVE_INFINITY,-1000000),0D);Assert.assertEquals(Double.NEGATIVE_INFINITY,FastMath.scalb(-1.1102230246251565E-16,1078),0D);Assert.assertEquals(Double.NEGATIVE_INFINITY,FastMath.scalb(-1.1102230246251565E-16,1079),0D);Assert.assertEquals(Double.NEGATIVE_INFINITY,FastMath.scalb(-2.2250738585072014E-308,2047),0D);Assert.assertEquals(Double.NEGATIVE_INFINITY,FastMath.scalb(-2.2250738585072014E-308,2048),0D);Assert.assertEquals(Double.NEGATIVE_INFINITY,FastMath.scalb(-1.7976931348623157E308,2147483647),0D);Assert.assertEquals(Double.POSITIVE_INFINITY,FastMath.scalb(1.7976931348623157E308,2147483647),0D);Assert.assertEquals(Double.NEGATIVE_INFINITY,FastMath.scalb(-1.1102230246251565E-16,2147483647),0D);Assert.assertEquals(Double.POSITIVE_INFINITY,FastMath.scalb(1.1102230246251565E-16,2147483647),0D);Assert.assertEquals(Double.NEGATIVE_INFINITY,FastMath.scalb(-2.2250738585072014E-308,2147483647),0D);Assert.assertEquals(Double.POSITIVE_INFINITY,FastMath.scalb(2.2250738585072014E-308,2147483647),0D);}
@Test public void testFloatScalbSpecialCases(){Assert.assertEquals(0f,FastMath.scalb(Float.MIN_VALUE,-30),0F);Assert.assertEquals(2 * Float.MIN_VALUE,FastMath.scalb(Float.MIN_VALUE,1),0F);Assert.assertEquals(7.555786e22f,FastMath.scalb(Float.MAX_VALUE,-52),0F);Assert.assertEquals(1.7014118e38f,FastMath.scalb(Float.MIN_VALUE,276),0F);Assert.assertEquals(Float.POSITIVE_INFINITY,FastMath.scalb(Float.MIN_VALUE,277),0F);Assert.assertEquals(5.8774718e-39f,FastMath.scalb(1.1754944e-38f,-1),0F);Assert.assertEquals(2 * Float.MIN_VALUE,FastMath.scalb(Float.MAX_VALUE,-276),0F);Assert.assertEquals(Float.MIN_VALUE,FastMath.scalb(Float.MAX_VALUE,-277),0F);Assert.assertEquals(0,FastMath.scalb(Float.MAX_VALUE,-278),0F);Assert.assertEquals(Float.POSITIVE_INFINITY,FastMath.scalb(Float.POSITIVE_INFINITY,-1000000),0F);Assert.assertEquals(-3.13994498e38f,FastMath.scalb(-1.1e-7f,151),0F);Assert.assertEquals(Float.NEGATIVE_INFINITY,FastMath.scalb(-1.1e-7f,152),0F);Assert.assertEquals(Float.POSITIVE_INFINITY,FastMath.scalb(3.4028235E38f,2147483647),0F);Assert.assertEquals(Float.NEGATIVE_INFINITY,FastMath.scalb(-3.4028235E38f,2147483647),0F);}
@Test public void checkMissingFastMathClasses(){}
@Ignore @Test public void checkExtraFastMathClasses(){compareClassMethods(FastMath.class,StrictMath.class);}
@Test public void testSignumDouble(){final double delta=0.0;Assert.assertEquals(1.0,FastMath.signum(2.0),delta);Assert.assertEquals(0.0,FastMath.signum(0.0),delta);Assert.assertEquals(-1.0,FastMath.signum(-2.0),delta);TestUtils.assertSame(-0. / 0.,FastMath.signum(Double.NaN));}
@Test public void testSignumFloat(){final float delta=0.0F;Assert.assertEquals(1.0F,FastMath.signum(2.0F),delta);Assert.assertEquals(0.0F,FastMath.signum(0.0F),delta);Assert.assertEquals(-1.0F,FastMath.signum(-2.0F),delta);TestUtils.assertSame(Float.NaN,FastMath.signum(Float.NaN));}
@Test public void testLogWithBase(){Assert.assertEquals(2.0,FastMath.log(2,4),0);Assert.assertEquals(3.0,FastMath.log(2,8),0);Assert.assertTrue(Double.isNaN(FastMath.log(-1,1)));Assert.assertTrue(Double.isNaN(FastMath.log(1,-1)));Assert.assertTrue(Double.isNaN(FastMath.log(0,0)));Assert.assertEquals(0,FastMath.log(0,10),0);Assert.assertEquals(Double.NEGATIVE_INFINITY,FastMath.log(10,0),0);}
@Test public void testIndicatorDouble(){double delta=0.0;Assert.assertEquals(1.0,FastMath.copySign(1d,2.0),delta);Assert.assertEquals(1.0,FastMath.copySign(1d,0.0),delta);Assert.assertEquals(-1.0,FastMath.copySign(1d,-2.0),delta);}
@Test public void testIndicatorFloat(){float delta=0.0F;Assert.assertEquals(1.0F,FastMath.copySign(1d,2.0F),delta);Assert.assertEquals(1.0F,FastMath.copySign(1d,0.0F),delta);Assert.assertEquals(-1.0F,FastMath.copySign(1d,-2.0F),delta);}
@Test public void testSimplyConnected(){Vector2D[][]vertices=new Vector2D[][]{new Vector2D[]{new Vector2D(36.0,22.0),new Vector2D(39.0,32.0),new Vector2D(19.0,32.0),new Vector2D(6.0,16.0),new Vector2D(31.0,10.0),new Vector2D(42.0,16.0),new Vector2D(34.0,20.0),new Vector2D(29.0,19.0),new Vector2D(23.0,22.0),new Vector2D(33.0,25.0)}};PolygonsSet set=buildSet(vertices);Assert.assertEquals(Region.Location.OUTSIDE,set.checkPoint(new Vector2D(50.0,30.0)));checkPoints(Region.Location.INSIDE,set,new Vector2D[]{new Vector2D(30.0,15.0),new Vector2D(15.0,20.0),new Vector2D(24.0,25.0),new Vector2D(35.0,30.0),new Vector2D(19.0,17.0)});checkPoints(Region.Location.OUTSIDE,set,new Vector2D[]{new Vector2D(50.0,30.0),new Vector2D(30.0,35.0),new Vector2D(10.0,25.0),new Vector2D(10.0,10.0),new Vector2D(40.0,10.0),new Vector2D(50.0,15.0),new Vector2D(30.0,22.0)});checkPoints(Region.Location.BOUNDARY,set,new Vector2D[]{new Vector2D(30.0,32.0),new Vector2D(34.0,20.0)});checkVertices(set.getVertices(),vertices);}
@Test public void testStair(){Vector2D[][]vertices=new Vector2D[][]{new Vector2D[]{new Vector2D(0.0,0.0),new Vector2D(0.0,2.0),new Vector2D(-0.1,2.0),new Vector2D(-0.1,1.0),new Vector2D(-0.3,1.0),new Vector2D(-0.3,1.5),new Vector2D(-1.3,1.5),new Vector2D(-1.3,2.0),new Vector2D(-1.8,2.0),new Vector2D(-1.8 - 1.0 / FastMath.sqrt(2.0),2.0 - 1.0 / FastMath.sqrt(2.0))}};PolygonsSet set=buildSet(vertices);checkVertices(set.getVertices(),vertices);Assert.assertEquals(1.1 + 0.95 * FastMath.sqrt(2.0),set.getSize(),1.0e-10);}
@Test public void testHole(){Vector2D[][]vertices=new Vector2D[][]{new Vector2D[]{new Vector2D(0.0,0.0),new Vector2D(3.0,0.0),new Vector2D(3.0,3.0),new Vector2D(0.0,3.0)},new Vector2D[]{new Vector2D(1.0,2.0),new Vector2D(2.0,2.0),new Vector2D(2.0,1.0),new Vector2D(1.0,1.0)}};PolygonsSet set=buildSet(vertices);checkPoints(Region.Location.INSIDE,set,new Vector2D[]{new Vector2D(0.5,0.5),new Vector2D(1.5,0.5),new Vector2D(2.5,0.5),new Vector2D(0.5,1.5),new Vector2D(2.5,1.5),new Vector2D(0.5,2.5),new Vector2D(1.5,2.5),new Vector2D(2.5,2.5),new Vector2D(0.5,1.0)});checkPoints(Region.Location.OUTSIDE,set,new Vector2D[]{new Vector2D(1.5,1.5),new Vector2D(3.5,1.0),new Vector2D(4.0,1.5),new Vector2D(6.0,6.0)});checkPoints(Region.Location.BOUNDARY,set,new Vector2D[]{new Vector2D(1.0,1.0),new Vector2D(1.5,0.0),new Vector2D(1.5,1.0),new Vector2D(1.5,2.0),new Vector2D(1.5,3.0),new Vector2D(3.0,3.0)});checkVertices(set.getVertices(),vertices);}
@Test public void testDisjointPolygons(){Vector2D[][]vertices=new Vector2D[][]{new Vector2D[]{new Vector2D(0.0,1.0),new Vector2D(2.0,1.0),new Vector2D(1.0,2.0)},new Vector2D[]{new Vector2D(4.0,0.0),new Vector2D(5.0,1.0),new Vector2D(3.0,1.0)}};PolygonsSet set=buildSet(vertices);Assert.assertEquals(Region.Location.INSIDE,set.checkPoint(new Vector2D(1.0,1.5)));checkPoints(Region.Location.INSIDE,set,new Vector2D[]{new Vector2D(1.0,1.5),new Vector2D(4.5,0.8)});checkPoints(Region.Location.OUTSIDE,set,new Vector2D[]{new Vector2D(1.0,0.0),new Vector2D(3.5,1.2),new Vector2D(2.5,1.0),new Vector2D(3.0,4.0)});checkPoints(Region.Location.BOUNDARY,set,new Vector2D[]{new Vector2D(1.0,1.0),new Vector2D(3.5,0.5),new Vector2D(0.0,1.0)});checkVertices(set.getVertices(),vertices);}
@Test public void testOppositeHyperplanes(){Vector2D[][]vertices=new Vector2D[][]{new Vector2D[]{new Vector2D(1.0,0.0),new Vector2D(2.0,1.0),new Vector2D(3.0,1.0),new Vector2D(2.0,2.0),new Vector2D(1.0,1.0),new Vector2D(0.0,1.0)}};PolygonsSet set=buildSet(vertices);checkVertices(set.getVertices(),vertices);}
@Test public void testSingularPoint(){Vector2D[][]vertices=new Vector2D[][]{new Vector2D[]{new Vector2D(0.0,0.0),new Vector2D(1.0,0.0),new Vector2D(1.0,1.0),new Vector2D(0.0,1.0),new Vector2D(0.0,0.0),new Vector2D(-1.0,0.0),new Vector2D(-1.0,-1.0),new Vector2D(0.0,-1.0)}};PolygonsSet set=buildSet(vertices);checkVertices(set.getVertices(),vertices);}
@Test public void testLineIntersection(){Vector2D[][]vertices=new Vector2D[][]{new Vector2D[]{new Vector2D(0.0,0.0),new Vector2D(2.0,0.0),new Vector2D(2.0,1.0),new Vector2D(3.0,1.0),new Vector2D(3.0,3.0),new Vector2D(1.0,3.0),new Vector2D(1.0,2.0),new Vector2D(0.0,2.0)}};PolygonsSet set=buildSet(vertices);Line l1=new Line(new Vector2D(-1.5,0.0),FastMath.PI / 4);SubLine s1=(SubLine)set.intersection(l1.wholeHyperplane());List<Interval> i1=((IntervalsSet)s1.getRemainingRegion()).asList();Assert.assertEquals(2,i1.size());Interval v10=i1.get(0);Vector2D p10Lower=l1.toSpace(new Vector1D(v10.getLower()));Assert.assertEquals(0.0,p10Lower.getX(),1.0e-10);Assert.assertEquals(1.5,p10Lower.getY(),1.0e-10);Vector2D p10Upper=l1.toSpace(new Vector1D(v10.getUpper()));Assert.assertEquals(0.5,p10Upper.getX(),1.0e-10);Assert.assertEquals(2.0,p10Upper.getY(),1.0e-10);Interval v11=i1.get(1);Vector2D p11Lower=l1.toSpace(new Vector1D(v11.getLower()));Assert.assertEquals(1.0,p11Lower.getX(),1.0e-10);Assert.assertEquals(2.5,p11Lower.getY(),1.0e-10);Vector2D p11Upper=l1.toSpace(new Vector1D(v11.getUpper()));Assert.assertEquals(1.5,p11Upper.getX(),1.0e-10);Assert.assertEquals(3.0,p11Upper.getY(),1.0e-10);Line l2=new Line(new Vector2D(-1.0,2.0),0);SubLine s2=(SubLine)set.intersection(l2.wholeHyperplane());List<Interval> i2=((IntervalsSet)s2.getRemainingRegion()).asList();Assert.assertEquals(1,i2.size());Interval v20=i2.get(0);Vector2D p20Lower=l2.toSpace(new Vector1D(v20.getLower()));Assert.assertEquals(1.0,p20Lower.getX(),1.0e-10);Assert.assertEquals(2.0,p20Lower.getY(),1.0e-10);Vector2D p20Upper=l2.toSpace(new Vector1D(v20.getUpper()));Assert.assertEquals(3.0,p20Upper.getX(),1.0e-10);Assert.assertEquals(2.0,p20Upper.getY(),1.0e-10);}
@Test public void testUnlimitedSubHyperplane(){Vector2D[][]vertices1=new Vector2D[][]{new Vector2D[]{new Vector2D(0.0,0.0),new Vector2D(4.0,0.0),new Vector2D(1.4,1.5),new Vector2D(0.0,3.5)}};PolygonsSet set1=buildSet(vertices1);Vector2D[][]vertices2=new Vector2D[][]{new Vector2D[]{new Vector2D(1.4,0.2),new Vector2D(2.8,-1.2),new Vector2D(2.5,0.6)}};PolygonsSet set2=buildSet(vertices2);PolygonsSet set=(PolygonsSet)new RegionFactory<Euclidean2D>().union(set1.copySelf(),set2.copySelf());checkVertices(set1.getVertices(),vertices1);checkVertices(set2.getVertices(),vertices2);checkVertices(set.getVertices(),new Vector2D[][]{new Vector2D[]{new Vector2D(0.0,0.0),new Vector2D(1.6,0.0),new Vector2D(2.8,-1.2),new Vector2D(2.6,0.0),new Vector2D(4.0,0.0),new Vector2D(1.4,1.5),new Vector2D(0.0,3.5)}});}
@Test public void testUnion(){Vector2D[][]vertices1=new Vector2D[][]{new Vector2D[]{new Vector2D(0.0,0.0),new Vector2D(2.0,0.0),new Vector2D(2.0,2.0),new Vector2D(0.0,2.0)}};PolygonsSet set1=buildSet(vertices1);Vector2D[][]vertices2=new Vector2D[][]{new Vector2D[]{new Vector2D(1.0,1.0),new Vector2D(3.0,1.0),new Vector2D(3.0,3.0),new Vector2D(1.0,3.0)}};PolygonsSet set2=buildSet(vertices2);PolygonsSet set=(PolygonsSet)new RegionFactory<Euclidean2D>().union(set1.copySelf(),set2.copySelf());checkVertices(set1.getVertices(),vertices1);checkVertices(set2.getVertices(),vertices2);checkVertices(set.getVertices(),new Vector2D[][]{new Vector2D[]{new Vector2D(0.0,0.0),new Vector2D(2.0,0.0),new Vector2D(2.0,1.0),new Vector2D(3.0,1.0),new Vector2D(3.0,3.0),new Vector2D(1.0,3.0),new Vector2D(1.0,2.0),new Vector2D(0.0,2.0)}});checkPoints(Region.Location.INSIDE,set,new Vector2D[]{new Vector2D(1.0,1.0),new Vector2D(0.5,0.5),new Vector2D(2.0,2.0),new Vector2D(2.5,2.5),new Vector2D(0.5,1.5),new Vector2D(1.5,1.5),new Vector2D(1.5,0.5),new Vector2D(1.5,2.5),new Vector2D(2.5,1.5),new Vector2D(2.5,2.5)});checkPoints(Region.Location.OUTSIDE,set,new Vector2D[]{new Vector2D(-0.5,0.5),new Vector2D(0.5,2.5),new Vector2D(2.5,0.5),new Vector2D(3.5,2.5)});checkPoints(Region.Location.BOUNDARY,set,new Vector2D[]{new Vector2D(0.0,0.0),new Vector2D(0.5,2.0),new Vector2D(2.0,0.5),new Vector2D(2.5,1.0),new Vector2D(3.0,2.5)});}
@Test public void testIntersection(){Vector2D[][]vertices1=new Vector2D[][]{new Vector2D[]{new Vector2D(0.0,0.0),new Vector2D(2.0,0.0),new Vector2D(2.0,2.0),new Vector2D(0.0,2.0)}};PolygonsSet set1=buildSet(vertices1);Vector2D[][]vertices2=new Vector2D[][]{new Vector2D[]{new Vector2D(1.0,1.0),new Vector2D(3.0,1.0),new Vector2D(3.0,3.0),new Vector2D(1.0,3.0)}};PolygonsSet set2=buildSet(vertices2);PolygonsSet set=(PolygonsSet)new RegionFactory<Euclidean2D>().intersection(set1.copySelf(),set2.copySelf());checkVertices(set1.getVertices(),vertices1);checkVertices(set2.getVertices(),vertices2);checkVertices(set.getVertices(),new Vector2D[][]{new Vector2D[]{new Vector2D(1.0,1.0),new Vector2D(2.0,1.0),new Vector2D(2.0,2.0),new Vector2D(1.0,2.0)}});checkPoints(Region.Location.INSIDE,set,new Vector2D[]{new Vector2D(1.5,1.5)});checkPoints(Region.Location.OUTSIDE,set,new Vector2D[]{new Vector2D(0.5,1.5),new Vector2D(2.5,1.5),new Vector2D(1.5,0.5),new Vector2D(0.5,0.5)});checkPoints(Region.Location.BOUNDARY,set,new Vector2D[]{new Vector2D(1.0,1.0),new Vector2D(2.0,2.0),new Vector2D(1.0,1.5),new Vector2D(1.5,2.0)});}
@Test public void testXor(){Vector2D[][]vertices1=new Vector2D[][]{new Vector2D[]{new Vector2D(0.0,0.0),new Vector2D(2.0,0.0),new Vector2D(2.0,2.0),new Vector2D(0.0,2.0)}};PolygonsSet set1=buildSet(vertices1);Vector2D[][]vertices2=new Vector2D[][]{new Vector2D[]{new Vector2D(1.0,1.0),new Vector2D(3.0,1.0),new Vector2D(3.0,3.0),new Vector2D(1.0,3.0)}};PolygonsSet set2=buildSet(vertices2);PolygonsSet set=(PolygonsSet)new RegionFactory<Euclidean2D>().xor(set1.copySelf(),set2.copySelf());checkVertices(set1.getVertices(),vertices1);checkVertices(set2.getVertices(),vertices2);checkVertices(set.getVertices(),new Vector2D[][]{new Vector2D[]{new Vector2D(0.0,0.0),new Vector2D(2.0,0.0),new Vector2D(2.0,1.0),new Vector2D(3.0,1.0),new Vector2D(3.0,3.0),new Vector2D(1.0,3.0),new Vector2D(1.0,2.0),new Vector2D(0.0,2.0)},new Vector2D[]{new Vector2D(1.0,1.0),new Vector2D(1.0,2.0),new Vector2D(2.0,2.0),new Vector2D(2.0,1.0)}});checkPoints(Region.Location.INSIDE,set,new Vector2D[]{new Vector2D(0.5,0.5),new Vector2D(2.5,2.5),new Vector2D(0.5,1.5),new Vector2D(1.5,0.5),new Vector2D(1.5,2.5),new Vector2D(2.5,1.5),new Vector2D(2.5,2.5)});checkPoints(Region.Location.OUTSIDE,set,new Vector2D[]{new Vector2D(-0.5,0.5),new Vector2D(0.5,2.5),new Vector2D(2.5,0.5),new Vector2D(1.5,1.5),new Vector2D(3.5,2.5)});checkPoints(Region.Location.BOUNDARY,set,new Vector2D[]{new Vector2D(1.0,1.0),new Vector2D(2.0,2.0),new Vector2D(1.5,1.0),new Vector2D(2.0,1.5),new Vector2D(0.0,0.0),new Vector2D(0.5,2.0),new Vector2D(2.0,0.5),new Vector2D(2.5,1.0),new Vector2D(3.0,2.5)});}
@Test public void testDifference(){Vector2D[][]vertices1=new Vector2D[][]{new Vector2D[]{new Vector2D(0.0,0.0),new Vector2D(2.0,0.0),new Vector2D(2.0,2.0),new Vector2D(0.0,2.0)}};PolygonsSet set1=buildSet(vertices1);Vector2D[][]vertices2=new Vector2D[][]{new Vector2D[]{new Vector2D(1.0,1.0),new Vector2D(3.0,1.0),new Vector2D(3.0,3.0),new Vector2D(1.0,3.0)}};PolygonsSet set2=buildSet(vertices2);PolygonsSet set=(PolygonsSet)new RegionFactory<Euclidean2D>().difference(set1.copySelf(),set2.copySelf());checkVertices(set1.getVertices(),vertices1);checkVertices(set2.getVertices(),vertices2);checkVertices(set.getVertices(),new Vector2D[][]{new Vector2D[]{new Vector2D(0.0,0.0),new Vector2D(2.0,0.0),new Vector2D(2.0,1.0),new Vector2D(1.0,1.0),new Vector2D(1.0,2.0),new Vector2D(0.0,2.0)}});checkPoints(Region.Location.INSIDE,set,new Vector2D[]{new Vector2D(0.5,0.5),new Vector2D(0.5,1.5),new Vector2D(1.5,0.5)});checkPoints(Region.Location.OUTSIDE,set,new Vector2D[]{new Vector2D(2.5,2.5),new Vector2D(-0.5,0.5),new Vector2D(0.5,2.5),new Vector2D(2.5,0.5),new Vector2D(1.5,1.5),new Vector2D(3.5,2.5),new Vector2D(1.5,2.5),new Vector2D(2.5,1.5),new Vector2D(2.0,1.5),new Vector2D(2.0,2.0),new Vector2D(2.5,1.0),new Vector2D(2.5,2.5),new Vector2D(3.0,2.5)});checkPoints(Region.Location.BOUNDARY,set,new Vector2D[]{new Vector2D(1.0,1.0),new Vector2D(1.5,1.0),new Vector2D(0.0,0.0),new Vector2D(0.5,2.0),new Vector2D(2.0,0.5)});}
@Test public void testEmptyDifference(){Vector2D[][]vertices1=new Vector2D[][]{new Vector2D[]{new Vector2D(0.5,3.5),new Vector2D(0.5,4.5),new Vector2D(-0.5,4.5),new Vector2D(-0.5,3.5)}};PolygonsSet set1=buildSet(vertices1);Vector2D[][]vertices2=new Vector2D[][]{new Vector2D[]{new Vector2D(1.0,2.0),new Vector2D(1.0,8.0),new Vector2D(-1.0,8.0),new Vector2D(-1.0,2.0)}};PolygonsSet set2=buildSet(vertices2);Assert.assertTrue(new RegionFactory<Euclidean2D>().difference(set1.copySelf(),set2.copySelf()).isEmpty());}
@Test public void testChoppedHexagon(){double pi6=FastMath.PI / 6.0;double sqrt3=FastMath.sqrt(3.0);SubLine[]hyp={new Line(new Vector2D(0.0,1.0),5 * pi6).wholeHyperplane(),new Line(new Vector2D(-sqrt3,1.0),7 * pi6).wholeHyperplane(),new Line(new Vector2D(-sqrt3,1.0),9 * pi6).wholeHyperplane(),new Line(new Vector2D(-sqrt3,0.0),11 * pi6).wholeHyperplane(),new Line(new Vector2D(0.0,0.0),13 * pi6).wholeHyperplane(),new Line(new Vector2D(0.0,1.0),3 * pi6).wholeHyperplane(),new Line(new Vector2D(-5.0 * sqrt3 / 6.0,0.0),9 * pi6).wholeHyperplane()};hyp[1]=(SubLine)hyp[1].split(hyp[0].getHyperplane()).getMinus();hyp[2]=(SubLine)hyp[2].split(hyp[1].getHyperplane()).getMinus();hyp[3]=(SubLine)hyp[3].split(hyp[2].getHyperplane()).getMinus();hyp[4]=(SubLine)hyp[4].split(hyp[3].getHyperplane()).getMinus().split(hyp[0].getHyperplane()).getMinus();hyp[5]=(SubLine)hyp[5].split(hyp[4].getHyperplane()).getMinus().split(hyp[0].getHyperplane()).getMinus();hyp[6]=(SubLine)hyp[6].split(hyp[3].getHyperplane()).getMinus().split(hyp[1].getHyperplane()).getMinus();BSPTree<Euclidean2D> tree=new BSPTree<Euclidean2D>(Boolean.TRUE);for (int i=hyp.length - 1;i >= 0;--i){tree=new BSPTree<Euclidean2D>(hyp[i],new BSPTree<Euclidean2D>(Boolean.FALSE),tree,null);}PolygonsSet set=new PolygonsSet(tree);SubLine splitter=new Line(new Vector2D(-2.0 * sqrt3 / 3.0,0.0),9 * pi6).wholeHyperplane();PolygonsSet slice=new PolygonsSet(new BSPTree<Euclidean2D>(splitter,set.getTree(false).split(splitter).getPlus(),new BSPTree<Euclidean2D>(Boolean.FALSE),null));Assert.assertEquals(Region.Location.OUTSIDE,slice.checkPoint(new Vector2D(0.1,0.5)));Assert.assertEquals(11.0 / 3.0,slice.getBoundarySize(),1.0e-10);}
@Test public void testConcentric(){double h=FastMath.sqrt(3.0)/ 2.0;Vector2D[][]vertices1=new Vector2D[][]{new Vector2D[]{new Vector2D(0.00,0.1 * h),new Vector2D(0.05,0.1 * h),new Vector2D(0.10,0.2 * h),new Vector2D(0.05,0.3 * h),new Vector2D(-0.05,0.3 * h),new Vector2D(-0.10,0.2 * h),new Vector2D(-0.05,0.1 * h)}};PolygonsSet set1=buildSet(vertices1);Vector2D[][]vertices2=new Vector2D[][]{new Vector2D[]{new Vector2D(0.00,0.0 * h),new Vector2D(0.10,0.0 * h),new Vector2D(0.20,0.2 * h),new Vector2D(0.10,0.4 * h),new Vector2D(-0.10,0.4 * h),new Vector2D(-0.20,0.2 * h),new Vector2D(-0.10,0.0 * h)}};PolygonsSet set2=buildSet(vertices2);Assert.assertTrue(set2.contains(set1));}
@Test public void testBug20040520(){BSPTree<Euclidean2D> a0=new BSPTree<Euclidean2D>(buildSegment(new Vector2D(0.85,-0.05),new Vector2D(0.90,-0.10)),new BSPTree<Euclidean2D>(Boolean.FALSE),new BSPTree<Euclidean2D>(Boolean.TRUE),null);BSPTree<Euclidean2D> a1=new BSPTree<Euclidean2D>(buildSegment(new Vector2D(0.85,-0.10),new Vector2D(0.90,-0.10)),new BSPTree<Euclidean2D>(Boolean.FALSE),a0,null);BSPTree<Euclidean2D> a2=new BSPTree<Euclidean2D>(buildSegment(new Vector2D(0.90,-0.05),new Vector2D(0.85,-0.05)),new BSPTree<Euclidean2D>(Boolean.FALSE),a1,null);BSPTree<Euclidean2D> a3=new BSPTree<Euclidean2D>(buildSegment(new Vector2D(0.82,-0.05),new Vector2D(0.82,-0.08)),new BSPTree<Euclidean2D>(Boolean.FALSE),new BSPTree<Euclidean2D>(Boolean.TRUE),null);BSPTree<Euclidean2D> a4=new BSPTree<Euclidean2D>(buildHalfLine(new Vector2D(0.85,-0.05),new Vector2D(0.80,-0.05),false),new BSPTree<Euclidean2D>(Boolean.FALSE),a3,null);BSPTree<Euclidean2D> a5=new BSPTree<Euclidean2D>(buildSegment(new Vector2D(0.82,-0.08),new Vector2D(0.82,-0.18)),new BSPTree<Euclidean2D>(Boolean.FALSE),new BSPTree<Euclidean2D>(Boolean.TRUE),null);BSPTree<Euclidean2D> a6=new BSPTree<Euclidean2D>(buildHalfLine(new Vector2D(0.82,-0.18),new Vector2D(0.85,-0.15),true),new BSPTree<Euclidean2D>(Boolean.FALSE),a5,null);BSPTree<Euclidean2D> a7=new BSPTree<Euclidean2D>(buildHalfLine(new Vector2D(0.85,-0.05),new Vector2D(0.82,-0.08),false),a4,a6,null);BSPTree<Euclidean2D> a8=new BSPTree<Euclidean2D>(buildLine(new Vector2D(0.85,-0.25),new Vector2D(0.85,0.05)),a2,a7,null);BSPTree<Euclidean2D> a9=new BSPTree<Euclidean2D>(buildLine(new Vector2D(0.90,0.05),new Vector2D(0.90,-0.50)),a8,new BSPTree<Euclidean2D>(Boolean.FALSE),null);BSPTree<Euclidean2D> b0=new BSPTree<Euclidean2D>(buildSegment(new Vector2D(0.92,-0.12),new Vector2D(0.92,-0.08)),new BSPTree<Euclidean2D>(Boolean.FALSE),new BSPTree<Euclidean2D>(Boolean.TRUE),null);BSPTree<Euclidean2D> b1=new BSPTree<Euclidean2D>(buildHalfLine(new Vector2D(0.92,-0.08),new Vector2D(0.90,-0.10),true),new BSPTree<Euclidean2D>(Boolean.FALSE),b0,null);BSPTree<Euclidean2D> b2=new BSPTree<Euclidean2D>(buildSegment(new Vector2D(0.92,-0.18),new Vector2D(0.92,-0.12)),new BSPTree<Euclidean2D>(Boolean.FALSE),new BSPTree<Euclidean2D>(Boolean.TRUE),null);BSPTree<Euclidean2D> b3=new BSPTree<Euclidean2D>(buildSegment(new Vector2D(0.85,-0.15),new Vector2D(0.90,-0.20)),new BSPTree<Euclidean2D>(Boolean.FALSE),b2,null);BSPTree<Euclidean2D> b4=new BSPTree<Euclidean2D>(buildSegment(new Vector2D(0.95,-0.15),new Vector2D(0.85,-0.05)),b1,b3,null);BSPTree<Euclidean2D> b5=new BSPTree<Euclidean2D>(buildHalfLine(new Vector2D(0.85,-0.05),new Vector2D(0.85,-0.25),true),new BSPTree<Euclidean2D>(Boolean.FALSE),b4,null);BSPTree<Euclidean2D> b6=new BSPTree<Euclidean2D>(buildLine(new Vector2D(0.0,-1.10),new Vector2D(1.0,-0.10)),new BSPTree<Euclidean2D>(Boolean.FALSE),b5,null);PolygonsSet c=(PolygonsSet)new RegionFactory<Euclidean2D>().union(new PolygonsSet(a9),new PolygonsSet(b6));checkPoints(Region.Location.INSIDE,c,new Vector2D[]{new Vector2D(0.83,-0.06),new Vector2D(0.83,-0.15),new Vector2D(0.88,-0.15),new Vector2D(0.88,-0.09),new Vector2D(0.88,-0.07),new Vector2D(0.91,-0.18),new Vector2D(0.91,-0.10)});checkPoints(Region.Location.OUTSIDE,c,new Vector2D[]{new Vector2D(0.80,-0.10),new Vector2D(0.83,-0.50),new Vector2D(0.83,-0.20),new Vector2D(0.83,-0.02),new Vector2D(0.87,-0.50),new Vector2D(0.87,-0.20),new Vector2D(0.87,-0.02),new Vector2D(0.91,-0.20),new Vector2D(0.91,-0.08),new Vector2D(0.93,-0.15)});checkVertices(c.getVertices(),new Vector2D[][]{new Vector2D[]{new Vector2D(0.85,-0.15),new Vector2D(0.90,-0.20),new Vector2D(0.92,-0.18),new Vector2D(0.92,-0.08),new Vector2D(0.90,-0.10),new Vector2D(0.90,-0.05),new Vector2D(0.82,-0.05),new Vector2D(0.82,-0.18)}});}
@Test public void testBug20041003(){Line[]l={new Line(new Vector2D(0.0,0.625000007541172),new Vector2D(1.0,0.625000007541172)),new Line(new Vector2D(-0.19204433621902645,0.0),new Vector2D(-0.19204433621902645,1.0)),new Line(new Vector2D(-0.40303524786887,0.4248364535319128),new Vector2D(-1.12851149797877,-0.2634107480798909)),new Line(new Vector2D(0.0,2.0),new Vector2D(1.0,2.0))};BSPTree<Euclidean2D> node1=new BSPTree<Euclidean2D>(new SubLine(l[0],new IntervalsSet(intersectionAbscissa(l[0],l[1]),intersectionAbscissa(l[0],l[2]))),new BSPTree<Euclidean2D>(Boolean.TRUE),new BSPTree<Euclidean2D>(Boolean.FALSE),null);BSPTree<Euclidean2D> node2=new BSPTree<Euclidean2D>(new SubLine(l[1],new IntervalsSet(intersectionAbscissa(l[1],l[2]),intersectionAbscissa(l[1],l[3]))),node1,new BSPTree<Euclidean2D>(Boolean.FALSE),null);BSPTree<Euclidean2D> node3=new BSPTree<Euclidean2D>(new SubLine(l[2],new IntervalsSet(intersectionAbscissa(l[2],l[3]),Double.POSITIVE_INFINITY)),node2,new BSPTree<Euclidean2D>(Boolean.FALSE),null);BSPTree<Euclidean2D> node4=new BSPTree<Euclidean2D>(l[3].wholeHyperplane(),node3,new BSPTree<Euclidean2D>(Boolean.FALSE),null);PolygonsSet set=new PolygonsSet(node4);Assert.assertEquals(0,set.getVertices().length);}
/** * test stats */@Test public void testStats(){double[]values=new double[]{one,two,two,three};Assert.assertEquals("sum",sum,StatUtils.sum(values),tolerance);Assert.assertEquals("sumsq",sumSq,StatUtils.sumSq(values),tolerance);Assert.assertEquals("var",var,StatUtils.variance(values),tolerance);Assert.assertEquals("var with mean",var,StatUtils.variance(values,mean),tolerance);Assert.assertEquals("mean",mean,StatUtils.mean(values),tolerance);Assert.assertEquals("min",min,StatUtils.min(values),tolerance);Assert.assertEquals("max",max,StatUtils.max(values),tolerance);}
@Test public void testN0andN1Conditions()throws Exception {double[]values=new double[0];Assert.assertTrue("Mean of n = 0 set should be NaN",Double.isNaN(StatUtils.mean(values)));Assert.assertTrue("Variance of n = 0 set should be NaN",Double.isNaN(StatUtils.variance(values)));values=new double[]{one};Assert.assertTrue("Mean of n = 1 set should be value of single item n1",StatUtils.mean(values)== one);Assert.assertTrue("Variance of n = 1 set should be zero",StatUtils.variance(values)== 0);}
@Test public void testArrayIndexConditions()throws Exception {double[]values={1.0,2.0,3.0,4.0};Assert.assertEquals("Sum not expected",5.0,StatUtils.sum(values,1,2),Double.MIN_VALUE);Assert.assertEquals("Sum not expected",3.0,StatUtils.sum(values,0,2),Double.MIN_VALUE);Assert.assertEquals("Sum not expected",7.0,StatUtils.sum(values,2,2),Double.MIN_VALUE);try {StatUtils.sum(values,2,3);Assert.fail("Expected RuntimeException");}catch(RuntimeException e){}try {StatUtils.sum(values,-1,2);Assert.fail("Expected RuntimeException");}catch(RuntimeException e){}}
@Test public void testSumSq(){double[]x=null;try {StatUtils.sumSq(x);Assert.fail("null is not a valid data array.");}catch(MathIllegalArgumentException ex){}try {StatUtils.sumSq(x,0,4);Assert.fail("null is not a valid data array.");}catch(MathIllegalArgumentException ex){}x=new double[]{};TestUtils.assertEquals(0,StatUtils.sumSq(x),tolerance);TestUtils.assertEquals(0,StatUtils.sumSq(x,0,0),tolerance);x=new double[]{two};TestUtils.assertEquals(4,StatUtils.sumSq(x),tolerance);TestUtils.assertEquals(4,StatUtils.sumSq(x,0,1),tolerance);x=new double[]{one,two,two,three};TestUtils.assertEquals(18,StatUtils.sumSq(x),tolerance);TestUtils.assertEquals(8,StatUtils.sumSq(x,1,2),tolerance);}
@Test public void testProduct(){double[]x=null;try {StatUtils.product(x);Assert.fail("null is not a valid data array.");}catch(MathIllegalArgumentException ex){}try {StatUtils.product(x,0,4);Assert.fail("null is not a valid data array.");}catch(MathIllegalArgumentException ex){}x=new double[]{};TestUtils.assertEquals(1,StatUtils.product(x),tolerance);TestUtils.assertEquals(1,StatUtils.product(x,0,0),tolerance);x=new double[]{two};TestUtils.assertEquals(two,StatUtils.product(x),tolerance);TestUtils.assertEquals(two,StatUtils.product(x,0,1),tolerance);x=new double[]{one,two,two,three};TestUtils.assertEquals(12,StatUtils.product(x),tolerance);TestUtils.assertEquals(4,StatUtils.product(x,1,2),tolerance);}
@Test public void testSumLog(){double[]x=null;try {StatUtils.sumLog(x);Assert.fail("null is not a valid data array.");}catch(MathIllegalArgumentException ex){}try {StatUtils.sumLog(x,0,4);Assert.fail("null is not a valid data array.");}catch(MathIllegalArgumentException ex){}x=new double[]{};TestUtils.assertEquals(0,StatUtils.sumLog(x),tolerance);TestUtils.assertEquals(0,StatUtils.sumLog(x,0,0),tolerance);x=new double[]{two};TestUtils.assertEquals(FastMath.log(two),StatUtils.sumLog(x),tolerance);TestUtils.assertEquals(FastMath.log(two),StatUtils.sumLog(x,0,1),tolerance);x=new double[]{one,two,two,three};TestUtils.assertEquals(FastMath.log(one)+ 2.0 * FastMath.log(two)+ FastMath.log(three),StatUtils.sumLog(x),tolerance);TestUtils.assertEquals(2.0 * FastMath.log(two),StatUtils.sumLog(x,1,2),tolerance);}
@Test public void testMean(){double[]x=null;try {StatUtils.mean(x,0,4);Assert.fail("null is not a valid data array.");}catch(MathIllegalArgumentException ex){}x=new double[]{};TestUtils.assertEquals(Double.NaN,StatUtils.mean(x,0,0),tolerance);x=new double[]{two};TestUtils.assertEquals(two,StatUtils.mean(x,0,1),tolerance);x=new double[]{one,two,two,three};TestUtils.assertEquals(2.5,StatUtils.mean(x,2,2),tolerance);}
@Test public void testVariance(){double[]x=null;try {StatUtils.variance(x,0,4);Assert.fail("null is not a valid data array.");}catch(MathIllegalArgumentException ex){}x=new double[]{};TestUtils.assertEquals(Double.NaN,StatUtils.variance(x,0,0),tolerance);x=new double[]{two};TestUtils.assertEquals(0.0,StatUtils.variance(x,0,1),tolerance);x=new double[]{one,two,two,three};TestUtils.assertEquals(0.5,StatUtils.variance(x,2,2),tolerance);x=new double[]{one,two,two,three};TestUtils.assertEquals(0.5,StatUtils.variance(x,2.5,2,2),tolerance);}
@Test public void testPopulationVariance(){double[]x=null;try {StatUtils.variance(x,0,4);Assert.fail("null is not a valid data array.");}catch(MathIllegalArgumentException ex){}x=new double[]{};TestUtils.assertEquals(Double.NaN,StatUtils.populationVariance(x,0,0),tolerance);x=new double[]{two};TestUtils.assertEquals(0.0,StatUtils.populationVariance(x,0,1),tolerance);x=new double[]{one,two,two,three};TestUtils.assertEquals(0.25,StatUtils.populationVariance(x,0,2),tolerance);x=new double[]{one,two,two,three};TestUtils.assertEquals(0.25,StatUtils.populationVariance(x,2.5,2,2),tolerance);}
@Test public void testMax(){double[]x=null;try {StatUtils.max(x,0,4);Assert.fail("null is not a valid data array.");}catch(MathIllegalArgumentException ex){}x=new double[]{};TestUtils.assertEquals(Double.NaN,StatUtils.max(x,0,0),tolerance);x=new double[]{two};TestUtils.assertEquals(two,StatUtils.max(x,0,1),tolerance);x=new double[]{one,two,two,three};TestUtils.assertEquals(three,StatUtils.max(x,1,3),tolerance);x=new double[]{nan,two,three};TestUtils.assertEquals(three,StatUtils.max(x),tolerance);x=new double[]{one,nan,three};TestUtils.assertEquals(three,StatUtils.max(x),tolerance);x=new double[]{one,two,nan};TestUtils.assertEquals(two,StatUtils.max(x),tolerance);x=new double[]{nan,nan,nan};TestUtils.assertEquals(nan,StatUtils.max(x),tolerance);}
@Test public void testMin(){double[]x=null;try {StatUtils.min(x,0,4);Assert.fail("null is not a valid data array.");}catch(MathIllegalArgumentException ex){}x=new double[]{};TestUtils.assertEquals(Double.NaN,StatUtils.min(x,0,0),tolerance);x=new double[]{two};TestUtils.assertEquals(two,StatUtils.min(x,0,1),tolerance);x=new double[]{one,two,two,three};TestUtils.assertEquals(two,StatUtils.min(x,1,3),tolerance);x=new double[]{nan,two,three};TestUtils.assertEquals(two,StatUtils.min(x),tolerance);x=new double[]{one,nan,three};TestUtils.assertEquals(one,StatUtils.min(x),tolerance);x=new double[]{one,two,nan};TestUtils.assertEquals(one,StatUtils.min(x),tolerance);x=new double[]{nan,nan,nan};TestUtils.assertEquals(nan,StatUtils.min(x),tolerance);}
@Test public void testPercentile(){double[]x=null;try {StatUtils.percentile(x,.25);Assert.fail("null is not a valid data array.");}catch(MathIllegalArgumentException ex){}try {StatUtils.percentile(x,0,4,0.25);Assert.fail("null is not a valid data array.");}catch(MathIllegalArgumentException ex){}x=new double[]{};TestUtils.assertEquals(Double.NaN,StatUtils.percentile(x,25),tolerance);TestUtils.assertEquals(Double.NaN,StatUtils.percentile(x,0,0,25),tolerance);x=new double[]{two};TestUtils.assertEquals(two,StatUtils.percentile(x,25),tolerance);TestUtils.assertEquals(two,StatUtils.percentile(x,0,1,25),tolerance);x=new double[]{one,two,two,three};TestUtils.assertEquals(2.5,StatUtils.percentile(x,70),tolerance);TestUtils.assertEquals(2.5,StatUtils.percentile(x,1,3,62.5),tolerance);}
@Test public void testDifferenceStats()throws Exception {double sample1[]={1d,2d,3d,4d};double sample2[]={1d,3d,4d,2d};double diff[]={0d,-1d,-1d,2d};double small[]={1d,4d};double meanDifference=StatUtils.meanDifference(sample1,sample2);Assert.assertEquals(StatUtils.sumDifference(sample1,sample2),StatUtils.sum(diff),tolerance);Assert.assertEquals(meanDifference,StatUtils.mean(diff),tolerance);Assert.assertEquals(StatUtils.varianceDifference(sample1,sample2,meanDifference),StatUtils.variance(diff),tolerance);try {StatUtils.meanDifference(sample1,small);Assert.fail("Expecting MathIllegalArgumentException");}catch(MathIllegalArgumentException ex){}try {StatUtils.varianceDifference(sample1,small,meanDifference);Assert.fail("Expecting MathIllegalArgumentException");}catch(MathIllegalArgumentException ex){}try {double[]single={1.0};StatUtils.varianceDifference(single,single,meanDifference);Assert.fail("Expecting MathIllegalArgumentException");}catch(MathIllegalArgumentException ex){}}
@Test public void testGeometricMean()throws Exception {double[]test=null;try {StatUtils.geometricMean(test);Assert.fail("Expecting MathIllegalArgumentException");}catch(MathIllegalArgumentException ex){}test=new double[]{2,4,6,8};Assert.assertEquals(FastMath.exp(0.25d * StatUtils.sumLog(test)),StatUtils.geometricMean(test),Double.MIN_VALUE);Assert.assertEquals(FastMath.exp(0.5 * StatUtils.sumLog(test,0,2)),StatUtils.geometricMean(test,0,2),Double.MIN_VALUE);}
/** * Run the test with the values 50 and 100 and assume standardized values    */@Test public void testNormalize1(){double sample[]={50,100};double expectedSample[]={-25 / Math.sqrt(1250),25 / Math.sqrt(1250)};double[]out=StatUtils.normalize(sample);for (int i=0;i < out.length;i++){Assert.assertTrue(Precision.equals(out[i],expectedSample[i],1));}}
/** * Run with 77 random values,assuming that the outcome has a mean of 0 and a standard deviation of 1 with a precision of 1E-10.*/@Test public void testNormalize2(){int length=77;double sample[]=new double[length];for (int i=0;i < length;i++){sample[i]=Math.random();}double standardizedSample[]=StatUtils.normalize(sample);DescriptiveStatistics stats=new DescriptiveStatistics();for (int i=0;i < length;i++){stats.addValue(standardizedSample[i]);}double distance=1E-10;Assert.assertEquals(0.0,stats.getMean(),distance);Assert.assertEquals(1.0,stats.getStandardDeviation(),distance);}
@Test public void testNextGeneration(){ElitisticListPopulation pop=new ElitisticListPopulation(100,0.203);for (int i=0;i < pop.getPopulationLimit();i++){pop.addChromosome(new DummyChromosome());}Population nextGeneration=pop.nextGeneration();Assert.assertEquals(20,nextGeneration.getPopulationSize());}
@Test public void testMismatch(){try {new VectorialMean(8).increment(new double[5]);Assert.fail("an exception should have been thrown");}catch(DimensionMismatchException dme){Assert.assertEquals(5,dme.getArgument());Assert.assertEquals(8,dme.getDimension());}}
@Test public void testSimplistic(){VectorialMean stat=new VectorialMean(2);stat.increment(new double[]{-1.0,1.0});stat.increment(new double[]{1.0,-1.0});double[]mean=stat.getResult();Assert.assertEquals(0.0,mean[0],1.0e-12);Assert.assertEquals(0.0,mean[1],1.0e-12);}
@Test public void testBasicStats(){VectorialMean stat=new VectorialMean(points[0].length);for (int i=0;i < points.length;++i){stat.increment(points[i]);}Assert.assertEquals(points.length,stat.getN());double[]mean=stat.getResult();double[]refMean=new double[]{1.78,1.62,3.12};for (int i=0;i < mean.length;++i){Assert.assertEquals(refMean[i],mean[i],1.0e-12);}}
@Test public void testSerial(){VectorialMean stat=new VectorialMean(points[0].length);for (int i=0;i < points.length;++i){stat.increment(points[i]);}Assert.assertEquals(stat,TestUtils.serializeAndRecover(stat));}
@Test public void testTrivial(){LinearProblem problem=new LinearProblem(new double[][]{{2}},new double[]{3});GaussNewtonOptimizer optimizer=new GaussNewtonOptimizer(new SimpleVectorialValueChecker(1.0e-6,1.0e-6));VectorialPointValuePair optimum=optimizer.optimize(100,problem,problem.target,new double[]{1},new double[]{0});Assert.assertEquals(0,optimizer.getRMS(),1.0e-10);Assert.assertEquals(1.5,optimum.getPoint()[0],1.0e-10);Assert.assertEquals(3.0,optimum.getValue()[0],1.0e-10);}
@Test public void testColumnsPermutation(){LinearProblem problem=new LinearProblem(new double[][]{{1.0,-1.0},{0.0,2.0},{1.0,-2.0}},new double[]{4.0,6.0,1.0});GaussNewtonOptimizer optimizer=new GaussNewtonOptimizer(new SimpleVectorialValueChecker(1.0e-6,1.0e-6));VectorialPointValuePair optimum=optimizer.optimize(100,problem,problem.target,new double[]{1,1,1},new double[]{0,0});Assert.assertEquals(0,optimizer.getRMS(),1.0e-10);Assert.assertEquals(7.0,optimum.getPoint()[0],1.0e-10);Assert.assertEquals(3.0,optimum.getPoint()[1],1.0e-10);Assert.assertEquals(4.0,optimum.getValue()[0],1.0e-10);Assert.assertEquals(6.0,optimum.getValue()[1],1.0e-10);Assert.assertEquals(1.0,optimum.getValue()[2],1.0e-10);}
@Test public void testNoDependency(){LinearProblem problem=new LinearProblem(new double[][]{{2,0,0,0,0,0},{0,2,0,0,0,0},{0,0,2,0,0,0},{0,0,0,2,0,0},{0,0,0,0,2,0},{0,0,0,0,0,2}},new double[]{0.0,1.1,2.2,3.3,4.4,5.5});GaussNewtonOptimizer optimizer=new GaussNewtonOptimizer(new SimpleVectorialValueChecker(1.0e-6,1.0e-6));VectorialPointValuePair optimum=optimizer.optimize(100,problem,problem.target,new double[]{1,1,1,1,1,1},new double[]{0,0,0,0,0,0});Assert.assertEquals(0,optimizer.getRMS(),1.0e-10);for (int i=0;i < problem.target.length;++i){Assert.assertEquals(0.55 * i,optimum.getPoint()[i],1.0e-10);}}
@Test public void testOneSet(){LinearProblem problem=new LinearProblem(new double[][]{{1,0,0},{-1,1,0},{0,-1,1}},new double[]{1,1,1});GaussNewtonOptimizer optimizer=new GaussNewtonOptimizer(new SimpleVectorialValueChecker(1.0e-6,1.0e-6));VectorialPointValuePair optimum=optimizer.optimize(100,problem,problem.target,new double[]{1,1,1},new double[]{0,0,0});Assert.assertEquals(0,optimizer.getRMS(),1.0e-10);Assert.assertEquals(1.0,optimum.getPoint()[0],1.0e-10);Assert.assertEquals(2.0,optimum.getPoint()[1],1.0e-10);Assert.assertEquals(3.0,optimum.getPoint()[2],1.0e-10);}
@Test public void testTwoSets(){double epsilon=1.0e-7;LinearProblem problem=new LinearProblem(new double[][]{{2,1,0,4,0,0},{-4,-2,3,-7,0,0},{4,1,-2,8,0,0},{0,-3,-12,-1,0,0},{0,0,0,0,epsilon,1},{0,0,0,0,1,1}},new double[]{2,-9,2,2,1 + epsilon * epsilon,2});GaussNewtonOptimizer optimizer=new GaussNewtonOptimizer(new SimpleVectorialValueChecker(1.0e-6,1.0e-6));VectorialPointValuePair optimum=optimizer.optimize(100,problem,problem.target,new double[]{1,1,1,1,1,1},new double[]{0,0,0,0,0,0});Assert.assertEquals(0,optimizer.getRMS(),1.0e-10);Assert.assertEquals(3.0,optimum.getPoint()[0],1.0e-10);Assert.assertEquals(4.0,optimum.getPoint()[1],1.0e-10);Assert.assertEquals(-1.0,optimum.getPoint()[2],1.0e-10);Assert.assertEquals(-2.0,optimum.getPoint()[3],1.0e-10);Assert.assertEquals(1.0 + epsilon,optimum.getPoint()[4],1.0e-10);Assert.assertEquals(1.0 - epsilon,optimum.getPoint()[5],1.0e-10);}
@Test(expected=ConvergenceException.class)public void testNonInversible()throws Exception {LinearProblem problem=new LinearProblem(new double[][]{{1,2,-3},{2,1,3},{-3,0,-9}},new double[]{1,1,1});GaussNewtonOptimizer optimizer=new GaussNewtonOptimizer(new SimpleVectorialValueChecker(1.0e-6,1.0e-6));optimizer.optimize(100,problem,problem.target,new double[]{1,1,1},new double[]{0,0,0});}
@Test public void testIllConditioned(){LinearProblem problem1=new LinearProblem(new double[][]{{10.0,7.0,8.0,7.0},{7.0,5.0,6.0,5.0},{8.0,6.0,10.0,9.0},{7.0,5.0,9.0,10.0}},new double[]{32,23,33,31});GaussNewtonOptimizer optimizer=new GaussNewtonOptimizer(new SimpleVectorialValueChecker(1.0e-6,1.0e-6));VectorialPointValuePair optimum1=optimizer.optimize(100,problem1,problem1.target,new double[]{1,1,1,1},new double[]{0,1,2,3});Assert.assertEquals(0,optimizer.getRMS(),1.0e-10);Assert.assertEquals(1.0,optimum1.getPoint()[0],1.0e-10);Assert.assertEquals(1.0,optimum1.getPoint()[1],1.0e-10);Assert.assertEquals(1.0,optimum1.getPoint()[2],1.0e-10);Assert.assertEquals(1.0,optimum1.getPoint()[3],1.0e-10);LinearProblem problem2=new LinearProblem(new double[][]{{10.00,7.00,8.10,7.20},{7.08,5.04,6.00,5.00},{8.00,5.98,9.89,9.00},{6.99,4.99,9.00,9.98}},new double[]{32,23,33,31});VectorialPointValuePair optimum2=optimizer.optimize(100,problem2,problem2.target,new double[]{1,1,1,1},new double[]{0,1,2,3});Assert.assertEquals(0,optimizer.getRMS(),1.0e-10);Assert.assertEquals(-81.0,optimum2.getPoint()[0],1.0e-8);Assert.assertEquals(137.0,optimum2.getPoint()[1],1.0e-8);Assert.assertEquals(-34.0,optimum2.getPoint()[2],1.0e-8);Assert.assertEquals(22.0,optimum2.getPoint()[3],1.0e-8);}
@Test(expected=ConvergenceException.class)public void testMoreEstimatedParametersSimple()throws Exception {LinearProblem problem=new LinearProblem(new double[][]{{3.0,2.0,0.0,0.0},{0.0,1.0,-1.0,1.0},{2.0,0.0,1.0,0.0}},new double[]{7.0,3.0,5.0});GaussNewtonOptimizer optimizer=new GaussNewtonOptimizer(new SimpleVectorialValueChecker(1.0e-6,1.0e-6));optimizer.optimize(100,problem,problem.target,new double[]{1,1,1},new double[]{7,6,5,4});}
@Test(expected=ConvergenceException.class)public void testMoreEstimatedParametersUnsorted()throws Exception {LinearProblem problem=new LinearProblem(new double[][]{{1.0,1.0,0.0,0.0,0.0,0.0},{0.0,0.0,1.0,1.0,1.0,0.0},{0.0,0.0,0.0,0.0,1.0,-1.0},{0.0,0.0,-1.0,1.0,0.0,1.0},{0.0,0.0,0.0,-1.0,1.0,0.0}},new double[]{3.0,12.0,-1.0,7.0,1.0});GaussNewtonOptimizer optimizer=new GaussNewtonOptimizer(new SimpleVectorialValueChecker(1.0e-6,1.0e-6));optimizer.optimize(100,problem,problem.target,new double[]{1,1,1,1,1},new double[]{2,2,2,2,2,2});}
@Test public void testRedundantEquations(){LinearProblem problem=new LinearProblem(new double[][]{{1.0,1.0},{1.0,-1.0},{1.0,3.0}},new double[]{3.0,1.0,5.0});GaussNewtonOptimizer optimizer=new GaussNewtonOptimizer(new SimpleVectorialValueChecker(1.0e-6,1.0e-6));VectorialPointValuePair optimum=optimizer.optimize(100,problem,problem.target,new double[]{1,1,1},new double[]{1,1});Assert.assertEquals(0,optimizer.getRMS(),1.0e-10);Assert.assertEquals(2.0,optimum.getPoint()[0],1.0e-8);Assert.assertEquals(1.0,optimum.getPoint()[1],1.0e-8);}
@Test public void testInconsistentEquations(){LinearProblem problem=new LinearProblem(new double[][]{{1.0,1.0},{1.0,-1.0},{1.0,3.0}},new double[]{3.0,1.0,4.0});GaussNewtonOptimizer optimizer=new GaussNewtonOptimizer(new SimpleVectorialValueChecker(1.0e-6,1.0e-6));optimizer.optimize(100,problem,problem.target,new double[]{1,1,1},new double[]{1,1});Assert.assertTrue(optimizer.getRMS()> 0.1);}
@Test(expected=DimensionMismatchException.class)public void testInconsistentSizes1(){LinearProblem problem=new LinearProblem(new double[][]{{1,0},{0,1}},new double[]{-1,1});GaussNewtonOptimizer optimizer=new GaussNewtonOptimizer(new SimpleVectorialValueChecker(1.0e-6,1.0e-6));VectorialPointValuePair optimum=optimizer.optimize(100,problem,problem.target,new double[]{1,1},new double[]{0,0});Assert.assertEquals(0,optimizer.getRMS(),1.0e-10);Assert.assertEquals(-1,optimum.getPoint()[0],1.0e-10);Assert.assertEquals(+1,optimum.getPoint()[1],1.0e-10);optimizer.optimize(100,problem,problem.target,new double[]{1},new double[]{0,0});}
@Test(expected=DimensionMismatchException.class)public void testInconsistentSizes2(){LinearProblem problem=new LinearProblem(new double[][]{{1,0},{0,1}},new double[]{-1,1});GaussNewtonOptimizer optimizer=new GaussNewtonOptimizer(new SimpleVectorialValueChecker(1.0e-6,1.0e-6));VectorialPointValuePair optimum=optimizer.optimize(100,problem,problem.target,new double[]{1,1},new double[]{0,0});Assert.assertEquals(0,optimizer.getRMS(),1.0e-10);Assert.assertEquals(-1,optimum.getPoint()[0],1.0e-10);Assert.assertEquals(+1,optimum.getPoint()[1],1.0e-10);optimizer.optimize(100,problem,new double[]{1},new double[]{1},new double[]{0,0});}
@Test(expected=TooManyEvaluationsException.class)public void testMaxEvaluations()throws Exception {CircleVectorial circle=new CircleVectorial();circle.addPoint(30.0,68.0);circle.addPoint(50.0,-6.0);circle.addPoint(110.0,-20.0);circle.addPoint(35.0,15.0);circle.addPoint(45.0,97.0);GaussNewtonOptimizer optimizer=new GaussNewtonOptimizer(new SimpleVectorialValueChecker(1.0e-30,1.0e-30));optimizer.optimize(100,circle,new double[]{0,0,0,0,0},new double[]{1,1,1,1,1},new double[]{98.680,47.345});}
@Test public void testCircleFitting(){CircleVectorial circle=new CircleVectorial();circle.addPoint(30.0,68.0);circle.addPoint(50.0,-6.0);circle.addPoint(110.0,-20.0);circle.addPoint(35.0,15.0);circle.addPoint(45.0,97.0);GaussNewtonOptimizer optimizer=new GaussNewtonOptimizer(new SimpleVectorialValueChecker(1.0e-13,1.0e-13));VectorialPointValuePair optimum=optimizer.optimize(100,circle,new double[]{0,0,0,0,0},new double[]{1,1,1,1,1},new double[]{98.680,47.345});Assert.assertEquals(1.768262623567235,FastMath.sqrt(circle.getN())* optimizer.getRMS(),1.0e-10);Point2D.Double center=new Point2D.Double(optimum.getPointRef()[0],optimum.getPointRef()[1]);Assert.assertEquals(69.96016175359975,circle.getRadius(center),1.0e-10);Assert.assertEquals(96.07590209601095,center.x,1.0e-10);Assert.assertEquals(48.135167894714,center.y,1.0e-10);}
@Test(expected=ConvergenceException.class)public void testCircleFittingBadInit(){CircleVectorial circle=new CircleVectorial();double[][]points=circlePoints;double[]target=new double[points.length];Arrays.fill(target,0.0);double[]weights=new double[points.length];Arrays.fill(weights,2.0);for (int i=0;i < points.length;++i){circle.addPoint(points[i][0],points[i][1]);}GaussNewtonOptimizer optimizer=new GaussNewtonOptimizer(new SimpleVectorialValueChecker(1.0e-6,1.0e-6));optimizer.optimize(100,circle,target,weights,new double[]{-12,-12});}
@Test public void testCircleFittingGoodInit(){CircleVectorial circle=new CircleVectorial();double[][]points=circlePoints;double[]target=new double[points.length];Arrays.fill(target,0.0);double[]weights=new double[points.length];Arrays.fill(weights,2.0);for (int i=0;i < points.length;++i){circle.addPoint(points[i][0],points[i][1]);}GaussNewtonOptimizer optimizer=new GaussNewtonOptimizer(new SimpleVectorialValueChecker(1.0e-6,1.0e-6));VectorialPointValuePair optimum=optimizer.optimize(100,circle,target,weights,new double[]{0,0});Assert.assertEquals(-0.1517383071957963,optimum.getPointRef()[0],1.0e-6);Assert.assertEquals(0.2074999736353867,optimum.getPointRef()[1],1.0e-6);Assert.assertEquals(0.04268731682389561,optimizer.getRMS(),1.0e-8);}
/** * test rank */@Test public void testRank(){DecompositionSolver solver=new QRDecomposition(MatrixUtils.createRealMatrix(testData3x3NonSingular)).getSolver();Assert.assertTrue(solver.isNonSingular());solver=new QRDecomposition(MatrixUtils.createRealMatrix(testData3x3Singular)).getSolver();Assert.assertFalse(solver.isNonSingular());solver=new QRDecomposition(MatrixUtils.createRealMatrix(testData3x4)).getSolver();Assert.assertTrue(solver.isNonSingular());solver=new QRDecomposition(MatrixUtils.createRealMatrix(testData4x3)).getSolver();Assert.assertTrue(solver.isNonSingular());}
/** * test solve dimension errors */@Test public void testSolveDimensionErrors(){DecompositionSolver solver=new QRDecomposition(MatrixUtils.createRealMatrix(testData3x3NonSingular)).getSolver();RealMatrix b=MatrixUtils.createRealMatrix(new double[2][2]);try {solver.solve(b);Assert.fail("an exception should have been thrown");}catch(MathIllegalArgumentException iae){}try {solver.solve(b.getColumnVector(0));Assert.fail("an exception should have been thrown");}catch(MathIllegalArgumentException iae){}}
/** * test solve rank errors */@Test public void testSolveRankErrors(){DecompositionSolver solver=new QRDecomposition(MatrixUtils.createRealMatrix(testData3x3Singular)).getSolver();RealMatrix b=MatrixUtils.createRealMatrix(new double[3][2]);try {solver.solve(b);Assert.fail("an exception should have been thrown");}catch(SingularMatrixException iae){}try {solver.solve(b.getColumnVector(0));Assert.fail("an exception should have been thrown");}catch(SingularMatrixException iae){}}
/** * test solve */@Test public void testSolve(){QRDecomposition decomposition=new QRDecomposition(MatrixUtils.createRealMatrix(testData3x3NonSingular));DecompositionSolver solver=decomposition.getSolver();RealMatrix b=MatrixUtils.createRealMatrix(new double[][]{{-102,12250},{544,24500},{167,-36750}});RealMatrix xRef=MatrixUtils.createRealMatrix(new double[][]{{1,2515},{2,422},{-3,898}});Assert.assertEquals(0,solver.solve(b).subtract(xRef).getNorm(),2.0e-16 * xRef.getNorm());for (int i=0;i < b.getColumnDimension();++i){final RealVector x=solver.solve(b.getColumnVector(i));final double error=x.subtract(xRef.getColumnVector(i)).getNorm();Assert.assertEquals(0,error,3.0e-16 * xRef.getColumnVector(i).getNorm());}for (int i=0;i < b.getColumnDimension();++i){ArrayRealVectorTest.RealVectorTestImpl v=new ArrayRealVectorTest.RealVectorTestImpl(b.getColumn(i));final RealVector x=solver.solve(v);final double error=x.subtract(xRef.getColumnVector(i)).getNorm();Assert.assertEquals(0,error,3.0e-16 * xRef.getColumnVector(i).getNorm());}}
@Test public void testOverdetermined(){final Random r=new Random(5559252868205245l);int p=(7 * BlockRealMatrix.BLOCK_SIZE)/ 4;int q=(5 * BlockRealMatrix.BLOCK_SIZE)/ 4;RealMatrix a=createTestMatrix(r,p,q);RealMatrix xRef=createTestMatrix(r,q,BlockRealMatrix.BLOCK_SIZE + 3);RealMatrix b=a.multiply(xRef);final double noise=0.001;b.walkInOptimizedOrder(new DefaultRealMatrixChangingVisitor(){@Override public double visit(int row,int column,double value){return value * (1.0 + noise * (2 * r.nextDouble()- 1));}});RealMatrix x=new QRDecomposition(a).getSolver().solve(b);Assert.assertEquals(0,x.subtract(xRef).getNorm(),0.01 * noise * p* q);}
@Test public void testUnderdetermined(){final Random r=new Random(42185006424567123l);int p=(5 * BlockRealMatrix.BLOCK_SIZE)/ 4;int q=(7 * BlockRealMatrix.BLOCK_SIZE)/ 4;RealMatrix a=createTestMatrix(r,p,q);RealMatrix xRef=createTestMatrix(r,q,BlockRealMatrix.BLOCK_SIZE + 3);RealMatrix b=a.multiply(xRef);RealMatrix x=new QRDecomposition(a).getSolver().solve(b);Assert.assertTrue(x.subtract(xRef).getNorm()/ (p * q)> 0.01);Assert.assertEquals(0.0,x.getSubMatrix(p,q - 1,0,x.getColumnDimension()- 1).getNorm(),0);}
@Test public void testMessage(){final int max=12345;final TooManyEvaluationsException e=new TooManyEvaluationsException(max);final String msg=e.getLocalizedMessage();Assert.assertTrue(msg,msg.matches(".*?" + MessageFormat.format("{0}",max)+ ".*"));}
@Test public void testDerivativesConsistency(){TestProblem3 pb=new TestProblem3();double step=(pb.getFinalTime()- pb.getInitialTime())* 0.001;MidpointIntegrator integ=new MidpointIntegrator(step);StepInterpolatorTestUtils.checkDerivativesConsistency(integ,pb,1.0e-10);}
@Test public void serialization()throws IOException,ClassNotFoundException {TestProblem1 pb=new TestProblem1();double step=(pb.getFinalTime()- pb.getInitialTime())* 0.001;MidpointIntegrator integ=new MidpointIntegrator(step);integ.addStepHandler(new ContinuousOutputModel());integ.integrate(pb,pb.getInitialTime(),pb.getInitialState(),pb.getFinalTime(),new double[pb.getDimension()]);ByteArrayOutputStream bos=new ByteArrayOutputStream();ObjectOutputStream oos=new ObjectOutputStream(bos);for(StepHandler handler : integ.getStepHandlers()){oos.writeObject(handler);}Assert.assertTrue(bos.size()> 135000);Assert.assertTrue(bos.size()< 145000);ByteArrayInputStream bis=new ByteArrayInputStream(bos.toByteArray());ObjectInputStream ois=new ObjectInputStream(bis);ContinuousOutputModel cm=(ContinuousOutputModel)ois.readObject();Random random=new Random(347588535632l);double maxError=0.0;for (int i=0;i < 1000;++i){double r=random.nextDouble();double time=r * pb.getInitialTime()+ (1.0 - r)* pb.getFinalTime();cm.setInterpolatedTime(time);double[]interpolatedY=cm.getInterpolatedState();double[]theoreticalY=pb.computeTheoreticalState(time);double dx=interpolatedY[0]- theoreticalY[0];double dy=interpolatedY[1]- theoreticalY[1];double error=dx * dx + dy * dy;if (error > maxError){maxError=error;}}Assert.assertTrue(maxError < 1.0e-6);}
@Test public void testAccessors(){final DimensionMismatchException e=new DimensionMismatchException(1,2);Assert.assertEquals(1,e.getArgument());Assert.assertEquals(2,e.getDimension());}
@Test public void testRound(){field.setRoundingMode(DfpField.RoundingMode.ROUND_HALF_EVEN);test(new DfpDec(field,"12345678901234567890"),new DfpDec(field,"12345678901234568000"),DfpField.FLAG_INEXACT,"Round #1");test(new DfpDec(field,"0.12345678901234567890"),new DfpDec(field,"0.12345678901234568"),DfpField.FLAG_INEXACT,"Round #2");test(new DfpDec(field,"0.12345678901234567500"),new DfpDec(field,"0.12345678901234568"),DfpField.FLAG_INEXACT,"Round #3");test(new DfpDec(field,"0.12345678901234568500"),new DfpDec(field,"0.12345678901234568"),DfpField.FLAG_INEXACT,"Round #4");test(new DfpDec(field,"0.12345678901234568501"),new DfpDec(field,"0.12345678901234569"),DfpField.FLAG_INEXACT,"Round #5");test(new DfpDec(field,"0.12345678901234568499"),new DfpDec(field,"0.12345678901234568"),DfpField.FLAG_INEXACT,"Round #6");test(new DfpDec(field,"1.2345678901234567890"),new DfpDec(field,"1.2345678901234568"),DfpField.FLAG_INEXACT,"Round #7");test(new DfpDec(field,"1.2345678901234567500"),new DfpDec(field,"1.2345678901234568"),DfpField.FLAG_INEXACT,"Round #8");test(new DfpDec(field,"1.2345678901234568500"),new DfpDec(field,"1.2345678901234568"),DfpField.FLAG_INEXACT,"Round #9");test(new DfpDec(field,"1.2345678901234568000").add(new DfpDec(field,".0000000000000000501")),new DfpDec(field,"1.2345678901234569"),DfpField.FLAG_INEXACT,"Round #10");test(new DfpDec(field,"1.2345678901234568499"),new DfpDec(field,"1.2345678901234568"),DfpField.FLAG_INEXACT,"Round #11");test(new DfpDec(field,"12.345678901234567890"),new DfpDec(field,"12.345678901234568"),DfpField.FLAG_INEXACT,"Round #12");test(new DfpDec(field,"12.345678901234567500"),new DfpDec(field,"12.345678901234568"),DfpField.FLAG_INEXACT,"Round #13");test(new DfpDec(field,"12.345678901234568500"),new DfpDec(field,"12.345678901234568"),DfpField.FLAG_INEXACT,"Round #14");test(new DfpDec(field,"12.345678901234568").add(new DfpDec(field,".000000000000000501")),new DfpDec(field,"12.345678901234569"),DfpField.FLAG_INEXACT,"Round #15");test(new DfpDec(field,"12.345678901234568499"),new DfpDec(field,"12.345678901234568"),DfpField.FLAG_INEXACT,"Round #16");test(new DfpDec(field,"123.45678901234567890"),new DfpDec(field,"123.45678901234568"),DfpField.FLAG_INEXACT,"Round #17");test(new DfpDec(field,"123.45678901234567500"),new DfpDec(field,"123.45678901234568"),DfpField.FLAG_INEXACT,"Round #18");test(new DfpDec(field,"123.45678901234568500"),new DfpDec(field,"123.45678901234568"),DfpField.FLAG_INEXACT,"Round #19");test(new DfpDec(field,"123.456789012345685").add(new DfpDec(field,".00000000000000501")),new DfpDec(field,"123.45678901234569"),DfpField.FLAG_INEXACT,"Round #20");test(new DfpDec(field,"123.45678901234568499"),new DfpDec(field,"123.45678901234568"),DfpField.FLAG_INEXACT,"Round #21");field.setRoundingMode(DfpField.RoundingMode.ROUND_DOWN);test(new DfpDec(field,"12345678901234567").add(new DfpDec(field,"0.9")),new DfpDec(field,"12345678901234567"),DfpField.FLAG_INEXACT,"Round #22");test(new DfpDec(field,"12345678901234567").add(new DfpDec(field,"0.99999999")),new DfpDec(field,"12345678901234567"),DfpField.FLAG_INEXACT,"Round #23");test(new DfpDec(field,"-12345678901234567").add(new DfpDec(field,"-0.99999999")),new DfpDec(field,"-12345678901234567"),DfpField.FLAG_INEXACT,"Round #24");field.setRoundingMode(DfpField.RoundingMode.ROUND_UP);test(new DfpDec(field,"12345678901234567").add(new DfpDec(field,"0.1")),new DfpDec(field,"12345678901234568"),DfpField.FLAG_INEXACT,"Round #25");test(new DfpDec(field,"12345678901234567").add(new DfpDec(field,"0.0001")),new DfpDec(field,"12345678901234568"),DfpField.FLAG_INEXACT,"Round #26");test(new DfpDec(field,"-12345678901234567").add(new DfpDec(field,"-0.1")),new DfpDec(field,"-12345678901234568"),DfpField.FLAG_INEXACT,"Round #27");test(new DfpDec(field,"-12345678901234567").add(new DfpDec(field,"-0.0001")),new DfpDec(field,"-12345678901234568"),DfpField.FLAG_INEXACT,"Round #28");test(new DfpDec(field,"-12345678901234567").add(new DfpDec(field,"0")),new DfpDec(field,"-12345678901234567"),0,"Round #28.5");field.setRoundingMode(DfpField.RoundingMode.ROUND_HALF_UP);test(new DfpDec(field,"12345678901234567").add(new DfpDec(field,"0.499999999999")),new DfpDec(field,"12345678901234567"),DfpField.FLAG_INEXACT,"Round #29");test(new DfpDec(field,"12345678901234567").add(new DfpDec(field,"0.50000001")),new DfpDec(field,"12345678901234568"),DfpField.FLAG_INEXACT,"Round #30");test(new DfpDec(field,"12345678901234567").add(new DfpDec(field,"0.5")),new DfpDec(field,"12345678901234568"),DfpField.FLAG_INEXACT,"Round #30.5");test(new DfpDec(field,"-12345678901234567").add(new DfpDec(field,"-0.499999999999")),new DfpDec(field,"-12345678901234567"),DfpField.FLAG_INEXACT,"Round #31");test(new DfpDec(field,"-12345678901234567").add(new DfpDec(field,"-0.50000001")),new DfpDec(field,"-12345678901234568"),DfpField.FLAG_INEXACT,"Round #32");field.setRoundingMode(DfpField.RoundingMode.ROUND_HALF_DOWN);test(new DfpDec(field,"12345678901234567").add(new DfpDec(field,"0.5001")),new DfpDec(field,"12345678901234568"),DfpField.FLAG_INEXACT,"Round #33");test(new DfpDec(field,"12345678901234567").add(new DfpDec(field,"0.5000")),new DfpDec(field,"12345678901234567"),DfpField.FLAG_INEXACT,"Round #34");test(new DfpDec(field,"-12345678901234567").add(new DfpDec(field,"-0.5001")),new DfpDec(field,"-12345678901234568"),DfpField.FLAG_INEXACT,"Round #35");test(new DfpDec(field,"-12345678901234567").add(new DfpDec(field,"-0.6")),new DfpDec(field,"-12345678901234568"),DfpField.FLAG_INEXACT,"Round #35.5");test(new DfpDec(field,"-12345678901234567").add(new DfpDec(field,"-0.5000")),new DfpDec(field,"-12345678901234567"),DfpField.FLAG_INEXACT,"Round #36");field.setRoundingMode(DfpField.RoundingMode.ROUND_HALF_ODD);test(new DfpDec(field,"12345678901234568").add(new DfpDec(field,"0.5000")),new DfpDec(field,"12345678901234569"),DfpField.FLAG_INEXACT,"Round #37");test(new DfpDec(field,"12345678901234567").add(new DfpDec(field,"0.5000")),new DfpDec(field,"12345678901234567"),DfpField.FLAG_INEXACT,"Round #38");test(new DfpDec(field,"-12345678901234568").add(new DfpDec(field,"-0.5000")),new DfpDec(field,"-12345678901234569"),DfpField.FLAG_INEXACT,"Round #39");test(new DfpDec(field,"-12345678901234567").add(new DfpDec(field,"-0.5000")),new DfpDec(field,"-12345678901234567"),DfpField.FLAG_INEXACT,"Round #40");field.setRoundingMode(DfpField.RoundingMode.ROUND_CEIL);test(new DfpDec(field,"12345678901234567").add(new DfpDec(field,"0.0001")),new DfpDec(field,"12345678901234568"),DfpField.FLAG_INEXACT,"Round #41");test(new DfpDec(field,"-12345678901234567").add(new DfpDec(field,"-0.9999")),new DfpDec(field,"-12345678901234567"),DfpField.FLAG_INEXACT,"Round #42");field.setRoundingMode(DfpField.RoundingMode.ROUND_FLOOR);test(new DfpDec(field,"12345678901234567").add(new DfpDec(field,"0.9999")),new DfpDec(field,"12345678901234567"),DfpField.FLAG_INEXACT,"Round #43");test(new DfpDec(field,"-12345678901234567").add(new DfpDec(field,"-0.0001")),new DfpDec(field,"-12345678901234568"),DfpField.FLAG_INEXACT,"Round #44");field.setRoundingMode(DfpField.RoundingMode.ROUND_HALF_EVEN);}
@Test public void testRoundDecimal10(){field.setRoundingMode(DfpField.RoundingMode.ROUND_HALF_EVEN);test(new Decimal10(field,"1234567891234567890"),new Decimal10(field,"1234567891000000000"),DfpField.FLAG_INEXACT,"RoundDecimal10 #1");test(new Decimal10(field,"0.1234567891634567890"),new Decimal10(field,"0.1234567892"),DfpField.FLAG_INEXACT,"RoundDecimal10 #2");test(new Decimal10(field,"0.1234567891500000000"),new Decimal10(field,"0.1234567892"),DfpField.FLAG_INEXACT,"RoundDecimal10 #3");test(new Decimal10(field,"0.1234567890500"),new Decimal10(field,"0.1234567890"),DfpField.FLAG_INEXACT,"RoundDecimal10 #4");test(new Decimal10(field,"0.1234567890501"),new Decimal10(field,"0.1234567891"),DfpField.FLAG_INEXACT,"RoundDecimal10 #5");test(new Decimal10(field,"0.1234567890499"),new Decimal10(field,"0.1234567890"),DfpField.FLAG_INEXACT,"RoundDecimal10 #6");test(new Decimal10(field,"1.234567890890"),new Decimal10(field,"1.234567891"),DfpField.FLAG_INEXACT,"RoundDecimal10 #7");test(new Decimal10(field,"1.234567891500"),new Decimal10(field,"1.234567892"),DfpField.FLAG_INEXACT,"RoundDecimal10 #8");test(new Decimal10(field,"1.234567890500"),new Decimal10(field,"1.234567890"),DfpField.FLAG_INEXACT,"RoundDecimal10 #9");test(new Decimal10(field,"1.234567890000").add(new Decimal10(field,".000000000501")),new Decimal10(field,"1.234567891"),DfpField.FLAG_INEXACT,"RoundDecimal10 #10");test(new Decimal10(field,"1.234567890499"),new Decimal10(field,"1.234567890"),DfpField.FLAG_INEXACT,"RoundDecimal10 #11");test(new Decimal10(field,"12.34567890890"),new Decimal10(field,"12.34567891"),DfpField.FLAG_INEXACT,"RoundDecimal10 #12");test(new Decimal10(field,"12.34567891500"),new Decimal10(field,"12.34567892"),DfpField.FLAG_INEXACT,"RoundDecimal10 #13");test(new Decimal10(field,"12.34567890500"),new Decimal10(field,"12.34567890"),DfpField.FLAG_INEXACT,"RoundDecimal10 #14");test(new Decimal10(field,"12.34567890").add(new Decimal10(field,".00000000501")),new Decimal10(field,"12.34567891"),DfpField.FLAG_INEXACT,"RoundDecimal10 #15");test(new Decimal10(field,"12.34567890499"),new Decimal10(field,"12.34567890"),DfpField.FLAG_INEXACT,"RoundDecimal10 #16");test(new Decimal10(field,"123.4567890890"),new Decimal10(field,"123.4567891"),DfpField.FLAG_INEXACT,"RoundDecimal10 #17");test(new Decimal10(field,"123.4567891500"),new Decimal10(field,"123.4567892"),DfpField.FLAG_INEXACT,"RoundDecimal10 #18");test(new Decimal10(field,"123.4567890500"),new Decimal10(field,"123.4567890"),DfpField.FLAG_INEXACT,"RoundDecimal10 #19");test(new Decimal10(field,"123.4567890").add(new Decimal10(field,".0000000501")),new Decimal10(field,"123.4567891"),DfpField.FLAG_INEXACT,"RoundDecimal10 #20");test(new Decimal10(field,"123.4567890499"),new Decimal10(field,"123.4567890"),DfpField.FLAG_INEXACT,"RoundDecimal10 #21");field.setRoundingMode(DfpField.RoundingMode.ROUND_DOWN);test(new Decimal10(field,"1234567890").add(new Decimal10(field,"0.9")),new Decimal10(field,"1234567890"),DfpField.FLAG_INEXACT,"RoundDecimal10 #22");test(new Decimal10(field,"1234567890").add(new Decimal10(field,"0.99999999")),new Decimal10(field,"1234567890"),DfpField.FLAG_INEXACT,"RoundDecimal10 #23");test(new Decimal10(field,"-1234567890").add(new Decimal10(field,"-0.99999999")),new Decimal10(field,"-1234567890"),DfpField.FLAG_INEXACT,"RoundDecimal10 #24");field.setRoundingMode(DfpField.RoundingMode.ROUND_UP);test(new Decimal10(field,1234567890).add(new Decimal10(field,"0.1")),new Decimal10(field,1234567891l),DfpField.FLAG_INEXACT,"RoundDecimal10 #25");test(new Decimal10(field,"1234567890").add(new Decimal10(field,"0.0001")),new Decimal10(field,"1234567891"),DfpField.FLAG_INEXACT,"RoundDecimal10 #26");test(new Decimal10(field,"-1234567890").add(new Decimal10(field,"-0.1")),new Decimal10(field,"-1234567891"),DfpField.FLAG_INEXACT,"RoundDecimal10 #27");test(new Decimal10(field,"-1234567890").add(new Decimal10(field,"-0.0001")),new Decimal10(field,"-1234567891"),DfpField.FLAG_INEXACT,"RoundDecimal10 #28");test(new Decimal10(field,"-1234567890").add(new Decimal10(field,"0")),new Decimal10(field,"-1234567890"),0,"RoundDecimal10 #28.5");field.setRoundingMode(DfpField.RoundingMode.ROUND_HALF_UP);test(new Decimal10(field,"1234567890").add(new Decimal10(field,"0.4999999999")),new Decimal10(field,"1234567890"),DfpField.FLAG_INEXACT,"RoundDecimal10 #29");test(new Decimal10(field,"1234567890").add(new Decimal10(field,"0.50000001")),new Decimal10(field,"1234567891"),DfpField.FLAG_INEXACT,"RoundDecimal10 #30");test(new Decimal10(field,"1234567890").add(new Decimal10(field,"0.5")),new Decimal10(field,"1234567891"),DfpField.FLAG_INEXACT,"RoundDecimal10 #30.5");test(new Decimal10(field,"-1234567890").add(new Decimal10(field,"-0.4999999999")),new Decimal10(field,"-1234567890"),DfpField.FLAG_INEXACT,"RoundDecimal10 #31");test(new Decimal10(field,"-1234567890").add(new Decimal10(field,"-0.50000001")),new Decimal10(field,"-1234567891"),DfpField.FLAG_INEXACT,"RoundDecimal10 #32");field.setRoundingMode(DfpField.RoundingMode.ROUND_HALF_DOWN);test(new Decimal10(field,"1234567890").add(new Decimal10(field,"0.5001")),new Decimal10(field,"1234567890"),DfpField.FLAG_INEXACT,"RoundDecimal10 #33");test(new Decimal10(field,"1234567890").add(new Decimal10(field,"0.5000")),new Decimal10(field,"1234567890"),DfpField.FLAG_INEXACT,"RoundDecimal10 #34");test(new Decimal10(field,"-1234567890").add(new Decimal10(field,"-0.5001")),new Decimal10(field,"-1234567890"),DfpField.FLAG_INEXACT,"RoundDecimal10 #35");test(new Decimal10(field,"-1234567890").add(new Decimal10(field,"-0.6")),new Decimal10(field,"-1234567891"),DfpField.FLAG_INEXACT,"RoundDecimal10 #35.5");test(new Decimal10(field,"-1234567890").add(new Decimal10(field,"-0.5000")),new Decimal10(field,"-1234567890"),DfpField.FLAG_INEXACT,"RoundDecimal10 #36");field.setRoundingMode(DfpField.RoundingMode.ROUND_HALF_ODD);test(new Decimal10(field,"1234567890").add(new Decimal10(field,"0.5000")),new Decimal10(field,"1234567891"),DfpField.FLAG_INEXACT,"RoundDecimal10 #37");test(new Decimal10(field,"1234567891").add(new Decimal10(field,"0.5000")),new Decimal10(field,"1234567891"),DfpField.FLAG_INEXACT,"RoundDecimal10 #38");test(new Decimal10(field,"-1234567890").add(new Decimal10(field,"-0.5000")),new Decimal10(field,"-1234567891"),DfpField.FLAG_INEXACT,"RoundDecimal10 #39");test(new Decimal10(field,"-1234567891").add(new Decimal10(field,"-0.5000")),new Decimal10(field,"-1234567891"),DfpField.FLAG_INEXACT,"RoundDecimal10 #40");field.setRoundingMode(DfpField.RoundingMode.ROUND_CEIL);test(new Decimal10(field,"1234567890").add(new Decimal10(field,"0.0001")),new Decimal10(field,"1234567891"),DfpField.FLAG_INEXACT,"RoundDecimal10 #41");test(new Decimal10(field,"-1234567890").add(new Decimal10(field,"-0.9999")),new Decimal10(field,"-1234567890"),DfpField.FLAG_INEXACT,"RoundDecimal10 #42");field.setRoundingMode(DfpField.RoundingMode.ROUND_FLOOR);test(new Decimal10(field,"1234567890").add(new Decimal10(field,"0.9999")),new Decimal10(field,"1234567890"),DfpField.FLAG_INEXACT,"RoundDecimal10 #43");test(new Decimal10(field,"-1234567890").add(new Decimal10(field,"-0.0001")),new Decimal10(field,"-1234567891"),DfpField.FLAG_INEXACT,"RoundDecimal10 #44");field.setRoundingMode(DfpField.RoundingMode.ROUND_HALF_EVEN);}
@Test public void testNextAfter(){test(new DfpDec(field,1).nextAfter(pinf),new DfpDec(field,"1.0000000000000001"),0,"NextAfter #1");test(new DfpDec(field,"1.0000000000000001").nextAfter(ninf),new DfpDec(field,1),0,"NextAfter #1.5");test(new DfpDec(field,1).nextAfter(ninf),new DfpDec(field,"0.99999999999999999"),0,"NextAfter #2");test(new DfpDec(field,"0.99999999999999999").nextAfter(new DfpDec(field,2)),new DfpDec(field,1),0,"NextAfter #3");test(new DfpDec(field,-1).nextAfter(ninf),new DfpDec(field,"-1.0000000000000001"),0,"NextAfter #4");test(new DfpDec(field,-1).nextAfter(pinf),new DfpDec(field,"-0.99999999999999999"),0,"NextAfter #5");test(new DfpDec(field,"-0.99999999999999999").nextAfter(new DfpDec(field,-2)),new DfpDec(field,(byte)-1),0,"NextAfter #6");test(new DfpDec(field,(byte)2).nextAfter(new DfpDec(field,2)),new DfpDec(field,2l),0,"NextAfter #7");test(new DfpDec(field,0).nextAfter(new DfpDec(field,0)),new DfpDec(field,0),0,"NextAfter #8");test(new DfpDec(field,-2).nextAfter(new DfpDec(field,-2)),new DfpDec(field,-2),0,"NextAfter #9");test(new DfpDec(field,0).nextAfter(new DfpDec(field,1)),new DfpDec(field,"1e-131092"),DfpField.FLAG_UNDERFLOW,"NextAfter #10");test(new DfpDec(field,0).nextAfter(new DfpDec(field,-1)),new DfpDec(field,"-1e-131092"),DfpField.FLAG_UNDERFLOW,"NextAfter #11");test(new DfpDec(field,"-1e-131092").nextAfter(pinf),new DfpDec(field,"-0"),DfpField.FLAG_UNDERFLOW | DfpField.FLAG_INEXACT,"Next After #12");test(new DfpDec(field,"1e-131092").nextAfter(ninf),new DfpDec(field,"0"),DfpField.FLAG_UNDERFLOW | DfpField.FLAG_INEXACT,"Next After #13");test(new DfpDec(field,"9.9999999999999999e131078").nextAfter(pinf),pinf,DfpField.FLAG_OVERFLOW | DfpField.FLAG_INEXACT,"Next After #14");}
/** * Test degenerate case p = 0   */@Test public void testDegenerate0()throws Exception {setDistribution(new PascalDistribution(5,0.0d));setCumulativeTestPoints(new int[]{-1,0,1,5,10});setCumulativeTestValues(new double[]{0d,0d,0d,0d,0d});setDensityTestPoints(new int[]{-1,0,1,10,11});setDensityTestValues(new double[]{0d,0d,0d,0d,0d});setInverseCumulativeTestPoints(new double[]{0.1d,0.5d});setInverseCumulativeTestValues(new int[]{Integer.MAX_VALUE - 1,Integer.MAX_VALUE - 1});verifyDensities();verifyCumulativeProbabilities();verifyInverseCumulativeProbabilities();}
/** * Test degenerate case p = 1   */@Test public void testDegenerate1()throws Exception {setDistribution(new PascalDistribution(5,1.0d));setCumulativeTestPoints(new int[]{-1,0,1,2,5,10});setCumulativeTestValues(new double[]{0d,1d,1d,1d,1d,1d});setDensityTestPoints(new int[]{-1,0,1,2,5,10});setDensityTestValues(new double[]{0d,1d,0d,0d,0d,0d});setInverseCumulativeTestPoints(new double[]{0.1d,0.5d});setInverseCumulativeTestValues(new int[]{-1,-1});verifyDensities();verifyCumulativeProbabilities();verifyInverseCumulativeProbabilities();}
@Test public void testMoments(){final double tol=1e-9;PascalDistribution dist;dist=new PascalDistribution(10,0.5);Assert.assertEquals(dist.getNumericalMean(),(10d * 0.5d)/ 0.5d,tol);Assert.assertEquals(dist.getNumericalVariance(),(10d * 0.5d)/ (0.5d * 0.5d),tol);dist=new PascalDistribution(25,0.3);Assert.assertEquals(dist.getNumericalMean(),(25d * 0.3d)/ 0.7d,tol);Assert.assertEquals(dist.getNumericalVariance(),(25d * 0.3d)/ (0.7d * 0.7d),tol);}
/** * Verifies that probability density calculations match expected values using default test instance data*/@Test public void testDensities()throws Exception {verifyDensities();}
/** * Verifies that cumulative probability density calculations match expected values using default test instance data*/@Test public void testCumulativeProbabilities()throws Exception {verifyCumulativeProbabilities();}
/** * Verifies that floating point arguments are correctly handled by cumulativeProbablility(-,-)JIRA: MATH-184*/@Test public void testFloatingPointArguments()throws Exception {for (int i=0;i < cumulativeTestPoints.length;i++){double arg=cumulativeTestPoints[i];Assert.assertEquals("Incorrect cumulative probability value returned for " + cumulativeTestPoints[i],cumulativeTestValues[i],distribution.cumulativeProbability(arg),tolerance);if (i < cumulativeTestPoints.length - 1){double arg2=cumulativeTestPoints[i + 1];Assert.assertEquals("Inconsistent probability for discrete range " + "[" + arg + ","+ arg2+ " ]",distribution.cumulativeProbability(cumulativeTestPoints[i],cumulativeTestPoints[i + 1]),distribution.cumulativeProbability(arg,arg2),tolerance);arg=arg - FastMath.random();arg2=arg2 + FastMath.random();Assert.assertEquals("Inconsistent probability for discrete range " + "[" + arg + ","+ arg2+ " ]",distribution.cumulativeProbability(cumulativeTestPoints[i],cumulativeTestPoints[i + 1]),distribution.cumulativeProbability(arg,arg2),tolerance);}}int one=1;int ten=10;int two=2;double oned=one;double twod=two;double tend=ten;Assert.assertEquals(distribution.cumulativeProbability(one,two),distribution.cumulativeProbability(oned,twod),tolerance);Assert.assertEquals(distribution.cumulativeProbability(one,two),distribution.cumulativeProbability(oned - tolerance,twod + 0.9),tolerance);Assert.assertEquals(distribution.cumulativeProbability(two,ten),distribution.cumulativeProbability(twod,tend),tolerance);Assert.assertEquals(distribution.cumulativeProbability(two,ten),distribution.cumulativeProbability(twod - tolerance,tend + 0.9),tolerance);}
/** * Verifies that inverse cumulative probability density calculations match expected values using default test instance data*/@Test public void testInverseCumulativeProbabilities()throws Exception {verifyInverseCumulativeProbabilities();}
/** * Verifies that illegal arguments are correctly handled*/@Test public void testIllegalArguments()throws Exception {try {distribution.cumulativeProbability(1,0);Assert.fail("Expecting MathIllegalArgumentException for bad cumulativeProbability interval");}catch(MathIllegalArgumentException ex){}try {distribution.inverseCumulativeProbability(-1);Assert.fail("Expecting MathIllegalArgumentException for p = -1");}catch(MathIllegalArgumentException ex){}try {distribution.inverseCumulativeProbability(2);Assert.fail("Expecting MathIllegalArgumentException for p = 2");}catch(MathIllegalArgumentException ex){}}
/** * Test sampling*/@Test public void testSampling()throws Exception {int[]densityPoints=makeDensityTestPoints();double[]densityValues=makeDensityTestValues();int sampleSize=1000;int length=TestUtils.eliminateZeroMassPoints(densityPoints,densityValues);AbstractIntegerDistribution distribution=(AbstractIntegerDistribution)makeDistribution();double[]expectedCounts=new double[length];long[]observedCounts=new long[length];for (int i=0;i < length;i++){expectedCounts[i]=sampleSize * densityValues[i];}distribution.reseedRandomGenerator(1000);int[]sample=distribution.sample(sampleSize);for (int i=0;i < sampleSize;i++){for (int j=0;j < length;j++){if (sample[i]== densityPoints[j]){observedCounts[j]++;}}}TestUtils.assertChiSquareAccept(densityPoints,expectedCounts,observedCounts,.001);}
@Test public void testAccessors(){final NotStrictlyPositiveException e=new NotStrictlyPositiveException(0);Assert.assertEquals(0,e.getArgument());Assert.assertEquals(0,e.getMin());Assert.assertFalse(e.getBoundIsAllowed());}
/** * Make sure Double.NaN is returned iff n < 4*/@Test public void testNaN(){Kurtosis kurt=new Kurtosis();Assert.assertTrue(Double.isNaN(kurt.getResult()));kurt.increment(1d);Assert.assertTrue(Double.isNaN(kurt.getResult()));kurt.increment(1d);Assert.assertTrue(Double.isNaN(kurt.getResult()));kurt.increment(1d);Assert.assertTrue(Double.isNaN(kurt.getResult()));kurt.increment(1d);Assert.assertFalse(Double.isNaN(kurt.getResult()));}
/** * Verifies that increment()and incrementAll work properly.*/@Test public void testIncrementation()throws Exception {StorelessUnivariateStatistic statistic=(StorelessUnivariateStatistic)getUnivariateStatistic();for (int i=0;i < testArray.length;i++){statistic.increment(testArray[i]);}Assert.assertEquals(expectedValue(),statistic.getResult(),getTolerance());Assert.assertEquals(testArray.length,statistic.getN());statistic.clear();statistic.incrementAll(testArray);Assert.assertEquals(expectedValue(),statistic.getResult(),getTolerance());Assert.assertEquals(testArray.length,statistic.getN());statistic.clear();checkClearValue(statistic);Assert.assertEquals(0,statistic.getN());}
@Test public void testSerialization()throws Exception {StorelessUnivariateStatistic statistic=(StorelessUnivariateStatistic)getUnivariateStatistic();TestUtils.checkSerializedEquality(statistic);statistic.clear();for (int i=0;i < testArray.length;i++){statistic.increment(testArray[i]);if (i % 5 == 0)statistic=(StorelessUnivariateStatistic)TestUtils.serializeAndRecover(statistic);}TestUtils.checkSerializedEquality(statistic);Assert.assertEquals(expectedValue(),statistic.getResult(),getTolerance());statistic.clear();checkClearValue(statistic);}
@Test public void testEqualsAndHashCode(){StorelessUnivariateStatistic statistic=(StorelessUnivariateStatistic)getUnivariateStatistic();StorelessUnivariateStatistic statistic2=null;Assert.assertTrue("non-null,compared to null",!statistic.equals(statistic2));Assert.assertTrue("reflexive,non-null",statistic.equals(statistic));int emptyHash=statistic.hashCode();statistic2=(StorelessUnivariateStatistic)getUnivariateStatistic();Assert.assertTrue("empty stats should be equal",statistic.equals(statistic2));Assert.assertEquals("empty stats should have the same hashcode",emptyHash,statistic2.hashCode());statistic.increment(1d);Assert.assertTrue("reflexive,non-empty",statistic.equals(statistic));Assert.assertTrue("non-empty,compared to empty",!statistic.equals(statistic2));Assert.assertTrue("non-empty,compared to empty",!statistic2.equals(statistic));Assert.assertTrue("non-empty stat should have different hashcode from empty stat",statistic.hashCode()!= emptyHash);statistic2.increment(1d);Assert.assertTrue("stats with same data should be equal",statistic.equals(statistic2));Assert.assertEquals("stats with same data should have the same hashcode",statistic.hashCode(),statistic2.hashCode());statistic.increment(Double.POSITIVE_INFINITY);Assert.assertTrue("stats with different n's should not be equal",!statistic2.equals(statistic));Assert.assertTrue("stats with different n's should have different hashcodes",statistic.hashCode()!= statistic2.hashCode());statistic2.increment(Double.POSITIVE_INFINITY);Assert.assertTrue("stats with same data should be equal",statistic.equals(statistic2));Assert.assertEquals("stats with same data should have the same hashcode",statistic.hashCode(),statistic2.hashCode());statistic.clear();statistic2.clear();Assert.assertTrue("cleared stats should be equal",statistic.equals(statistic2));Assert.assertEquals("cleared stats should have thashcode of empty stat",emptyHash,statistic2.hashCode());Assert.assertEquals("cleared stats should have thashcode of empty stat",emptyHash,statistic.hashCode());}
@Test public void testMomentSmallSamples(){UnivariateStatistic stat=getUnivariateStatistic();if (stat instanceof SecondMoment){SecondMoment moment=(SecondMoment)getUnivariateStatistic();Assert.assertTrue(Double.isNaN(moment.getResult()));moment.increment(1d);Assert.assertEquals(0d,moment.getResult(),0);}}
/** * Make sure that evaluate(double[])and inrementAll(double[]),getResult()give same results.*/@Test public void testConsistency(){StorelessUnivariateStatistic stat=(StorelessUnivariateStatistic)getUnivariateStatistic();stat.incrementAll(testArray);Assert.assertEquals(stat.getResult(),stat.evaluate(testArray),getTolerance());for (int i=0;i < smallSamples.length;i++){stat.clear();for (int j=0;j < smallSamples[i].length;j++){stat.increment(smallSamples[i][j]);}TestUtils.assertEquals(stat.getResult(),stat.evaluate(smallSamples[i]),getTolerance());}}
/** * Verifies that copied statistics remain equal to originals when incremented the same way.*/@Test public void testCopyConsistency(){StorelessUnivariateStatistic master=(StorelessUnivariateStatistic)getUnivariateStatistic();StorelessUnivariateStatistic replica=null;long index=FastMath.round((FastMath.random())* testArray.length);master.incrementAll(testArray,0,(int)index);replica=master.copy();Assert.assertTrue(replica.equals(master));Assert.assertTrue(master.equals(replica));master.incrementAll(testArray,(int)index,(int)(testArray.length - index));replica.incrementAll(testArray,(int)index,(int)(testArray.length - index));Assert.assertTrue(replica.equals(master));Assert.assertTrue(master.equals(replica));}
@Test public void testSerial(){StorelessUnivariateStatistic s=(StorelessUnivariateStatistic)getUnivariateStatistic();Assert.assertEquals(s,TestUtils.serializeAndRecover(s));}
@Test public void testEvaluation()throws Exception {Assert.assertEquals(expectedValue(),getUnivariateStatistic().evaluate(testArray),getTolerance());}
@Test public void testEvaluateArraySegment(){final UnivariateStatistic stat=getUnivariateStatistic();final double[]arrayZero=new double[5];System.arraycopy(testArray,0,arrayZero,0,5);Assert.assertEquals(stat.evaluate(arrayZero),stat.evaluate(testArray,0,5),0);final double[]arrayOne=new double[5];System.arraycopy(testArray,5,arrayOne,0,5);Assert.assertEquals(stat.evaluate(arrayOne),stat.evaluate(testArray,5,5),0);final double[]arrayEnd=new double[5];System.arraycopy(testArray,testArray.length - 5,arrayEnd,0,5);Assert.assertEquals(stat.evaluate(arrayEnd),stat.evaluate(testArray,testArray.length - 5,5),0);}
@Test public void testEvaluateArraySegmentWeighted(){UnivariateStatistic statistic=getUnivariateStatistic();if (!(statistic instanceof WeightedEvaluation)){return;}final WeightedEvaluation stat=(WeightedEvaluation)getUnivariateStatistic();final double[]arrayZero=new double[5];final double[]weightZero=new double[5];System.arraycopy(testArray,0,arrayZero,0,5);System.arraycopy(testWeightsArray,0,weightZero,0,5);Assert.assertEquals(stat.evaluate(arrayZero,weightZero),stat.evaluate(testArray,testWeightsArray,0,5),0);final double[]arrayOne=new double[5];final double[]weightOne=new double[5];System.arraycopy(testArray,5,arrayOne,0,5);System.arraycopy(testWeightsArray,5,weightOne,0,5);Assert.assertEquals(stat.evaluate(arrayOne,weightOne),stat.evaluate(testArray,testWeightsArray,5,5),0);final double[]arrayEnd=new double[5];final double[]weightEnd=new double[5];System.arraycopy(testArray,testArray.length - 5,arrayEnd,0,5);System.arraycopy(testWeightsArray,testArray.length - 5,weightEnd,0,5);Assert.assertEquals(stat.evaluate(arrayEnd,weightEnd),stat.evaluate(testArray,testWeightsArray,testArray.length - 5,5),0);}
@Test public void testCopy()throws Exception {UnivariateStatistic original=getUnivariateStatistic();UnivariateStatistic copy=original.copy();Assert.assertEquals(expectedValue(),copy.evaluate(testArray),getTolerance());}
/** * Tests consistency of weighted statistic computation. For statistics that support weighted evaluation,this test case compares the result of direct computation on an array with repeated values with a weighted computation on the corresponding (shorter)array with each value appearing only once but with a weight value equal to its multiplicity in the repeating array.*/@Test public void testWeightedConsistency()throws Exception {UnivariateStatistic statistic=getUnivariateStatistic();if (!(statistic instanceof WeightedEvaluation)){return;}final int len=10;final double mu=0;final double sigma=5;double[]values=new double[len];double[]weights=new double[len];RandomData randomData=new RandomDataImpl();int[]intWeights=new int[len];for (int i=0;i < len;i++){intWeights[i]=randomData.nextInt(1,5);weights[i]=intWeights[i];}List<Double> valuesList=new ArrayList<Double>();for (int i=0;i < len;i++){double value=randomData.nextGaussian(mu,sigma);values[i]=value;for (int j=0;j < intWeights[i];j++){valuesList.add(new Double(value));}}int sumWeights=valuesList.size();double[]repeatedValues=new double[sumWeights];for (int i=0;i < sumWeights;i++){repeatedValues[i]=valuesList.get(i);}WeightedEvaluation weightedStatistic=(WeightedEvaluation)statistic;TestUtils.assertRelativelyEquals(statistic.evaluate(repeatedValues),weightedStatistic.evaluate(values,weights,0,values.length),10E-14);Assert.assertEquals(weightedStatistic.evaluate(values,weights,0,values.length),weightedStatistic.evaluate(values,weights),Double.MIN_VALUE);}
@Test public void testMinimize1(){SimplexOptimizer optimizer=new SimplexOptimizer(1e-11,1e-30);optimizer.setSimplex(new MultiDirectionalSimplex(new double[]{0.2,0.2}));final FourExtrema fourExtrema=new FourExtrema();final RealPointValuePair optimum=optimizer.optimize(200,fourExtrema,GoalType.MINIMIZE,new double[]{-3,0});Assert.assertEquals(fourExtrema.xM,optimum.getPoint()[0],4e-6);Assert.assertEquals(fourExtrema.yP,optimum.getPoint()[1],3e-6);Assert.assertEquals(fourExtrema.valueXmYp,optimum.getValue(),8e-13);Assert.assertTrue(optimizer.getEvaluations()> 120);Assert.assertTrue(optimizer.getEvaluations()< 150);}
@Test public void testMinimize2(){SimplexOptimizer optimizer=new SimplexOptimizer(1e-11,1e-30);optimizer.setSimplex(new MultiDirectionalSimplex(new double[]{0.2,0.2}));final FourExtrema fourExtrema=new FourExtrema();final RealPointValuePair optimum=optimizer.optimize(200,fourExtrema,GoalType.MINIMIZE,new double[]{1,0});Assert.assertEquals(fourExtrema.xP,optimum.getPoint()[0],2e-8);Assert.assertEquals(fourExtrema.yM,optimum.getPoint()[1],3e-6);Assert.assertEquals(fourExtrema.valueXpYm,optimum.getValue(),2e-12);Assert.assertTrue(optimizer.getEvaluations()> 120);Assert.assertTrue(optimizer.getEvaluations()< 150);}
@Test public void testMaximize1(){SimplexOptimizer optimizer=new SimplexOptimizer(1e-11,1e-30);optimizer.setSimplex(new MultiDirectionalSimplex(new double[]{0.2,0.2}));final FourExtrema fourExtrema=new FourExtrema();final RealPointValuePair optimum=optimizer.optimize(200,fourExtrema,GoalType.MAXIMIZE,new double[]{-3.0,0.0});Assert.assertEquals(fourExtrema.xM,optimum.getPoint()[0],7e-7);Assert.assertEquals(fourExtrema.yM,optimum.getPoint()[1],3e-7);Assert.assertEquals(fourExtrema.valueXmYm,optimum.getValue(),2e-14);Assert.assertTrue(optimizer.getEvaluations()> 120);Assert.assertTrue(optimizer.getEvaluations()< 150);}
@Test public void testMaximize2(){SimplexOptimizer optimizer=new SimplexOptimizer(new SimpleScalarValueChecker(1e-15,1e-30));optimizer.setSimplex(new MultiDirectionalSimplex(new double[]{0.2,0.2}));final FourExtrema fourExtrema=new FourExtrema();final RealPointValuePair optimum=optimizer.optimize(200,fourExtrema,GoalType.MAXIMIZE,new double[]{1,0});Assert.assertEquals(fourExtrema.xP,optimum.getPoint()[0],2e-8);Assert.assertEquals(fourExtrema.yP,optimum.getPoint()[1],3e-6);Assert.assertEquals(fourExtrema.valueXpYp,optimum.getValue(),2e-12);Assert.assertTrue(optimizer.getEvaluations()> 180);Assert.assertTrue(optimizer.getEvaluations()< 220);}
@Test public void testRosenbrock(){MultivariateFunction rosenbrock=new MultivariateFunction(){public double value(double[]x){++count;double a=x[1]- x[0]* x[0];double b=1.0 - x[0];return 100 * a * a + b * b;}};count=0;SimplexOptimizer optimizer=new SimplexOptimizer(-1,1e-3);optimizer.setSimplex(new MultiDirectionalSimplex(new double[][]{{-1.2,1.0},{0.9,1.2},{3.5,-2.3}}));RealPointValuePair optimum=optimizer.optimize(100,rosenbrock,GoalType.MINIMIZE,new double[]{-1.2,1});Assert.assertEquals(count,optimizer.getEvaluations());Assert.assertTrue(optimizer.getEvaluations()> 50);Assert.assertTrue(optimizer.getEvaluations()< 100);Assert.assertTrue(optimum.getValue()> 1e-2);}
@Test public void testPowell(){MultivariateFunction powell=new MultivariateFunction(){public double value(double[]x){++count;double a=x[0]+ 10 * x[1];double b=x[2]- x[3];double c=x[1]- 2 * x[2];double d=x[0]- x[3];return a * a + 5 * b * b + c * c * c* c + 10 * d * d* d* d;}};count=0;SimplexOptimizer optimizer=new SimplexOptimizer(-1,1e-3);optimizer.setSimplex(new MultiDirectionalSimplex(4));RealPointValuePair optimum=optimizer.optimize(1000,powell,GoalType.MINIMIZE,new double[]{3,-1,0,1});Assert.assertEquals(count,optimizer.getEvaluations());Assert.assertTrue(optimizer.getEvaluations()> 800);Assert.assertTrue(optimizer.getEvaluations()< 900);Assert.assertTrue(optimum.getValue()> 1e-2);}
@Test public void testMath283(){SimplexOptimizer optimizer=new SimplexOptimizer();optimizer.setSimplex(new MultiDirectionalSimplex(2));final Gaussian2D function=new Gaussian2D(0,0,1);RealPointValuePair estimate=optimizer.optimize(1000,function,GoalType.MAXIMIZE,function.getMaximumPosition());final double EPSILON=1e-5;final double expectedMaximum=function.getMaximum();final double actualMaximum=estimate.getValue();Assert.assertEquals(expectedMaximum,actualMaximum,EPSILON);final double[]expectedPosition=function.getMaximumPosition();final double[]actualPosition=estimate.getPoint();Assert.assertEquals(expectedPosition[0],actualPosition[0],EPSILON);Assert.assertEquals(expectedPosition[1],actualPosition[1],EPSILON);}
@Test public void derivativesConsistency(){TestProblem3 pb=new TestProblem3(0.1);double minStep=0;double maxStep=pb.getFinalTime()- pb.getInitialTime();double scalAbsoluteTolerance=1.0e-8;double scalRelativeTolerance=scalAbsoluteTolerance;HighamHall54Integrator integ=new HighamHall54Integrator(minStep,maxStep,scalAbsoluteTolerance,scalRelativeTolerance);StepInterpolatorTestUtils.checkDerivativesConsistency(integ,pb,1.1e-10);}
@Test public void serialization()throws IOException,ClassNotFoundException {TestProblem3 pb=new TestProblem3(0.9);double minStep=0;double maxStep=pb.getFinalTime()- pb.getInitialTime();double scalAbsoluteTolerance=1.0e-8;double scalRelativeTolerance=scalAbsoluteTolerance;HighamHall54Integrator integ=new HighamHall54Integrator(minStep,maxStep,scalAbsoluteTolerance,scalRelativeTolerance);integ.addStepHandler(new ContinuousOutputModel());integ.integrate(pb,pb.getInitialTime(),pb.getInitialState(),pb.getFinalTime(),new double[pb.getDimension()]);ByteArrayOutputStream bos=new ByteArrayOutputStream();ObjectOutputStream oos=new ObjectOutputStream(bos);for(StepHandler handler : integ.getStepHandlers()){oos.writeObject(handler);}Assert.assertTrue(bos.size()> 185000);Assert.assertTrue(bos.size()< 195000);ByteArrayInputStream bis=new ByteArrayInputStream(bos.toByteArray());ObjectInputStream ois=new ObjectInputStream(bis);ContinuousOutputModel cm=(ContinuousOutputModel)ois.readObject();Random random=new Random(347588535632l);double maxError=0.0;for (int i=0;i < 1000;++i){double r=random.nextDouble();double time=r * pb.getInitialTime()+ (1.0 - r)* pb.getFinalTime();cm.setInterpolatedTime(time);double[]interpolatedY=cm.getInterpolatedState();double[]theoreticalY=pb.computeTheoreticalState(time);double dx=interpolatedY[0]- theoreticalY[0];double dy=interpolatedY[1]- theoreticalY[1];double error=dx * dx + dy * dy;if (error > maxError){maxError=error;}}Assert.assertTrue(maxError < 1.6e-10);}
@Test public void checkClone(){TestProblem3 pb=new TestProblem3(0.9);double minStep=0;double maxStep=pb.getFinalTime()- pb.getInitialTime();double scalAbsoluteTolerance=1.0e-8;double scalRelativeTolerance=scalAbsoluteTolerance;HighamHall54Integrator integ=new HighamHall54Integrator(minStep,maxStep,scalAbsoluteTolerance,scalRelativeTolerance);integ.addStepHandler(new StepHandler(){public void handleStep(StepInterpolator interpolator,boolean isLast){StepInterpolator cloned=interpolator.copy();double tA=cloned.getPreviousTime();double tB=cloned.getCurrentTime();double halfStep=FastMath.abs(tB - tA)/ 2;Assert.assertEquals(interpolator.getPreviousTime(),tA,1.0e-12);Assert.assertEquals(interpolator.getCurrentTime(),tB,1.0e-12);for (int i=0;i < 10;++i){double t=(i * tB + (9 - i)* tA)/ 9;interpolator.setInterpolatedTime(t);Assert.assertTrue(FastMath.abs(cloned.getInterpolatedTime()- t)> (halfStep / 10));cloned.setInterpolatedTime(t);Assert.assertEquals(t,cloned.getInterpolatedTime(),1.0e-12);double[]referenceState=interpolator.getInterpolatedState();double[]cloneState=cloned.getInterpolatedState();for (int j=0;j < referenceState.length;++j){Assert.assertEquals(referenceState[j],cloneState[j],1.0e-12);}}}public void init(double t0,double[]y0,double t){}});integ.integrate(pb,pb.getInitialTime(),pb.getInitialState(),pb.getFinalTime(),new double[pb.getDimension()]);}
@Test public void testDoubleDimension(){for (int i=1;i < 10;++i){SecondOrderDifferentialEquations eqn2=new Equations(i,0.2);FirstOrderConverter eqn1=new FirstOrderConverter(eqn2);Assert.assertTrue(eqn1.getDimension()== (2 * eqn2.getDimension()));}}
@Test public void testDecreasingSteps(){double previousError=Double.NaN;for (int i=0;i < 10;++i){double step=FastMath.pow(2.0,-(i + 1));double error=integrateWithSpecifiedStep(4.0,0.0,1.0,step)- FastMath.sin(4.0);if (i > 0){Assert.assertTrue(FastMath.abs(error)< FastMath.abs(previousError));}previousError=error;}}
@Test public void testSmallStep(){double error=integrateWithSpecifiedStep(4.0,0.0,1.0,1.0e-4)- FastMath.sin(4.0);Assert.assertTrue(FastMath.abs(error)< 1.0e-10);}
@Test public void testBigStep(){double error=integrateWithSpecifiedStep(4.0,0.0,1.0,0.5)- FastMath.sin(4.0);Assert.assertTrue(FastMath.abs(error)> 0.1);}
@Test public void testInverseCumulativeProbabilityExtremes()throws Exception {setInverseCumulativeTestPoints(new double[]{0.0,1.0});setInverseCumulativeTestValues(new double[]{Double.NEGATIVE_INFINITY,Double.POSITIVE_INFINITY});verifyInverseCumulativeProbabilities();}
@Test public void testMedian(){CauchyDistribution distribution=(CauchyDistribution)getDistribution();Assert.assertEquals(1.2,distribution.getMedian(),0.0);}
@Test public void testScale(){CauchyDistribution distribution=(CauchyDistribution)getDistribution();Assert.assertEquals(2.1,distribution.getScale(),0.0);}
@Test public void testPreconditions(){try {new CauchyDistribution(0,0);Assert.fail("Cannot have zero scale");}catch(NotStrictlyPositiveException ex){}try {new CauchyDistribution(0,-1);Assert.fail("Cannot have negative scale");}catch(NotStrictlyPositiveException ex){}}
@Test public void testMoments(){CauchyDistribution dist;dist=new CauchyDistribution(10.2,0.15);Assert.assertTrue(Double.isNaN(dist.getNumericalMean()));Assert.assertTrue(Double.isNaN(dist.getNumericalVariance()));dist=new CauchyDistribution(23.12,2.12);Assert.assertTrue(Double.isNaN(dist.getNumericalMean()));Assert.assertTrue(Double.isNaN(dist.getNumericalVariance()));}
/** * Verifies that cumulative probability density calculations match expected values using default test instance data*/@Test public void testCumulativeProbabilities()throws Exception {verifyCumulativeProbabilities();}
/** * Verifies that inverse cumulative probability density calculations match expected values using default test instance data*/@Test public void testInverseCumulativeProbabilities()throws Exception {verifyInverseCumulativeProbabilities();}
/** * Verifies that density calculations return expected values for default test instance data*/@Test public void testDensities()throws Exception {verifyDensities();}
/** * Verifies that probability computations are consistent*/@Test public void testConsistency()throws Exception {for (int i=1;i < cumulativeTestPoints.length;i++){TestUtils.assertEquals(0d,distribution.cumulativeProbability(cumulativeTestPoints[i],cumulativeTestPoints[i]),tolerance);double upper=FastMath.max(cumulativeTestPoints[i],cumulativeTestPoints[i - 1]);double lower=FastMath.min(cumulativeTestPoints[i],cumulativeTestPoints[i - 1]);double diff=distribution.cumulativeProbability(upper)- distribution.cumulativeProbability(lower);double direct=distribution.cumulativeProbability(lower,upper);TestUtils.assertEquals("Inconsistent cumulative probabilities for (" + lower + ","+ upper+ ")",diff,direct,tolerance);}}
/** * Verifies that illegal arguments are correctly handled*/@Test public void testIllegalArguments()throws Exception {try {distribution.cumulativeProbability(1,0);Assert.fail("Expecting MathIllegalArgumentException for bad cumulativeProbability interval");}catch(MathIllegalArgumentException ex){}try {distribution.inverseCumulativeProbability(-1);Assert.fail("Expecting MathIllegalArgumentException for p = -1");}catch(MathIllegalArgumentException ex){}try {distribution.inverseCumulativeProbability(2);Assert.fail("Expecting MathIllegalArgumentException for p = 2");}catch(MathIllegalArgumentException ex){}}
/** * Test sampling*/@Test public void testSampling()throws Exception {AbstractContinuousDistribution dist=(AbstractContinuousDistribution)makeDistribution();final int sampleSize=1000;dist.reseedRandomGenerator(1000);double[]sample=dist.sample(sampleSize);double[]quartiles=TestUtils.getDistributionQuartiles(dist);double[]expected={250,250,250,250};long[]counts=new long[4];for (int i=0;i < sampleSize;i++){TestUtils.updateCounts(sample[i],counts,quartiles);}TestUtils.assertChiSquareAccept(expected,counts,0.001);}
@Test public void testNonSquare(){try {new TriDiagonalTransformer(MatrixUtils.createRealMatrix(new double[3][2]));Assert.fail("an exception should have been thrown");}catch(NonSquareMatrixException ime){}}
@Test public void testAEqualQTQt(){checkAEqualQTQt(MatrixUtils.createRealMatrix(testSquare5));checkAEqualQTQt(MatrixUtils.createRealMatrix(testSquare3));}
@Test public void testNoAccessBelowDiagonal(){checkNoAccessBelowDiagonal(testSquare5);checkNoAccessBelowDiagonal(testSquare3);}
@Test public void testQOrthogonal(){checkOrthogonal(new TriDiagonalTransformer(MatrixUtils.createRealMatrix(testSquare5)).getQ());checkOrthogonal(new TriDiagonalTransformer(MatrixUtils.createRealMatrix(testSquare3)).getQ());}
@Test public void testQTOrthogonal(){checkOrthogonal(new TriDiagonalTransformer(MatrixUtils.createRealMatrix(testSquare5)).getQT());checkOrthogonal(new TriDiagonalTransformer(MatrixUtils.createRealMatrix(testSquare3)).getQT());}
@Test public void testTTriDiagonal(){checkTriDiagonal(new TriDiagonalTransformer(MatrixUtils.createRealMatrix(testSquare5)).getT());checkTriDiagonal(new TriDiagonalTransformer(MatrixUtils.createRealMatrix(testSquare3)).getT());}
@Test public void testMatricesValues5(){checkMatricesValues(testSquare5,new double[][]{{1.0,0.0,0.0,0.0,0.0},{0.0,-0.5163977794943222,0.016748280772542083,0.839800693771262,0.16669620021405473},{0.0,-0.7745966692414833,-0.4354553000860955,-0.44989322880603355,-0.08930153582895772},{0.0,-0.2581988897471611,0.6364346693566014,-0.30263204032131164,0.6608313651342882},{0.0,-0.2581988897471611,0.6364346693566009,-0.027289660803112598,-0.7263191580755246}},new double[]{1,4.4,1.433099579242636,-0.89537362758743,2.062274048344794},new double[]{-FastMath.sqrt(15),-3.0832882879592476,0.6082710842351517,1.1786086405912128});}
@Test public void testMatricesValues3(){checkMatricesValues(testSquare3,new double[][]{{1.0,0.0,0.0},{0.0,-0.6,0.8},{0.0,-0.8,-0.6}},new double[]{1,2.64,-0.64},new double[]{-5,-1.52});}
@Test(expected=NumberIsTooSmallException.class)public void testPreconditions1(){HarmonicFitter fitter=new HarmonicFitter(new LevenbergMarquardtOptimizer());fitter.fit();}
@Test public void testNoError(){final double a=0.2;final double w=3.4;final double p=4.1;HarmonicOscillator f=new HarmonicOscillator(a,w,p);HarmonicFitter fitter=new HarmonicFitter(new LevenbergMarquardtOptimizer());for (double x=0.0;x < 1.3;x+=0.01){fitter.addObservedPoint(1,x,f.value(x));}final double[]fitted=fitter.fit();Assert.assertEquals(a,fitted[0],1.0e-13);Assert.assertEquals(w,fitted[1],1.0e-13);Assert.assertEquals(p,MathUtils.normalizeAngle(fitted[2],p),1e-13);HarmonicOscillator ff=new HarmonicOscillator(fitted[0],fitted[1],fitted[2]);for (double x=-1.0;x < 1.0;x+=0.01){Assert.assertTrue(FastMath.abs(f.value(x)- ff.value(x))< 1e-13);}}
@Test public void test1PercentError(){Random randomizer=new Random(64925784252l);final double a=0.2;final double w=3.4;final double p=4.1;HarmonicOscillator f=new HarmonicOscillator(a,w,p);HarmonicFitter fitter=new HarmonicFitter(new LevenbergMarquardtOptimizer());for (double x=0.0;x < 10.0;x+=0.1){fitter.addObservedPoint(1,x,f.value(x)+ 0.01 * randomizer.nextGaussian());}final double[]fitted=fitter.fit();Assert.assertEquals(a,fitted[0],7.6e-4);Assert.assertEquals(w,fitted[1],2.7e-3);Assert.assertEquals(p,MathUtils.normalizeAngle(fitted[2],p),1.3e-2);}
@Test public void testTinyVariationsData(){Random randomizer=new Random(64925784252l);HarmonicFitter fitter=new HarmonicFitter(new LevenbergMarquardtOptimizer());for (double x=0.0;x < 10.0;x+=0.1){fitter.addObservedPoint(1,x,1e-7 * randomizer.nextGaussian());}fitter.fit();}
@Test public void testInitialGuess(){Random randomizer=new Random(45314242l);final double a=0.2;final double w=3.4;final double p=4.1;HarmonicOscillator f=new HarmonicOscillator(a,w,p);HarmonicFitter fitter=new HarmonicFitter(new LevenbergMarquardtOptimizer());for (double x=0.0;x < 10.0;x+=0.1){fitter.addObservedPoint(1,x,f.value(x)+ 0.01 * randomizer.nextGaussian());}final double[]fitted=fitter.fit(new double[]{0.15,3.6,4.5});Assert.assertEquals(a,fitted[0],1.2e-3);Assert.assertEquals(w,fitted[1],3.3e-3);Assert.assertEquals(p,MathUtils.normalizeAngle(fitted[2],p),1.7e-2);}
@Test public void testUnsorted(){Random randomizer=new Random(64925784252l);final double a=0.2;final double w=3.4;final double p=4.1;HarmonicOscillator f=new HarmonicOscillator(a,w,p);HarmonicFitter fitter=new HarmonicFitter(new LevenbergMarquardtOptimizer());int size=100;double[]xTab=new double[size];double[]yTab=new double[size];for (int i=0;i < size;++i){xTab[i]=0.1 * i;yTab[i]=f.value(xTab[i])+ 0.01 * randomizer.nextGaussian();}for (int i=0;i < size;++i){int i1=randomizer.nextInt(size);int i2=randomizer.nextInt(size);double xTmp=xTab[i1];double yTmp=yTab[i1];xTab[i1]=xTab[i2];yTab[i1]=yTab[i2];xTab[i2]=xTmp;yTab[i2]=yTmp;}for (int i=0;i < size;++i){fitter.addObservedPoint(1,xTab[i],yTab[i]);}final double[]fitted=fitter.fit();Assert.assertEquals(a,fitted[0],7.6e-4);Assert.assertEquals(w,fitted[1],3.5e-3);Assert.assertEquals(p,MathUtils.normalizeAngle(fitted[2],p),1.5e-2);}
@Test public void testMutate(){MutationPolicy mutation=new RandomKeyMutation();int l=10;for (int i=0;i < 20;i++){DummyRandomKey origRk=new DummyRandomKey(RandomKey.randomPermutation(l));Chromosome mutated=mutation.mutate(origRk);DummyRandomKey mutatedRk=(DummyRandomKey)mutated;int changes=0;for (int j=0;j < origRk.getLength();j++){if (origRk.getRepresentation().get(j)!= mutatedRk.getRepresentation().get(j)){changes++;}}Assert.assertEquals(1,changes);}}
@Test(expected=NonSquareOperatorException.class)public void testNonSquareOperator(){final Array2DRowRealMatrix a=new Array2DRowRealMatrix(2,3);final IterativeLinearSolver solver;solver=new ConjugateGradient(10,0.,false);final ArrayRealVector b=new ArrayRealVector(a.getRowDimension());final ArrayRealVector x=new ArrayRealVector(a.getColumnDimension());solver.solve(a,b,x);}
@Test(expected=DimensionMismatchException.class)public void testDimensionMismatchRightHandSide(){final Array2DRowRealMatrix a=new Array2DRowRealMatrix(3,3);final IterativeLinearSolver solver;solver=new ConjugateGradient(10,0.,false);final ArrayRealVector b=new ArrayRealVector(2);final ArrayRealVector x=new ArrayRealVector(3);solver.solve(a,b,x);}
@Test(expected=DimensionMismatchException.class)public void testDimensionMismatchSolution(){final Array2DRowRealMatrix a=new Array2DRowRealMatrix(3,3);final IterativeLinearSolver solver;solver=new ConjugateGradient(10,0.,false);final ArrayRealVector b=new ArrayRealVector(3);final ArrayRealVector x=new ArrayRealVector(2);solver.solve(a,b,x);}
@Test(expected=NonPositiveDefiniteOperatorException.class)public void testNonPositiveDefiniteLinearOperator(){final Array2DRowRealMatrix a=new Array2DRowRealMatrix(2,2);a.setEntry(0,0,-1.);a.setEntry(0,1,2.);a.setEntry(1,0,3.);a.setEntry(1,1,4.);final IterativeLinearSolver solver;solver=new ConjugateGradient(10,0.,true);final ArrayRealVector b=new ArrayRealVector(2);b.setEntry(0,-1.);b.setEntry(1,-1.);final ArrayRealVector x=new ArrayRealVector(2);solver.solve(a,b,x);}
@Test public void testUnpreconditionedSolution(){final int n=5;final int maxIterations=100;final RealLinearOperator a=new HilbertMatrix(n);final InverseHilbertMatrix ainv=new InverseHilbertMatrix(n);final IterativeLinearSolver solver;solver=new ConjugateGradient(maxIterations,1E-10,true);final RealVector b=new ArrayRealVector(n);for (int j=0;j < n;j++){b.set(0.);b.setEntry(j,1.);final RealVector x=solver.solve(a,b);for (int i=0;i < n;i++){final double actual=x.getEntry(i);final double expected=ainv.getEntry(i,j);final double delta=1E-10 * Math.abs(expected);final String msg=String.format("entry[%d][%d]",i,j);Assert.assertEquals(msg,expected,actual,delta);}}}
@Test public void testUnpreconditionedInPlaceSolutionWithInitialGuess(){final int n=5;final int maxIterations=100;final RealLinearOperator a=new HilbertMatrix(n);final InverseHilbertMatrix ainv=new InverseHilbertMatrix(n);final IterativeLinearSolver solver;solver=new ConjugateGradient(maxIterations,1E-10,true);final RealVector b=new ArrayRealVector(n);for (int j=0;j < n;j++){b.set(0.);b.setEntry(j,1.);final RealVector x0=new ArrayRealVector(n);x0.set(1.);final RealVector x=solver.solveInPlace(a,b,x0);Assert.assertSame("x should be a reference to x0",x0,x);for (int i=0;i < n;i++){final double actual=x.getEntry(i);final double expected=ainv.getEntry(i,j);final double delta=1E-10 * Math.abs(expected);final String msg=String.format("entry[%d][%d)",i,j);Assert.assertEquals(msg,expected,actual,delta);}}}
@Test public void testUnpreconditionedSolutionWithInitialGuess(){final int n=5;final int maxIterations=100;final RealLinearOperator a=new HilbertMatrix(n);final InverseHilbertMatrix ainv=new InverseHilbertMatrix(n);final IterativeLinearSolver solver;solver=new ConjugateGradient(maxIterations,1E-10,true);final RealVector b=new ArrayRealVector(n);for (int j=0;j < n;j++){b.set(0.);b.setEntry(j,1.);final RealVector x0=new ArrayRealVector(n);x0.set(1.);final RealVector x=solver.solve(a,b,x0);Assert.assertNotSame("x should not be a reference to x0",x0,x);for (int i=0;i < n;i++){final double actual=x.getEntry(i);final double expected=ainv.getEntry(i,j);final double delta=1E-10 * Math.abs(expected);final String msg=String.format("entry[%d][%d]",i,j);Assert.assertEquals(msg,expected,actual,delta);Assert.assertEquals(msg,x0.getEntry(i),1.,Math.ulp(1.));}}}
/** * Check whether the estimate of the (updated)residual corresponds to the exact residual. This fails to be true for a large number of iterations,due to the loss of orthogonality of the successive search directions. Therefore,in the present test,the number of iterations is limited.*/@Test public void testUnpreconditionedResidual(){final int n=10;final int maxIterations=n;final RealLinearOperator a=new HilbertMatrix(n);final ConjugateGradient solver;solver=new ConjugateGradient(maxIterations,1E-15,true);final RealVector r=new ArrayRealVector(n);final RealVector x=new ArrayRealVector(n);final IterationListener listener=new IterationListener(){public void terminationPerformed(final IterationEvent e){}public void iterationStarted(final IterationEvent e){}public void iterationPerformed(final IterationEvent e){RealVector v=((ProvidesResidual)e).getResidual();r.setSubVector(0,v);v=((IterativeLinearSolverEvent)e).getSolution();x.setSubVector(0,v);}public void initializationPerformed(final IterationEvent e){}};solver.getIterationManager().addIterationListener(listener);final RealVector b=new ArrayRealVector(n);for (int j=0;j < n;j++){b.set(0.);b.setEntry(j,1.);boolean caught=false;try {solver.solve(a,b);}catch(MaxCountExceededException e){caught=true;final RealVector y=a.operate(x);for (int i=0;i < n;i++){final double actual=b.getEntry(i)- y.getEntry(i);final double expected=r.getEntry(i);final double delta=1E-6 * Math.abs(expected);final String msg=String.format("column %d,residual %d",i,j);Assert.assertEquals(msg,expected,actual,delta);}}Assert.assertTrue("MaxCountExceededException should have been caught",caught);}}
@Test(expected=NonSquareOperatorException.class)public void testNonSquarePreconditioner(){final Array2DRowRealMatrix a=new Array2DRowRealMatrix(2,2);final InvertibleRealLinearOperator m;m=new InvertibleRealLinearOperator(){@Override public RealVector operate(final RealVector x){throw new UnsupportedOperationException();}@Override public int getRowDimension(){return 2;}@Override public int getColumnDimension(){return 3;}@Override public RealVector solve(final RealVector b){throw new UnsupportedOperationException();}};final PreconditionedIterativeLinearSolver solver;solver=new ConjugateGradient(10,0d,false);final ArrayRealVector b=new ArrayRealVector(a.getRowDimension());solver.solve(a,m,b);}
@Test(expected=DimensionMismatchException.class)public void testMismatchedOperatorDimensions(){final Array2DRowRealMatrix a=new Array2DRowRealMatrix(2,2);final InvertibleRealLinearOperator m;m=new InvertibleRealLinearOperator(){@Override public RealVector operate(final RealVector x){throw new UnsupportedOperationException();}@Override public int getRowDimension(){return 3;}@Override public int getColumnDimension(){return 3;}@Override public RealVector solve(final RealVector b){throw new UnsupportedOperationException();}};final PreconditionedIterativeLinearSolver solver;solver=new ConjugateGradient(10,0d,false);final ArrayRealVector b=new ArrayRealVector(a.getRowDimension());solver.solve(a,m,b);}
@Test(expected=NonPositiveDefiniteOperatorException.class)public void testNonPositiveDefinitePreconditioner(){final Array2DRowRealMatrix a=new Array2DRowRealMatrix(2,2);a.setEntry(0,0,1d);a.setEntry(0,1,2d);a.setEntry(1,0,3d);a.setEntry(1,1,4d);final InvertibleRealLinearOperator m;m=new InvertibleRealLinearOperator(){@Override public RealVector operate(final RealVector x){final ArrayRealVector y=new ArrayRealVector(2);y.setEntry(0,-x.getEntry(0));y.setEntry(1,x.getEntry(1));return y;}@Override public int getRowDimension(){return 2;}@Override public int getColumnDimension(){return 2;}@Override public RealVector solve(final RealVector b){final ArrayRealVector x=new ArrayRealVector(2);x.setEntry(0,-b.getEntry(0));x.setEntry(1,b.getEntry(1));return x;}};final PreconditionedIterativeLinearSolver solver;solver=new ConjugateGradient(10,0d,true);final ArrayRealVector b=new ArrayRealVector(2);b.setEntry(0,-1d);b.setEntry(1,-1d);solver.solve(a,m,b);}
@Test public void testPreconditionedSolution(){final int n=8;final int maxIterations=100;final RealLinearOperator a=new HilbertMatrix(n);final InverseHilbertMatrix ainv=new InverseHilbertMatrix(n);final InvertibleRealLinearOperator m=JacobiPreconditioner.create(a);final PreconditionedIterativeLinearSolver solver;solver=new ConjugateGradient(maxIterations,1E-15,true);final RealVector b=new ArrayRealVector(n);for (int j=0;j < n;j++){b.set(0.);b.setEntry(j,1.);final RealVector x=solver.solve(a,m,b);for (int i=0;i < n;i++){final double actual=x.getEntry(i);final double expected=ainv.getEntry(i,j);final double delta=1E-6 * Math.abs(expected);final String msg=String.format("coefficient (%d,%d)",i,j);Assert.assertEquals(msg,expected,actual,delta);}}}
@Test public void testPreconditionedResidual(){final int n=10;final int maxIterations=n;final RealLinearOperator a=new HilbertMatrix(n);final InvertibleRealLinearOperator m=JacobiPreconditioner.create(a);final ConjugateGradient solver;solver=new ConjugateGradient(maxIterations,1E-15,true);final RealVector r=new ArrayRealVector(n);final RealVector x=new ArrayRealVector(n);final IterationListener listener=new IterationListener(){public void terminationPerformed(final IterationEvent e){}public void iterationStarted(final IterationEvent e){}public void iterationPerformed(final IterationEvent e){RealVector v=((ProvidesResidual)e).getResidual();r.setSubVector(0,v);v=((IterativeLinearSolverEvent)e).getSolution();x.setSubVector(0,v);}public void initializationPerformed(final IterationEvent e){}};solver.getIterationManager().addIterationListener(listener);final RealVector b=new ArrayRealVector(n);for (int j=0;j < n;j++){b.set(0.);b.setEntry(j,1.);boolean caught=false;try {solver.solve(a,m,b);}catch(MaxCountExceededException e){caught=true;final RealVector y=a.operate(x);for (int i=0;i < n;i++){final double actual=b.getEntry(i)- y.getEntry(i);final double expected=r.getEntry(i);final double delta=1E-6 * Math.abs(expected);final String msg=String.format("column %d,residual %d",i,j);Assert.assertEquals(msg,expected,actual,delta);}}Assert.assertTrue("MaxCountExceededException should have been caught",caught);}}
@Test public void testPreconditionedSolution2(){final int n=100;final int maxIterations=100000;final Array2DRowRealMatrix a=new Array2DRowRealMatrix(n,n);double daux=1.;for (int i=0;i < n;i++){a.setEntry(i,i,daux);daux*=1.2;for (int j=i + 1;j < n;j++){if (i == j){}else {final double value=1.0;a.setEntry(i,j,value);a.setEntry(j,i,value);}}}final InvertibleRealLinearOperator m=JacobiPreconditioner.create(a);final PreconditionedIterativeLinearSolver pcg;final IterativeLinearSolver cg;pcg=new ConjugateGradient(maxIterations,1E-6,true);cg=new ConjugateGradient(maxIterations,1E-6,true);final RealVector b=new ArrayRealVector(n);final String pattern="preconditioned gradient (%d iterations)should" + " have been faster than unpreconditioned (%d iterations)";String msg;for (int j=0;j < 1;j++){b.set(0.);b.setEntry(j,1.);final RealVector px=pcg.solve(a,m,b);final RealVector x=cg.solve(a,b);final int npcg=pcg.getIterationManager().getIterations();final int ncg=cg.getIterationManager().getIterations();msg=String.format(pattern,npcg,ncg);Assert.assertTrue(msg,npcg < ncg);for (int i=0;i < n;i++){msg=String.format("row %d,column %d",i,j);final double expected=x.getEntry(i);final double actual=px.getEntry(i);final double delta=1E-6 * Math.abs(expected);Assert.assertEquals(msg,expected,actual,delta);}}}
@Test public void testEventManagement(){final int n=5;final int maxIterations=100;final RealLinearOperator a=new HilbertMatrix(n);final IterativeLinearSolver solver;final int[]count=new int[]{0,0,0,0};final IterationListener listener=new IterationListener(){public void initializationPerformed(final IterationEvent e){count[0]=1;count[1]=0;count[2]=0;count[3]=0;}public void iterationPerformed(final IterationEvent e){++count[2];}public void iterationStarted(IterationEvent e){++count[1];}public void terminationPerformed(final IterationEvent e){++count[3];}};solver=new ConjugateGradient(maxIterations,1E-10,true);solver.getIterationManager().addIterationListener(listener);final RealVector b=new ArrayRealVector(n);for (int j=0;j < n;j++){b.set(0.);b.setEntry(j,1.);solver.solve(a,b);String msg=String.format("column %d (initialization)",j);Assert.assertEquals(msg,1,count[0]);msg=String.format("column %d (iterations started)",j);Assert.assertEquals(msg,solver.getIterationManager().getIterations()- 1,count[1]);msg=String.format("column %d (iterations performed)",j);Assert.assertEquals(msg,solver.getIterationManager().getIterations()- 1,count[2]);msg=String.format("column %d (finalization)",j);Assert.assertEquals(msg,1,count[3]);}}
@Test(expected=NumberIsTooSmallException.class)public void testInsufficientOrder1(){new BracketingNthOrderBrentSolver(1.0e-10,1);}
@Test(expected=NumberIsTooSmallException.class)public void testInsufficientOrder2(){new BracketingNthOrderBrentSolver(1.0e-10,1.0e-10,1);}
@Test(expected=NumberIsTooSmallException.class)public void testInsufficientOrder3(){new BracketingNthOrderBrentSolver(1.0e-10,1.0e-10,1.0e-10,1);}
@Test public void testConstructorsOK(){Assert.assertEquals(2,new BracketingNthOrderBrentSolver(1.0e-10,2).getMaximalOrder());Assert.assertEquals(2,new BracketingNthOrderBrentSolver(1.0e-10,1.0e-10,2).getMaximalOrder());Assert.assertEquals(2,new BracketingNthOrderBrentSolver(1.0e-10,1.0e-10,1.0e-10,2).getMaximalOrder());}
@Test public void testConvergenceOnFunctionAccuracy(){BracketingNthOrderBrentSolver solver=new BracketingNthOrderBrentSolver(1.0e-12,1.0e-10,0.001,3);QuinticFunction f=new QuinticFunction();double result=solver.solve(20,f,0.2,0.9,0.4,AllowedSolution.BELOW_SIDE);Assert.assertEquals(0,f.value(result),solver.getFunctionValueAccuracy());Assert.assertTrue(f.value(result)<= 0);Assert.assertTrue(result - 0.5 > solver.getAbsoluteAccuracy());result=solver.solve(20,f,-0.9,-0.2,-0.4,AllowedSolution.ABOVE_SIDE);Assert.assertEquals(0,f.value(result),solver.getFunctionValueAccuracy());Assert.assertTrue(f.value(result)>= 0);Assert.assertTrue(result + 0.5 < -solver.getAbsoluteAccuracy());}
@Test public void testFasterThanNewton(){compare(new TestFunction(0.0,-2,2){@Override public double value(double x){return FastMath.sin(x)- 0.5 * x;}@Override public double derivative(double x){return FastMath.cos(x)- 0.5;}});compare(new TestFunction(6.3087771299726890947,-5,10){@Override public double value(double x){return FastMath.pow(x,5)+ x - 10000;}@Override public double derivative(double x){return 5 * FastMath.pow(x,4)+ 1;}});compare(new TestFunction(9.6335955628326951924,0.001,10){@Override public double value(double x){return FastMath.sqrt(x)- 1 / x - 3;}@Override public double derivative(double x){return 0.5 / FastMath.sqrt(x)+ 1 / (x * x);}});compare(new TestFunction(2.8424389537844470678,-5,5){@Override public double value(double x){return FastMath.exp(x)+ x - 20;}@Override public double derivative(double x){return FastMath.exp(x)+ 1;}});compare(new TestFunction(8.3094326942315717953,0.001,10){@Override public double value(double x){return FastMath.log(x)+ FastMath.sqrt(x)- 5;}@Override public double derivative(double x){return 1 / x + 0.5 / FastMath.sqrt(x);}});compare(new TestFunction(1.4655712318767680266,-0.5,1.5){@Override public double value(double x){return (x - 1)* x * x - 1;}@Override public double derivative(double x){return (3 * x - 2)* x;}});}
@Test public void testSinZero(){UnivariateFunction f=new SinFunction();double result;UnivariateRealSolver solver=getSolver();result=solver.solve(100,f,3,4);Assert.assertEquals(result,FastMath.PI,solver.getAbsoluteAccuracy());Assert.assertTrue(solver.getEvaluations()<= 6);result=solver.solve(100,f,1,4);Assert.assertEquals(result,FastMath.PI,solver.getAbsoluteAccuracy());Assert.assertTrue(solver.getEvaluations()<= 7);}
@Test public void testQuinticZero(){UnivariateFunction f=new QuinticFunction();double result;UnivariateRealSolver solver=getSolver();double atol=solver.getAbsoluteAccuracy();int[]counts=getQuinticEvalCounts();double[][]testsData={{-0.2,0.2,0.0},{-0.1,0.3,0.0},{-0.3,0.45,0.0},{0.3,0.7,0.5},{0.2,0.6,0.5},{0.05,0.95,0.5},{0.85,1.25,1.0},{0.8,1.2,1.0},{0.85,1.75,1.0},{0.55,1.45,1.0},{0.85,5.0,1.0}};int maxIter=500;for (int i=0;i < testsData.length;i++){if (counts[i]== -1)continue;double[]testData=testsData[i];result=solver.solve(maxIter,f,testData[0],testData[1]);Assert.assertEquals(result,testData[2],atol);Assert.assertTrue(solver.getEvaluations()<= counts[i]+ 1);}}
@Test public void testRootEndpoints(){UnivariateFunction f=new XMinus5Function();UnivariateRealSolver solver=getSolver();double result=solver.solve(100,f,5.0,6.0);Assert.assertEquals(5.0,result,0.0);result=solver.solve(100,f,4.0,5.0);Assert.assertEquals(5.0,result,0.0);result=solver.solve(100,f,5.0,6.0,5.5);Assert.assertEquals(5.0,result,0.0);result=solver.solve(100,f,4.0,5.0,4.5);Assert.assertEquals(5.0,result,0.0);}
@Test public void testBadEndpoints(){UnivariateFunction f=new SinFunction();UnivariateRealSolver solver=getSolver();try {solver.solve(100,f,1,-1);Assert.fail("Expecting NumberIsTooLargeException - bad interval");}catch(NumberIsTooLargeException ex){}try {solver.solve(100,f,1,1.5);Assert.fail("Expecting NoBracketingException - non-bracketing");}catch(NoBracketingException ex){}try {solver.solve(100,f,1,1.5,1.2);Assert.fail("Expecting NoBracketingException - non-bracketing");}catch(NoBracketingException ex){}}
@Test public void testSolutionLeftSide(){UnivariateFunction f=new SinFunction();UnivariateRealSolver solver=getSolver();double left=-1.5;double right=0.05;for (int i=0;i < 10;i++){double solution=getSolution(solver,100,f,left,right,AllowedSolution.LEFT_SIDE);if (!Double.isNaN(solution)){Assert.assertTrue(solution <= 0.0);}left-=0.1;right+=0.3;}}
@Test public void testSolutionRightSide(){UnivariateFunction f=new SinFunction();UnivariateRealSolver solver=getSolver();double left=-1.5;double right=0.05;for (int i=0;i < 10;i++){double solution=getSolution(solver,100,f,left,right,AllowedSolution.RIGHT_SIDE);if (!Double.isNaN(solution)){Assert.assertTrue(solution >= 0.0);}left-=0.1;right+=0.3;}}
@Test public void testSolutionBelowSide(){UnivariateFunction f=new SinFunction();UnivariateRealSolver solver=getSolver();double left=-1.5;double right=0.05;for (int i=0;i < 10;i++){double solution=getSolution(solver,100,f,left,right,AllowedSolution.BELOW_SIDE);if (!Double.isNaN(solution)){Assert.assertTrue(f.value(solution)<= 0.0);}left-=0.1;right+=0.3;}}
@Test public void testSolutionAboveSide(){UnivariateFunction f=new SinFunction();UnivariateRealSolver solver=getSolver();double left=-1.5;double right=0.05;for (int i=0;i < 10;i++){double solution=getSolution(solver,100,f,left,right,AllowedSolution.ABOVE_SIDE);if (!Double.isNaN(solution)){Assert.assertTrue(f.value(solution)>= 0.0);}left-=0.1;right+=0.3;}}
/** * Test of interpolator for the sine function. <p> |sin^(n)(zeta)| <= 1.0,zeta in [0,2*PI]*/@Test public void testSinFunction(){UnivariateFunction f=new SinFunction();UnivariateRealInterpolator interpolator=new DividedDifferenceInterpolator();double x[],y[],z,expected,result,tolerance;int n=6;double min=0.0,max=2 * FastMath.PI;x=new double[n];y=new double[n];for (int i=0;i < n;i++){x[i]=min + i * (max - min)/ n;y[i]=f.value(x[i]);}double derivativebound=1.0;UnivariateFunction p=interpolator.interpolate(x,y);z=FastMath.PI / 4;expected=f.value(z);result=p.value(z);tolerance=FastMath.abs(derivativebound * partialerror(x,z));Assert.assertEquals(expected,result,tolerance);z=FastMath.PI * 1.5;expected=f.value(z);result=p.value(z);tolerance=FastMath.abs(derivativebound * partialerror(x,z));Assert.assertEquals(expected,result,tolerance);}
/** * Test of interpolator for the exponential function. <p> |expm1^(n)(zeta)| <= e,zeta in [-1,1]*/@Test public void testExpm1Function(){UnivariateFunction f=new Expm1Function();UnivariateRealInterpolator interpolator=new DividedDifferenceInterpolator();double x[],y[],z,expected,result,tolerance;int n=5;double min=-1.0,max=1.0;x=new double[n];y=new double[n];for (int i=0;i < n;i++){x[i]=min + i * (max - min)/ n;y[i]=f.value(x[i]);}double derivativebound=FastMath.E;UnivariateFunction p=interpolator.interpolate(x,y);z=0.0;expected=f.value(z);result=p.value(z);tolerance=FastMath.abs(derivativebound * partialerror(x,z));Assert.assertEquals(expected,result,tolerance);z=0.5;expected=f.value(z);result=p.value(z);tolerance=FastMath.abs(derivativebound * partialerror(x,z));Assert.assertEquals(expected,result,tolerance);z=-0.5;expected=f.value(z);result=p.value(z);tolerance=FastMath.abs(derivativebound * partialerror(x,z));Assert.assertEquals(expected,result,tolerance);}
/** * Test of parameters for the interpolator.*/@Test public void testParameters()throws Exception {UnivariateRealInterpolator interpolator=new DividedDifferenceInterpolator();try {double x[]={1.0,2.0,2.0,4.0};double y[]={0.0,4.0,4.0,2.5};UnivariateFunction p=interpolator.interpolate(x,y);p.value(0.0);Assert.fail("Expecting NonMonotonicSequenceException - bad abscissas array");}catch(NonMonotonicSequenceException ex){}}
/** * Test of interpolator for a plane. <p> y = 2 x<sub>1</sub> - 3 x<sub>2</sub> + 5*/@Test public void testLinearFunction2D(){MultivariateFunction f=new MultivariateFunction(){public double value(double[]x){if (x.length != 2){throw new IllegalArgumentException();}return 2 * x[0]- 3 * x[1]+ 5;}};MultivariateRealInterpolator interpolator=new MicrosphereInterpolator();final int n=9;final int dim=2;double[][]x=new double[n][dim];double[]y=new double[n];int index=0;for (int i=-1;i <= 1;i++){for (int j=-1;j <= 1;j++){x[index][0]=i;x[index][1]=j;y[index]=f.value(x[index]);++index;}}MultivariateFunction p=interpolator.interpolate(x,y);double[]c=new double[dim];double expected,result;c[0]=0;c[1]=0;expected=f.value(c);result=p.value(c);Assert.assertEquals("On sample point",expected,result,FastMath.ulp(1d));c[0]=0 + 1e-5;c[1]=1 - 1e-5;expected=f.value(c);result=p.value(c);Assert.assertEquals("1e-5 away from sample point",expected,result,1e-4);}
/** * Test of interpolator for a quadratic function. <p> y = 2 x<sub>1</sub><sup>2</sup> - 3 x<sub>2</sub><sup>2</sup> + 4 x<sub>1</sub> x<sub>2</sub> - 5*/@Test public void testParaboloid2D(){MultivariateFunction f=new MultivariateFunction(){public double value(double[]x){if (x.length != 2){throw new IllegalArgumentException();}return 2 * x[0]* x[0]- 3 * x[1]* x[1]+ 4 * x[0]* x[1]- 5;}};MultivariateRealInterpolator interpolator=new MicrosphereInterpolator();final int n=121;final int dim=2;double[][]x=new double[n][dim];double[]y=new double[n];int index=0;for (int i=-10;i <= 10;i+=2){for (int j=-10;j <= 10;j+=2){x[index][0]=i;x[index][1]=j;y[index]=f.value(x[index]);++index;}}MultivariateFunction p=interpolator.interpolate(x,y);double[]c=new double[dim];double expected,result;c[0]=0;c[1]=0;expected=f.value(c);result=p.value(c);Assert.assertEquals("On sample point",expected,result,FastMath.ulp(1d));c[0]=2 + 1e-5;c[1]=2 - 1e-5;expected=f.value(c);result=p.value(c);Assert.assertEquals("1e-5 away from sample point",expected,result,1e-3);}
@Test(expected=DimensionMismatchException.class)public void testDimensionCheck(){TestProblem1 pb=new TestProblem1();new ThreeEighthesIntegrator(0.01).integrate(pb,0.0,new double[pb.getDimension()+ 10],1.0,new double[pb.getDimension()+ 10]);Assert.fail("an exception should have been thrown");}
@Test public void testDecreasingSteps(){TestProblemAbstract[]problems=TestProblemFactory.getProblems();for (int k=0;k < problems.length;++k){double previousValueError=Double.NaN;double previousTimeError=Double.NaN;for (int i=4;i < 10;++i){TestProblemAbstract pb=problems[k].copy();double step=(pb.getFinalTime()- pb.getInitialTime())* FastMath.pow(2.0,-i);FirstOrderIntegrator integ=new ThreeEighthesIntegrator(step);TestProblemHandler handler=new TestProblemHandler(pb,integ);integ.addStepHandler(handler);EventHandler[]functions=pb.getEventsHandlers();for (int l=0;l < functions.length;++l){integ.addEventHandler(functions[l],Double.POSITIVE_INFINITY,1.0e-6 * step,1000);}double stopTime=integ.integrate(pb,pb.getInitialTime(),pb.getInitialState(),pb.getFinalTime(),new double[pb.getDimension()]);if (functions.length == 0){Assert.assertEquals(pb.getFinalTime(),stopTime,1.0e-10);}double error=handler.getMaximalValueError();if (i > 4){Assert.assertTrue(error < 1.01 * FastMath.abs(previousValueError));}previousValueError=error;double timeError=handler.getMaximalTimeError();if (i > 4){Assert.assertTrue(timeError <= FastMath.abs(previousTimeError));}previousTimeError=timeError;}}}
@Test public void testSmallStep(){TestProblem1 pb=new TestProblem1();double step=(pb.getFinalTime()- pb.getInitialTime())* 0.001;FirstOrderIntegrator integ=new ThreeEighthesIntegrator(step);TestProblemHandler handler=new TestProblemHandler(pb,integ);integ.addStepHandler(handler);integ.integrate(pb,pb.getInitialTime(),pb.getInitialState(),pb.getFinalTime(),new double[pb.getDimension()]);Assert.assertTrue(handler.getLastError()< 2.0e-13);Assert.assertTrue(handler.getMaximalValueError()< 4.0e-12);Assert.assertEquals(0,handler.getMaximalTimeError(),1.0e-12);Assert.assertEquals("3/8",integ.getName());}
@Test public void testBigStep(){TestProblem1 pb=new TestProblem1();double step=(pb.getFinalTime()- pb.getInitialTime())* 0.2;FirstOrderIntegrator integ=new ThreeEighthesIntegrator(step);TestProblemHandler handler=new TestProblemHandler(pb,integ);integ.addStepHandler(handler);integ.integrate(pb,pb.getInitialTime(),pb.getInitialState(),pb.getFinalTime(),new double[pb.getDimension()]);Assert.assertTrue(handler.getLastError()> 0.0004);Assert.assertTrue(handler.getMaximalValueError()> 0.005);Assert.assertEquals(0,handler.getMaximalTimeError(),1.0e-12);}
@Test public void testBackward(){TestProblem5 pb=new TestProblem5();double step=FastMath.abs(pb.getFinalTime()- pb.getInitialTime())* 0.001;FirstOrderIntegrator integ=new ThreeEighthesIntegrator(step);TestProblemHandler handler=new TestProblemHandler(pb,integ);integ.addStepHandler(handler);integ.integrate(pb,pb.getInitialTime(),pb.getInitialState(),pb.getFinalTime(),new double[pb.getDimension()]);Assert.assertTrue(handler.getLastError()< 5.0e-10);Assert.assertTrue(handler.getMaximalValueError()< 7.0e-10);Assert.assertEquals(0,handler.getMaximalTimeError(),1.0e-12);Assert.assertEquals("3/8",integ.getName());}
@Test public void testKepler(){final TestProblem3 pb=new TestProblem3(0.9);double step=(pb.getFinalTime()- pb.getInitialTime())* 0.0003;FirstOrderIntegrator integ=new ThreeEighthesIntegrator(step);integ.addStepHandler(new KeplerHandler(pb));integ.integrate(pb,pb.getInitialTime(),pb.getInitialState(),pb.getFinalTime(),new double[pb.getDimension()]);}
@Test public void testStepSize(){final double step=1.23456;FirstOrderIntegrator integ=new ThreeEighthesIntegrator(step);integ.addStepHandler(new StepHandler(){public void handleStep(StepInterpolator interpolator,boolean isLast){if (!isLast){Assert.assertEquals(step,interpolator.getCurrentTime()- interpolator.getPreviousTime(),1.0e-12);}}public void init(double t0,double[]y0,double t){}});integ.integrate(new FirstOrderDifferentialEquations(){public void computeDerivatives(double t,double[]y,double[]dot){dot[0]=1.0;}public int getDimension(){return 1;}},0.0,new double[]{0.0},5.0,new double[1]);}
@Test public void testChiSquare()throws Exception {long[]observed={10,9,11};double[]expected={10,10,10};Assert.assertEquals("chi-square statistic",0.2,TestUtils.chiSquare(expected,observed),10E-12);Assert.assertEquals("chi-square p-value",0.904837418036,TestUtils.chiSquareTest(expected,observed),1E-10);long[]observed1={500,623,72,70,31};double[]expected1={485,541,82,61,37};Assert.assertEquals("chi-square test statistic",9.023307936427388,TestUtils.chiSquare(expected1,observed1),1E-10);Assert.assertEquals("chi-square p-value",0.06051952647453607,TestUtils.chiSquareTest(expected1,observed1),1E-9);Assert.assertTrue("chi-square test reject",TestUtils.chiSquareTest(expected1,observed1,0.07));Assert.assertTrue("chi-square test accept",!TestUtils.chiSquareTest(expected1,observed1,0.05));try {TestUtils.chiSquareTest(expected1,observed1,95);Assert.fail("alpha out of range,MathIllegalArgumentException expected");}catch(MathIllegalArgumentException ex){}long[]tooShortObs={0};double[]tooShortEx={1};try {TestUtils.chiSquare(tooShortEx,tooShortObs);Assert.fail("arguments too short,MathIllegalArgumentException expected");}catch(MathIllegalArgumentException ex){}long[]unMatchedObs={0,1,2,3};double[]unMatchedEx={1,1,2};try {TestUtils.chiSquare(unMatchedEx,unMatchedObs);Assert.fail("arrays have different lengths,MathIllegalArgumentException expected");}catch(MathIllegalArgumentException ex){}expected[0]=0;try {TestUtils.chiSquareTest(expected,observed,.01);Assert.fail("bad expected count,MathIllegalArgumentException expected");}catch(MathIllegalArgumentException ex){}expected[0]=1;observed[0]=-1;try {TestUtils.chiSquareTest(expected,observed,.01);Assert.fail("bad expected count,MathIllegalArgumentException expected");}catch(MathIllegalArgumentException ex){}}
@Test public void testChiSquareIndependence()throws Exception {long[][]counts={{40,22,43},{91,21,28},{60,10,22}};Assert.assertEquals("chi-square test statistic",22.709027688,TestUtils.chiSquare(counts),1E-9);Assert.assertEquals("chi-square p-value",0.000144751460134,TestUtils.chiSquareTest(counts),1E-9);Assert.assertTrue("chi-square test reject",TestUtils.chiSquareTest(counts,0.0002));Assert.assertTrue("chi-square test accept",!TestUtils.chiSquareTest(counts,0.0001));long[][]counts2={{10,15},{30,40},{60,90}};Assert.assertEquals("chi-square test statistic",0.168965517241,TestUtils.chiSquare(counts2),1E-9);Assert.assertEquals("chi-square p-value",0.918987499852,TestUtils.chiSquareTest(counts2),1E-9);Assert.assertTrue("chi-square test accept",!TestUtils.chiSquareTest(counts2,0.1));long[][]counts3={{40,22,43},{91,21,28},{60,10}};try {TestUtils.chiSquare(counts3);Assert.fail("Expecting MathIllegalArgumentException");}catch(MathIllegalArgumentException ex){}long[][]counts4={{40,22,43}};try {TestUtils.chiSquare(counts4);Assert.fail("Expecting MathIllegalArgumentException");}catch(MathIllegalArgumentException ex){}long[][]counts5={{40},{40},{30},{10}};try {TestUtils.chiSquare(counts5);Assert.fail("Expecting MathIllegalArgumentException");}catch(MathIllegalArgumentException ex){}long[][]counts6={{10,-2},{30,40},{60,90}};try {TestUtils.chiSquare(counts6);Assert.fail("Expecting MathIllegalArgumentException");}catch(MathIllegalArgumentException ex){}try {TestUtils.chiSquareTest(counts,0);Assert.fail("Expecting MathIllegalArgumentException");}catch(MathIllegalArgumentException ex){}}
@Test public void testChiSquareLargeTestStatistic()throws Exception {double[]exp=new double[]{3389119.5,649136.6,285745.4,25357364.76,11291189.78,543628.0,232921.0,437665.75};long[]obs=new long[]{2372383,584222,257170,17750155,7903832,489265,209628,393899};org.apache.commons.math.stat.inference.ChiSquareTestImpl csti=new org.apache.commons.math.stat.inference.ChiSquareTestImpl();double cst=csti.chiSquareTest(exp,obs);Assert.assertEquals("chi-square p-value",0.0,cst,1E-3);Assert.assertEquals("chi-square test statistic",114875.90421929007,TestUtils.chiSquare(exp,obs),1E-9);}
/** * Contingency table containing zeros - PR # 32531 */@Test public void testChiSquareZeroCount()throws Exception {long[][]counts={{40,0,4},{91,1,2},{60,2,0}};Assert.assertEquals("chi-square test statistic",9.67444662263,TestUtils.chiSquare(counts),1E-9);Assert.assertEquals("chi-square p-value",0.0462835770603,TestUtils.chiSquareTest(counts),1E-9);}
@Test public void testOneSampleT()throws Exception {double[]observed={93.0,103.0,95.0,101.0,91.0,105.0,96.0,94.0,101.0,88.0,98.0,94.0,101.0,92.0,95.0};double mu=100.0;SummaryStatistics sampleStats=null;sampleStats=new SummaryStatistics();for (int i=0;i < observed.length;i++){sampleStats.addValue(observed[i]);}Assert.assertEquals("t statistic",-2.81976445346,TestUtils.t(mu,observed),10E-10);Assert.assertEquals("t statistic",-2.81976445346,TestUtils.t(mu,sampleStats),10E-10);Assert.assertEquals("p value",0.0136390585873,TestUtils.tTest(mu,observed),10E-10);Assert.assertEquals("p value",0.0136390585873,TestUtils.tTest(mu,sampleStats),10E-10);try {TestUtils.t(mu,(double[])null);Assert.fail("arguments too short,MathIllegalArgumentException expected");}catch(MathIllegalArgumentException ex){}try {TestUtils.t(mu,(SummaryStatistics)null);Assert.fail("arguments too short,MathIllegalArgumentException expected");}catch(MathIllegalArgumentException ex){}try {TestUtils.t(mu,emptyObs);Assert.fail("arguments too short,MathIllegalArgumentException expected");}catch(MathIllegalArgumentException ex){}try {TestUtils.t(mu,emptyStats);Assert.fail("arguments too short,MathIllegalArgumentException expected");}catch(MathIllegalArgumentException ex){}try {TestUtils.t(mu,tooShortObs);Assert.fail("insufficient data to compute t statistic,MathIllegalArgumentException expected");}catch(MathIllegalArgumentException ex){}try {TestUtils.tTest(mu,tooShortObs);Assert.fail("insufficient data to perform t test,MathIllegalArgumentException expected");}catch(MathIllegalArgumentException ex){}try {TestUtils.t(mu,(SummaryStatistics)null);Assert.fail("insufficient data to compute t statistic,MathIllegalArgumentException expected");}catch(MathIllegalArgumentException ex){}try {TestUtils.tTest(mu,(SummaryStatistics)null);Assert.fail("insufficient data to perform t test,MathIllegalArgumentException expected");}catch(MathIllegalArgumentException ex){}}
@Test public void testOneSampleTTest()throws Exception {double[]oneSidedP={2d,0d,6d,6d,3d,3d,2d,3d,-6d,6d,6d,6d,3d,0d,1d,1d,0d,2d,3d,3d};SummaryStatistics oneSidedPStats=new SummaryStatistics();for (int i=0;i < oneSidedP.length;i++){oneSidedPStats.addValue(oneSidedP[i]);}Assert.assertEquals("one sample t stat",3.86485535541,TestUtils.t(0d,oneSidedP),10E-10);Assert.assertEquals("one sample t stat",3.86485535541,TestUtils.t(0d,oneSidedPStats),1E-10);Assert.assertEquals("one sample p value",0.000521637019637,TestUtils.tTest(0d,oneSidedP)/ 2d,10E-10);Assert.assertEquals("one sample p value",0.000521637019637,TestUtils.tTest(0d,oneSidedPStats)/ 2d,10E-5);Assert.assertTrue("one sample t-test reject",TestUtils.tTest(0d,oneSidedP,0.01));Assert.assertTrue("one sample t-test reject",TestUtils.tTest(0d,oneSidedPStats,0.01));Assert.assertTrue("one sample t-test accept",!TestUtils.tTest(0d,oneSidedP,0.0001));Assert.assertTrue("one sample t-test accept",!TestUtils.tTest(0d,oneSidedPStats,0.0001));try {TestUtils.tTest(0d,oneSidedP,95);Assert.fail("alpha out of range,MathIllegalArgumentException expected");}catch(MathIllegalArgumentException ex){}try {TestUtils.tTest(0d,oneSidedPStats,95);Assert.fail("alpha out of range,MathIllegalArgumentException expected");}catch(MathIllegalArgumentException ex){}}
@Test public void testTwoSampleTHeterscedastic()throws Exception {double[]sample1={7d,-4d,18d,17d,-3d,-5d,1d,10d,11d,-2d};double[]sample2={-1d,12d,-1d,-3d,3d,-5d,5d,2d,-11d,-1d,-3d};SummaryStatistics sampleStats1=new SummaryStatistics();for (int i=0;i < sample1.length;i++){sampleStats1.addValue(sample1[i]);}SummaryStatistics sampleStats2=new SummaryStatistics();for (int i=0;i < sample2.length;i++){sampleStats2.addValue(sample2[i]);}Assert.assertEquals("two sample heteroscedastic t stat",1.60371728768,TestUtils.t(sample1,sample2),1E-10);Assert.assertEquals("two sample heteroscedastic t stat",1.60371728768,TestUtils.t(sampleStats1,sampleStats2),1E-10);Assert.assertEquals("two sample heteroscedastic p value",0.128839369622,TestUtils.tTest(sample1,sample2),1E-10);Assert.assertEquals("two sample heteroscedastic p value",0.128839369622,TestUtils.tTest(sampleStats1,sampleStats2),1E-10);Assert.assertTrue("two sample heteroscedastic t-test reject",TestUtils.tTest(sample1,sample2,0.2));Assert.assertTrue("two sample heteroscedastic t-test reject",TestUtils.tTest(sampleStats1,sampleStats2,0.2));Assert.assertTrue("two sample heteroscedastic t-test accept",!TestUtils.tTest(sample1,sample2,0.1));Assert.assertTrue("two sample heteroscedastic t-test accept",!TestUtils.tTest(sampleStats1,sampleStats2,0.1));try {TestUtils.tTest(sample1,sample2,.95);Assert.fail("alpha out of range,MathIllegalArgumentException expected");}catch(MathIllegalArgumentException ex){}try {TestUtils.tTest(sampleStats1,sampleStats2,.95);Assert.fail("alpha out of range,MathIllegalArgumentException expected");}catch(MathIllegalArgumentException ex){}try {TestUtils.tTest(sample1,tooShortObs,.01);Assert.fail("insufficient data,MathIllegalArgumentException expected");}catch(MathIllegalArgumentException ex){}try {TestUtils.tTest(sampleStats1,(SummaryStatistics)null,.01);Assert.fail("insufficient data,MathIllegalArgumentException expected");}catch(MathIllegalArgumentException ex){}try {TestUtils.tTest(sample1,tooShortObs);Assert.fail("insufficient data,MathIllegalArgumentException expected");}catch(MathIllegalArgumentException ex){}try {TestUtils.tTest(sampleStats1,(SummaryStatistics)null);Assert.fail("insufficient data,MathIllegalArgumentException expected");}catch(MathIllegalArgumentException ex){}try {TestUtils.t(sample1,tooShortObs);Assert.fail("insufficient data,MathIllegalArgumentException expected");}catch(MathIllegalArgumentException ex){}try {TestUtils.t(sampleStats1,(SummaryStatistics)null);Assert.fail("insufficient data,MathIllegalArgumentException expected");}catch(MathIllegalArgumentException ex){}}
@Test public void testTwoSampleTHomoscedastic()throws Exception {double[]sample1={2,4,6,8,10,97};double[]sample2={4,6,8,10,16};SummaryStatistics sampleStats1=new SummaryStatistics();for (int i=0;i < sample1.length;i++){sampleStats1.addValue(sample1[i]);}SummaryStatistics sampleStats2=new SummaryStatistics();for (int i=0;i < sample2.length;i++){sampleStats2.addValue(sample2[i]);}Assert.assertEquals("two sample homoscedastic t stat",0.73096310086,TestUtils.homoscedasticT(sample1,sample2),10E-11);Assert.assertEquals("two sample homoscedastic p value",0.4833963785,TestUtils.homoscedasticTTest(sampleStats1,sampleStats2),1E-10);Assert.assertTrue("two sample homoscedastic t-test reject",TestUtils.homoscedasticTTest(sample1,sample2,0.49));Assert.assertTrue("two sample homoscedastic t-test accept",!TestUtils.homoscedasticTTest(sample1,sample2,0.48));}
@Test public void testSmallSamples()throws Exception {double[]sample1={1d,3d};double[]sample2={4d,5d};Assert.assertEquals(-2.2360679775,TestUtils.t(sample1,sample2),1E-10);Assert.assertEquals(0.198727388935,TestUtils.tTest(sample1,sample2),1E-10);}
@Test public void testPaired()throws Exception {double[]sample1={1d,3d,5d,7d};double[]sample2={0d,6d,11d,2d};double[]sample3={5d,7d,8d,10d};Assert.assertEquals(-0.3133,TestUtils.pairedT(sample1,sample2),1E-4);Assert.assertEquals(0.774544295819,TestUtils.pairedTTest(sample1,sample2),1E-10);Assert.assertEquals(0.001208,TestUtils.pairedTTest(sample1,sample3),1E-6);Assert.assertFalse(TestUtils.pairedTTest(sample1,sample3,.001));Assert.assertTrue(TestUtils.pairedTTest(sample1,sample3,.002));}
@Test public void testOneWayAnovaUtils()throws Exception {classes.add(classA);classes.add(classB);classes.add(classC);Assert.assertEquals(oneWayAnova.anovaFValue(classes),TestUtils.oneWayAnovaFValue(classes),10E-12);Assert.assertEquals(oneWayAnova.anovaPValue(classes),TestUtils.oneWayAnovaPValue(classes),10E-12);Assert.assertEquals(oneWayAnova.anovaTest(classes,0.01),TestUtils.oneWayAnovaTest(classes,0.01));}
@Test public void closeEvents(){final double r1=90.0;final double r2=135.0;final double gap=r2 - r1;EventHandler closeEventsGenerator=new EventHandler(){public void init(double t0,double[]y0,double t){}public void resetState(double t,double[]y){}public double g(double t,double[]y){return (t - r1)* (r2 - t);}public Action eventOccurred(double t,double[]y,boolean increasing){return Action.CONTINUE;}};final double tolerance=0.1;EventState es=new EventState(closeEventsGenerator,1.5 * gap,tolerance,100,new BrentSolver(tolerance));AbstractStepInterpolator interpolator=new DummyStepInterpolator(new double[0],new double[0],true);interpolator.storeTime(r1 - 2.5 * gap);interpolator.shift();interpolator.storeTime(r1 - 1.5 * gap);es.reinitializeBegin(interpolator);interpolator.shift();interpolator.storeTime(r1 - 0.5 * gap);Assert.assertFalse(es.evaluateStep(interpolator));interpolator.shift();interpolator.storeTime(0.5 * (r1 + r2));Assert.assertTrue(es.evaluateStep(interpolator));Assert.assertEquals(r1,es.getEventTime(),tolerance);es.stepAccepted(es.getEventTime(),new double[0]);interpolator.shift();interpolator.storeTime(r2 + 0.4 * gap);Assert.assertTrue(es.evaluateStep(interpolator));Assert.assertEquals(r2,es.getEventTime(),tolerance);}
@Test public void testIssue695(){FirstOrderDifferentialEquations equation=new FirstOrderDifferentialEquations(){public int getDimension(){return 1;}public void computeDerivatives(double t,double[]y,double[]yDot){yDot[0]=1.0;}};DormandPrince853Integrator integrator=new DormandPrince853Integrator(0.001,1000,1.0e-14,1.0e-14);integrator.addEventHandler(new ResettingEvent(10.99),0.1,1.0e-9,1000);integrator.addEventHandler(new ResettingEvent(11.01),0.1,1.0e-9,1000);integrator.setInitialStepSize(3.0);double target=30.0;double[]y=new double[1];double tEnd=integrator.integrate(equation,0.0,y,target,y);Assert.assertEquals(target,tEnd,1.0e-10);Assert.assertEquals(32.0,y[0],1.0e-10);}
@Test public void testRegressIfaceMethod(){final SimpleRegression regression=new SimpleRegression(true);final UpdatingMultipleLinearRegression iface=regression;final SimpleRegression regressionNoint=new SimpleRegression(false);final SimpleRegression regressionIntOnly=new SimpleRegression(false);for (int i=0;i < data.length;i++){iface.addObservation(new double[]{data[i][1]},data[i][0]);regressionNoint.addData(data[i][1],data[i][0]);regressionIntOnly.addData(1.0,data[i][0]);}final RegressionResults fullReg=iface.regress();Assert.assertNotNull(fullReg);Assert.assertEquals("intercept",regression.getIntercept(),fullReg.getParameterEstimate(0),1.0e-16);Assert.assertEquals("intercept std err",regression.getInterceptStdErr(),fullReg.getStdErrorOfEstimate(0),1.0E-16);Assert.assertEquals("slope",regression.getSlope(),fullReg.getParameterEstimate(1),1.0e-16);Assert.assertEquals("slope std err",regression.getSlopeStdErr(),fullReg.getStdErrorOfEstimate(1),1.0E-16);Assert.assertEquals("number of observations",regression.getN(),fullReg.getN());Assert.assertEquals("r-square",regression.getRSquare(),fullReg.getRSquared(),1.0E-16);Assert.assertEquals("SSR",regression.getRegressionSumSquares(),fullReg.getRegressionSumSquares(),1.0E-16);Assert.assertEquals("MSE",regression.getMeanSquareError(),fullReg.getMeanSquareError(),1.0E-16);Assert.assertEquals("SSE",regression.getSumSquaredErrors(),fullReg.getErrorSumSquares(),1.0E-16);final RegressionResults noInt=iface.regress(new int[]{1});Assert.assertNotNull(noInt);Assert.assertEquals("slope",regressionNoint.getSlope(),noInt.getParameterEstimate(0),1.0e-12);Assert.assertEquals("slope std err",regressionNoint.getSlopeStdErr(),noInt.getStdErrorOfEstimate(0),1.0E-16);Assert.assertEquals("number of observations",regressionNoint.getN(),noInt.getN());Assert.assertEquals("r-square",regressionNoint.getRSquare(),noInt.getRSquared(),1.0E-16);Assert.assertEquals("SSR",regressionNoint.getRegressionSumSquares(),noInt.getRegressionSumSquares(),1.0E-8);Assert.assertEquals("MSE",regressionNoint.getMeanSquareError(),noInt.getMeanSquareError(),1.0E-16);Assert.assertEquals("SSE",regressionNoint.getSumSquaredErrors(),noInt.getErrorSumSquares(),1.0E-16);final RegressionResults onlyInt=iface.regress(new int[]{0});Assert.assertNotNull(onlyInt);Assert.assertEquals("slope",regressionIntOnly.getSlope(),onlyInt.getParameterEstimate(0),1.0e-12);Assert.assertEquals("slope std err",regressionIntOnly.getSlopeStdErr(),onlyInt.getStdErrorOfEstimate(0),1.0E-12);Assert.assertEquals("number of observations",regressionIntOnly.getN(),onlyInt.getN());Assert.assertEquals("r-square",regressionIntOnly.getRSquare(),onlyInt.getRSquared(),1.0E-14);Assert.assertEquals("SSE",regressionIntOnly.getSumSquaredErrors(),onlyInt.getErrorSumSquares(),1.0E-8);Assert.assertEquals("SSR",regressionIntOnly.getRegressionSumSquares(),onlyInt.getRegressionSumSquares(),1.0E-8);Assert.assertEquals("MSE",regressionIntOnly.getMeanSquareError(),onlyInt.getMeanSquareError(),1.0E-8);}
@Test public void testNoInterceot_noint2(){SimpleRegression regression=new SimpleRegression(false);regression.addData(noint2[0][1],noint2[0][0]);regression.addData(noint2[1][1],noint2[1][0]);regression.addData(noint2[2][1],noint2[2][0]);Assert.assertEquals("intercept",0,regression.getIntercept(),0);Assert.assertEquals("slope",0.727272727272727,regression.getSlope(),10E-12);Assert.assertEquals("slope std err",0.420827318078432E-01,regression.getSlopeStdErr(),10E-12);Assert.assertEquals("number of observations",3,regression.getN());Assert.assertEquals("r-square",0.993348115299335,regression.getRSquare(),10E-12);Assert.assertEquals("SSR",40.7272727272727,regression.getRegressionSumSquares(),10E-9);Assert.assertEquals("MSE",0.136363636363636,regression.getMeanSquareError(),10E-10);Assert.assertEquals("SSE",0.272727272727273,regression.getSumSquaredErrors(),10E-9);}
@Test public void testNoIntercept_noint1(){SimpleRegression regression=new SimpleRegression(false);for (int i=0;i < noint1.length;i++){regression.addData(noint1[i][1],noint1[i][0]);}Assert.assertEquals("intercept",0,regression.getIntercept(),0);Assert.assertEquals("slope",2.07438016528926,regression.getSlope(),10E-12);Assert.assertEquals("slope std err",0.165289256198347E-01,regression.getSlopeStdErr(),10E-12);Assert.assertEquals("number of observations",11,regression.getN());Assert.assertEquals("r-square",0.999365492298663,regression.getRSquare(),10E-12);Assert.assertEquals("SSR",200457.727272727,regression.getRegressionSumSquares(),10E-9);Assert.assertEquals("MSE",12.7272727272727,regression.getMeanSquareError(),10E-10);Assert.assertEquals("SSE",127.272727272727,regression.getSumSquaredErrors(),10E-9);}
@Test public void testNorris(){SimpleRegression regression=new SimpleRegression();for (int i=0;i < data.length;i++){regression.addData(data[i][1],data[i][0]);}Assert.assertEquals("slope",1.00211681802045,regression.getSlope(),10E-12);Assert.assertEquals("slope std err",0.429796848199937E-03,regression.getSlopeStdErr(),10E-12);Assert.assertEquals("number of observations",36,regression.getN());Assert.assertEquals("intercept",-0.262323073774029,regression.getIntercept(),10E-12);Assert.assertEquals("std err intercept",0.232818234301152,regression.getInterceptStdErr(),10E-12);Assert.assertEquals("r-square",0.999993745883712,regression.getRSquare(),10E-12);Assert.assertEquals("SSR",4255954.13232369,regression.getRegressionSumSquares(),10E-9);Assert.assertEquals("MSE",0.782864662630069,regression.getMeanSquareError(),10E-10);Assert.assertEquals("SSE",26.6173985294224,regression.getSumSquaredErrors(),10E-9);Assert.assertEquals("predict(0)",-0.262323073774029,regression.predict(0),10E-12);Assert.assertEquals("predict(1)",1.00211681802045 - 0.262323073774029,regression.predict(1),10E-12);}
@Test public void testCorr(){SimpleRegression regression=new SimpleRegression();regression.addData(corrData);Assert.assertEquals("number of observations",17,regression.getN());Assert.assertEquals("r-square",.896123,regression.getRSquare(),10E-6);Assert.assertEquals("r",-0.94663767742,regression.getR(),1E-10);}
@Test public void testNaNs(){SimpleRegression regression=new SimpleRegression();Assert.assertTrue("intercept not NaN",Double.isNaN(regression.getIntercept()));Assert.assertTrue("slope not NaN",Double.isNaN(regression.getSlope()));Assert.assertTrue("slope std err not NaN",Double.isNaN(regression.getSlopeStdErr()));Assert.assertTrue("intercept std err not NaN",Double.isNaN(regression.getInterceptStdErr()));Assert.assertTrue("MSE not NaN",Double.isNaN(regression.getMeanSquareError()));Assert.assertTrue("e not NaN",Double.isNaN(regression.getR()));Assert.assertTrue("r-square not NaN",Double.isNaN(regression.getRSquare()));Assert.assertTrue("RSS not NaN",Double.isNaN(regression.getRegressionSumSquares()));Assert.assertTrue("SSE not NaN",Double.isNaN(regression.getSumSquaredErrors()));Assert.assertTrue("SSTO not NaN",Double.isNaN(regression.getTotalSumSquares()));Assert.assertTrue("predict not NaN",Double.isNaN(regression.predict(0)));regression.addData(1,2);regression.addData(1,3);Assert.assertTrue("intercept not NaN",Double.isNaN(regression.getIntercept()));Assert.assertTrue("slope not NaN",Double.isNaN(regression.getSlope()));Assert.assertTrue("slope std err not NaN",Double.isNaN(regression.getSlopeStdErr()));Assert.assertTrue("intercept std err not NaN",Double.isNaN(regression.getInterceptStdErr()));Assert.assertTrue("MSE not NaN",Double.isNaN(regression.getMeanSquareError()));Assert.assertTrue("e not NaN",Double.isNaN(regression.getR()));Assert.assertTrue("r-square not NaN",Double.isNaN(regression.getRSquare()));Assert.assertTrue("RSS not NaN",Double.isNaN(regression.getRegressionSumSquares()));Assert.assertTrue("SSE not NaN",Double.isNaN(regression.getSumSquaredErrors()));Assert.assertTrue("predict not NaN",Double.isNaN(regression.predict(0)));Assert.assertTrue("SSTO NaN",!Double.isNaN(regression.getTotalSumSquares()));regression=new SimpleRegression();regression.addData(1,2);regression.addData(3,3);Assert.assertTrue("interceptNaN",!Double.isNaN(regression.getIntercept()));Assert.assertTrue("slope NaN",!Double.isNaN(regression.getSlope()));Assert.assertTrue("slope std err not NaN",Double.isNaN(regression.getSlopeStdErr()));Assert.assertTrue("intercept std err not NaN",Double.isNaN(regression.getInterceptStdErr()));Assert.assertTrue("MSE not NaN",Double.isNaN(regression.getMeanSquareError()));Assert.assertTrue("r NaN",!Double.isNaN(regression.getR()));Assert.assertTrue("r-square NaN",!Double.isNaN(regression.getRSquare()));Assert.assertTrue("RSS NaN",!Double.isNaN(regression.getRegressionSumSquares()));Assert.assertTrue("SSE NaN",!Double.isNaN(regression.getSumSquaredErrors()));Assert.assertTrue("SSTO NaN",!Double.isNaN(regression.getTotalSumSquares()));Assert.assertTrue("predict NaN",!Double.isNaN(regression.predict(0)));regression.addData(1,4);Assert.assertTrue("MSE NaN",!Double.isNaN(regression.getMeanSquareError()));Assert.assertTrue("slope std err NaN",!Double.isNaN(regression.getSlopeStdErr()));Assert.assertTrue("intercept std err NaN",!Double.isNaN(regression.getInterceptStdErr()));}
@Test public void testClear(){SimpleRegression regression=new SimpleRegression();regression.addData(corrData);Assert.assertEquals("number of observations",17,regression.getN());regression.clear();Assert.assertEquals("number of observations",0,regression.getN());regression.addData(corrData);Assert.assertEquals("r-square",.896123,regression.getRSquare(),10E-6);regression.addData(data);Assert.assertEquals("number of observations",53,regression.getN());}
@Test public void testInference()throws Exception {SimpleRegression regression=new SimpleRegression();regression.addData(infData);Assert.assertEquals("slope std err",0.011448491,regression.getSlopeStdErr(),1E-10);Assert.assertEquals("std err intercept",0.286036932,regression.getInterceptStdErr(),1E-8);Assert.assertEquals("significance",4.596e-07,regression.getSignificance(),1E-8);Assert.assertEquals("slope conf interval half-width",0.0270713794287,regression.getSlopeConfidenceInterval(),1E-8);regression=new SimpleRegression();regression.addData(infData2);Assert.assertEquals("slope std err",1.07260253,regression.getSlopeStdErr(),1E-8);Assert.assertEquals("std err intercept",4.17718672,regression.getInterceptStdErr(),1E-8);Assert.assertEquals("significance",0.261829133982,regression.getSignificance(),1E-11);Assert.assertEquals("slope conf interval half-width",2.97802204827,regression.getSlopeConfidenceInterval(),1E-8);Assert.assertTrue("tighter means wider",regression.getSlopeConfidenceInterval()< regression.getSlopeConfidenceInterval(0.01));try {regression.getSlopeConfidenceInterval(1);Assert.fail("expecting MathIllegalArgumentException for alpha = 1");}catch(MathIllegalArgumentException ex){}}
@Test public void testPerfect()throws Exception {SimpleRegression regression=new SimpleRegression();int n=100;for (int i=0;i < n;i++){regression.addData(((double)i)/ (n - 1),i);}Assert.assertEquals(0.0,regression.getSignificance(),1.0e-5);Assert.assertTrue(regression.getSlope()> 0.0);Assert.assertTrue(regression.getSumSquaredErrors()>= 0.0);}
@Test public void testPerfectNegative()throws Exception {SimpleRegression regression=new SimpleRegression();int n=100;for (int i=0;i < n;i++){regression.addData(-((double)i)/ (n - 1),i);}Assert.assertEquals(0.0,regression.getSignificance(),1.0e-5);Assert.assertTrue(regression.getSlope()< 0.0);}
@Test public void testRandom()throws Exception {SimpleRegression regression=new SimpleRegression();Random random=new Random(1);int n=100;for (int i=0;i < n;i++){regression.addData(((double)i)/ (n - 1),random.nextDouble());}Assert.assertTrue(0.0 < regression.getSignificance()&& regression.getSignificance()< 1.0);}
@Test public void testSSENonNegative(){double[]y={8915.102,8919.302,8923.502};double[]x={1.107178495E2,1.107264895E2,1.107351295E2};SimpleRegression reg=new SimpleRegression();for (int i=0;i < x.length;i++){reg.addData(x[i],y[i]);}Assert.assertTrue(reg.getSumSquaredErrors()>= 0.0);}
@Test public void testRemoveXY()throws Exception {SimpleRegression regression=new SimpleRegression();regression.addData(infData);regression.removeData(removeX,removeY);regression.addData(removeX,removeY);Assert.assertEquals("slope std err",0.011448491,regression.getSlopeStdErr(),1E-10);Assert.assertEquals("std err intercept",0.286036932,regression.getInterceptStdErr(),1E-8);Assert.assertEquals("significance",4.596e-07,regression.getSignificance(),1E-8);Assert.assertEquals("slope conf interval half-width",0.0270713794287,regression.getSlopeConfidenceInterval(),1E-8);}
@Test public void testRemoveSingle()throws Exception {SimpleRegression regression=new SimpleRegression();regression.addData(infData);regression.removeData(removeSingle);regression.addData(removeSingle);Assert.assertEquals("slope std err",0.011448491,regression.getSlopeStdErr(),1E-10);Assert.assertEquals("std err intercept",0.286036932,regression.getInterceptStdErr(),1E-8);Assert.assertEquals("significance",4.596e-07,regression.getSignificance(),1E-8);Assert.assertEquals("slope conf interval half-width",0.0270713794287,regression.getSlopeConfidenceInterval(),1E-8);}
@Test public void testRemoveMultiple()throws Exception {SimpleRegression regression=new SimpleRegression();regression.addData(infData);regression.removeData(removeMultiple);regression.addData(removeMultiple);Assert.assertEquals("slope std err",0.011448491,regression.getSlopeStdErr(),1E-10);Assert.assertEquals("std err intercept",0.286036932,regression.getInterceptStdErr(),1E-8);Assert.assertEquals("significance",4.596e-07,regression.getSignificance(),1E-8);Assert.assertEquals("slope conf interval half-width",0.0270713794287,regression.getSlopeConfidenceInterval(),1E-8);}
@Test public void testRemoveObsFromEmpty(){SimpleRegression regression=new SimpleRegression();regression.removeData(removeX,removeY);Assert.assertEquals(regression.getN(),0);}
@Test public void testRemoveObsFromSingle(){SimpleRegression regression=new SimpleRegression();regression.addData(removeX,removeY);regression.removeData(removeX,removeY);Assert.assertEquals(regression.getN(),0);}
@Test public void testRemoveMultipleToEmpty(){SimpleRegression regression=new SimpleRegression();regression.addData(removeMultiple);regression.removeData(removeMultiple);Assert.assertEquals(regression.getN(),0);}
@Test public void testRemoveMultiplePastEmpty(){SimpleRegression regression=new SimpleRegression();regression.addData(removeX,removeY);regression.removeData(removeMultiple);Assert.assertEquals(regression.getN(),0);}
@Test public void testInterval(){IntervalsSet set=new IntervalsSet(2.3,5.7);Assert.assertEquals(3.4,set.getSize(),1.0e-10);Assert.assertEquals(4.0,((Vector1D)set.getBarycenter()).getX(),1.0e-10);Assert.assertEquals(Region.Location.BOUNDARY,set.checkPoint(new Vector1D(2.3)));Assert.assertEquals(Region.Location.BOUNDARY,set.checkPoint(new Vector1D(5.7)));Assert.assertEquals(Region.Location.OUTSIDE,set.checkPoint(new Vector1D(1.2)));Assert.assertEquals(Region.Location.OUTSIDE,set.checkPoint(new Vector1D(8.7)));Assert.assertEquals(Region.Location.INSIDE,set.checkPoint(new Vector1D(3.0)));Assert.assertEquals(2.3,set.getInf(),1.0e-10);Assert.assertEquals(5.7,set.getSup(),1.0e-10);}
@Test public void testInfinite(){IntervalsSet set=new IntervalsSet(9.0,Double.POSITIVE_INFINITY);Assert.assertEquals(Region.Location.BOUNDARY,set.checkPoint(new Vector1D(9.0)));Assert.assertEquals(Region.Location.OUTSIDE,set.checkPoint(new Vector1D(8.4)));for (double e=1.0;e <= 6.0;e+=1.0){Assert.assertEquals(Region.Location.INSIDE,set.checkPoint(new Vector1D(FastMath.pow(10.0,e))));}Assert.assertTrue(Double.isInfinite(set.getSize()));Assert.assertEquals(9.0,set.getInf(),1.0e-10);Assert.assertTrue(Double.isInfinite(set.getSup()));set=(IntervalsSet)new RegionFactory<Euclidean1D>().getComplement(set);Assert.assertEquals(9.0,set.getSup(),1.0e-10);Assert.assertTrue(Double.isInfinite(set.getInf()));}
@Test public void testMultiple(){RegionFactory<Euclidean1D> factory=new RegionFactory<Euclidean1D>();IntervalsSet set=(IntervalsSet)factory.intersection(factory.union(factory.difference(new IntervalsSet(1.0,6.0),new IntervalsSet(3.0,5.0)),new IntervalsSet(9.0,Double.POSITIVE_INFINITY)),new IntervalsSet(Double.NEGATIVE_INFINITY,11.0));Assert.assertEquals(5.0,set.getSize(),1.0e-10);Assert.assertEquals(5.9,((Vector1D)set.getBarycenter()).getX(),1.0e-10);Assert.assertEquals(Region.Location.OUTSIDE,set.checkPoint(new Vector1D(0.0)));Assert.assertEquals(Region.Location.OUTSIDE,set.checkPoint(new Vector1D(4.0)));Assert.assertEquals(Region.Location.OUTSIDE,set.checkPoint(new Vector1D(8.0)));Assert.assertEquals(Region.Location.OUTSIDE,set.checkPoint(new Vector1D(12.0)));Assert.assertEquals(Region.Location.INSIDE,set.checkPoint(new Vector1D(1.2)));Assert.assertEquals(Region.Location.INSIDE,set.checkPoint(new Vector1D(5.9)));Assert.assertEquals(Region.Location.INSIDE,set.checkPoint(new Vector1D(9.01)));Assert.assertEquals(Region.Location.BOUNDARY,set.checkPoint(new Vector1D(5.0)));Assert.assertEquals(Region.Location.BOUNDARY,set.checkPoint(new Vector1D(11.0)));Assert.assertEquals(1.0,set.getInf(),1.0e-10);Assert.assertEquals(11.0,set.getSup(),1.0e-10);List<Interval> list=set.asList();Assert.assertEquals(3,list.size());Assert.assertEquals(1.0,list.get(0).getLower(),1.0e-10);Assert.assertEquals(3.0,list.get(0).getUpper(),1.0e-10);Assert.assertEquals(5.0,list.get(1).getLower(),1.0e-10);Assert.assertEquals(6.0,list.get(1).getUpper(),1.0e-10);Assert.assertEquals(9.0,list.get(2).getLower(),1.0e-10);Assert.assertEquals(11.0,list.get(2).getUpper(),1.0e-10);}
