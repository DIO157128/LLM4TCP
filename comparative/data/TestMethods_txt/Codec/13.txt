@Test public void testCtor(){assertNotNull(new Sha2Crypt());}
/** * Tests the problem reported in CODEC-130. Missing / wrong implementation of skip.*/@Test public void testCodec130()throws IOException {final ByteArrayOutputStream bos=new ByteArrayOutputStream();final Base64OutputStream base64os=new Base64OutputStream(bos);base64os.write(StringUtils.getBytesUtf8(STRING_FIXTURE));base64os.close();final ByteArrayInputStream bis=new ByteArrayInputStream(bos.toByteArray());final Base64InputStream ins=new Base64InputStream(bis);ins.skip(1);final byte[]decodedBytes=Base64TestData.streamToBytes(ins,new byte[64]);final String str=StringUtils.newStringUtf8(decodedBytes);assertEquals(STRING_FIXTURE.substring(1),str);}
/** * Tests the bug reported in CODEC-105. Bad interactions with InputStream when reading one byte at a time.*/@Test public void testCodec105()throws IOException {final Base64InputStream in=new Base64InputStream(new Codec105ErrorInputStream(),true,0,null);try {for (int i=0;i < 5;i++){in.read();}}finally {in.close();}}
/** * Test for the CODEC-101 bug: InputStream.read(byte[])should never return 0 because Java's builtin InputStreamReader hates that.* @throws Exception for some failure scenarios.*/@Test public void testCodec101()throws Exception {final byte[]codec101=StringUtils.getBytesUtf8(Base64TestData.CODEC_101_MULTIPLE_OF_3);final ByteArrayInputStream bais=new ByteArrayInputStream(codec101);final Base64InputStream in=new Base64InputStream(bais);final byte[]result=new byte[8192];int c=in.read(result);assertTrue("Codec101: First read successful [c=" + c + "]",c > 0);c=in.read(result);assertTrue("Codec101: Second read should report end-of-stream [c=" + c + "]",c < 0);in.close();}
/** * Another test for the CODEC-101 bug: In commons-codec-1.4 this test shows InputStreamReader explicitly hating an InputStream.read(byte[])return of 0: java.io.IOException: Underlying input stream returned zero bytes at sun.nio.cs.StreamDecoder.readBytes(StreamDecoder.java:268)at sun.nio.cs.StreamDecoder.implRead(StreamDecoder.java:306)at sun.nio.cs.StreamDecoder.read(StreamDecoder.java:158)at java.io.InputStreamReader.read(InputStreamReader.java:167)at java.io.BufferedReader.fill(BufferedReader.java:136)at java.io.BufferedReader.readLine(BufferedReader.java:299)at java.io.BufferedReader.readLine(BufferedReader.java:362)at org.apache.commons.codec.binary.Base64InputStreamTest.testInputStreamReader(Base64InputStreamTest.java:75)But in commons-codec-1.5 it's fixed. :-)* @throws Exception for some failure scenarios.*/@Test public void testInputStreamReader()throws Exception {final byte[]codec101=StringUtils.getBytesUtf8(Base64TestData.CODEC_101_MULTIPLE_OF_3);final ByteArrayInputStream bais=new ByteArrayInputStream(codec101);final Base64InputStream in=new Base64InputStream(bais);final InputStreamReader isr=new InputStreamReader(in);final BufferedReader br=new BufferedReader(isr);final String line=br.readLine();assertNotNull("Codec101:  InputStreamReader works!",line);br.close();}
/** * Test the Base64InputStream implementation against the special NPE inducing input identified in the CODEC-98 bug.* @throws Exception for some failure scenarios.*/@Test public void testCodec98NPE()throws Exception {final byte[]codec98=StringUtils.getBytesUtf8(Base64TestData.CODEC_98_NPE);final ByteArrayInputStream data=new ByteArrayInputStream(codec98);final Base64InputStream stream=new Base64InputStream(data);final byte[]decodedBytes=Base64TestData.streamToBytes(stream,new byte[1024]);final String decoded=StringUtils.newStringUtf8(decodedBytes);assertEquals("codec-98 NPE Base64InputStream",Base64TestData.CODEC_98_NPE_DECODED,decoded);}
/** * Tests skipping past the end of a stream.* @throws Throwable*/@Test public void testAvailable()throws Throwable {final InputStream ins=new ByteArrayInputStream(StringUtils.getBytesIso8859_1(ENCODED_B64));final Base64InputStream b64stream=new Base64InputStream(ins);assertEquals(1,b64stream.available());assertEquals(6,b64stream.skip(10));assertEquals(0,b64stream.available());assertEquals(-1,b64stream.read());assertEquals(-1,b64stream.read());assertEquals(0,b64stream.available());b64stream.close();}
/** * Tests the Base64InputStream implementation against empty input.* @throws Exception for some failure scenarios.*/@Test public void testBase64EmptyInputStreamMimeChuckSize()throws Exception {testBase64EmptyInputStream(BaseNCodec.MIME_CHUNK_SIZE);}
/** * Tests the Base64InputStream implementation against empty input.* @throws Exception for some failure scenarios.*/@Test public void testBase64EmptyInputStreamPemChuckSize()throws Exception {testBase64EmptyInputStream(BaseNCodec.PEM_CHUNK_SIZE);}
/** * Tests the Base64InputStream implementation.* @throws Exception for some failure scenarios.*/@Test public void testBase64InputStreamByChunk()throws Exception {byte[]encoded=StringUtils.getBytesUtf8("SGVsbG8gV29ybGQ=\r\n");byte[]decoded=StringUtils.getBytesUtf8(STRING_FIXTURE);testByChunk(encoded,decoded,BaseNCodec.MIME_CHUNK_SIZE,CRLF);encoded=StringUtils.getBytesUtf8("AA==\r\n");decoded=new byte[]{(byte)0};testByChunk(encoded,decoded,BaseNCodec.MIME_CHUNK_SIZE,CRLF);encoded=StringUtils.getBytesUtf8(Base64TestData.ENCODED_64_CHARS_PER_LINE);decoded=Base64TestData.DECODED;testByChunk(encoded,decoded,BaseNCodec.PEM_CHUNK_SIZE,LF);final String singleLine=Base64TestData.ENCODED_64_CHARS_PER_LINE.replaceAll("\n","");encoded=StringUtils.getBytesUtf8(singleLine);decoded=Base64TestData.DECODED;testByChunk(encoded,decoded,0,LF);for (int i=0;i <= 150;i++){final byte[][]randomData=Base64TestData.randomData(i,false);encoded=randomData[1];decoded=randomData[0];testByChunk(encoded,decoded,0,LF);}}
/** * Tests the Base64InputStream implementation.* @throws Exception for some failure scenarios.*/@Test public void testBase64InputStreamByteByByte()throws Exception {byte[]encoded=StringUtils.getBytesUtf8("SGVsbG8gV29ybGQ=\r\n");byte[]decoded=StringUtils.getBytesUtf8(STRING_FIXTURE);testByteByByte(encoded,decoded,BaseNCodec.MIME_CHUNK_SIZE,CRLF);encoded=StringUtils.getBytesUtf8("AA==\r\n");decoded=new byte[]{(byte)0};testByteByByte(encoded,decoded,BaseNCodec.MIME_CHUNK_SIZE,CRLF);encoded=StringUtils.getBytesUtf8(Base64TestData.ENCODED_64_CHARS_PER_LINE);decoded=Base64TestData.DECODED;testByteByByte(encoded,decoded,BaseNCodec.PEM_CHUNK_SIZE,LF);final String singleLine=Base64TestData.ENCODED_64_CHARS_PER_LINE.replaceAll("\n","");encoded=StringUtils.getBytesUtf8(singleLine);decoded=Base64TestData.DECODED;testByteByByte(encoded,decoded,0,LF);for (int i=0;i <= 150;i++){final byte[][]randomData=Base64TestData.randomData(i,false);encoded=randomData[1];decoded=randomData[0];testByteByByte(encoded,decoded,0,LF);}}
/** * Tests markSupported.* @throws Exception*/@Test public void testMarkSupported()throws Exception {final byte[]decoded=StringUtils.getBytesUtf8(STRING_FIXTURE);final ByteArrayInputStream bin=new ByteArrayInputStream(decoded);final Base64InputStream in=new Base64InputStream(bin,true,4,new byte[]{0,0,0});assertFalse("Base64InputStream.markSupported()is false",in.markSupported());in.close();}
/** * Tests read returning 0* @throws Exception*/@Test public void testRead0()throws Exception {final byte[]decoded=StringUtils.getBytesUtf8(STRING_FIXTURE);final byte[]buf=new byte[1024];int bytesRead=0;final ByteArrayInputStream bin=new ByteArrayInputStream(decoded);final Base64InputStream in=new Base64InputStream(bin,true,4,new byte[]{0,0,0});bytesRead=in.read(buf,0,0);assertEquals("Base64InputStream.read(buf,0,0)returns 0",0,bytesRead);in.close();}
/** * Tests read with null.* @throws Exception for some failure scenarios.*/@Test public void testReadNull()throws Exception {final byte[]decoded=StringUtils.getBytesUtf8(STRING_FIXTURE);final ByteArrayInputStream bin=new ByteArrayInputStream(decoded);final Base64InputStream in=new Base64InputStream(bin,true,4,new byte[]{0,0,0});try {in.read(null,0,0);fail("Base64InputStream.read(null,0,0)to throw a NullPointerException");}catch(final NullPointerException e){}in.close();}
/** * Tests read throwing IndexOutOfBoundsException* @throws Exception*/@Test public void testReadOutOfBounds()throws Exception {final byte[]decoded=StringUtils.getBytesUtf8(STRING_FIXTURE);final byte[]buf=new byte[1024];final ByteArrayInputStream bin=new ByteArrayInputStream(decoded);final Base64InputStream in=new Base64InputStream(bin,true,4,new byte[]{0,0,0});try {in.read(buf,-1,0);fail("Expected Base64InputStream.read(buf,-1,0)to throw IndexOutOfBoundsException");}catch(final IndexOutOfBoundsException e){}try {in.read(buf,0,-1);fail("Expected Base64InputStream.read(buf,0,-1)to throw IndexOutOfBoundsException");}catch(final IndexOutOfBoundsException e){}try {in.read(buf,buf.length + 1,0);fail("Base64InputStream.read(buf,buf.length + 1,0)throws IndexOutOfBoundsException");}catch(final IndexOutOfBoundsException e){}try {in.read(buf,buf.length - 1,2);fail("Base64InputStream.read(buf,buf.length - 1,2)throws IndexOutOfBoundsException");}catch(final IndexOutOfBoundsException e){}in.close();}
/** * Tests skipping number of characters larger than the internal buffer.* @throws Throwable*/@Test public void testSkipBig()throws Throwable {final InputStream ins=new ByteArrayInputStream(StringUtils.getBytesIso8859_1(ENCODED_B64));final Base64InputStream b64stream=new Base64InputStream(ins);assertEquals(6,b64stream.skip(Integer.MAX_VALUE));assertEquals(-1,b64stream.read());assertEquals(-1,b64stream.read());b64stream.close();}
/** * Tests skipping as a noop* @throws Throwable*/@Test public void testSkipNone()throws Throwable {final InputStream ins=new ByteArrayInputStream(StringUtils.getBytesIso8859_1(ENCODED_B64));final Base64InputStream b64stream=new Base64InputStream(ins);final byte[]actualBytes=new byte[6];assertEquals(0,b64stream.skip(0));b64stream.read(actualBytes,0,actualBytes.length);assertArrayEquals(actualBytes,new byte[]{0,0,0,(byte)255,(byte)255,(byte)255});assertEquals(-1,b64stream.read());b64stream.close();}
/** * Tests skipping past the end of a stream.* @throws Throwable*/@Test public void testSkipPastEnd()throws Throwable {final InputStream ins=new ByteArrayInputStream(StringUtils.getBytesIso8859_1(ENCODED_B64));final Base64InputStream b64stream=new Base64InputStream(ins);assertEquals(6,b64stream.skip(10));assertEquals(-1,b64stream.read());assertEquals(-1,b64stream.read());b64stream.close();}
/** * Tests skipping to the end of a stream.* @throws Throwable*/@Test public void testSkipToEnd()throws Throwable {final InputStream ins=new ByteArrayInputStream(StringUtils.getBytesIso8859_1(ENCODED_B64));final Base64InputStream b64stream=new Base64InputStream(ins);assertEquals(6,b64stream.skip(6));assertEquals(-1,b64stream.read());assertEquals(-1,b64stream.read());b64stream.close();}
/** * Tests if negative arguments to skip are handled correctly.* @throws Throwable*/@Test(expected=IllegalArgumentException.class)public void testSkipWrongArgument()throws Throwable {final InputStream ins=new ByteArrayInputStream(StringUtils.getBytesIso8859_1(ENCODED_B64));final Base64InputStream b64stream=new Base64InputStream(ins);b64stream.skip(-10);b64stream.close();}
/** * See http://caversham.otago.ac.nz/files/working/ctp150804.pdf AT11111111 words: add,aid,at,art,eat,earth,head,hit,hot,hold,hard,heart,it,out,old* @throws EncoderException*/@Test public void testCaverphoneRevisitedCommonCodeAT11111111()throws EncoderException {this.checkEncodingVariations("AT11111111",new String[]{"add","aid","at","art","eat","earth","head","hit","hot","hold","hard","heart","it","out","old"});}
/** * See http://caversham.otago.ac.nz/files/working/ctp150804.pdf* @throws EncoderException*/@Test public void testCaverphoneRevisitedExamples()throws EncoderException {final String[][]data={{"Stevenson","STFNSN1111"},{"Peter","PTA1111111"}};this.checkEncodings(data);}
/** * See http://caversham.otago.ac.nz/files/working/ctp150804.pdf* @throws EncoderException*/@Test public void testCaverphoneRevisitedRandomNameKLN1111111()throws EncoderException {this.checkEncodingVariations("KLN1111111",new String[]{"Cailean","Calan","Calen","Callahan","Callan","Callean","Carleen","Carlen","Carlene","Carlin","Carline","Carlyn","Carlynn","Carlynne","Charlean","Charleen","Charlene","Charline","Cherlyn","Chirlin","Clein","Cleon","Cline","Cohleen","Colan","Coleen","Colene","Colin","Colleen","Collen","Collin","Colline","Colon","Cullan","Cullen","Cullin","Gaelan","Galan","Galen","Garlan","Garlen","Gaulin","Gayleen","Gaylene","Giliane","Gillan","Gillian","Glen","Glenn","Glyn","Glynn","Gollin","Gorlin","Kalin","Karlan","Karleen","Karlen","Karlene","Karlin","Karlyn","Kaylyn","Keelin","Kellen","Kellene","Kellyann","Kellyn","Khalin","Kilan","Kilian","Killen","Killian","Killion","Klein","Kleon","Kline","Koerlin","Kylen","Kylynn","Quillan","Quillon","Qulllon","Xylon"});}
/** * See http://caversham.otago.ac.nz/files/working/ctp150804.pdf* @throws EncoderException*/@Test public void testCaverphoneRevisitedRandomNameTN11111111()throws EncoderException {this.checkEncodingVariations("TN11111111",new String[]{"Dan","Dane","Dann","Darn","Daune","Dawn","Ddene","Dean","Deane","Deanne","DeeAnn","Deeann","Deeanne","Deeyn","Den","Dene","Denn","Deonne","Diahann","Dian","Diane","Diann","Dianne","Diannne","Dine","Dion","Dione","Dionne","Doane","Doehne","Don","Donn","Doone","Dorn","Down","Downe","Duane","Dun","Dunn","Duyne","Dyan","Dyane","Dyann","Dyanne","Dyun","Tan","Tann","Teahan","Ten","Tenn","Terhune","Thain","Thaine","Thane","Thanh","Thayne","Theone","Thin","Thorn","Thorne","Thun","Thynne","Tien","Tine","Tjon","Town","Towne","Turne","Tyne"});}
/** * See http://caversham.otago.ac.nz/files/working/ctp150804.pdf* @throws EncoderException*/@Test public void testCaverphoneRevisitedRandomNameTTA1111111()throws EncoderException {this.checkEncodingVariations("TTA1111111",new String[]{"Darda","Datha","Dedie","Deedee","Deerdre","Deidre","Deirdre","Detta","Didi","Didier","Dido","Dierdre","Dieter","Dita","Ditter","Dodi","Dodie","Dody","Doherty","Dorthea","Dorthy","Doti","Dotti","Dottie","Dotty","Doty","Doughty","Douty","Dowdell","Duthie","Tada","Taddeo","Tadeo","Tadio","Tati","Teador","Tedda","Tedder","Teddi","Teddie","Teddy","Tedi","Tedie","Teeter","Teodoor","Teodor","Terti","Theda","Theodor","Theodore","Theta","Thilda","Thordia","Tilda","Tildi","Tildie","Tildy","Tita","Tito","Tjader","Toddie","Toddy","Torto","Tuddor","Tudor","Turtle","Tuttle","Tutto"});}
/** * See http://caversham.otago.ac.nz/files/working/ctp150804.pdf* @throws EncoderException*/@Test public void testCaverphoneRevisitedRandomWords()throws EncoderException {this.checkEncodingVariations("RTA1111111",new String[]{"rather","ready","writer"});this.checkEncoding("SSA1111111","social");this.checkEncodingVariations("APA1111111",new String[]{"able","appear"});}
@Test public void testEndMb()throws EncoderException {final String[][]data={{"mb","M111111111"},{"mbmb","MPM1111111"}};this.checkEncodings(data);}
@Test public void testIsCaverphoneEquals()throws EncoderException {final Caverphone2 caverphone=new Caverphone2();Assert.assertFalse("Caverphone encodings should not be equal",caverphone.isEncodeEqual("Peter","Stevenson"));Assert.assertTrue("Caverphone encodings should be equal",caverphone.isEncodeEqual("Peter","Peady"));}
@Test public void testSpecificationExamples()throws EncoderException {final String[][]data={{"Peter","PTA1111111"},{"ready","RTA1111111"},{"social","SSA1111111"},{"able","APA1111111"},{"Tedder","TTA1111111"},{"Karleen","KLN1111111"},{"Dyun","TN11111111"}};this.checkEncodings(data);}
/** * We could make the constructor private in the future,it's a matter a style.*/@Test public void testConstructor(){new CharEncoding();}
@Test public void testIso8859_1(){Assert.assertEquals("ISO-8859-1",CharEncoding.ISO_8859_1);}
@Test public void testUsAscii(){Assert.assertEquals("US-ASCII",CharEncoding.US_ASCII);}
@Test public void testUtf16(){Assert.assertEquals("UTF-16",CharEncoding.UTF_16);}
@Test public void testUtf16Be(){Assert.assertEquals("UTF-16BE",CharEncoding.UTF_16BE);}
@Test public void testUtf16Le(){Assert.assertEquals("UTF-16LE",CharEncoding.UTF_16LE);}
@Test public void testUtf8(){Assert.assertEquals("UTF-8",CharEncoding.UTF_8);}
@Test public void testConstructable(){assertNotNull(new DigestUtils());}
@Test(expected=IllegalArgumentException.class)public void testInternalNoSuchAlgorithmException(){DigestUtils.getDigest("Bogus Bogus");}
@Test public void testMd2Hex()throws IOException {assertEquals("8350e5a3e24c153df2275c9f80692773",DigestUtils.md2Hex(""));assertEquals("32ec01ec4a6dac72c0ab96fb34c0b5d1",DigestUtils.md2Hex("a"));assertEquals("da853b0d3f88d99b30283a69e6ded6bb",DigestUtils.md2Hex("abc"));assertEquals("ab4f496bfb2a530b219ff33031fe06b0",DigestUtils.md2Hex("message digest"));assertEquals("4e8ddff3650292ab5a4108c3aa47940b",DigestUtils.md2Hex("abcdefghijklmnopqrstuvwxyz"));assertEquals("da33def2a42df13975352846c30338cd",DigestUtils.md2Hex("ABCDEFGHIJKLMNOPQRSTUVWXYZ" + "abcdefghijklmnopqrstuvwxyz" + "0123456789"));assertEquals("d5976f79d83d3a0dc9806c3c66f3efd8",DigestUtils.md2Hex("1234567890123456789012345678901234567890" + "1234567890123456789012345678901234567890"));assertEquals(DigestUtils.md2Hex(testData),DigestUtils.md2Hex(new ByteArrayInputStream(testData)));}
/** * An MD2 hash converted to hex should always be 32 characters.*/@Test public void testMd2HexLength(){String hashMe="this is some string that is longer than 32 characters";String hash=DigestUtils.md2Hex(getBytesUtf8(hashMe));assertEquals(32,hash.length());hashMe="length < 32";hash=DigestUtils.md2Hex(getBytesUtf8(hashMe));assertEquals(32,hash.length());}
/** * An MD2 hash should always be a 16 element byte[].*/@Test public void testMd2Length(){String hashMe="this is some string that is longer than 16 characters";byte[]hash=DigestUtils.md2(getBytesUtf8(hashMe));assertEquals(16,hash.length);hashMe="length < 16";hash=DigestUtils.md2(getBytesUtf8(hashMe));assertEquals(16,hash.length);}
@Test public void testMd5Hex()throws IOException {assertEquals("d41d8cd98f00b204e9800998ecf8427e",DigestUtils.md5Hex(""));assertEquals("0cc175b9c0f1b6a831c399e269772661",DigestUtils.md5Hex("a"));assertEquals("900150983cd24fb0d6963f7d28e17f72",DigestUtils.md5Hex("abc"));assertEquals("f96b697d7cb7938d525a2f31aaf161d0",DigestUtils.md5Hex("message digest"));assertEquals("c3fcd3d76192e4007dfb496cca67e13b",DigestUtils.md5Hex("abcdefghijklmnopqrstuvwxyz"));assertEquals("d174ab98d277d9f5a5611c2c9f419d9f",DigestUtils.md5Hex("ABCDEFGHIJKLMNOPQRSTUVWXYZ" + "abcdefghijklmnopqrstuvwxyz" + "0123456789"));assertEquals("57edf4a22be3c955ac49da2e2107b67a",DigestUtils.md5Hex("1234567890123456789012345678901234567890" + "1234567890123456789012345678901234567890"));assertEquals(DigestUtils.md5Hex(testData),DigestUtils.md5Hex(new ByteArrayInputStream(testData)));}
/** * An MD5 hash converted to hex should always be 32 characters.*/@Test public void testMd5HexLength(){String hashMe="this is some string that is longer than 32 characters";String hash=DigestUtils.md5Hex(getBytesUtf8(hashMe));assertEquals(32,hash.length());hashMe="length < 32";hash=DigestUtils.md5Hex(getBytesUtf8(hashMe));assertEquals(32,hash.length());}
/** * An MD5 hash should always be a 16 element byte[].*/@Test public void testMd5Length(){String hashMe="this is some string that is longer than 16 characters";byte[]hash=DigestUtils.md5(getBytesUtf8(hashMe));assertEquals(16,hash.length);hashMe="length < 16";hash=DigestUtils.md5(getBytesUtf8(hashMe));assertEquals(16,hash.length);}
@Test public void testSha1Hex()throws IOException {assertEquals("a9993e364706816aba3e25717850c26c9cd0d89d",DigestUtils.sha1Hex("abc"));assertEquals("a9993e364706816aba3e25717850c26c9cd0d89d",DigestUtils.sha1Hex(getBytesUtf8("abc")));assertEquals("84983e441c3bd26ebaae4aa1f95129e5e54670f1",DigestUtils.sha1Hex("abcdbcdecdefdefgefghfghighij" + "hijkijkljklmklmnlmnomnopnopq"));assertEquals(DigestUtils.sha1Hex(testData),DigestUtils.sha1Hex(new ByteArrayInputStream(testData)));}
@Test public void testSha1UpdateWithByteArray(){final String d1="C'est un homme qui rentre dans un café,et plouf";final String d2="C'est un homme,c'est qu'une tête,on lui offre un cadeau: 'oh... encore un chapeau!'";MessageDigest messageDigest=DigestUtils.getSha1Digest();messageDigest.update(d1.getBytes());messageDigest.update(d2.getBytes());final String expectedResult=Hex.encodeHexString(messageDigest.digest());messageDigest=DigestUtils.getSha1Digest();DigestUtils.updateDigest(messageDigest,d1.getBytes());DigestUtils.updateDigest(messageDigest,d2.getBytes());final String actualResult=Hex.encodeHexString(messageDigest.digest());assertEquals(expectedResult,actualResult);}
@Test public void testSha1UpdateWithString(){final String d1="C'est un homme qui rentre dans un café,et plouf";final String d2="C'est un homme,c'est qu'une tête,on lui offre un cadeau: 'oh... encore un chapeau!'";MessageDigest messageDigest=DigestUtils.getSha1Digest();messageDigest.update(StringUtils.getBytesUtf8(d1));messageDigest.update(StringUtils.getBytesUtf8(d2));final String expectedResult=Hex.encodeHexString(messageDigest.digest());messageDigest=DigestUtils.getSha1Digest();DigestUtils.updateDigest(messageDigest,d1);DigestUtils.updateDigest(messageDigest,d2);final String actualResult=Hex.encodeHexString(messageDigest.digest());assertEquals(expectedResult,actualResult);}
@Test public void testSha256()throws IOException {assertEquals("ba7816bf8f01cfea414140de5dae2223b00361a396177a9cb410ff61f20015ad",DigestUtils.sha256Hex("abc"));assertEquals("ba7816bf8f01cfea414140de5dae2223b00361a396177a9cb410ff61f20015ad",DigestUtils.sha256Hex(getBytesUtf8("abc")));assertEquals("248d6a61d20638b8e5c026930c3e6039a33ce45964ff2167f6ecedd419db06c1",DigestUtils.sha256Hex("abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq"));assertEquals(DigestUtils.sha256Hex(testData),DigestUtils.sha256Hex(new ByteArrayInputStream(testData)));}
@Test public void testSha384()throws IOException {assertEquals("cb00753f45a35e8bb5a03d699ac65007272c32ab0eded1631a8b605a43ff5bed" + "8086072ba1e7cc2358baeca134c825a7",DigestUtils.sha384Hex("abc"));assertEquals("cb00753f45a35e8bb5a03d699ac65007272c32ab0eded1631a8b605a43ff5bed" + "8086072ba1e7cc2358baeca134c825a7",DigestUtils.sha384Hex(getBytesUtf8("abc")));assertEquals("09330c33f71147e83d192fc782cd1b4753111b173b3b05d22fa08086e3b0f712" + "fcc7c71a557e2db966c3e9fa91746039",DigestUtils.sha384Hex("abcdefghbcdefghicdefghijdefghijkefghijklfghijklmghijklmn" + "hijklmnoijklmnopjklmnopqklmnopqrlmnopqrsmnopqrstnopqrstu"));assertEquals(DigestUtils.sha384Hex(testData),DigestUtils.sha384Hex(new ByteArrayInputStream(testData)));}
@Test public void testSha512()throws IOException {assertEquals("ddaf35a193617abacc417349ae20413112e6fa4e89a97ea20a9eeee64b55d39a" + "2192992a274fc1a836ba3c23a3feebbd454d4423643ce80e2a9ac94fa54ca49f",DigestUtils.sha512Hex("abc"));assertEquals("ddaf35a193617abacc417349ae20413112e6fa4e89a97ea20a9eeee64b55d39a" + "2192992a274fc1a836ba3c23a3feebbd454d4423643ce80e2a9ac94fa54ca49f",DigestUtils.sha512Hex(getBytesUtf8("abc")));assertEquals("8e959b75dae313da8cf4f72814fc143f8f7779c6eb9f7fa17299aeadb6889018" + "501d289e4900f7e4331b99dec4b5433ac7d329eeb6dd26545e96e55b874be909",DigestUtils.sha512Hex("abcdefghbcdefghicdefghijdefghijkefghijklfghijklmghijklmn" + "hijklmnoijklmnopjklmnopqklmnopqrlmnopqrsmnopqrstnopqrstu"));assertEquals(DigestUtils.sha512Hex(testData),DigestUtils.sha512Hex(new ByteArrayInputStream(testData)));}
@SuppressWarnings("deprecation")@Test public void testShaHex()throws IOException {assertEquals("a9993e364706816aba3e25717850c26c9cd0d89d",DigestUtils.shaHex("abc"));assertEquals("a9993e364706816aba3e25717850c26c9cd0d89d",DigestUtils.shaHex(getBytesUtf8("abc")));assertEquals("84983e441c3bd26ebaae4aa1f95129e5e54670f1",DigestUtils.shaHex("abcdbcdecdefdefgefghfghighij" + "hijkijkljklmklmnlmnomnopnopq"));assertEquals(DigestUtils.shaHex(testData),DigestUtils.shaHex(new ByteArrayInputStream(testData)));}
@SuppressWarnings("deprecation")@Test public void testShaUpdateWithByteArray(){final String d1="C'est un homme qui rentre dans un café,et plouf";final String d2="C'est un homme,c'est qu'une tête,on lui offre un cadeau: 'oh... encore un chapeau!'";MessageDigest messageDigest=DigestUtils.getShaDigest();messageDigest.update(d1.getBytes());messageDigest.update(d2.getBytes());final String expectedResult=Hex.encodeHexString(messageDigest.digest());messageDigest=DigestUtils.getShaDigest();DigestUtils.updateDigest(messageDigest,d1.getBytes());DigestUtils.updateDigest(messageDigest,d2.getBytes());final String actualResult=Hex.encodeHexString(messageDigest.digest());assertEquals(expectedResult,actualResult);}
@SuppressWarnings("deprecation")@Test public void testShaUpdateWithString(){final String d1="C'est un homme qui rentre dans un café,et plouf";final String d2="C'est un homme,c'est qu'une tête,on lui offre un cadeau: 'oh... encore un chapeau!'";MessageDigest messageDigest=DigestUtils.getShaDigest();messageDigest.update(StringUtils.getBytesUtf8(d1));messageDigest.update(StringUtils.getBytesUtf8(d2));final String expectedResult=Hex.encodeHexString(messageDigest.digest());messageDigest=DigestUtils.getShaDigest();DigestUtils.updateDigest(messageDigest,d1);DigestUtils.updateDigest(messageDigest,d2);final String actualResult=Hex.encodeHexString(messageDigest.digest());assertEquals(expectedResult,actualResult);}
/** * Test the isStringBase64 method.*/@Test public void testIsStringBase64(){final String nullString=null;final String emptyString="";final String validString="abc===defg\n\r123456\r789\r\rABC\n\nDEF==GHI\r\nJKL==============";final String invalidString=validString + (char)0;try {Base64.isBase64(nullString);fail("Base64.isStringBase64()should not be null-safe.");}catch(final NullPointerException npe){assertNotNull("Base64.isStringBase64()should not be null-safe.",npe);}assertTrue("Base64.isStringBase64(empty-string)is true",Base64.isBase64(emptyString));assertTrue("Base64.isStringBase64(valid-string)is true",Base64.isBase64(validString));assertFalse("Base64.isStringBase64(invalid-string)is false",Base64.isBase64(invalidString));}
/** * Test the Base64 implementation*/@Test public void testBase64(){final String content="Hello World";String encodedContent;byte[]encodedBytes=Base64.encodeBase64(StringUtils.getBytesUtf8(content));encodedContent=StringUtils.newStringUtf8(encodedBytes);assertEquals("encoding hello world","SGVsbG8gV29ybGQ=",encodedContent);Base64 b64=new Base64(BaseNCodec.MIME_CHUNK_SIZE,null);encodedBytes=b64.encode(StringUtils.getBytesUtf8(content));encodedContent=StringUtils.newStringUtf8(encodedBytes);assertEquals("encoding hello world","SGVsbG8gV29ybGQ=",encodedContent);b64=new Base64(0,null);encodedBytes=b64.encode(StringUtils.getBytesUtf8(content));encodedContent=StringUtils.newStringUtf8(encodedBytes);assertEquals("encoding hello world","SGVsbG8gV29ybGQ=",encodedContent);final byte[]decode=b64.decode("SGVsbG{\u00e9\u00e9\u00e9\u00e9\u00e9\u00e9}8gV29ybGQ=");final String decodeString=StringUtils.newStringUtf8(decode);assertEquals("decode hello world","Hello World",decodeString);}
/** * Test our decode with pad character in the middle. (Our current implementation:  halt decode and return what we've got so far). The point of this test is not to say "this is the correct way to decode base64." The point is simply to keep us aware of the current logic since 1.4 so we don't accidentally break it without realizing. Note for historians.  The 1.3 logic would decode to: "Hello World\u0000Hello World" -- null in the middle --- and 1.4 unwittingly changed it to current logic.*/@Test public void testDecodeWithInnerPad(){final String content="SGVsbG8gV29ybGQ=SGVsbG8gV29ybGQ=";final byte[]result=Base64.decodeBase64(content);final byte[]shouldBe=StringUtils.getBytesUtf8("Hello World");assertTrue("decode should halt at pad (=)",Arrays.equals(result,shouldBe));}
/** * Tests Base64.encodeBase64().*/@Test public void testChunkedEncodeMultipleOf76(){final byte[]expectedEncode=Base64.encodeBase64(Base64TestData.DECODED,true);final String actualResult=Base64TestData.ENCODED_76_CHARS_PER_LINE.replaceAll("\n","\r\n");final byte[]actualEncode=StringUtils.getBytesUtf8(actualResult);assertTrue("chunkedEncodeMultipleOf76",Arrays.equals(expectedEncode,actualEncode));}
/** * CODEC-68: isBase64 throws ArrayIndexOutOfBoundsException on some non-BASE64 bytes*/@Test public void testCodec68(){final byte[]x=new byte[]{'n','A','=','=',(byte)0x9c};Base64.decodeBase64(x);}
@Test public void testCodeInteger1(){final String encodedInt1="li7dzDacuo67Jg7mtqEm2TRuOMU=";final BigInteger bigInt1=new BigInteger("85739377120809420210425962799" + "0318636601332086981");assertEquals(encodedInt1,new String(Base64.encodeInteger(bigInt1)));assertEquals(bigInt1,Base64.decodeInteger(encodedInt1.getBytes(Charsets.UTF_8)));}
@Test public void testCodeInteger2(){final String encodedInt2="9B5ypLY9pMOmtxCeTDHgwdNFeGs=";final BigInteger bigInt2=new BigInteger("13936727572861167254666467268" + "91466679477132949611");assertEquals(encodedInt2,new String(Base64.encodeInteger(bigInt2)));assertEquals(bigInt2,Base64.decodeInteger(encodedInt2.getBytes(Charsets.UTF_8)));}
@Test public void testCodeInteger3(){final String encodedInt3="FKIhdgaG5LGKiEtF1vHy4f3y700zaD6QwDS3IrNVGzNp2" + "rY+1LFWTK6D44AyiC1n8uWz1itkYMZF0/aKDK0Yjg==";final BigInteger bigInt3=new BigInteger("10806548154093873461951748545" + "1196989136416448805819079363524309897749044958112417136240557" + "4495062430572478766856090958495998158114332651671116876320938126");assertEquals(encodedInt3,new String(Base64.encodeInteger(bigInt3)));assertEquals(bigInt3,Base64.decodeInteger(encodedInt3.getBytes(Charsets.UTF_8)));}
@Test public void testCodeInteger4(){final String encodedInt4="ctA8YGxrtngg/zKVvqEOefnwmViFztcnPBYPlJsvh6yKI" + "4iDm68fnp4Mi3RrJ6bZAygFrUIQLxLjV+OJtgJAEto0xAs+Mehuq1DkSFEpP3o" + "DzCTOsrOiS1DwQe4oIb7zVk/9l7aPtJMHW0LVlMdwZNFNNJoqMcT2ZfCPrfvYv"+ "Q0=";final BigInteger bigInt4=new BigInteger("80624726256040348115552042320" + "6968135001872753709424419772586693950232350200555646471175944" + "519297087885987040810778908507262272892702303774422853675597"+ "748008534040890923814202286633163248086055216976551456088015"+ "338880713818192088877057717530169381044092839402438015097654"+ "53542091716518238707344493641683483917");assertEquals(encodedInt4,new String(Base64.encodeInteger(bigInt4)));assertEquals(bigInt4,Base64.decodeInteger(encodedInt4.getBytes(Charsets.UTF_8)));}
@Test public void testCodeIntegerEdgeCases(){}
@Test public void testCodeIntegerNull(){try {Base64.encodeInteger(null);fail("Exception not thrown when passing in null to encodeInteger(BigInteger)");}catch(final NullPointerException npe){}catch(final Exception e){fail("Incorrect Exception caught when passing in null to encodeInteger(BigInteger)");}}
@Test public void testConstructors(){Base64 base64;base64=new Base64();base64=new Base64(-1);base64=new Base64(-1,new byte[]{});base64=new Base64(64,new byte[]{});try {base64=new Base64(-1,new byte[]{'A'});fail("Should have rejected attempt to use 'A' as a line separator");}catch(final IllegalArgumentException ignored){}try {base64=new Base64(64,new byte[]{'A'});fail("Should have rejected attempt to use 'A' as a line separator");}catch(final IllegalArgumentException ignored){}try {base64=new Base64(64,new byte[]{'='});fail("Should have rejected attempt to use '=' as a line separator");}catch(final IllegalArgumentException ignored){}base64=new Base64(64,new byte[]{'$'});try {base64=new Base64(64,new byte[]{'A','$'});fail("Should have rejected attempt to use 'A$' as a line separator");}catch(final IllegalArgumentException ignored){}base64=new Base64(64,new byte[]{' ','$','\n','\r','\t'});assertNotNull(base64);}
@Test public void testConstructor_Int_ByteArray_Boolean(){final Base64 base64=new Base64(65,new byte[]{'\t'},false);final byte[]encoded=base64.encode(Base64TestData.DECODED);String expectedResult=Base64TestData.ENCODED_64_CHARS_PER_LINE;expectedResult=expectedResult.replace('\n','\t');final String result=StringUtils.newStringUtf8(encoded);assertEquals("new Base64(65,\\t,false)",expectedResult,result);}
@Test public void testConstructor_Int_ByteArray_Boolean_UrlSafe(){final Base64 base64=new Base64(64,new byte[]{'\t'},true);final byte[]encoded=base64.encode(Base64TestData.DECODED);String expectedResult=Base64TestData.ENCODED_64_CHARS_PER_LINE;expectedResult=expectedResult.replaceAll("=","");expectedResult=expectedResult.replace('\n','\t');expectedResult=expectedResult.replace('+','-');expectedResult=expectedResult.replace('/','_');final String result=StringUtils.newStringUtf8(encoded);assertEquals("new Base64(64,\\t,true)",result,expectedResult);}
/** * Tests conditional true branch for "marker0" test.*/@Test public void testDecodePadMarkerIndex2(){assertEquals("A",new String(Base64.decodeBase64("QQ==".getBytes(Charsets.UTF_8))));}
/** * Tests conditional branches for "marker1" test.*/@Test public void testDecodePadMarkerIndex3(){assertEquals("AA",new String(Base64.decodeBase64("QUE=".getBytes(Charsets.UTF_8))));assertEquals("AAA",new String(Base64.decodeBase64("QUFB".getBytes(Charsets.UTF_8))));}
@Test public void testDecodePadOnly(){assertEquals(0,Base64.decodeBase64("====".getBytes(Charsets.UTF_8)).length);assertEquals("",new String(Base64.decodeBase64("====".getBytes(Charsets.UTF_8))));assertEquals(0,Base64.decodeBase64("===".getBytes(Charsets.UTF_8)).length);assertEquals(0,Base64.decodeBase64("==".getBytes(Charsets.UTF_8)).length);assertEquals(0,Base64.decodeBase64("=".getBytes(Charsets.UTF_8)).length);assertEquals(0,Base64.decodeBase64("".getBytes(Charsets.UTF_8)).length);}
@Test public void testDecodePadOnlyChunked(){assertEquals(0,Base64.decodeBase64("====\n".getBytes(Charsets.UTF_8)).length);assertEquals("",new String(Base64.decodeBase64("====\n".getBytes(Charsets.UTF_8))));assertEquals(0,Base64.decodeBase64("===\n".getBytes(Charsets.UTF_8)).length);assertEquals(0,Base64.decodeBase64("==\n".getBytes(Charsets.UTF_8)).length);assertEquals(0,Base64.decodeBase64("=\n".getBytes(Charsets.UTF_8)).length);assertEquals(0,Base64.decodeBase64("\n".getBytes(Charsets.UTF_8)).length);}
@Test public void testDecodeWithWhitespace()throws Exception {final String orig="I am a late night coder.";final byte[]encodedArray=Base64.encodeBase64(orig.getBytes(Charsets.UTF_8));final StringBuilder intermediate=new StringBuilder(new String(encodedArray));intermediate.insert(2,' ');intermediate.insert(5,'\t');intermediate.insert(10,'\r');intermediate.insert(15,'\n');final byte[]encodedWithWS=intermediate.toString().getBytes(Charsets.UTF_8);final byte[]decodedWithWS=Base64.decodeBase64(encodedWithWS);final String dest=new String(decodedWithWS);assertEquals("Dest string doesn't equal the original",orig,dest);}
/** * Test encode and decode of empty byte array.*/@Test public void testEmptyBase64(){byte[]empty=new byte[0];byte[]result=Base64.encodeBase64(empty);assertEquals("empty base64 encode",0,result.length);assertEquals("empty base64 encode",null,Base64.encodeBase64(null));empty=new byte[0];result=Base64.decodeBase64(empty);assertEquals("empty base64 decode",0,result.length);assertEquals("empty base64 encode",null,Base64.decodeBase64((byte[])null));}
@Test public void testEncodeDecodeRandom(){for (int i=1;i < 5;i++){final byte[]data=new byte[this.getRandom().nextInt(10000)+ 1];this.getRandom().nextBytes(data);final byte[]enc=Base64.encodeBase64(data);assertTrue(Base64.isBase64(enc));final byte[]data2=Base64.decodeBase64(enc);assertTrue(Arrays.equals(data,data2));}}
@Test public void testEncodeDecodeSmall(){for (int i=0;i < 12;i++){final byte[]data=new byte[i];this.getRandom().nextBytes(data);final byte[]enc=Base64.encodeBase64(data);assertTrue("\"" + new String(enc)+ "\" is Base64 data.",Base64.isBase64(enc));final byte[]data2=Base64.decodeBase64(enc);assertTrue(toString(data)+ " equals " + toString(data2),Arrays.equals(data,data2));}}
@Test public void testEncodeOverMaxSize()throws Exception {testEncodeOverMaxSize(-1);testEncodeOverMaxSize(0);testEncodeOverMaxSize(1);testEncodeOverMaxSize(2);}
@Test public void testCodec112(){final byte[]in=new byte[]{0};final byte[]out=Base64.encodeBase64(in);Base64.encodeBase64(in,false,false,out.length);}
@Test public void testIgnoringNonBase64InDecode()throws Exception {assertEquals("The quick brown fox jumped over the lazy dogs.",new String(Base64.decodeBase64("VGhlIH@$#$@%F1aWN@#@#@@rIGJyb3duIGZve\n\r\t%#%#%#%CBqd##$#$W1wZWQgb3ZlciB0aGUgbGF6eSBkb2dzLg==".getBytes(Charsets.UTF_8))));}
@Test public void testIsArrayByteBase64(){assertFalse(Base64.isBase64(new byte[]{Byte.MIN_VALUE}));assertFalse(Base64.isBase64(new byte[]{-125}));assertFalse(Base64.isBase64(new byte[]{-10}));assertFalse(Base64.isBase64(new byte[]{0}));assertFalse(Base64.isBase64(new byte[]{64,Byte.MAX_VALUE}));assertFalse(Base64.isBase64(new byte[]{Byte.MAX_VALUE}));assertTrue(Base64.isBase64(new byte[]{'A'}));assertFalse(Base64.isBase64(new byte[]{'A',Byte.MIN_VALUE}));assertTrue(Base64.isBase64(new byte[]{'A','Z','a'}));assertTrue(Base64.isBase64(new byte[]{'/','=','+'}));assertFalse(Base64.isBase64(new byte[]{'$'}));}
/** * Tests isUrlSafe.*/@Test public void testIsUrlSafe(){final Base64 base64Standard=new Base64(false);final Base64 base64URLSafe=new Base64(true);assertFalse("Base64.isUrlSafe=false",base64Standard.isUrlSafe());assertTrue("Base64.isUrlSafe=true",base64URLSafe.isUrlSafe());final byte[]whiteSpace={' ','\n','\r','\t'};assertTrue("Base64.isBase64(whiteSpace)=true",Base64.isBase64(whiteSpace));}
@Test public void testKnownDecodings(){assertEquals("The quick brown fox jumped over the lazy dogs.",new String(Base64.decodeBase64("VGhlIHF1aWNrIGJyb3duIGZveCBqdW1wZWQgb3ZlciB0aGUgbGF6eSBkb2dzLg==".getBytes(Charsets.UTF_8))));assertEquals("It was the best of times,it was the worst of times.",new String(Base64.decodeBase64("SXQgd2FzIHRoZSBiZXN0IG9mIHRpbWVzLCBpdCB3YXMgdGhlIHdvcnN0IG9mIHRpbWVzLg==".getBytes(Charsets.UTF_8))));assertEquals("http://jakarta.apache.org/commmons",new String(Base64.decodeBase64("aHR0cDovL2pha2FydGEuYXBhY2hlLm9yZy9jb21tbW9ucw==".getBytes(Charsets.UTF_8))));assertEquals("AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz",new String(Base64.decodeBase64("QWFCYkNjRGRFZUZmR2dIaElpSmpLa0xsTW1Obk9vUHBRcVJyU3NUdFV1VnZXd1h4WXlaeg==".getBytes(Charsets.UTF_8))));assertEquals("{0,1,2,3,4,5,6,7,8,9 }",new String(Base64.decodeBase64("eyAwLCAxLCAyLCAzLCA0LCA1LCA2LCA3LCA4LCA5IH0=".getBytes(Charsets.UTF_8))));assertEquals("xyzzy!",new String(Base64.decodeBase64("eHl6enkh".getBytes(Charsets.UTF_8))));}
@Test public void testKnownEncodings(){assertEquals("VGhlIHF1aWNrIGJyb3duIGZveCBqdW1wZWQgb3ZlciB0aGUgbGF6eSBkb2dzLg==",new String(Base64.encodeBase64("The quick brown fox jumped over the lazy dogs.".getBytes(Charsets.UTF_8))));assertEquals("YmxhaCBibGFoIGJsYWggYmxhaCBibGFoIGJsYWggYmxhaCBibGFoIGJsYWggYmxhaCBibGFoIGJs\r\nYWggYmxhaCBibGFoIGJsYWggYmxhaCBibGFoIGJsYWggYmxhaCBibGFoIGJsYWggYmxhaCBibGFo\r\nIGJsYWggYmxhaCBibGFoIGJsYWggYmxhaCBibGFoIGJsYWggYmxhaCBibGFoIGJsYWggYmxhaCBi\r\nbGFoIGJsYWg=\r\n",new String(Base64.encodeBase64Chunked("blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah".getBytes(Charsets.UTF_8))));assertEquals("SXQgd2FzIHRoZSBiZXN0IG9mIHRpbWVzLCBpdCB3YXMgdGhlIHdvcnN0IG9mIHRpbWVzLg==",new String(Base64.encodeBase64("It was the best of times,it was the worst of times.".getBytes(Charsets.UTF_8))));assertEquals("aHR0cDovL2pha2FydGEuYXBhY2hlLm9yZy9jb21tbW9ucw==",new String(Base64.encodeBase64("http://jakarta.apache.org/commmons".getBytes(Charsets.UTF_8))));assertEquals("QWFCYkNjRGRFZUZmR2dIaElpSmpLa0xsTW1Obk9vUHBRcVJyU3NUdFV1VnZXd1h4WXlaeg==",new String(Base64.encodeBase64("AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz".getBytes(Charsets.UTF_8))));assertEquals("eyAwLCAxLCAyLCAzLCA0LCA1LCA2LCA3LCA4LCA5IH0=",new String(Base64.encodeBase64("{0,1,2,3,4,5,6,7,8,9 }".getBytes(Charsets.UTF_8))));assertEquals("eHl6enkh",new String(Base64.encodeBase64("xyzzy!".getBytes(Charsets.UTF_8))));}
@Test public void testNonBase64Test()throws Exception {final byte[]bArray={'%'};assertFalse("Invalid Base64 array was incorrectly validated as " + "an array of Base64 encoded data",Base64.isBase64(bArray));try {final Base64 b64=new Base64();final byte[]result=b64.decode(bArray);assertEquals("The result should be empty as the test encoded content did " + "not contain any valid base 64 characters",0,result.length);}catch(final Exception e){fail("Exception was thrown when trying to decode " + "invalid base64 encoded data - RFC 2045 requires that all " + "non base64 character be discarded,an exception should not"+ " have been thrown");}}
@Test public void testObjectDecodeWithInvalidParameter()throws Exception {final Base64 b64=new Base64();try {b64.decode(Integer.valueOf(5));fail("decode(Object)didn't throw an exception when passed an Integer object");}catch(final DecoderException e){}}
@Test public void testObjectDecodeWithValidParameter()throws Exception {final String original="Hello World!";final Object o=Base64.encodeBase64(original.getBytes(Charsets.UTF_8));final Base64 b64=new Base64();final Object oDecoded=b64.decode(o);final byte[]baDecoded=(byte[])oDecoded;final String dest=new String(baDecoded);assertEquals("dest string does not equal original",original,dest);}
@Test public void testObjectEncodeWithInvalidParameter()throws Exception {final Base64 b64=new Base64();try {b64.encode("Yadayadayada");fail("encode(Object)didn't throw an exception when passed a String object");}catch(final EncoderException e){}}
@Test public void testObjectEncodeWithValidParameter()throws Exception {final String original="Hello World!";final Object origObj=original.getBytes(Charsets.UTF_8);final Base64 b64=new Base64();final Object oEncoded=b64.encode(origObj);final byte[]bArray=Base64.decodeBase64((byte[])oEncoded);final String dest=new String(bArray);assertEquals("dest string does not equal original",original,dest);}
@Test public void testObjectEncode()throws Exception {final Base64 b64=new Base64();assertEquals("SGVsbG8gV29ybGQ=",new String(b64.encode("Hello World".getBytes(Charsets.UTF_8))));}
@Test public void testPairs(){assertEquals("AAA=",new String(Base64.encodeBase64(new byte[]{0,0})));for (int i=-128;i <= 127;i++){final byte test[]={(byte)i,(byte)i};assertTrue(Arrays.equals(test,Base64.decodeBase64(Base64.encodeBase64(test))));}}
/** * Tests RFC 2045 section 2.1 CRLF definition.*/@Test public void testRfc2045Section2Dot1CrLfDefinition(){assertTrue(Arrays.equals(new byte[]{13,10},Base64.CHUNK_SEPARATOR));}
/** * Tests RFC 2045 section 6.8 chuck size definition.*/@Test public void testRfc2045Section6Dot8ChunkSizeDefinition(){assertEquals(76,BaseNCodec.MIME_CHUNK_SIZE);}
/** * Tests RFC 1421 section 4.3.2.4 chuck size definition.*/@Test public void testRfc1421Section6Dot8ChunkSizeDefinition(){assertEquals(64,BaseNCodec.PEM_CHUNK_SIZE);}
/** * Tests RFC 4648 section 10 test vectors. <ul> <li>BASE64("")= ""</li> <li>BASE64("f")= "Zg=="</li> <li>BASE64("fo")= "Zm8="</li> <li>BASE64("foo")= "Zm9v"</li> <li>BASE64("foob")= "Zm9vYg=="</li> <li>BASE64("fooba")= "Zm9vYmE="</li> <li>BASE64("foobar")= "Zm9vYmFy"</li> </ul>* @see <a href="http://tools.ietf.org/html/rfc4648">http://tools.ietf.org/html/rfc4648</a>*/@Test public void testRfc4648Section10Decode(){assertEquals("",StringUtils.newStringUsAscii(Base64.decodeBase64("")));assertEquals("f",StringUtils.newStringUsAscii(Base64.decodeBase64("Zg==")));assertEquals("fo",StringUtils.newStringUsAscii(Base64.decodeBase64("Zm8=")));assertEquals("foo",StringUtils.newStringUsAscii(Base64.decodeBase64("Zm9v")));assertEquals("foob",StringUtils.newStringUsAscii(Base64.decodeBase64("Zm9vYg==")));assertEquals("fooba",StringUtils.newStringUsAscii(Base64.decodeBase64("Zm9vYmE=")));assertEquals("foobar",StringUtils.newStringUsAscii(Base64.decodeBase64("Zm9vYmFy")));}
/** * Tests RFC 4648 section 10 test vectors. <ul> <li>BASE64("")= ""</li> <li>BASE64("f")= "Zg=="</li> <li>BASE64("fo")= "Zm8="</li> <li>BASE64("foo")= "Zm9v"</li> <li>BASE64("foob")= "Zm9vYg=="</li> <li>BASE64("fooba")= "Zm9vYmE="</li> <li>BASE64("foobar")= "Zm9vYmFy"</li> </ul>* @see <a href="http://tools.ietf.org/html/rfc4648">http://tools.ietf.org/html/rfc4648</a>*/@Test public void testRfc4648Section10DecodeWithCrLf(){final String CRLF=StringUtils.newStringUsAscii(Base64.CHUNK_SEPARATOR);assertEquals("",StringUtils.newStringUsAscii(Base64.decodeBase64("" + CRLF)));assertEquals("f",StringUtils.newStringUsAscii(Base64.decodeBase64("Zg==" + CRLF)));assertEquals("fo",StringUtils.newStringUsAscii(Base64.decodeBase64("Zm8=" + CRLF)));assertEquals("foo",StringUtils.newStringUsAscii(Base64.decodeBase64("Zm9v" + CRLF)));assertEquals("foob",StringUtils.newStringUsAscii(Base64.decodeBase64("Zm9vYg==" + CRLF)));assertEquals("fooba",StringUtils.newStringUsAscii(Base64.decodeBase64("Zm9vYmE=" + CRLF)));assertEquals("foobar",StringUtils.newStringUsAscii(Base64.decodeBase64("Zm9vYmFy" + CRLF)));}
/** * Tests RFC 4648 section 10 test vectors. <ul> <li>BASE64("")= ""</li> <li>BASE64("f")= "Zg=="</li> <li>BASE64("fo")= "Zm8="</li> <li>BASE64("foo")= "Zm9v"</li> <li>BASE64("foob")= "Zm9vYg=="</li> <li>BASE64("fooba")= "Zm9vYmE="</li> <li>BASE64("foobar")= "Zm9vYmFy"</li> </ul>* @see <a href="http://tools.ietf.org/html/rfc4648">http://tools.ietf.org/html/rfc4648</a>*/@Test public void testRfc4648Section10Encode(){assertEquals("",Base64.encodeBase64String(StringUtils.getBytesUtf8("")));assertEquals("Zg==",Base64.encodeBase64String(StringUtils.getBytesUtf8("f")));assertEquals("Zm8=",Base64.encodeBase64String(StringUtils.getBytesUtf8("fo")));assertEquals("Zm9v",Base64.encodeBase64String(StringUtils.getBytesUtf8("foo")));assertEquals("Zm9vYg==",Base64.encodeBase64String(StringUtils.getBytesUtf8("foob")));assertEquals("Zm9vYmE=",Base64.encodeBase64String(StringUtils.getBytesUtf8("fooba")));assertEquals("Zm9vYmFy",Base64.encodeBase64String(StringUtils.getBytesUtf8("foobar")));}
/** * Tests RFC 4648 section 10 test vectors. <ul> <li>BASE64("")= ""</li> <li>BASE64("f")= "Zg=="</li> <li>BASE64("fo")= "Zm8="</li> <li>BASE64("foo")= "Zm9v"</li> <li>BASE64("foob")= "Zm9vYg=="</li> <li>BASE64("fooba")= "Zm9vYmE="</li> <li>BASE64("foobar")= "Zm9vYmFy"</li> </ul>* @see <a href="http://tools.ietf.org/html/rfc4648">http://tools.ietf.org/html/rfc4648</a>*/@Test public void testRfc4648Section10DecodeEncode(){testDecodeEncode("");testDecodeEncode("Zg==");testDecodeEncode("Zm8=");testDecodeEncode("Zm9v");testDecodeEncode("Zm9vYg==");testDecodeEncode("Zm9vYmE=");testDecodeEncode("Zm9vYmFy");}
/** * Tests RFC 4648 section 10 test vectors. <ul> <li>BASE64("")= ""</li> <li>BASE64("f")= "Zg=="</li> <li>BASE64("fo")= "Zm8="</li> <li>BASE64("foo")= "Zm9v"</li> <li>BASE64("foob")= "Zm9vYg=="</li> <li>BASE64("fooba")= "Zm9vYmE="</li> <li>BASE64("foobar")= "Zm9vYmFy"</li> </ul>* @see <a href="http://tools.ietf.org/html/rfc4648">http://tools.ietf.org/html/rfc4648</a>*/@Test public void testRfc4648Section10EncodeDecode(){testEncodeDecode("");testEncodeDecode("f");testEncodeDecode("fo");testEncodeDecode("foo");testEncodeDecode("foob");testEncodeDecode("fooba");testEncodeDecode("foobar");}
@Test public void testSingletons(){assertEquals("AA==",new String(Base64.encodeBase64(new byte[]{(byte)0})));assertEquals("AQ==",new String(Base64.encodeBase64(new byte[]{(byte)1})));assertEquals("Ag==",new String(Base64.encodeBase64(new byte[]{(byte)2})));assertEquals("Aw==",new String(Base64.encodeBase64(new byte[]{(byte)3})));assertEquals("BA==",new String(Base64.encodeBase64(new byte[]{(byte)4})));assertEquals("BQ==",new String(Base64.encodeBase64(new byte[]{(byte)5})));assertEquals("Bg==",new String(Base64.encodeBase64(new byte[]{(byte)6})));assertEquals("Bw==",new String(Base64.encodeBase64(new byte[]{(byte)7})));assertEquals("CA==",new String(Base64.encodeBase64(new byte[]{(byte)8})));assertEquals("CQ==",new String(Base64.encodeBase64(new byte[]{(byte)9})));assertEquals("Cg==",new String(Base64.encodeBase64(new byte[]{(byte)10})));assertEquals("Cw==",new String(Base64.encodeBase64(new byte[]{(byte)11})));assertEquals("DA==",new String(Base64.encodeBase64(new byte[]{(byte)12})));assertEquals("DQ==",new String(Base64.encodeBase64(new byte[]{(byte)13})));assertEquals("Dg==",new String(Base64.encodeBase64(new byte[]{(byte)14})));assertEquals("Dw==",new String(Base64.encodeBase64(new byte[]{(byte)15})));assertEquals("EA==",new String(Base64.encodeBase64(new byte[]{(byte)16})));assertEquals("EQ==",new String(Base64.encodeBase64(new byte[]{(byte)17})));assertEquals("Eg==",new String(Base64.encodeBase64(new byte[]{(byte)18})));assertEquals("Ew==",new String(Base64.encodeBase64(new byte[]{(byte)19})));assertEquals("FA==",new String(Base64.encodeBase64(new byte[]{(byte)20})));assertEquals("FQ==",new String(Base64.encodeBase64(new byte[]{(byte)21})));assertEquals("Fg==",new String(Base64.encodeBase64(new byte[]{(byte)22})));assertEquals("Fw==",new String(Base64.encodeBase64(new byte[]{(byte)23})));assertEquals("GA==",new String(Base64.encodeBase64(new byte[]{(byte)24})));assertEquals("GQ==",new String(Base64.encodeBase64(new byte[]{(byte)25})));assertEquals("Gg==",new String(Base64.encodeBase64(new byte[]{(byte)26})));assertEquals("Gw==",new String(Base64.encodeBase64(new byte[]{(byte)27})));assertEquals("HA==",new String(Base64.encodeBase64(new byte[]{(byte)28})));assertEquals("HQ==",new String(Base64.encodeBase64(new byte[]{(byte)29})));assertEquals("Hg==",new String(Base64.encodeBase64(new byte[]{(byte)30})));assertEquals("Hw==",new String(Base64.encodeBase64(new byte[]{(byte)31})));assertEquals("IA==",new String(Base64.encodeBase64(new byte[]{(byte)32})));assertEquals("IQ==",new String(Base64.encodeBase64(new byte[]{(byte)33})));assertEquals("Ig==",new String(Base64.encodeBase64(new byte[]{(byte)34})));assertEquals("Iw==",new String(Base64.encodeBase64(new byte[]{(byte)35})));assertEquals("JA==",new String(Base64.encodeBase64(new byte[]{(byte)36})));assertEquals("JQ==",new String(Base64.encodeBase64(new byte[]{(byte)37})));assertEquals("Jg==",new String(Base64.encodeBase64(new byte[]{(byte)38})));assertEquals("Jw==",new String(Base64.encodeBase64(new byte[]{(byte)39})));assertEquals("KA==",new String(Base64.encodeBase64(new byte[]{(byte)40})));assertEquals("KQ==",new String(Base64.encodeBase64(new byte[]{(byte)41})));assertEquals("Kg==",new String(Base64.encodeBase64(new byte[]{(byte)42})));assertEquals("Kw==",new String(Base64.encodeBase64(new byte[]{(byte)43})));assertEquals("LA==",new String(Base64.encodeBase64(new byte[]{(byte)44})));assertEquals("LQ==",new String(Base64.encodeBase64(new byte[]{(byte)45})));assertEquals("Lg==",new String(Base64.encodeBase64(new byte[]{(byte)46})));assertEquals("Lw==",new String(Base64.encodeBase64(new byte[]{(byte)47})));assertEquals("MA==",new String(Base64.encodeBase64(new byte[]{(byte)48})));assertEquals("MQ==",new String(Base64.encodeBase64(new byte[]{(byte)49})));assertEquals("Mg==",new String(Base64.encodeBase64(new byte[]{(byte)50})));assertEquals("Mw==",new String(Base64.encodeBase64(new byte[]{(byte)51})));assertEquals("NA==",new String(Base64.encodeBase64(new byte[]{(byte)52})));assertEquals("NQ==",new String(Base64.encodeBase64(new byte[]{(byte)53})));assertEquals("Ng==",new String(Base64.encodeBase64(new byte[]{(byte)54})));assertEquals("Nw==",new String(Base64.encodeBase64(new byte[]{(byte)55})));assertEquals("OA==",new String(Base64.encodeBase64(new byte[]{(byte)56})));assertEquals("OQ==",new String(Base64.encodeBase64(new byte[]{(byte)57})));assertEquals("Og==",new String(Base64.encodeBase64(new byte[]{(byte)58})));assertEquals("Ow==",new String(Base64.encodeBase64(new byte[]{(byte)59})));assertEquals("PA==",new String(Base64.encodeBase64(new byte[]{(byte)60})));assertEquals("PQ==",new String(Base64.encodeBase64(new byte[]{(byte)61})));assertEquals("Pg==",new String(Base64.encodeBase64(new byte[]{(byte)62})));assertEquals("Pw==",new String(Base64.encodeBase64(new byte[]{(byte)63})));assertEquals("QA==",new String(Base64.encodeBase64(new byte[]{(byte)64})));assertEquals("QQ==",new String(Base64.encodeBase64(new byte[]{(byte)65})));assertEquals("Qg==",new String(Base64.encodeBase64(new byte[]{(byte)66})));assertEquals("Qw==",new String(Base64.encodeBase64(new byte[]{(byte)67})));assertEquals("RA==",new String(Base64.encodeBase64(new byte[]{(byte)68})));assertEquals("RQ==",new String(Base64.encodeBase64(new byte[]{(byte)69})));assertEquals("Rg==",new String(Base64.encodeBase64(new byte[]{(byte)70})));assertEquals("Rw==",new String(Base64.encodeBase64(new byte[]{(byte)71})));assertEquals("SA==",new String(Base64.encodeBase64(new byte[]{(byte)72})));assertEquals("SQ==",new String(Base64.encodeBase64(new byte[]{(byte)73})));assertEquals("Sg==",new String(Base64.encodeBase64(new byte[]{(byte)74})));assertEquals("Sw==",new String(Base64.encodeBase64(new byte[]{(byte)75})));assertEquals("TA==",new String(Base64.encodeBase64(new byte[]{(byte)76})));assertEquals("TQ==",new String(Base64.encodeBase64(new byte[]{(byte)77})));assertEquals("Tg==",new String(Base64.encodeBase64(new byte[]{(byte)78})));assertEquals("Tw==",new String(Base64.encodeBase64(new byte[]{(byte)79})));assertEquals("UA==",new String(Base64.encodeBase64(new byte[]{(byte)80})));assertEquals("UQ==",new String(Base64.encodeBase64(new byte[]{(byte)81})));assertEquals("Ug==",new String(Base64.encodeBase64(new byte[]{(byte)82})));assertEquals("Uw==",new String(Base64.encodeBase64(new byte[]{(byte)83})));assertEquals("VA==",new String(Base64.encodeBase64(new byte[]{(byte)84})));assertEquals("VQ==",new String(Base64.encodeBase64(new byte[]{(byte)85})));assertEquals("Vg==",new String(Base64.encodeBase64(new byte[]{(byte)86})));assertEquals("Vw==",new String(Base64.encodeBase64(new byte[]{(byte)87})));assertEquals("WA==",new String(Base64.encodeBase64(new byte[]{(byte)88})));assertEquals("WQ==",new String(Base64.encodeBase64(new byte[]{(byte)89})));assertEquals("Wg==",new String(Base64.encodeBase64(new byte[]{(byte)90})));assertEquals("Ww==",new String(Base64.encodeBase64(new byte[]{(byte)91})));assertEquals("XA==",new String(Base64.encodeBase64(new byte[]{(byte)92})));assertEquals("XQ==",new String(Base64.encodeBase64(new byte[]{(byte)93})));assertEquals("Xg==",new String(Base64.encodeBase64(new byte[]{(byte)94})));assertEquals("Xw==",new String(Base64.encodeBase64(new byte[]{(byte)95})));assertEquals("YA==",new String(Base64.encodeBase64(new byte[]{(byte)96})));assertEquals("YQ==",new String(Base64.encodeBase64(new byte[]{(byte)97})));assertEquals("Yg==",new String(Base64.encodeBase64(new byte[]{(byte)98})));assertEquals("Yw==",new String(Base64.encodeBase64(new byte[]{(byte)99})));assertEquals("ZA==",new String(Base64.encodeBase64(new byte[]{(byte)100})));assertEquals("ZQ==",new String(Base64.encodeBase64(new byte[]{(byte)101})));assertEquals("Zg==",new String(Base64.encodeBase64(new byte[]{(byte)102})));assertEquals("Zw==",new String(Base64.encodeBase64(new byte[]{(byte)103})));assertEquals("aA==",new String(Base64.encodeBase64(new byte[]{(byte)104})));for (int i=-128;i <= 127;i++){final byte test[]={(byte)i};assertTrue(Arrays.equals(test,Base64.decodeBase64(Base64.encodeBase64(test))));}}
@Test public void testSingletonsChunked(){assertEquals("AA==\r\n",new String(Base64.encodeBase64Chunked(new byte[]{(byte)0})));assertEquals("AQ==\r\n",new String(Base64.encodeBase64Chunked(new byte[]{(byte)1})));assertEquals("Ag==\r\n",new String(Base64.encodeBase64Chunked(new byte[]{(byte)2})));assertEquals("Aw==\r\n",new String(Base64.encodeBase64Chunked(new byte[]{(byte)3})));assertEquals("BA==\r\n",new String(Base64.encodeBase64Chunked(new byte[]{(byte)4})));assertEquals("BQ==\r\n",new String(Base64.encodeBase64Chunked(new byte[]{(byte)5})));assertEquals("Bg==\r\n",new String(Base64.encodeBase64Chunked(new byte[]{(byte)6})));assertEquals("Bw==\r\n",new String(Base64.encodeBase64Chunked(new byte[]{(byte)7})));assertEquals("CA==\r\n",new String(Base64.encodeBase64Chunked(new byte[]{(byte)8})));assertEquals("CQ==\r\n",new String(Base64.encodeBase64Chunked(new byte[]{(byte)9})));assertEquals("Cg==\r\n",new String(Base64.encodeBase64Chunked(new byte[]{(byte)10})));assertEquals("Cw==\r\n",new String(Base64.encodeBase64Chunked(new byte[]{(byte)11})));assertEquals("DA==\r\n",new String(Base64.encodeBase64Chunked(new byte[]{(byte)12})));assertEquals("DQ==\r\n",new String(Base64.encodeBase64Chunked(new byte[]{(byte)13})));assertEquals("Dg==\r\n",new String(Base64.encodeBase64Chunked(new byte[]{(byte)14})));assertEquals("Dw==\r\n",new String(Base64.encodeBase64Chunked(new byte[]{(byte)15})));assertEquals("EA==\r\n",new String(Base64.encodeBase64Chunked(new byte[]{(byte)16})));assertEquals("EQ==\r\n",new String(Base64.encodeBase64Chunked(new byte[]{(byte)17})));assertEquals("Eg==\r\n",new String(Base64.encodeBase64Chunked(new byte[]{(byte)18})));assertEquals("Ew==\r\n",new String(Base64.encodeBase64Chunked(new byte[]{(byte)19})));assertEquals("FA==\r\n",new String(Base64.encodeBase64Chunked(new byte[]{(byte)20})));assertEquals("FQ==\r\n",new String(Base64.encodeBase64Chunked(new byte[]{(byte)21})));assertEquals("Fg==\r\n",new String(Base64.encodeBase64Chunked(new byte[]{(byte)22})));assertEquals("Fw==\r\n",new String(Base64.encodeBase64Chunked(new byte[]{(byte)23})));assertEquals("GA==\r\n",new String(Base64.encodeBase64Chunked(new byte[]{(byte)24})));assertEquals("GQ==\r\n",new String(Base64.encodeBase64Chunked(new byte[]{(byte)25})));assertEquals("Gg==\r\n",new String(Base64.encodeBase64Chunked(new byte[]{(byte)26})));assertEquals("Gw==\r\n",new String(Base64.encodeBase64Chunked(new byte[]{(byte)27})));assertEquals("HA==\r\n",new String(Base64.encodeBase64Chunked(new byte[]{(byte)28})));assertEquals("HQ==\r\n",new String(Base64.encodeBase64Chunked(new byte[]{(byte)29})));assertEquals("Hg==\r\n",new String(Base64.encodeBase64Chunked(new byte[]{(byte)30})));assertEquals("Hw==\r\n",new String(Base64.encodeBase64Chunked(new byte[]{(byte)31})));assertEquals("IA==\r\n",new String(Base64.encodeBase64Chunked(new byte[]{(byte)32})));assertEquals("IQ==\r\n",new String(Base64.encodeBase64Chunked(new byte[]{(byte)33})));assertEquals("Ig==\r\n",new String(Base64.encodeBase64Chunked(new byte[]{(byte)34})));assertEquals("Iw==\r\n",new String(Base64.encodeBase64Chunked(new byte[]{(byte)35})));assertEquals("JA==\r\n",new String(Base64.encodeBase64Chunked(new byte[]{(byte)36})));assertEquals("JQ==\r\n",new String(Base64.encodeBase64Chunked(new byte[]{(byte)37})));assertEquals("Jg==\r\n",new String(Base64.encodeBase64Chunked(new byte[]{(byte)38})));assertEquals("Jw==\r\n",new String(Base64.encodeBase64Chunked(new byte[]{(byte)39})));assertEquals("KA==\r\n",new String(Base64.encodeBase64Chunked(new byte[]{(byte)40})));assertEquals("KQ==\r\n",new String(Base64.encodeBase64Chunked(new byte[]{(byte)41})));assertEquals("Kg==\r\n",new String(Base64.encodeBase64Chunked(new byte[]{(byte)42})));assertEquals("Kw==\r\n",new String(Base64.encodeBase64Chunked(new byte[]{(byte)43})));assertEquals("LA==\r\n",new String(Base64.encodeBase64Chunked(new byte[]{(byte)44})));assertEquals("LQ==\r\n",new String(Base64.encodeBase64Chunked(new byte[]{(byte)45})));assertEquals("Lg==\r\n",new String(Base64.encodeBase64Chunked(new byte[]{(byte)46})));assertEquals("Lw==\r\n",new String(Base64.encodeBase64Chunked(new byte[]{(byte)47})));assertEquals("MA==\r\n",new String(Base64.encodeBase64Chunked(new byte[]{(byte)48})));assertEquals("MQ==\r\n",new String(Base64.encodeBase64Chunked(new byte[]{(byte)49})));assertEquals("Mg==\r\n",new String(Base64.encodeBase64Chunked(new byte[]{(byte)50})));assertEquals("Mw==\r\n",new String(Base64.encodeBase64Chunked(new byte[]{(byte)51})));assertEquals("NA==\r\n",new String(Base64.encodeBase64Chunked(new byte[]{(byte)52})));assertEquals("NQ==\r\n",new String(Base64.encodeBase64Chunked(new byte[]{(byte)53})));assertEquals("Ng==\r\n",new String(Base64.encodeBase64Chunked(new byte[]{(byte)54})));assertEquals("Nw==\r\n",new String(Base64.encodeBase64Chunked(new byte[]{(byte)55})));assertEquals("OA==\r\n",new String(Base64.encodeBase64Chunked(new byte[]{(byte)56})));assertEquals("OQ==\r\n",new String(Base64.encodeBase64Chunked(new byte[]{(byte)57})));assertEquals("Og==\r\n",new String(Base64.encodeBase64Chunked(new byte[]{(byte)58})));assertEquals("Ow==\r\n",new String(Base64.encodeBase64Chunked(new byte[]{(byte)59})));assertEquals("PA==\r\n",new String(Base64.encodeBase64Chunked(new byte[]{(byte)60})));assertEquals("PQ==\r\n",new String(Base64.encodeBase64Chunked(new byte[]{(byte)61})));assertEquals("Pg==\r\n",new String(Base64.encodeBase64Chunked(new byte[]{(byte)62})));assertEquals("Pw==\r\n",new String(Base64.encodeBase64Chunked(new byte[]{(byte)63})));assertEquals("QA==\r\n",new String(Base64.encodeBase64Chunked(new byte[]{(byte)64})));assertEquals("QQ==\r\n",new String(Base64.encodeBase64Chunked(new byte[]{(byte)65})));assertEquals("Qg==\r\n",new String(Base64.encodeBase64Chunked(new byte[]{(byte)66})));assertEquals("Qw==\r\n",new String(Base64.encodeBase64Chunked(new byte[]{(byte)67})));assertEquals("RA==\r\n",new String(Base64.encodeBase64Chunked(new byte[]{(byte)68})));assertEquals("RQ==\r\n",new String(Base64.encodeBase64Chunked(new byte[]{(byte)69})));assertEquals("Rg==\r\n",new String(Base64.encodeBase64Chunked(new byte[]{(byte)70})));assertEquals("Rw==\r\n",new String(Base64.encodeBase64Chunked(new byte[]{(byte)71})));assertEquals("SA==\r\n",new String(Base64.encodeBase64Chunked(new byte[]{(byte)72})));assertEquals("SQ==\r\n",new String(Base64.encodeBase64Chunked(new byte[]{(byte)73})));assertEquals("Sg==\r\n",new String(Base64.encodeBase64Chunked(new byte[]{(byte)74})));assertEquals("Sw==\r\n",new String(Base64.encodeBase64Chunked(new byte[]{(byte)75})));assertEquals("TA==\r\n",new String(Base64.encodeBase64Chunked(new byte[]{(byte)76})));assertEquals("TQ==\r\n",new String(Base64.encodeBase64Chunked(new byte[]{(byte)77})));assertEquals("Tg==\r\n",new String(Base64.encodeBase64Chunked(new byte[]{(byte)78})));assertEquals("Tw==\r\n",new String(Base64.encodeBase64Chunked(new byte[]{(byte)79})));assertEquals("UA==\r\n",new String(Base64.encodeBase64Chunked(new byte[]{(byte)80})));assertEquals("UQ==\r\n",new String(Base64.encodeBase64Chunked(new byte[]{(byte)81})));assertEquals("Ug==\r\n",new String(Base64.encodeBase64Chunked(new byte[]{(byte)82})));assertEquals("Uw==\r\n",new String(Base64.encodeBase64Chunked(new byte[]{(byte)83})));assertEquals("VA==\r\n",new String(Base64.encodeBase64Chunked(new byte[]{(byte)84})));assertEquals("VQ==\r\n",new String(Base64.encodeBase64Chunked(new byte[]{(byte)85})));assertEquals("Vg==\r\n",new String(Base64.encodeBase64Chunked(new byte[]{(byte)86})));assertEquals("Vw==\r\n",new String(Base64.encodeBase64Chunked(new byte[]{(byte)87})));assertEquals("WA==\r\n",new String(Base64.encodeBase64Chunked(new byte[]{(byte)88})));assertEquals("WQ==\r\n",new String(Base64.encodeBase64Chunked(new byte[]{(byte)89})));assertEquals("Wg==\r\n",new String(Base64.encodeBase64Chunked(new byte[]{(byte)90})));assertEquals("Ww==\r\n",new String(Base64.encodeBase64Chunked(new byte[]{(byte)91})));assertEquals("XA==\r\n",new String(Base64.encodeBase64Chunked(new byte[]{(byte)92})));assertEquals("XQ==\r\n",new String(Base64.encodeBase64Chunked(new byte[]{(byte)93})));assertEquals("Xg==\r\n",new String(Base64.encodeBase64Chunked(new byte[]{(byte)94})));assertEquals("Xw==\r\n",new String(Base64.encodeBase64Chunked(new byte[]{(byte)95})));assertEquals("YA==\r\n",new String(Base64.encodeBase64Chunked(new byte[]{(byte)96})));assertEquals("YQ==\r\n",new String(Base64.encodeBase64Chunked(new byte[]{(byte)97})));assertEquals("Yg==\r\n",new String(Base64.encodeBase64Chunked(new byte[]{(byte)98})));assertEquals("Yw==\r\n",new String(Base64.encodeBase64Chunked(new byte[]{(byte)99})));assertEquals("ZA==\r\n",new String(Base64.encodeBase64Chunked(new byte[]{(byte)100})));assertEquals("ZQ==\r\n",new String(Base64.encodeBase64Chunked(new byte[]{(byte)101})));assertEquals("Zg==\r\n",new String(Base64.encodeBase64Chunked(new byte[]{(byte)102})));assertEquals("Zw==\r\n",new String(Base64.encodeBase64Chunked(new byte[]{(byte)103})));assertEquals("aA==\r\n",new String(Base64.encodeBase64Chunked(new byte[]{(byte)104})));}
@Test public void testTriplets(){assertEquals("AAAA",new String(Base64.encodeBase64(new byte[]{(byte)0,(byte)0,(byte)0})));assertEquals("AAAB",new String(Base64.encodeBase64(new byte[]{(byte)0,(byte)0,(byte)1})));assertEquals("AAAC",new String(Base64.encodeBase64(new byte[]{(byte)0,(byte)0,(byte)2})));assertEquals("AAAD",new String(Base64.encodeBase64(new byte[]{(byte)0,(byte)0,(byte)3})));assertEquals("AAAE",new String(Base64.encodeBase64(new byte[]{(byte)0,(byte)0,(byte)4})));assertEquals("AAAF",new String(Base64.encodeBase64(new byte[]{(byte)0,(byte)0,(byte)5})));assertEquals("AAAG",new String(Base64.encodeBase64(new byte[]{(byte)0,(byte)0,(byte)6})));assertEquals("AAAH",new String(Base64.encodeBase64(new byte[]{(byte)0,(byte)0,(byte)7})));assertEquals("AAAI",new String(Base64.encodeBase64(new byte[]{(byte)0,(byte)0,(byte)8})));assertEquals("AAAJ",new String(Base64.encodeBase64(new byte[]{(byte)0,(byte)0,(byte)9})));assertEquals("AAAK",new String(Base64.encodeBase64(new byte[]{(byte)0,(byte)0,(byte)10})));assertEquals("AAAL",new String(Base64.encodeBase64(new byte[]{(byte)0,(byte)0,(byte)11})));assertEquals("AAAM",new String(Base64.encodeBase64(new byte[]{(byte)0,(byte)0,(byte)12})));assertEquals("AAAN",new String(Base64.encodeBase64(new byte[]{(byte)0,(byte)0,(byte)13})));assertEquals("AAAO",new String(Base64.encodeBase64(new byte[]{(byte)0,(byte)0,(byte)14})));assertEquals("AAAP",new String(Base64.encodeBase64(new byte[]{(byte)0,(byte)0,(byte)15})));assertEquals("AAAQ",new String(Base64.encodeBase64(new byte[]{(byte)0,(byte)0,(byte)16})));assertEquals("AAAR",new String(Base64.encodeBase64(new byte[]{(byte)0,(byte)0,(byte)17})));assertEquals("AAAS",new String(Base64.encodeBase64(new byte[]{(byte)0,(byte)0,(byte)18})));assertEquals("AAAT",new String(Base64.encodeBase64(new byte[]{(byte)0,(byte)0,(byte)19})));assertEquals("AAAU",new String(Base64.encodeBase64(new byte[]{(byte)0,(byte)0,(byte)20})));assertEquals("AAAV",new String(Base64.encodeBase64(new byte[]{(byte)0,(byte)0,(byte)21})));assertEquals("AAAW",new String(Base64.encodeBase64(new byte[]{(byte)0,(byte)0,(byte)22})));assertEquals("AAAX",new String(Base64.encodeBase64(new byte[]{(byte)0,(byte)0,(byte)23})));assertEquals("AAAY",new String(Base64.encodeBase64(new byte[]{(byte)0,(byte)0,(byte)24})));assertEquals("AAAZ",new String(Base64.encodeBase64(new byte[]{(byte)0,(byte)0,(byte)25})));assertEquals("AAAa",new String(Base64.encodeBase64(new byte[]{(byte)0,(byte)0,(byte)26})));assertEquals("AAAb",new String(Base64.encodeBase64(new byte[]{(byte)0,(byte)0,(byte)27})));assertEquals("AAAc",new String(Base64.encodeBase64(new byte[]{(byte)0,(byte)0,(byte)28})));assertEquals("AAAd",new String(Base64.encodeBase64(new byte[]{(byte)0,(byte)0,(byte)29})));assertEquals("AAAe",new String(Base64.encodeBase64(new byte[]{(byte)0,(byte)0,(byte)30})));assertEquals("AAAf",new String(Base64.encodeBase64(new byte[]{(byte)0,(byte)0,(byte)31})));assertEquals("AAAg",new String(Base64.encodeBase64(new byte[]{(byte)0,(byte)0,(byte)32})));assertEquals("AAAh",new String(Base64.encodeBase64(new byte[]{(byte)0,(byte)0,(byte)33})));assertEquals("AAAi",new String(Base64.encodeBase64(new byte[]{(byte)0,(byte)0,(byte)34})));assertEquals("AAAj",new String(Base64.encodeBase64(new byte[]{(byte)0,(byte)0,(byte)35})));assertEquals("AAAk",new String(Base64.encodeBase64(new byte[]{(byte)0,(byte)0,(byte)36})));assertEquals("AAAl",new String(Base64.encodeBase64(new byte[]{(byte)0,(byte)0,(byte)37})));assertEquals("AAAm",new String(Base64.encodeBase64(new byte[]{(byte)0,(byte)0,(byte)38})));assertEquals("AAAn",new String(Base64.encodeBase64(new byte[]{(byte)0,(byte)0,(byte)39})));assertEquals("AAAo",new String(Base64.encodeBase64(new byte[]{(byte)0,(byte)0,(byte)40})));assertEquals("AAAp",new String(Base64.encodeBase64(new byte[]{(byte)0,(byte)0,(byte)41})));assertEquals("AAAq",new String(Base64.encodeBase64(new byte[]{(byte)0,(byte)0,(byte)42})));assertEquals("AAAr",new String(Base64.encodeBase64(new byte[]{(byte)0,(byte)0,(byte)43})));assertEquals("AAAs",new String(Base64.encodeBase64(new byte[]{(byte)0,(byte)0,(byte)44})));assertEquals("AAAt",new String(Base64.encodeBase64(new byte[]{(byte)0,(byte)0,(byte)45})));assertEquals("AAAu",new String(Base64.encodeBase64(new byte[]{(byte)0,(byte)0,(byte)46})));assertEquals("AAAv",new String(Base64.encodeBase64(new byte[]{(byte)0,(byte)0,(byte)47})));assertEquals("AAAw",new String(Base64.encodeBase64(new byte[]{(byte)0,(byte)0,(byte)48})));assertEquals("AAAx",new String(Base64.encodeBase64(new byte[]{(byte)0,(byte)0,(byte)49})));assertEquals("AAAy",new String(Base64.encodeBase64(new byte[]{(byte)0,(byte)0,(byte)50})));assertEquals("AAAz",new String(Base64.encodeBase64(new byte[]{(byte)0,(byte)0,(byte)51})));assertEquals("AAA0",new String(Base64.encodeBase64(new byte[]{(byte)0,(byte)0,(byte)52})));assertEquals("AAA1",new String(Base64.encodeBase64(new byte[]{(byte)0,(byte)0,(byte)53})));assertEquals("AAA2",new String(Base64.encodeBase64(new byte[]{(byte)0,(byte)0,(byte)54})));assertEquals("AAA3",new String(Base64.encodeBase64(new byte[]{(byte)0,(byte)0,(byte)55})));assertEquals("AAA4",new String(Base64.encodeBase64(new byte[]{(byte)0,(byte)0,(byte)56})));assertEquals("AAA5",new String(Base64.encodeBase64(new byte[]{(byte)0,(byte)0,(byte)57})));assertEquals("AAA6",new String(Base64.encodeBase64(new byte[]{(byte)0,(byte)0,(byte)58})));assertEquals("AAA7",new String(Base64.encodeBase64(new byte[]{(byte)0,(byte)0,(byte)59})));assertEquals("AAA8",new String(Base64.encodeBase64(new byte[]{(byte)0,(byte)0,(byte)60})));assertEquals("AAA9",new String(Base64.encodeBase64(new byte[]{(byte)0,(byte)0,(byte)61})));assertEquals("AAA+",new String(Base64.encodeBase64(new byte[]{(byte)0,(byte)0,(byte)62})));assertEquals("AAA/",new String(Base64.encodeBase64(new byte[]{(byte)0,(byte)0,(byte)63})));}
@Test public void testTripletsChunked(){assertEquals("AAAA\r\n",new String(Base64.encodeBase64Chunked(new byte[]{(byte)0,(byte)0,(byte)0})));assertEquals("AAAB\r\n",new String(Base64.encodeBase64Chunked(new byte[]{(byte)0,(byte)0,(byte)1})));assertEquals("AAAC\r\n",new String(Base64.encodeBase64Chunked(new byte[]{(byte)0,(byte)0,(byte)2})));assertEquals("AAAD\r\n",new String(Base64.encodeBase64Chunked(new byte[]{(byte)0,(byte)0,(byte)3})));assertEquals("AAAE\r\n",new String(Base64.encodeBase64Chunked(new byte[]{(byte)0,(byte)0,(byte)4})));assertEquals("AAAF\r\n",new String(Base64.encodeBase64Chunked(new byte[]{(byte)0,(byte)0,(byte)5})));assertEquals("AAAG\r\n",new String(Base64.encodeBase64Chunked(new byte[]{(byte)0,(byte)0,(byte)6})));assertEquals("AAAH\r\n",new String(Base64.encodeBase64Chunked(new byte[]{(byte)0,(byte)0,(byte)7})));assertEquals("AAAI\r\n",new String(Base64.encodeBase64Chunked(new byte[]{(byte)0,(byte)0,(byte)8})));assertEquals("AAAJ\r\n",new String(Base64.encodeBase64Chunked(new byte[]{(byte)0,(byte)0,(byte)9})));assertEquals("AAAK\r\n",new String(Base64.encodeBase64Chunked(new byte[]{(byte)0,(byte)0,(byte)10})));assertEquals("AAAL\r\n",new String(Base64.encodeBase64Chunked(new byte[]{(byte)0,(byte)0,(byte)11})));assertEquals("AAAM\r\n",new String(Base64.encodeBase64Chunked(new byte[]{(byte)0,(byte)0,(byte)12})));assertEquals("AAAN\r\n",new String(Base64.encodeBase64Chunked(new byte[]{(byte)0,(byte)0,(byte)13})));assertEquals("AAAO\r\n",new String(Base64.encodeBase64Chunked(new byte[]{(byte)0,(byte)0,(byte)14})));assertEquals("AAAP\r\n",new String(Base64.encodeBase64Chunked(new byte[]{(byte)0,(byte)0,(byte)15})));assertEquals("AAAQ\r\n",new String(Base64.encodeBase64Chunked(new byte[]{(byte)0,(byte)0,(byte)16})));assertEquals("AAAR\r\n",new String(Base64.encodeBase64Chunked(new byte[]{(byte)0,(byte)0,(byte)17})));assertEquals("AAAS\r\n",new String(Base64.encodeBase64Chunked(new byte[]{(byte)0,(byte)0,(byte)18})));assertEquals("AAAT\r\n",new String(Base64.encodeBase64Chunked(new byte[]{(byte)0,(byte)0,(byte)19})));assertEquals("AAAU\r\n",new String(Base64.encodeBase64Chunked(new byte[]{(byte)0,(byte)0,(byte)20})));assertEquals("AAAV\r\n",new String(Base64.encodeBase64Chunked(new byte[]{(byte)0,(byte)0,(byte)21})));assertEquals("AAAW\r\n",new String(Base64.encodeBase64Chunked(new byte[]{(byte)0,(byte)0,(byte)22})));assertEquals("AAAX\r\n",new String(Base64.encodeBase64Chunked(new byte[]{(byte)0,(byte)0,(byte)23})));assertEquals("AAAY\r\n",new String(Base64.encodeBase64Chunked(new byte[]{(byte)0,(byte)0,(byte)24})));assertEquals("AAAZ\r\n",new String(Base64.encodeBase64Chunked(new byte[]{(byte)0,(byte)0,(byte)25})));assertEquals("AAAa\r\n",new String(Base64.encodeBase64Chunked(new byte[]{(byte)0,(byte)0,(byte)26})));assertEquals("AAAb\r\n",new String(Base64.encodeBase64Chunked(new byte[]{(byte)0,(byte)0,(byte)27})));assertEquals("AAAc\r\n",new String(Base64.encodeBase64Chunked(new byte[]{(byte)0,(byte)0,(byte)28})));assertEquals("AAAd\r\n",new String(Base64.encodeBase64Chunked(new byte[]{(byte)0,(byte)0,(byte)29})));assertEquals("AAAe\r\n",new String(Base64.encodeBase64Chunked(new byte[]{(byte)0,(byte)0,(byte)30})));assertEquals("AAAf\r\n",new String(Base64.encodeBase64Chunked(new byte[]{(byte)0,(byte)0,(byte)31})));assertEquals("AAAg\r\n",new String(Base64.encodeBase64Chunked(new byte[]{(byte)0,(byte)0,(byte)32})));assertEquals("AAAh\r\n",new String(Base64.encodeBase64Chunked(new byte[]{(byte)0,(byte)0,(byte)33})));assertEquals("AAAi\r\n",new String(Base64.encodeBase64Chunked(new byte[]{(byte)0,(byte)0,(byte)34})));assertEquals("AAAj\r\n",new String(Base64.encodeBase64Chunked(new byte[]{(byte)0,(byte)0,(byte)35})));assertEquals("AAAk\r\n",new String(Base64.encodeBase64Chunked(new byte[]{(byte)0,(byte)0,(byte)36})));assertEquals("AAAl\r\n",new String(Base64.encodeBase64Chunked(new byte[]{(byte)0,(byte)0,(byte)37})));assertEquals("AAAm\r\n",new String(Base64.encodeBase64Chunked(new byte[]{(byte)0,(byte)0,(byte)38})));assertEquals("AAAn\r\n",new String(Base64.encodeBase64Chunked(new byte[]{(byte)0,(byte)0,(byte)39})));assertEquals("AAAo\r\n",new String(Base64.encodeBase64Chunked(new byte[]{(byte)0,(byte)0,(byte)40})));assertEquals("AAAp\r\n",new String(Base64.encodeBase64Chunked(new byte[]{(byte)0,(byte)0,(byte)41})));assertEquals("AAAq\r\n",new String(Base64.encodeBase64Chunked(new byte[]{(byte)0,(byte)0,(byte)42})));assertEquals("AAAr\r\n",new String(Base64.encodeBase64Chunked(new byte[]{(byte)0,(byte)0,(byte)43})));assertEquals("AAAs\r\n",new String(Base64.encodeBase64Chunked(new byte[]{(byte)0,(byte)0,(byte)44})));assertEquals("AAAt\r\n",new String(Base64.encodeBase64Chunked(new byte[]{(byte)0,(byte)0,(byte)45})));assertEquals("AAAu\r\n",new String(Base64.encodeBase64Chunked(new byte[]{(byte)0,(byte)0,(byte)46})));assertEquals("AAAv\r\n",new String(Base64.encodeBase64Chunked(new byte[]{(byte)0,(byte)0,(byte)47})));assertEquals("AAAw\r\n",new String(Base64.encodeBase64Chunked(new byte[]{(byte)0,(byte)0,(byte)48})));assertEquals("AAAx\r\n",new String(Base64.encodeBase64Chunked(new byte[]{(byte)0,(byte)0,(byte)49})));assertEquals("AAAy\r\n",new String(Base64.encodeBase64Chunked(new byte[]{(byte)0,(byte)0,(byte)50})));assertEquals("AAAz\r\n",new String(Base64.encodeBase64Chunked(new byte[]{(byte)0,(byte)0,(byte)51})));assertEquals("AAA0\r\n",new String(Base64.encodeBase64Chunked(new byte[]{(byte)0,(byte)0,(byte)52})));assertEquals("AAA1\r\n",new String(Base64.encodeBase64Chunked(new byte[]{(byte)0,(byte)0,(byte)53})));assertEquals("AAA2\r\n",new String(Base64.encodeBase64Chunked(new byte[]{(byte)0,(byte)0,(byte)54})));assertEquals("AAA3\r\n",new String(Base64.encodeBase64Chunked(new byte[]{(byte)0,(byte)0,(byte)55})));assertEquals("AAA4\r\n",new String(Base64.encodeBase64Chunked(new byte[]{(byte)0,(byte)0,(byte)56})));assertEquals("AAA5\r\n",new String(Base64.encodeBase64Chunked(new byte[]{(byte)0,(byte)0,(byte)57})));assertEquals("AAA6\r\n",new String(Base64.encodeBase64Chunked(new byte[]{(byte)0,(byte)0,(byte)58})));assertEquals("AAA7\r\n",new String(Base64.encodeBase64Chunked(new byte[]{(byte)0,(byte)0,(byte)59})));assertEquals("AAA8\r\n",new String(Base64.encodeBase64Chunked(new byte[]{(byte)0,(byte)0,(byte)60})));assertEquals("AAA9\r\n",new String(Base64.encodeBase64Chunked(new byte[]{(byte)0,(byte)0,(byte)61})));assertEquals("AAA+\r\n",new String(Base64.encodeBase64Chunked(new byte[]{(byte)0,(byte)0,(byte)62})));assertEquals("AAA/\r\n",new String(Base64.encodeBase64Chunked(new byte[]{(byte)0,(byte)0,(byte)63})));}
/** * Tests url-safe Base64 against random data,sizes 0 to 150.*/@Test public void testUrlSafe(){for (int i=0;i <= 150;i++){final byte[][]randomData=Base64TestData.randomData(i,true);final byte[]encoded=randomData[1];final byte[]decoded=randomData[0];final byte[]result=Base64.decodeBase64(encoded);assertTrue("url-safe i=" + i,Arrays.equals(decoded,result));assertFalse("url-safe i=" + i + " no '='",Base64TestData.bytesContain(encoded,(byte)'='));assertFalse("url-safe i=" + i + " no '\\'",Base64TestData.bytesContain(encoded,(byte)'\\'));assertFalse("url-safe i=" + i + " no '+'",Base64TestData.bytesContain(encoded,(byte)'+'));}}
/** * Base64 encoding of UUID's is a common use-case,especially in URL-SAFE mode. This test case ends up being the "URL-SAFE" JUnit's.* @throws DecoderException if Hex.decode()fails - a serious problem since Hex comes from our own commons-codec!*/@Test public void testUUID()throws DecoderException {final byte[][]ids=new byte[4][];ids[0]=Hex.decodeHex("94ed8d0319e4493399560fb67404d370".toCharArray());ids[1]=Hex.decodeHex("2bf7cc2701fe4397b49ebeed5acc7090".toCharArray());ids[2]=Hex.decodeHex("64be154b6ffa40258d1a01288e7c31ca".toCharArray());ids[3]=Hex.decodeHex("ff7f8fc01cdb471a8c8b5a9306183fe8".toCharArray());final byte[][]standard=new byte[4][];standard[0]=StringUtils.getBytesUtf8("lO2NAxnkSTOZVg+2dATTcA==");standard[1]=StringUtils.getBytesUtf8("K/fMJwH+Q5e0nr7tWsxwkA==");standard[2]=StringUtils.getBytesUtf8("ZL4VS2/6QCWNGgEojnwxyg==");standard[3]=StringUtils.getBytesUtf8("/3+PwBzbRxqMi1qTBhg/6A==");final byte[][]urlSafe1=new byte[4][];urlSafe1[0]=StringUtils.getBytesUtf8("lO2NAxnkSTOZVg-2dATTcA==");urlSafe1[1]=StringUtils.getBytesUtf8("K_fMJwH-Q5e0nr7tWsxwkA==");urlSafe1[2]=StringUtils.getBytesUtf8("ZL4VS2_6QCWNGgEojnwxyg==");urlSafe1[3]=StringUtils.getBytesUtf8("_3-PwBzbRxqMi1qTBhg_6A==");final byte[][]urlSafe2=new byte[4][];urlSafe2[0]=StringUtils.getBytesUtf8("lO2NAxnkSTOZVg-2dATTcA=");urlSafe2[1]=StringUtils.getBytesUtf8("K_fMJwH-Q5e0nr7tWsxwkA=");urlSafe2[2]=StringUtils.getBytesUtf8("ZL4VS2_6QCWNGgEojnwxyg=");urlSafe2[3]=StringUtils.getBytesUtf8("_3-PwBzbRxqMi1qTBhg_6A=");final byte[][]urlSafe3=new byte[4][];urlSafe3[0]=StringUtils.getBytesUtf8("lO2NAxnkSTOZVg-2dATTcA");urlSafe3[1]=StringUtils.getBytesUtf8("K_fMJwH-Q5e0nr7tWsxwkA");urlSafe3[2]=StringUtils.getBytesUtf8("ZL4VS2_6QCWNGgEojnwxyg");urlSafe3[3]=StringUtils.getBytesUtf8("_3-PwBzbRxqMi1qTBhg_6A");for (int i=0;i < 4;i++){final byte[]encodedStandard=Base64.encodeBase64(ids[i]);final byte[]encodedUrlSafe=Base64.encodeBase64URLSafe(ids[i]);final byte[]decodedStandard=Base64.decodeBase64(standard[i]);final byte[]decodedUrlSafe1=Base64.decodeBase64(urlSafe1[i]);final byte[]decodedUrlSafe2=Base64.decodeBase64(urlSafe2[i]);final byte[]decodedUrlSafe3=Base64.decodeBase64(urlSafe3[i]);if (false){System.out.println("reference: [" + Hex.encodeHexString(ids[i])+ "]");System.out.println("standard:  [" + Hex.encodeHexString(decodedStandard)+ "]From: ["+ StringUtils.newStringUtf8(standard[i])+ "]");System.out.println("safe1:     [" + Hex.encodeHexString(decodedUrlSafe1)+ "]From: ["+ StringUtils.newStringUtf8(urlSafe1[i])+ "]");System.out.println("safe2:     [" + Hex.encodeHexString(decodedUrlSafe2)+ "]From: ["+ StringUtils.newStringUtf8(urlSafe2[i])+ "]");System.out.println("safe3:     [" + Hex.encodeHexString(decodedUrlSafe3)+ "]From: ["+ StringUtils.newStringUtf8(urlSafe3[i])+ "]");}assertTrue("standard encode uuid",Arrays.equals(encodedStandard,standard[i]));assertTrue("url-safe encode uuid",Arrays.equals(encodedUrlSafe,urlSafe3[i]));assertTrue("standard decode uuid",Arrays.equals(decodedStandard,ids[i]));assertTrue("url-safe1 decode uuid",Arrays.equals(decodedUrlSafe1,ids[i]));assertTrue("url-safe2 decode uuid",Arrays.equals(decodedUrlSafe2,ids[i]));assertTrue("url-safe3 decode uuid",Arrays.equals(decodedUrlSafe3,ids[i]));}}
@Test public void testByteToStringVariations()throws DecoderException {final Base64 base64=new Base64(0);final byte[]b1=StringUtils.getBytesUtf8("Hello World");final byte[]b2=new byte[0];final byte[]b3=null;final byte[]b4=Hex.decodeHex("2bf7cc2701fe4397b49ebeed5acc7090".toCharArray());assertEquals("byteToString Hello World","SGVsbG8gV29ybGQ=",base64.encodeToString(b1));assertEquals("byteToString static Hello World","SGVsbG8gV29ybGQ=",Base64.encodeBase64String(b1));assertEquals("byteToString \"\"","",base64.encodeToString(b2));assertEquals("byteToString static \"\"","",Base64.encodeBase64String(b2));assertEquals("byteToString null",null,base64.encodeToString(b3));assertEquals("byteToString static null",null,Base64.encodeBase64String(b3));assertEquals("byteToString UUID","K/fMJwH+Q5e0nr7tWsxwkA==",base64.encodeToString(b4));assertEquals("byteToString static UUID","K/fMJwH+Q5e0nr7tWsxwkA==",Base64.encodeBase64String(b4));assertEquals("byteToString static-url-safe UUID","K_fMJwH-Q5e0nr7tWsxwkA",Base64.encodeBase64URLSafeString(b4));}
@Test public void testStringToByteVariations()throws DecoderException {final Base64 base64=new Base64();final String s1="SGVsbG8gV29ybGQ=\r\n";final String s2="";final String s3=null;final String s4a="K/fMJwH+Q5e0nr7tWsxwkA==\r\n";final String s4b="K_fMJwH-Q5e0nr7tWsxwkA";final byte[]b4=Hex.decodeHex("2bf7cc2701fe4397b49ebeed5acc7090".toCharArray());assertEquals("StringToByte Hello World","Hello World",StringUtils.newStringUtf8(base64.decode(s1)));assertEquals("StringToByte Hello World","Hello World",StringUtils.newStringUtf8((byte[])base64.decode((Object)s1)));assertEquals("StringToByte static Hello World","Hello World",StringUtils.newStringUtf8(Base64.decodeBase64(s1)));assertEquals("StringToByte \"\"","",StringUtils.newStringUtf8(base64.decode(s2)));assertEquals("StringToByte static \"\"","",StringUtils.newStringUtf8(Base64.decodeBase64(s2)));assertEquals("StringToByte null",null,StringUtils.newStringUtf8(base64.decode(s3)));assertEquals("StringToByte static null",null,StringUtils.newStringUtf8(Base64.decodeBase64(s3)));assertTrue("StringToByte UUID",Arrays.equals(b4,base64.decode(s4b)));assertTrue("StringToByte static UUID",Arrays.equals(b4,Base64.decodeBase64(s4a)));assertTrue("StringToByte static-url-safe UUID",Arrays.equals(b4,Base64.decodeBase64(s4b)));}
/** * Tests a lineSeparator much bigger than DEFAULT_BUFFER_SIZE.* @see "<a href='http://mail-archives.apache.org/mod_mbox/commons-dev/201202.mbox/%3C4F3C85D7.5060706@snafu.de%3E'>dev@commons.apache.org</a>"*/@Test @Ignore public void testHugeLineSeparator(){final int BaseNCodec_DEFAULT_BUFFER_SIZE=8192;final int Base64_BYTES_PER_ENCODED_BLOCK=4;final byte[]baLineSeparator=new byte[BaseNCodec_DEFAULT_BUFFER_SIZE * 4 - 3];final Base64 b64=new Base64(Base64_BYTES_PER_ENCODED_BLOCK,baLineSeparator);final String strOriginal="Hello World";final String strDecoded=new String(b64.decode(b64.encode(StringUtils.getBytesUtf8(strOriginal))));assertEquals("testDEFAULT_BUFFER_SIZE",strOriginal,strDecoded);}
@Test public void testLanguageGuessing(){final Languages.LanguageSet guesses=this.lang.guessLanguages(this.name);assertTrue("language predicted for name '" + this.name + "' is wrong: "+ guesses+ " should contain '"+ this.language+ "'",guesses.contains(this.language));}
@Test public void testSha256CryptStrings(){assertEquals("$5$foo$Fq9CX624QIfnCAmlGiPKLlAasdacKCRxZztPoeo7o0B",Crypt.crypt("","$5$foo"));assertEquals("$5$45678$LulJuUIJIn.1uU.KPV9x92umMYFopzVDD.o2ZqA1i2/",Crypt.crypt("secret","$5$45678"));assertEquals("$5$45678$LulJuUIJIn.1uU.KPV9x92umMYFopzVDD.o2ZqA1i2/",Crypt.crypt("secret","$5$45678$012"));assertEquals("$5$45678$LulJuUIJIn.1uU.KPV9x92umMYFopzVDD.o2ZqA1i2/",Crypt.crypt("secret","$5$45678$012$456"));assertEquals("$5$1234567890123456$GUiFKBSTUAGvcK772ulTDPltkTOLtFvPOmp9o.9FNPB",Crypt.crypt("secret","$5$1234567890123456"));assertEquals("$5$1234567890123456$GUiFKBSTUAGvcK772ulTDPltkTOLtFvPOmp9o.9FNPB",Crypt.crypt("secret","$5$1234567890123456789"));}
@Test public void testSha256CryptBytes(){assertEquals("$5$foo$Fq9CX624QIfnCAmlGiPKLlAasdacKCRxZztPoeo7o0B",Crypt.crypt(new byte[0],"$5$foo"));assertEquals("$5$./$iH66LwY5sTDTdHeOxq5nvNDVAxuoCcyH/y6Ptte82P8",Crypt.crypt("t\u00e4st","$5$./$"));assertEquals("$5$./$qx5gFfCzjuWUOvsDDy.5Nor3UULPIqLVBZhgGNS0c14",Crypt.crypt("t\u00e4st".getBytes(Charsets.ISO_8859_1),"$5$./$"));}
@Test public void testSha2CryptRounds(){assertEquals("$5$rounds=1000$abcd$b8MCU4GEeZIekOy5ahQ8EWfT330hvYGVeDYkBxXBva.",Sha2Crypt.sha256Crypt("secret".getBytes(Charsets.UTF_8),"$5$rounds=50$abcd$"));assertEquals("$5$rounds=1001$abcd$SQsJZs7KXKdd2DtklI3TY3tkD7UYA99RD0FBLm4Sk48",Sha2Crypt.sha256Crypt("secret".getBytes(Charsets.UTF_8),"$5$rounds=1001$abcd$"));assertEquals("$5$rounds=9999$abcd$Rh/8ngVh9oyuS6lL3.fsq.9xbvXJsfyKWxSjO2mPIa7",Sha2Crypt.sha256Crypt("secret".getBytes(Charsets.UTF_8),"$5$rounds=9999$abcd"));}
@Test public void testSha256CryptExplicitCall(){assertTrue(Sha2Crypt.sha256Crypt("secret".getBytes()).matches("^\\$5\\$[a-zA-Z0-9./]{0,16}\\$.{1,}$"));assertTrue(Sha2Crypt.sha256Crypt("secret".getBytes(),null).matches("^\\$5\\$[a-zA-Z0-9./]{0,16}\\$.{1,}$"));}
@Test(expected=NullPointerException.class)public void testSha256CryptNullData(){Sha2Crypt.sha256Crypt((byte[])null);}
@Test(expected=IllegalArgumentException.class)public void testSha256CryptWithEmptySalt(){Sha2Crypt.sha256Crypt("secret".getBytes(),"");}
@Test public void testSha256LargetThanBlocksize(){final byte[]buffer=new byte[200];Arrays.fill(buffer,0,200,(byte)'A');assertEquals("$5$abc$HbF3RRc15OwNKB/RZZ5F.1I6zsLcKXHQoSdB9Owx/Q8",Sha2Crypt.sha256Crypt(buffer,"$5$abc"));}
@Test public void testBran(){encodeAll(new String[]{"Brian","Brown","Brun"},"BRAN");}
@Test public void testCap(){this.encodeAll(new String[]{"Capp","Cope","Copp","Kipp"},"CAP");}
@Test public void testDad(){this.encodeAll(new String[]{"Dent"},"DAD");}
@Test public void testDan(){this.encodeAll(new String[]{"Dane","Dean","Dionne"},"DAN");}
/** * Tests data gathered from around the internet.* @see <a href="http://www.dropby.com/NYSIISTextStrings.html">http://www.dropby.com/NYSIISTextStrings.html</a>* @throws EncoderException*/@Test public void testDropBy()throws EncoderException {this.assertEncodings(new String[]{"MACINTOSH","MCANT"},new String[]{"KNUTH","NAT"},new String[]{"KOEHN","CAN"},new String[]{"PHILLIPSON","FALAPSAN"},new String[]{"PFEISTER","FASTAR"},new String[]{"SCHOENHOEFT","SANAFT"},new String[]{"MCKEE","MCY"},new String[]{"MACKIE","MCY"},new String[]{"HEITSCHMIDT","HATSNAD"},new String[]{"BART","BAD"},new String[]{"HURD","HAD"},new String[]{"HUNT","HAD"},new String[]{"WESTERLUND","WASTARLAD"},new String[]{"CASSTEVENS","CASTAFAN"},new String[]{"VASQUEZ","VASG"},new String[]{"FRAZIER","FRASAR"},new String[]{"BOWMAN","BANAN"},new String[]{"MCKNIGHT","MCNAGT"},new String[]{"RICKERT","RACAD"},new String[]{"DEUTSCH","DAT"},new String[]{"WESTPHAL","WASTFAL"},new String[]{"SHRIVER","SRAVAR"},new String[]{"KUHL","CAL"},new String[]{"RAWSON","RASAN"},new String[]{"JILES","JAL"},new String[]{"CARRAWAY","CARY"},new String[]{"YAMADA","YANAD"});}
@Test public void testFal(){this.encodeAll(new String[]{"Phil"},"FAL");}
/** * Tests data gathered from around the internets.* @throws EncoderException*/@Test public void testOthers()throws EncoderException {this.assertEncodings(new String[]{"O'Daniel","ODANAL"},new String[]{"O'Donnel","ODANAL"},new String[]{"Cory","CARY"},new String[]{"Corey","CARY"},new String[]{"Kory","CARY"},new String[]{"FUZZY","FASY"});}
/** * Tests rule 1: Translate first characters of name: MAC → MCC,KN → N,K → C,PH,PF → FF,SCH → SSS* @throws EncoderException*/@Test public void testRule1()throws EncoderException {this.assertEncodings(new String[]{"MACX","MCX"},new String[]{"KNX","NX"},new String[]{"KX","CX"},new String[]{"PHX","FX"},new String[]{"PFX","FX"},new String[]{"SCHX","SX"});}
/** * Tests rule 2: Translate last characters of name: EE → Y,IE → Y,DT,RT,RD,NT,ND → D* @throws EncoderException*/@Test public void testRule2()throws EncoderException {this.assertEncodings(new String[]{"XEE","XY"},new String[]{"XIE","XY"},new String[]{"XDT","XD"},new String[]{"XRT","XD"},new String[]{"XRD","XD"},new String[]{"XNT","XD"},new String[]{"XND","XD"});}
/** * Tests rule 4.1: EV → AF else A,E,I,O,U → A* @throws EncoderException*/@Test public void testRule4Dot1()throws EncoderException {this.assertEncodings(new String[]{"XEV","XAF"},new String[]{"XAX","XAX"},new String[]{"XEX","XAX"},new String[]{"XIX","XAX"},new String[]{"XOX","XAX"},new String[]{"XUX","XAX"});}
/** * Tests rule 4.2: Q → G,Z → S,M → N* @throws EncoderException*/@Test public void testRule4Dot2()throws EncoderException {this.assertEncodings(new String[]{"XQ","XG"},new String[]{"XZ","X"},new String[]{"XM","XN"});}
/** * Tests rule 5: If last character is S,remove it.* @throws EncoderException*/@Test public void testRule5()throws EncoderException {this.assertEncodings(new String[]{"XS","X"},new String[]{"XSS","X"});}
/** * Tests rule 6: If last characters are AY,replace with Y.* @throws EncoderException*/@Test public void testRule6()throws EncoderException {this.assertEncodings(new String[]{"XAY","XY"},new String[]{"XAYS","XY"});}
/** * Tests rule 7: If last character is A,remove it.* @throws EncoderException*/@Test public void testRule7()throws EncoderException {this.assertEncodings(new String[]{"XA","X"},new String[]{"XAS","X"});}
@Test public void testSnad(){this.encodeAll(new String[]{"Schmidt"},"SNAD");}
@Test public void testSnat(){this.encodeAll(new String[]{"Smith","Schmit"},"SNAT");}
@Test public void testSpecialBranches(){this.encodeAll(new String[]{"Kobwick"},"CABWAC");this.encodeAll(new String[]{"Kocher"},"CACAR");this.encodeAll(new String[]{"Fesca"},"FASC");this.encodeAll(new String[]{"Shom"},"SAN");this.encodeAll(new String[]{"Ohlo"},"OL");this.encodeAll(new String[]{"Uhu"},"UH");this.encodeAll(new String[]{"Um"},"UN");}
@Test public void testTranan(){this.encodeAll(new String[]{"Trueman","Truman"},"TRANAN");}
@Test public void testTrueVariant(){final Nysiis encoder=new Nysiis(true);final String encoded=encoder.encode("WESTERLUND");Assert.assertTrue(encoded.length()<= 6);Assert.assertEquals("WASTAR",encoded);}
@Test public void testB64T(){assertNotNull(new B64());assertEquals(64,B64.B64T.length());}
@Test public void testB64from24bit(){final StringBuilder buffer=new StringBuilder("");B64.b64from24bit((byte)8,(byte)16,(byte)64,2,buffer);B64.b64from24bit((byte)7,(byte)77,(byte)120,4,buffer);assertEquals("./spo/",buffer.toString());}
@Test public void testAabjoe()throws EncoderException {this.checkEncoding("01","Aabjoe");}
@Test public void testAaclan()throws EncoderException {this.checkEncoding("0856","Aaclan");}
/** * Tests [CODEC-122]* @throws EncoderException*/@Test public void testAychlmajrForCodec122()throws EncoderException {this.checkEncoding("04567","Aychlmajr");}
@Test public void testEdgeCases()throws EncoderException {final String[][]data={{"a","0"},{"e","0"},{"i","0"},{"o","0"},{"u","0"},{"\u00E4","0"},{"\u00F6","0"},{"\u00FC","0"},{"aa","0"},{"ha","0"},{"h",""},{"aha","0"},{"b","1"},{"p","1"},{"ph","3"},{"f","3"},{"v","3"},{"w","3"},{"g","4"},{"k","4"},{"q","4"},{"x","48"},{"ax","048"},{"cx","48"},{"l","5"},{"cl","45"},{"acl","085"},{"mn","6"},{"r","7"}};this.checkEncodings(data);}
@Test public void testExamples()throws EncoderException {final String[][]data={{"m\u00DCller","657"},{"schmidt","862"},{"schneider","8627"},{"fischer","387"},{"weber","317"},{"wagner","3467"},{"becker","147"},{"hoffmann","0366"},{"sch\u00C4fer","837"},{"Breschnew","17863"},{"Wikipedia","3412"},{"peter","127"},{"pharma","376"},{"m\u00f6nchengladbach","664645214"},{"deutsch","28"},{"deutz","28"},{"hamburg","06174"},{"hannover","0637"},{"christstollen","478256"},{"Xanthippe","48621"},{"Zacharias","8478"},{"Holzbau","0581"},{"matsch","68"},{"matz","68"},{"Arbeitsamt","071862"},{"Eberhard","01772"},{"Eberhardt","01772"},{"heithabu","021"}};this.checkEncodings(data);}
@Test public void testHyphen()throws EncoderException {final String[][]data={{"bergisch-gladbach","174845214"},{"M\u00fcller-L\u00fcdenscheidt","65752682"}};this.checkEncodings(data);}
@Test public void testIsEncodeEquals(){final String[][]data={{"Meyer","M\u00fcller"},{"Meyer","Mayr"},{"house","house"},{"House","house"},{"Haus","house"},{"ganz","Gans"},{"ganz","G\u00e4nse"},{"Miyagi","Miyako"}};for(final String[]element : data){this.getStringEncoder().isEncodeEqual(element[1],element[0]);}}
@Test public void testVariationsMella()throws EncoderException {final String data[]={"mella","milah","moulla","mellah","muehle","mule"};this.checkEncodingVariations("65",data);}
@Test public void testVariationsMeyer()throws EncoderException {final String data[]={"Meier","Maier","Mair","Meyer","Meyr","Mejer","Major"};this.checkEncodingVariations("67",data);}
@Test public void testDifference()throws EncoderException {assertEquals(0,this.getStringEncoder().difference(null,null));assertEquals(0,this.getStringEncoder().difference("",""));assertEquals(0,this.getStringEncoder().difference(" "," "));assertEquals(6,this.getStringEncoder().difference("Smith","Smythe"));assertEquals(3,this.getStringEncoder().difference("Ann","Andrew"));assertEquals(1,this.getStringEncoder().difference("Margaret","Andrew"));assertEquals(1,this.getStringEncoder().difference("Janet","Margaret"));assertEquals(5,this.getStringEncoder().difference("Green","Greene"));assertEquals(1,this.getStringEncoder().difference("Blotchet-Halls","Greene"));assertEquals(6,this.getStringEncoder().difference("Smith","Smythe"));assertEquals(8,this.getStringEncoder().difference("Smithers","Smythers"));assertEquals(5,this.getStringEncoder().difference("Anothers","Brothers"));}
@Test public void testEncode(){assertEquals("T6036084",this.getStringEncoder().encode("testing"));assertEquals("T6036084",this.getStringEncoder().encode("TESTING"));assertEquals("T60",this.getStringEncoder().encode("The"));assertEquals("Q503",this.getStringEncoder().encode("quick"));assertEquals("B1908",this.getStringEncoder().encode("brown"));assertEquals("F205",this.getStringEncoder().encode("fox"));assertEquals("J408106",this.getStringEncoder().encode("jumped"));assertEquals("O0209",this.getStringEncoder().encode("over"));assertEquals("T60",this.getStringEncoder().encode("the"));assertEquals("L7050",this.getStringEncoder().encode("lazy"));assertEquals("D6043",this.getStringEncoder().encode("dogs"));assertEquals("D6043",RefinedSoundex.US_ENGLISH.encode("dogs"));}
@Test public void testGetMappingCodeNonLetter(){final char code=this.getStringEncoder().getMappingCode('#');assertEquals("Code does not equals zero",0,code);}
@Test public void testNewInstance(){assertEquals("D6043",new RefinedSoundex().soundex("dogs"));}
@Test public void testNewInstance2(){assertEquals("D6043",new RefinedSoundex(RefinedSoundex.US_ENGLISH_MAPPING_STRING.toCharArray()).soundex("dogs"));}
@Test public void testNewInstance3(){assertEquals("D6043",new RefinedSoundex(RefinedSoundex.US_ENGLISH_MAPPING_STRING).soundex("dogs"));}
/** * Tests the problem reported in CODEC-130. Missing / wrong implementation of skip.*/@Test public void testCodec130()throws IOException {final ByteArrayOutputStream bos=new ByteArrayOutputStream();final Base32OutputStream base32os=new Base32OutputStream(bos);base32os.write(StringUtils.getBytesUtf8(STRING_FIXTURE));base32os.close();final ByteArrayInputStream bis=new ByteArrayInputStream(bos.toByteArray());final Base32InputStream ins=new Base32InputStream(bis);ins.skip(1);final byte[]decodedBytes=Base32TestData.streamToBytes(ins,new byte[64]);final String str=StringUtils.newStringUtf8(decodedBytes);assertEquals(STRING_FIXTURE.substring(1),str);}
/** * Tests the bug reported in CODEC-105. Bad interactions with InputStream when reading one byte at a time.*/@Test public void testCodec105()throws IOException {final Base32InputStream in=new Base32InputStream(new Codec105ErrorInputStream(),true,0,null);try {for (int i=0;i < 5;i++){in.read();}}finally {in.close();}}
/** * Tests skipping past the end of a stream.* @throws Throwable*/@Test public void testAvailable()throws Throwable {final InputStream ins=new ByteArrayInputStream(StringUtils.getBytesIso8859_1(ENCODED_FOO));final Base32InputStream b32stream=new Base32InputStream(ins);assertEquals(1,b32stream.available());assertEquals(3,b32stream.skip(10));assertEquals(0,b32stream.available());assertEquals(-1,b32stream.read());assertEquals(-1,b32stream.read());assertEquals(0,b32stream.available());b32stream.close();}
/** * Tests the Base32InputStream implementation against empty input.* @throws Exception for some failure scenarios.*/@Test public void testBase32EmptyInputStreamMimeChuckSize()throws Exception {testBase32EmptyInputStream(BaseNCodec.MIME_CHUNK_SIZE);}
/** * Tests the Base32InputStream implementation against empty input.* @throws Exception for some failure scenarios.*/@Test public void testBase32EmptyInputStreamPemChuckSize()throws Exception {testBase32EmptyInputStream(BaseNCodec.PEM_CHUNK_SIZE);}
/** * Tests the Base32InputStream implementation.* @throws Exception for some failure scenarios.*/@Test public void testBase32InputStreamByChunk()throws Exception {byte[]encoded=StringUtils.getBytesUtf8(Base32TestData.BASE32_FIXTURE);byte[]decoded=StringUtils.getBytesUtf8(Base32TestData.STRING_FIXTURE);testByChunk(encoded,decoded,BaseNCodec.MIME_CHUNK_SIZE,CRLF);encoded=StringUtils.getBytesUtf8("AA======\r\n");decoded=new byte[]{(byte)0};testByChunk(encoded,decoded,BaseNCodec.MIME_CHUNK_SIZE,CRLF);final BaseNCodec codec=new Base32();for (int i=0;i <= 150;i++){final byte[][]randomData=Base32TestData.randomData(codec,i);encoded=randomData[1];decoded=randomData[0];testByChunk(encoded,decoded,0,LF);}}
/** * Tests the Base32InputStream implementation.* @throws Exception for some failure scenarios.*/@Test public void testBase32InputStreamByteByByte()throws Exception {byte[]encoded=StringUtils.getBytesUtf8(Base32TestData.BASE32_FIXTURE);byte[]decoded=StringUtils.getBytesUtf8(Base32TestData.STRING_FIXTURE);testByteByByte(encoded,decoded,BaseNCodec.MIME_CHUNK_SIZE,CRLF);encoded=StringUtils.getBytesUtf8("AA======\r\n");decoded=new byte[]{(byte)0};testByteByByte(encoded,decoded,BaseNCodec.MIME_CHUNK_SIZE,CRLF);final BaseNCodec codec=new Base32();for (int i=0;i <= 150;i++){final byte[][]randomData=Base32TestData.randomData(codec,i);encoded=randomData[1];decoded=randomData[0];testByteByByte(encoded,decoded,0,LF);}}
/** * Tests markSupported.* @throws Exception*/@Test public void testMarkSupported()throws Exception {final byte[]decoded=StringUtils.getBytesUtf8(Base32TestData.STRING_FIXTURE);final ByteArrayInputStream bin=new ByteArrayInputStream(decoded);final Base32InputStream in=new Base32InputStream(bin,true,4,new byte[]{0,0,0});assertFalse("Base32InputStream.markSupported()is false",in.markSupported());in.close();}
/** * Tests read returning 0* @throws Exception*/@Test public void testRead0()throws Exception {final byte[]decoded=StringUtils.getBytesUtf8(Base32TestData.STRING_FIXTURE);final byte[]buf=new byte[1024];int bytesRead=0;final ByteArrayInputStream bin=new ByteArrayInputStream(decoded);final Base32InputStream in=new Base32InputStream(bin,true,4,new byte[]{0,0,0});bytesRead=in.read(buf,0,0);assertEquals("Base32InputStream.read(buf,0,0)returns 0",0,bytesRead);in.close();}
/** * Tests read with null.* @throws Exception for some failure scenarios.*/@Test public void testReadNull()throws Exception {final byte[]decoded=StringUtils.getBytesUtf8(Base32TestData.STRING_FIXTURE);final ByteArrayInputStream bin=new ByteArrayInputStream(decoded);final Base32InputStream in=new Base32InputStream(bin,true,4,new byte[]{0,0,0});try {in.read(null,0,0);fail("Base32InputStream.read(null,0,0)to throw a NullPointerException");}catch(final NullPointerException e){}in.close();}
/** * Tests read throwing IndexOutOfBoundsException* @throws Exception*/@Test public void testReadOutOfBounds()throws Exception {final byte[]decoded=StringUtils.getBytesUtf8(Base32TestData.STRING_FIXTURE);final byte[]buf=new byte[1024];final ByteArrayInputStream bin=new ByteArrayInputStream(decoded);final Base32InputStream in=new Base32InputStream(bin,true,4,new byte[]{0,0,0});try {in.read(buf,-1,0);fail("Expected Base32InputStream.read(buf,-1,0)to throw IndexOutOfBoundsException");}catch(final IndexOutOfBoundsException e){}try {in.read(buf,0,-1);fail("Expected Base32InputStream.read(buf,0,-1)to throw IndexOutOfBoundsException");}catch(final IndexOutOfBoundsException e){}try {in.read(buf,buf.length + 1,0);fail("Base32InputStream.read(buf,buf.length + 1,0)throws IndexOutOfBoundsException");}catch(final IndexOutOfBoundsException e){}try {in.read(buf,buf.length - 1,2);fail("Base32InputStream.read(buf,buf.length - 1,2)throws IndexOutOfBoundsException");}catch(final IndexOutOfBoundsException e){}in.close();}
/** * Tests skipping as a noop* @throws Throwable*/@Test public void testSkipNone()throws Throwable {final InputStream ins=new ByteArrayInputStream(StringUtils.getBytesIso8859_1(ENCODED_FOO));final Base32InputStream b32stream=new Base32InputStream(ins);final byte[]actualBytes=new byte[6];assertEquals(0,b32stream.skip(0));b32stream.read(actualBytes,0,actualBytes.length);assertArrayEquals(actualBytes,new byte[]{102,111,111,0,0,0});assertEquals(-1,b32stream.read());b32stream.close();}
/** * Tests skipping number of characters larger than the internal buffer.* @throws Throwable*/@Test public void testSkipBig()throws Throwable {final InputStream ins=new ByteArrayInputStream(StringUtils.getBytesIso8859_1(ENCODED_FOO));final Base32InputStream b32stream=new Base32InputStream(ins);assertEquals(3,b32stream.skip(1024));assertEquals(-1,b32stream.read());assertEquals(-1,b32stream.read());b32stream.close();}
/** * Tests skipping past the end of a stream.* @throws Throwable*/@Test public void testSkipPastEnd()throws Throwable {final InputStream ins=new ByteArrayInputStream(StringUtils.getBytesIso8859_1(ENCODED_FOO));final Base32InputStream b32stream=new Base32InputStream(ins);assertEquals(3,b32stream.skip(10));assertEquals(-1,b32stream.read());assertEquals(-1,b32stream.read());b32stream.close();}
/** * Tests skipping to the end of a stream.* @throws Throwable*/@Test public void testSkipToEnd()throws Throwable {final InputStream ins=new ByteArrayInputStream(StringUtils.getBytesIso8859_1(ENCODED_FOO));final Base32InputStream b32stream=new Base32InputStream(ins);assertEquals(3,b32stream.skip(3));assertEquals(-1,b32stream.read());assertEquals(-1,b32stream.read());b32stream.close();}
/** * Tests if negative arguments to skip are handled correctly.* @throws Throwable*/@Test(expected=IllegalArgumentException.class)public void testSkipWrongArgument()throws Throwable {final InputStream ins=new ByteArrayInputStream(StringUtils.getBytesIso8859_1(ENCODED_FOO));final Base32InputStream b32stream=new Base32InputStream(ins);b32stream.skip(-10);b32stream.close();}
/** * Tests for Object decode(Object)*/@Test public void testDecodeObjectException(){try {this.instance.decode(new Object());}catch(final DecoderException e){return;}fail("Expected DecoderException");}
/** * Tests for Object decode(Object)*/@Test public void testDecodeObject()throws Exception {byte[]bits;bits=new byte[1];assertDecodeObject(bits,"00000000");bits=new byte[1];bits[0]=BIT_0;assertDecodeObject(bits,"00000001");bits=new byte[1];bits[0]=BIT_0 | BIT_1;assertDecodeObject(bits,"00000011");bits=new byte[1];bits[0]=BIT_0 | BIT_1 | BIT_2;assertDecodeObject(bits,"00000111");bits=new byte[1];bits[0]=BIT_0 | BIT_1 | BIT_2| BIT_3;assertDecodeObject(bits,"00001111");bits=new byte[1];bits[0]=BIT_0 | BIT_1 | BIT_2| BIT_3| BIT_4;assertDecodeObject(bits,"00011111");bits=new byte[1];bits[0]=BIT_0 | BIT_1 | BIT_2| BIT_3| BIT_4| BIT_5;assertDecodeObject(bits,"00111111");bits=new byte[1];bits[0]=BIT_0 | BIT_1 | BIT_2| BIT_3| BIT_4| BIT_5| BIT_6;assertDecodeObject(bits,"01111111");bits=new byte[1];bits[0]=(byte)(BIT_0 | BIT_1 | BIT_2| BIT_3| BIT_4| BIT_5| BIT_6| BIT_7);assertDecodeObject(bits,"11111111");bits=new byte[2];bits[0]=(byte)(BIT_0 | BIT_1 | BIT_2| BIT_3| BIT_4| BIT_5| BIT_6| BIT_7);assertDecodeObject(bits,"0000000011111111");bits=new byte[2];bits[1]=BIT_0;bits[0]=(byte)(BIT_0 | BIT_1 | BIT_2| BIT_3| BIT_4| BIT_5| BIT_6| BIT_7);assertDecodeObject(bits,"0000000111111111");bits=new byte[2];bits[1]=BIT_0 | BIT_1;bits[0]=(byte)(BIT_0 | BIT_1 | BIT_2| BIT_3| BIT_4| BIT_5| BIT_6| BIT_7);assertDecodeObject(bits,"0000001111111111");bits=new byte[2];bits[1]=BIT_0 | BIT_1 | BIT_2;bits[0]=(byte)(BIT_0 | BIT_1 | BIT_2| BIT_3| BIT_4| BIT_5| BIT_6| BIT_7);assertDecodeObject(bits,"0000011111111111");bits=new byte[2];bits[1]=BIT_0 | BIT_1 | BIT_2| BIT_3;bits[0]=(byte)(BIT_0 | BIT_1 | BIT_2| BIT_3| BIT_4| BIT_5| BIT_6| BIT_7);assertDecodeObject(bits,"0000111111111111");bits=new byte[2];bits[1]=BIT_0 | BIT_1 | BIT_2| BIT_3| BIT_4;bits[0]=(byte)(BIT_0 | BIT_1 | BIT_2| BIT_3| BIT_4| BIT_5| BIT_6| BIT_7);assertDecodeObject(bits,"0001111111111111");bits=new byte[2];bits[1]=BIT_0 | BIT_1 | BIT_2| BIT_3| BIT_4| BIT_5;bits[0]=(byte)(BIT_0 | BIT_1 | BIT_2| BIT_3| BIT_4| BIT_5| BIT_6| BIT_7);assertDecodeObject(bits,"0011111111111111");bits=new byte[2];bits[1]=BIT_0 | BIT_1 | BIT_2| BIT_3| BIT_4| BIT_5| BIT_6;bits[0]=(byte)(BIT_0 | BIT_1 | BIT_2| BIT_3| BIT_4| BIT_5| BIT_6| BIT_7);assertDecodeObject(bits,"0111111111111111");bits=new byte[2];bits[1]=(byte)(BIT_0 | BIT_1 | BIT_2| BIT_3| BIT_4| BIT_5| BIT_6| BIT_7);bits[0]=(byte)(BIT_0 | BIT_1 | BIT_2| BIT_3| BIT_4| BIT_5| BIT_6| BIT_7);assertDecodeObject(bits,"1111111111111111");assertDecodeObject(new byte[0],null);}
@Test public void testDecodeByteArray(){byte[]bits=new byte[1];byte[]decoded=instance.decode("00000000".getBytes(Charsets.UTF_8));assertEquals(new String(bits),new String(decoded));bits=new byte[1];bits[0]=BIT_0;decoded=instance.decode("00000001".getBytes(Charsets.UTF_8));assertEquals(new String(bits),new String(decoded));bits=new byte[1];bits[0]=BIT_0 | BIT_1;decoded=instance.decode("00000011".getBytes(Charsets.UTF_8));assertEquals(new String(bits),new String(decoded));bits=new byte[1];bits[0]=BIT_0 | BIT_1 | BIT_2;decoded=instance.decode("00000111".getBytes(Charsets.UTF_8));assertEquals(new String(bits),new String(decoded));bits=new byte[1];bits[0]=BIT_0 | BIT_1 | BIT_2| BIT_3;decoded=instance.decode("00001111".getBytes(Charsets.UTF_8));assertEquals(new String(bits),new String(decoded));bits=new byte[1];bits[0]=BIT_0 | BIT_1 | BIT_2| BIT_3| BIT_4;decoded=instance.decode("00011111".getBytes(Charsets.UTF_8));assertEquals(new String(bits),new String(decoded));bits=new byte[1];bits[0]=BIT_0 | BIT_1 | BIT_2| BIT_3| BIT_4| BIT_5;decoded=instance.decode("00111111".getBytes(Charsets.UTF_8));assertEquals(new String(bits),new String(decoded));bits=new byte[1];bits[0]=BIT_0 | BIT_1 | BIT_2| BIT_3| BIT_4| BIT_5| BIT_6;decoded=instance.decode("01111111".getBytes(Charsets.UTF_8));assertEquals(new String(bits),new String(decoded));bits=new byte[1];bits[0]=(byte)(BIT_0 | BIT_1 | BIT_2| BIT_3| BIT_4| BIT_5| BIT_6| BIT_7);decoded=instance.decode("11111111".getBytes(Charsets.UTF_8));assertEquals(new String(bits),new String(decoded));bits=new byte[2];bits[0]=(byte)(BIT_0 | BIT_1 | BIT_2| BIT_3| BIT_4| BIT_5| BIT_6| BIT_7);decoded=instance.decode("0000000011111111".getBytes(Charsets.UTF_8));assertEquals(new String(bits),new String(decoded));bits=new byte[2];bits[1]=BIT_0;bits[0]=(byte)(BIT_0 | BIT_1 | BIT_2| BIT_3| BIT_4| BIT_5| BIT_6| BIT_7);decoded=instance.decode("0000000111111111".getBytes(Charsets.UTF_8));assertEquals(new String(bits),new String(decoded));bits=new byte[2];bits[1]=BIT_0 | BIT_1;bits[0]=(byte)(BIT_0 | BIT_1 | BIT_2| BIT_3| BIT_4| BIT_5| BIT_6| BIT_7);decoded=instance.decode("0000001111111111".getBytes(Charsets.UTF_8));assertEquals(new String(bits),new String(decoded));bits=new byte[2];bits[1]=BIT_0 | BIT_1 | BIT_2;bits[0]=(byte)(BIT_0 | BIT_1 | BIT_2| BIT_3| BIT_4| BIT_5| BIT_6| BIT_7);decoded=instance.decode("0000011111111111".getBytes(Charsets.UTF_8));assertEquals(new String(bits),new String(decoded));bits=new byte[2];bits[1]=BIT_0 | BIT_1 | BIT_2| BIT_3;bits[0]=(byte)(BIT_0 | BIT_1 | BIT_2| BIT_3| BIT_4| BIT_5| BIT_6| BIT_7);decoded=instance.decode("0000111111111111".getBytes(Charsets.UTF_8));assertEquals(new String(bits),new String(decoded));bits=new byte[2];bits[1]=BIT_0 | BIT_1 | BIT_2| BIT_3| BIT_4;bits[0]=(byte)(BIT_0 | BIT_1 | BIT_2| BIT_3| BIT_4| BIT_5| BIT_6| BIT_7);decoded=instance.decode("0001111111111111".getBytes(Charsets.UTF_8));assertEquals(new String(bits),new String(decoded));bits=new byte[2];bits[1]=BIT_0 | BIT_1 | BIT_2| BIT_3| BIT_4| BIT_5;bits[0]=(byte)(BIT_0 | BIT_1 | BIT_2| BIT_3| BIT_4| BIT_5| BIT_6| BIT_7);decoded=instance.decode("0011111111111111".getBytes(Charsets.UTF_8));assertEquals(new String(bits),new String(decoded));bits=new byte[2];bits[1]=BIT_0 | BIT_1 | BIT_2| BIT_3| BIT_4| BIT_5| BIT_6;bits[0]=(byte)(BIT_0 | BIT_1 | BIT_2| BIT_3| BIT_4| BIT_5| BIT_6| BIT_7);decoded=instance.decode("0111111111111111".getBytes(Charsets.UTF_8));assertEquals(new String(bits),new String(decoded));bits=new byte[2];bits[1]=(byte)(BIT_0 | BIT_1 | BIT_2| BIT_3| BIT_4| BIT_5| BIT_6| BIT_7);bits[0]=(byte)(BIT_0 | BIT_1 | BIT_2| BIT_3| BIT_4| BIT_5| BIT_6| BIT_7);decoded=instance.decode("1111111111111111".getBytes(Charsets.UTF_8));assertEquals(new String(bits),new String(decoded));}
@Test public void testToByteArrayFromString(){byte[]bits=new byte[1];byte[]decoded=instance.toByteArray("00000000");assertEquals(new String(bits),new String(decoded));bits=new byte[1];bits[0]=BIT_0;decoded=instance.toByteArray("00000001");assertEquals(new String(bits),new String(decoded));bits=new byte[1];bits[0]=BIT_0 | BIT_1;decoded=instance.toByteArray("00000011");assertEquals(new String(bits),new String(decoded));bits=new byte[1];bits[0]=BIT_0 | BIT_1 | BIT_2;decoded=instance.toByteArray("00000111");assertEquals(new String(bits),new String(decoded));bits=new byte[1];bits[0]=BIT_0 | BIT_1 | BIT_2| BIT_3;decoded=instance.toByteArray("00001111");assertEquals(new String(bits),new String(decoded));bits=new byte[1];bits[0]=BIT_0 | BIT_1 | BIT_2| BIT_3| BIT_4;decoded=instance.toByteArray("00011111");assertEquals(new String(bits),new String(decoded));bits=new byte[1];bits[0]=BIT_0 | BIT_1 | BIT_2| BIT_3| BIT_4| BIT_5;decoded=instance.toByteArray("00111111");assertEquals(new String(bits),new String(decoded));bits=new byte[1];bits[0]=BIT_0 | BIT_1 | BIT_2| BIT_3| BIT_4| BIT_5| BIT_6;decoded=instance.toByteArray("01111111");assertEquals(new String(bits),new String(decoded));bits=new byte[1];bits[0]=(byte)(BIT_0 | BIT_1 | BIT_2| BIT_3| BIT_4| BIT_5| BIT_6| BIT_7);decoded=instance.toByteArray("11111111");assertEquals(new String(bits),new String(decoded));bits=new byte[2];bits[0]=(byte)(BIT_0 | BIT_1 | BIT_2| BIT_3| BIT_4| BIT_5| BIT_6| BIT_7);decoded=instance.toByteArray("0000000011111111");assertEquals(new String(bits),new String(decoded));bits=new byte[2];bits[1]=BIT_0;bits[0]=(byte)(BIT_0 | BIT_1 | BIT_2| BIT_3| BIT_4| BIT_5| BIT_6| BIT_7);decoded=instance.toByteArray("0000000111111111");assertEquals(new String(bits),new String(decoded));bits=new byte[2];bits[1]=BIT_0 | BIT_1;bits[0]=(byte)(BIT_0 | BIT_1 | BIT_2| BIT_3| BIT_4| BIT_5| BIT_6| BIT_7);decoded=instance.toByteArray("0000001111111111");assertEquals(new String(bits),new String(decoded));bits=new byte[2];bits[1]=BIT_0 | BIT_1 | BIT_2;bits[0]=(byte)(BIT_0 | BIT_1 | BIT_2| BIT_3| BIT_4| BIT_5| BIT_6| BIT_7);decoded=instance.toByteArray("0000011111111111");assertEquals(new String(bits),new String(decoded));bits=new byte[2];bits[1]=BIT_0 | BIT_1 | BIT_2| BIT_3;bits[0]=(byte)(BIT_0 | BIT_1 | BIT_2| BIT_3| BIT_4| BIT_5| BIT_6| BIT_7);decoded=instance.toByteArray("0000111111111111");assertEquals(new String(bits),new String(decoded));bits=new byte[2];bits[1]=BIT_0 | BIT_1 | BIT_2| BIT_3| BIT_4;bits[0]=(byte)(BIT_0 | BIT_1 | BIT_2| BIT_3| BIT_4| BIT_5| BIT_6| BIT_7);decoded=instance.toByteArray("0001111111111111");assertEquals(new String(bits),new String(decoded));bits=new byte[2];bits[1]=BIT_0 | BIT_1 | BIT_2| BIT_3| BIT_4| BIT_5;bits[0]=(byte)(BIT_0 | BIT_1 | BIT_2| BIT_3| BIT_4| BIT_5| BIT_6| BIT_7);decoded=instance.toByteArray("0011111111111111");assertEquals(new String(bits),new String(decoded));bits=new byte[2];bits[1]=BIT_0 | BIT_1 | BIT_2| BIT_3| BIT_4| BIT_5| BIT_6;bits[0]=(byte)(BIT_0 | BIT_1 | BIT_2| BIT_3| BIT_4| BIT_5| BIT_6| BIT_7);decoded=instance.toByteArray("0111111111111111");assertEquals(new String(bits),new String(decoded));bits=new byte[2];bits[1]=(byte)(BIT_0 | BIT_1 | BIT_2| BIT_3| BIT_4| BIT_5| BIT_6| BIT_7);bits[0]=(byte)(BIT_0 | BIT_1 | BIT_2| BIT_3| BIT_4| BIT_5| BIT_6| BIT_7);decoded=instance.toByteArray("1111111111111111");assertEquals(new String(bits),new String(decoded));assertEquals(0,instance.toByteArray((String)null).length);}
@Test public void testFromAsciiCharArray(){assertEquals(0,BinaryCodec.fromAscii((char[])null).length);assertEquals(0,BinaryCodec.fromAscii(new char[0]).length);byte[]bits=new byte[1];byte[]decoded=BinaryCodec.fromAscii("00000000".toCharArray());assertEquals(new String(bits),new String(decoded));bits=new byte[1];bits[0]=BIT_0;decoded=BinaryCodec.fromAscii("00000001".toCharArray());assertEquals(new String(bits),new String(decoded));bits=new byte[1];bits[0]=BIT_0 | BIT_1;decoded=BinaryCodec.fromAscii("00000011".toCharArray());assertEquals(new String(bits),new String(decoded));bits=new byte[1];bits[0]=BIT_0 | BIT_1 | BIT_2;decoded=BinaryCodec.fromAscii("00000111".toCharArray());assertEquals(new String(bits),new String(decoded));bits=new byte[1];bits[0]=BIT_0 | BIT_1 | BIT_2| BIT_3;decoded=BinaryCodec.fromAscii("00001111".toCharArray());assertEquals(new String(bits),new String(decoded));bits=new byte[1];bits[0]=BIT_0 | BIT_1 | BIT_2| BIT_3| BIT_4;decoded=BinaryCodec.fromAscii("00011111".toCharArray());assertEquals(new String(bits),new String(decoded));bits=new byte[1];bits[0]=BIT_0 | BIT_1 | BIT_2| BIT_3| BIT_4| BIT_5;decoded=BinaryCodec.fromAscii("00111111".toCharArray());assertEquals(new String(bits),new String(decoded));bits=new byte[1];bits[0]=BIT_0 | BIT_1 | BIT_2| BIT_3| BIT_4| BIT_5| BIT_6;decoded=BinaryCodec.fromAscii("01111111".toCharArray());assertEquals(new String(bits),new String(decoded));bits=new byte[1];bits[0]=(byte)(BIT_0 | BIT_1 | BIT_2| BIT_3| BIT_4| BIT_5| BIT_6| BIT_7);decoded=BinaryCodec.fromAscii("11111111".toCharArray());assertEquals(new String(bits),new String(decoded));bits=new byte[2];bits[0]=(byte)(BIT_0 | BIT_1 | BIT_2| BIT_3| BIT_4| BIT_5| BIT_6| BIT_7);decoded=BinaryCodec.fromAscii("0000000011111111".toCharArray());assertEquals(new String(bits),new String(decoded));bits=new byte[2];bits[1]=BIT_0;bits[0]=(byte)(BIT_0 | BIT_1 | BIT_2| BIT_3| BIT_4| BIT_5| BIT_6| BIT_7);decoded=BinaryCodec.fromAscii("0000000111111111".toCharArray());assertEquals(new String(bits),new String(decoded));bits=new byte[2];bits[1]=BIT_0 | BIT_1;bits[0]=(byte)(BIT_0 | BIT_1 | BIT_2| BIT_3| BIT_4| BIT_5| BIT_6| BIT_7);decoded=BinaryCodec.fromAscii("0000001111111111".toCharArray());assertEquals(new String(bits),new String(decoded));bits=new byte[2];bits[1]=BIT_0 | BIT_1 | BIT_2;bits[0]=(byte)(BIT_0 | BIT_1 | BIT_2| BIT_3| BIT_4| BIT_5| BIT_6| BIT_7);decoded=BinaryCodec.fromAscii("0000011111111111".toCharArray());assertEquals(new String(bits),new String(decoded));bits=new byte[2];bits[1]=BIT_0 | BIT_1 | BIT_2| BIT_3;bits[0]=(byte)(BIT_0 | BIT_1 | BIT_2| BIT_3| BIT_4| BIT_5| BIT_6| BIT_7);decoded=BinaryCodec.fromAscii("0000111111111111".toCharArray());assertEquals(new String(bits),new String(decoded));bits=new byte[2];bits[1]=BIT_0 | BIT_1 | BIT_2| BIT_3| BIT_4;bits[0]=(byte)(BIT_0 | BIT_1 | BIT_2| BIT_3| BIT_4| BIT_5| BIT_6| BIT_7);decoded=BinaryCodec.fromAscii("0001111111111111".toCharArray());assertEquals(new String(bits),new String(decoded));bits=new byte[2];bits[1]=BIT_0 | BIT_1 | BIT_2| BIT_3| BIT_4| BIT_5;bits[0]=(byte)(BIT_0 | BIT_1 | BIT_2| BIT_3| BIT_4| BIT_5| BIT_6| BIT_7);decoded=BinaryCodec.fromAscii("0011111111111111".toCharArray());assertEquals(new String(bits),new String(decoded));bits=new byte[2];bits[1]=BIT_0 | BIT_1 | BIT_2| BIT_3| BIT_4| BIT_5| BIT_6;bits[0]=(byte)(BIT_0 | BIT_1 | BIT_2| BIT_3| BIT_4| BIT_5| BIT_6| BIT_7);decoded=BinaryCodec.fromAscii("0111111111111111".toCharArray());assertEquals(new String(bits),new String(decoded));bits=new byte[2];bits[1]=(byte)(BIT_0 | BIT_1 | BIT_2| BIT_3| BIT_4| BIT_5| BIT_6| BIT_7);bits[0]=(byte)(BIT_0 | BIT_1 | BIT_2| BIT_3| BIT_4| BIT_5| BIT_6| BIT_7);decoded=BinaryCodec.fromAscii("1111111111111111".toCharArray());assertEquals(new String(bits),new String(decoded));assertEquals(0,BinaryCodec.fromAscii((char[])null).length);}
@Test public void testFromAsciiByteArray(){assertEquals(0,BinaryCodec.fromAscii((byte[])null).length);assertEquals(0,BinaryCodec.fromAscii(new byte[0]).length);byte[]bits=new byte[1];byte[]decoded=BinaryCodec.fromAscii("00000000".getBytes(Charsets.UTF_8));assertEquals(new String(bits),new String(decoded));bits=new byte[1];bits[0]=BIT_0;decoded=BinaryCodec.fromAscii("00000001".getBytes(Charsets.UTF_8));assertEquals(new String(bits),new String(decoded));bits=new byte[1];bits[0]=BIT_0 | BIT_1;decoded=BinaryCodec.fromAscii("00000011".getBytes(Charsets.UTF_8));assertEquals(new String(bits),new String(decoded));bits=new byte[1];bits[0]=BIT_0 | BIT_1 | BIT_2;decoded=BinaryCodec.fromAscii("00000111".getBytes(Charsets.UTF_8));assertEquals(new String(bits),new String(decoded));bits=new byte[1];bits[0]=BIT_0 | BIT_1 | BIT_2| BIT_3;decoded=BinaryCodec.fromAscii("00001111".getBytes(Charsets.UTF_8));assertEquals(new String(bits),new String(decoded));bits=new byte[1];bits[0]=BIT_0 | BIT_1 | BIT_2| BIT_3| BIT_4;decoded=BinaryCodec.fromAscii("00011111".getBytes(Charsets.UTF_8));assertEquals(new String(bits),new String(decoded));bits=new byte[1];bits[0]=BIT_0 | BIT_1 | BIT_2| BIT_3| BIT_4| BIT_5;decoded=BinaryCodec.fromAscii("00111111".getBytes(Charsets.UTF_8));assertEquals(new String(bits),new String(decoded));bits=new byte[1];bits[0]=BIT_0 | BIT_1 | BIT_2| BIT_3| BIT_4| BIT_5| BIT_6;decoded=BinaryCodec.fromAscii("01111111".getBytes(Charsets.UTF_8));assertEquals(new String(bits),new String(decoded));bits=new byte[1];bits[0]=(byte)(BIT_0 | BIT_1 | BIT_2| BIT_3| BIT_4| BIT_5| BIT_6| BIT_7);decoded=BinaryCodec.fromAscii("11111111".getBytes(Charsets.UTF_8));assertEquals(new String(bits),new String(decoded));bits=new byte[2];bits[0]=(byte)(BIT_0 | BIT_1 | BIT_2| BIT_3| BIT_4| BIT_5| BIT_6| BIT_7);decoded=BinaryCodec.fromAscii("0000000011111111".getBytes(Charsets.UTF_8));assertEquals(new String(bits),new String(decoded));bits=new byte[2];bits[1]=BIT_0;bits[0]=(byte)(BIT_0 | BIT_1 | BIT_2| BIT_3| BIT_4| BIT_5| BIT_6| BIT_7);decoded=BinaryCodec.fromAscii("0000000111111111".getBytes(Charsets.UTF_8));assertEquals(new String(bits),new String(decoded));bits=new byte[2];bits[1]=BIT_0 | BIT_1;bits[0]=(byte)(BIT_0 | BIT_1 | BIT_2| BIT_3| BIT_4| BIT_5| BIT_6| BIT_7);decoded=BinaryCodec.fromAscii("0000001111111111".getBytes(Charsets.UTF_8));assertEquals(new String(bits),new String(decoded));bits=new byte[2];bits[1]=BIT_0 | BIT_1 | BIT_2;bits[0]=(byte)(BIT_0 | BIT_1 | BIT_2| BIT_3| BIT_4| BIT_5| BIT_6| BIT_7);decoded=BinaryCodec.fromAscii("0000011111111111".getBytes(Charsets.UTF_8));assertEquals(new String(bits),new String(decoded));bits=new byte[2];bits[1]=BIT_0 | BIT_1 | BIT_2| BIT_3;bits[0]=(byte)(BIT_0 | BIT_1 | BIT_2| BIT_3| BIT_4| BIT_5| BIT_6| BIT_7);decoded=BinaryCodec.fromAscii("0000111111111111".getBytes(Charsets.UTF_8));assertEquals(new String(bits),new String(decoded));bits=new byte[2];bits[1]=BIT_0 | BIT_1 | BIT_2| BIT_3| BIT_4;bits[0]=(byte)(BIT_0 | BIT_1 | BIT_2| BIT_3| BIT_4| BIT_5| BIT_6| BIT_7);decoded=BinaryCodec.fromAscii("0001111111111111".getBytes(Charsets.UTF_8));assertEquals(new String(bits),new String(decoded));bits=new byte[2];bits[1]=BIT_0 | BIT_1 | BIT_2| BIT_3| BIT_4| BIT_5;bits[0]=(byte)(BIT_0 | BIT_1 | BIT_2| BIT_3| BIT_4| BIT_5| BIT_6| BIT_7);decoded=BinaryCodec.fromAscii("0011111111111111".getBytes(Charsets.UTF_8));assertEquals(new String(bits),new String(decoded));bits=new byte[2];bits[1]=BIT_0 | BIT_1 | BIT_2| BIT_3| BIT_4| BIT_5| BIT_6;bits[0]=(byte)(BIT_0 | BIT_1 | BIT_2| BIT_3| BIT_4| BIT_5| BIT_6| BIT_7);decoded=BinaryCodec.fromAscii("0111111111111111".getBytes(Charsets.UTF_8));assertEquals(new String(bits),new String(decoded));bits=new byte[2];bits[1]=(byte)(BIT_0 | BIT_1 | BIT_2| BIT_3| BIT_4| BIT_5| BIT_6| BIT_7);bits[0]=(byte)(BIT_0 | BIT_1 | BIT_2| BIT_3| BIT_4| BIT_5| BIT_6| BIT_7);decoded=BinaryCodec.fromAscii("1111111111111111".getBytes(Charsets.UTF_8));assertEquals(new String(bits),new String(decoded));assertEquals(0,BinaryCodec.fromAscii((byte[])null).length);}
@Test public void testEncodeByteArray(){byte[]bits=new byte[1];String l_encoded=new String(instance.encode(bits));assertEquals("00000000",l_encoded);bits=new byte[1];bits[0]=BIT_0;l_encoded=new String(instance.encode(bits));assertEquals("00000001",l_encoded);bits=new byte[1];bits[0]=BIT_0 | BIT_1;l_encoded=new String(instance.encode(bits));assertEquals("00000011",l_encoded);bits=new byte[1];bits[0]=BIT_0 | BIT_1 | BIT_2;l_encoded=new String(instance.encode(bits));assertEquals("00000111",l_encoded);bits=new byte[1];bits[0]=BIT_0 | BIT_1 | BIT_2| BIT_3;l_encoded=new String(instance.encode(bits));assertEquals("00001111",l_encoded);bits=new byte[1];bits[0]=BIT_0 | BIT_1 | BIT_2| BIT_3| BIT_4;l_encoded=new String(instance.encode(bits));assertEquals("00011111",l_encoded);bits=new byte[1];bits[0]=BIT_0 | BIT_1 | BIT_2| BIT_3| BIT_4| BIT_5;l_encoded=new String(instance.encode(bits));assertEquals("00111111",l_encoded);bits=new byte[1];bits[0]=BIT_0 | BIT_1 | BIT_2| BIT_3| BIT_4| BIT_5| BIT_6;l_encoded=new String(instance.encode(bits));assertEquals("01111111",l_encoded);bits=new byte[1];bits[0]=(byte)(BIT_0 | BIT_1 | BIT_2| BIT_3| BIT_4| BIT_5| BIT_6| BIT_7);l_encoded=new String(instance.encode(bits));assertEquals("11111111",l_encoded);bits=new byte[2];l_encoded=new String(instance.encode(bits));assertEquals("0000000000000000",l_encoded);bits=new byte[2];bits[0]=BIT_0;l_encoded=new String(instance.encode(bits));assertEquals("0000000000000001",l_encoded);bits=new byte[2];bits[0]=BIT_0 | BIT_1;l_encoded=new String(instance.encode(bits));assertEquals("0000000000000011",l_encoded);bits=new byte[2];bits[0]=BIT_0 | BIT_1 | BIT_2;l_encoded=new String(instance.encode(bits));assertEquals("0000000000000111",l_encoded);bits=new byte[2];bits[0]=BIT_0 | BIT_1 | BIT_2| BIT_3;l_encoded=new String(instance.encode(bits));assertEquals("0000000000001111",l_encoded);bits=new byte[2];bits[0]=BIT_0 | BIT_1 | BIT_2| BIT_3| BIT_4;l_encoded=new String(instance.encode(bits));assertEquals("0000000000011111",l_encoded);bits=new byte[2];bits[0]=BIT_0 | BIT_1 | BIT_2| BIT_3| BIT_4| BIT_5;l_encoded=new String(instance.encode(bits));assertEquals("0000000000111111",l_encoded);bits=new byte[2];bits[0]=BIT_0 | BIT_1 | BIT_2| BIT_3| BIT_4| BIT_5| BIT_6;l_encoded=new String(instance.encode(bits));assertEquals("0000000001111111",l_encoded);bits=new byte[2];bits[0]=(byte)(BIT_0 | BIT_1 | BIT_2| BIT_3| BIT_4| BIT_5| BIT_6| BIT_7);l_encoded=new String(instance.encode(bits));assertEquals("0000000011111111",l_encoded);bits=new byte[2];bits[1]=BIT_0;bits[0]=(byte)(BIT_0 | BIT_1 | BIT_2| BIT_3| BIT_4| BIT_5| BIT_6| BIT_7);l_encoded=new String(instance.encode(bits));assertEquals("0000000111111111",l_encoded);bits=new byte[2];bits[1]=BIT_0 | BIT_1;bits[0]=(byte)(BIT_0 | BIT_1 | BIT_2| BIT_3| BIT_4| BIT_5| BIT_6| BIT_7);l_encoded=new String(instance.encode(bits));assertEquals("0000001111111111",l_encoded);bits=new byte[2];bits[1]=BIT_0 | BIT_1 | BIT_2;bits[0]=(byte)(BIT_0 | BIT_1 | BIT_2| BIT_3| BIT_4| BIT_5| BIT_6| BIT_7);l_encoded=new String(instance.encode(bits));assertEquals("0000011111111111",l_encoded);bits=new byte[2];bits[1]=BIT_0 | BIT_1 | BIT_2| BIT_3;bits[0]=(byte)(BIT_0 | BIT_1 | BIT_2| BIT_3| BIT_4| BIT_5| BIT_6| BIT_7);l_encoded=new String(instance.encode(bits));assertEquals("0000111111111111",l_encoded);bits=new byte[2];bits[1]=BIT_0 | BIT_1 | BIT_2| BIT_3| BIT_4;bits[0]=(byte)(BIT_0 | BIT_1 | BIT_2| BIT_3| BIT_4| BIT_5| BIT_6| BIT_7);l_encoded=new String(instance.encode(bits));assertEquals("0001111111111111",l_encoded);bits=new byte[2];bits[1]=BIT_0 | BIT_1 | BIT_2| BIT_3| BIT_4| BIT_5;bits[0]=(byte)(BIT_0 | BIT_1 | BIT_2| BIT_3| BIT_4| BIT_5| BIT_6| BIT_7);l_encoded=new String(instance.encode(bits));assertEquals("0011111111111111",l_encoded);bits=new byte[2];bits[1]=BIT_0 | BIT_1 | BIT_2| BIT_3| BIT_4| BIT_5| BIT_6;bits[0]=(byte)(BIT_0 | BIT_1 | BIT_2| BIT_3| BIT_4| BIT_5| BIT_6| BIT_7);l_encoded=new String(instance.encode(bits));assertEquals("0111111111111111",l_encoded);bits=new byte[2];bits[0]=(byte)(BIT_0 | BIT_1 | BIT_2| BIT_3| BIT_4| BIT_5| BIT_6| BIT_7);bits[1]=(byte)(BIT_0 | BIT_1 | BIT_2| BIT_3| BIT_4| BIT_5| BIT_6| BIT_7);l_encoded=new String(instance.encode(bits));assertEquals("1111111111111111",l_encoded);assertEquals(0,instance.encode((byte[])null).length);}
@Test public void testToAsciiBytes(){byte[]bits=new byte[1];String l_encoded=new String(BinaryCodec.toAsciiBytes(bits));assertEquals("00000000",l_encoded);bits=new byte[1];bits[0]=BIT_0;l_encoded=new String(BinaryCodec.toAsciiBytes(bits));assertEquals("00000001",l_encoded);bits=new byte[1];bits[0]=BIT_0 | BIT_1;l_encoded=new String(BinaryCodec.toAsciiBytes(bits));assertEquals("00000011",l_encoded);bits=new byte[1];bits[0]=BIT_0 | BIT_1 | BIT_2;l_encoded=new String(BinaryCodec.toAsciiBytes(bits));assertEquals("00000111",l_encoded);bits=new byte[1];bits[0]=BIT_0 | BIT_1 | BIT_2| BIT_3;l_encoded=new String(BinaryCodec.toAsciiBytes(bits));assertEquals("00001111",l_encoded);bits=new byte[1];bits[0]=BIT_0 | BIT_1 | BIT_2| BIT_3| BIT_4;l_encoded=new String(BinaryCodec.toAsciiBytes(bits));assertEquals("00011111",l_encoded);bits=new byte[1];bits[0]=BIT_0 | BIT_1 | BIT_2| BIT_3| BIT_4| BIT_5;l_encoded=new String(BinaryCodec.toAsciiBytes(bits));assertEquals("00111111",l_encoded);bits=new byte[1];bits[0]=BIT_0 | BIT_1 | BIT_2| BIT_3| BIT_4| BIT_5| BIT_6;l_encoded=new String(BinaryCodec.toAsciiBytes(bits));assertEquals("01111111",l_encoded);bits=new byte[1];bits[0]=(byte)(BIT_0 | BIT_1 | BIT_2| BIT_3| BIT_4| BIT_5| BIT_6| BIT_7);l_encoded=new String(BinaryCodec.toAsciiBytes(bits));assertEquals("11111111",l_encoded);bits=new byte[2];l_encoded=new String(BinaryCodec.toAsciiBytes(bits));assertEquals("0000000000000000",l_encoded);bits=new byte[2];bits[0]=BIT_0;l_encoded=new String(BinaryCodec.toAsciiBytes(bits));assertEquals("0000000000000001",l_encoded);bits=new byte[2];bits[0]=BIT_0 | BIT_1;l_encoded=new String(BinaryCodec.toAsciiBytes(bits));assertEquals("0000000000000011",l_encoded);bits=new byte[2];bits[0]=BIT_0 | BIT_1 | BIT_2;l_encoded=new String(BinaryCodec.toAsciiBytes(bits));assertEquals("0000000000000111",l_encoded);bits=new byte[2];bits[0]=BIT_0 | BIT_1 | BIT_2| BIT_3;l_encoded=new String(BinaryCodec.toAsciiBytes(bits));assertEquals("0000000000001111",l_encoded);bits=new byte[2];bits[0]=BIT_0 | BIT_1 | BIT_2| BIT_3| BIT_4;l_encoded=new String(BinaryCodec.toAsciiBytes(bits));assertEquals("0000000000011111",l_encoded);bits=new byte[2];bits[0]=BIT_0 | BIT_1 | BIT_2| BIT_3| BIT_4| BIT_5;l_encoded=new String(BinaryCodec.toAsciiBytes(bits));assertEquals("0000000000111111",l_encoded);bits=new byte[2];bits[0]=BIT_0 | BIT_1 | BIT_2| BIT_3| BIT_4| BIT_5| BIT_6;l_encoded=new String(BinaryCodec.toAsciiBytes(bits));assertEquals("0000000001111111",l_encoded);bits=new byte[2];bits[0]=(byte)(BIT_0 | BIT_1 | BIT_2| BIT_3| BIT_4| BIT_5| BIT_6| BIT_7);l_encoded=new String(BinaryCodec.toAsciiBytes(bits));assertEquals("0000000011111111",l_encoded);bits=new byte[2];bits[1]=BIT_0;bits[0]=(byte)(BIT_0 | BIT_1 | BIT_2| BIT_3| BIT_4| BIT_5| BIT_6| BIT_7);l_encoded=new String(BinaryCodec.toAsciiBytes(bits));assertEquals("0000000111111111",l_encoded);bits=new byte[2];bits[1]=BIT_0 | BIT_1;bits[0]=(byte)(BIT_0 | BIT_1 | BIT_2| BIT_3| BIT_4| BIT_5| BIT_6| BIT_7);l_encoded=new String(BinaryCodec.toAsciiBytes(bits));assertEquals("0000001111111111",l_encoded);bits=new byte[2];bits[1]=BIT_0 | BIT_1 | BIT_2;bits[0]=(byte)(BIT_0 | BIT_1 | BIT_2| BIT_3| BIT_4| BIT_5| BIT_6| BIT_7);l_encoded=new String(BinaryCodec.toAsciiBytes(bits));assertEquals("0000011111111111",l_encoded);bits=new byte[2];bits[1]=BIT_0 | BIT_1 | BIT_2| BIT_3;bits[0]=(byte)(BIT_0 | BIT_1 | BIT_2| BIT_3| BIT_4| BIT_5| BIT_6| BIT_7);l_encoded=new String(BinaryCodec.toAsciiBytes(bits));assertEquals("0000111111111111",l_encoded);bits=new byte[2];bits[1]=BIT_0 | BIT_1 | BIT_2| BIT_3| BIT_4;bits[0]=(byte)(BIT_0 | BIT_1 | BIT_2| BIT_3| BIT_4| BIT_5| BIT_6| BIT_7);l_encoded=new String(BinaryCodec.toAsciiBytes(bits));assertEquals("0001111111111111",l_encoded);bits=new byte[2];bits[1]=BIT_0 | BIT_1 | BIT_2| BIT_3| BIT_4| BIT_5;bits[0]=(byte)(BIT_0 | BIT_1 | BIT_2| BIT_3| BIT_4| BIT_5| BIT_6| BIT_7);l_encoded=new String(BinaryCodec.toAsciiBytes(bits));assertEquals("0011111111111111",l_encoded);bits=new byte[2];bits[1]=BIT_0 | BIT_1 | BIT_2| BIT_3| BIT_4| BIT_5| BIT_6;bits[0]=(byte)(BIT_0 | BIT_1 | BIT_2| BIT_3| BIT_4| BIT_5| BIT_6| BIT_7);l_encoded=new String(BinaryCodec.toAsciiBytes(bits));assertEquals("0111111111111111",l_encoded);bits=new byte[2];bits[0]=(byte)(BIT_0 | BIT_1 | BIT_2| BIT_3| BIT_4| BIT_5| BIT_6| BIT_7);bits[1]=(byte)(BIT_0 | BIT_1 | BIT_2| BIT_3| BIT_4| BIT_5| BIT_6| BIT_7);l_encoded=new String(BinaryCodec.toAsciiBytes(bits));assertEquals("1111111111111111",l_encoded);assertEquals(0,BinaryCodec.toAsciiBytes((byte[])null).length);}
@Test public void testToAsciiChars(){byte[]bits=new byte[1];String l_encoded=new String(BinaryCodec.toAsciiChars(bits));assertEquals("00000000",l_encoded);bits=new byte[1];bits[0]=BIT_0;l_encoded=new String(BinaryCodec.toAsciiChars(bits));assertEquals("00000001",l_encoded);bits=new byte[1];bits[0]=BIT_0 | BIT_1;l_encoded=new String(BinaryCodec.toAsciiChars(bits));assertEquals("00000011",l_encoded);bits=new byte[1];bits[0]=BIT_0 | BIT_1 | BIT_2;l_encoded=new String(BinaryCodec.toAsciiChars(bits));assertEquals("00000111",l_encoded);bits=new byte[1];bits[0]=BIT_0 | BIT_1 | BIT_2| BIT_3;l_encoded=new String(BinaryCodec.toAsciiChars(bits));assertEquals("00001111",l_encoded);bits=new byte[1];bits[0]=BIT_0 | BIT_1 | BIT_2| BIT_3| BIT_4;l_encoded=new String(BinaryCodec.toAsciiChars(bits));assertEquals("00011111",l_encoded);bits=new byte[1];bits[0]=BIT_0 | BIT_1 | BIT_2| BIT_3| BIT_4| BIT_5;l_encoded=new String(BinaryCodec.toAsciiChars(bits));assertEquals("00111111",l_encoded);bits=new byte[1];bits[0]=BIT_0 | BIT_1 | BIT_2| BIT_3| BIT_4| BIT_5| BIT_6;l_encoded=new String(BinaryCodec.toAsciiChars(bits));assertEquals("01111111",l_encoded);bits=new byte[1];bits[0]=(byte)(BIT_0 | BIT_1 | BIT_2| BIT_3| BIT_4| BIT_5| BIT_6| BIT_7);l_encoded=new String(BinaryCodec.toAsciiChars(bits));assertEquals("11111111",l_encoded);bits=new byte[2];l_encoded=new String(BinaryCodec.toAsciiChars(bits));assertEquals("0000000000000000",l_encoded);bits=new byte[2];bits[0]=BIT_0;l_encoded=new String(BinaryCodec.toAsciiChars(bits));assertEquals("0000000000000001",l_encoded);bits=new byte[2];bits[0]=BIT_0 | BIT_1;l_encoded=new String(BinaryCodec.toAsciiChars(bits));assertEquals("0000000000000011",l_encoded);bits=new byte[2];bits[0]=BIT_0 | BIT_1 | BIT_2;l_encoded=new String(BinaryCodec.toAsciiChars(bits));assertEquals("0000000000000111",l_encoded);bits=new byte[2];bits[0]=BIT_0 | BIT_1 | BIT_2| BIT_3;l_encoded=new String(BinaryCodec.toAsciiChars(bits));assertEquals("0000000000001111",l_encoded);bits=new byte[2];bits[0]=BIT_0 | BIT_1 | BIT_2| BIT_3| BIT_4;l_encoded=new String(BinaryCodec.toAsciiChars(bits));assertEquals("0000000000011111",l_encoded);bits=new byte[2];bits[0]=BIT_0 | BIT_1 | BIT_2| BIT_3| BIT_4| BIT_5;l_encoded=new String(BinaryCodec.toAsciiChars(bits));assertEquals("0000000000111111",l_encoded);bits=new byte[2];bits[0]=BIT_0 | BIT_1 | BIT_2| BIT_3| BIT_4| BIT_5| BIT_6;l_encoded=new String(BinaryCodec.toAsciiChars(bits));assertEquals("0000000001111111",l_encoded);bits=new byte[2];bits[0]=(byte)(BIT_0 | BIT_1 | BIT_2| BIT_3| BIT_4| BIT_5| BIT_6| BIT_7);l_encoded=new String(BinaryCodec.toAsciiChars(bits));assertEquals("0000000011111111",l_encoded);bits=new byte[2];bits[1]=BIT_0;bits[0]=(byte)(BIT_0 | BIT_1 | BIT_2| BIT_3| BIT_4| BIT_5| BIT_6| BIT_7);l_encoded=new String(BinaryCodec.toAsciiChars(bits));assertEquals("0000000111111111",l_encoded);bits=new byte[2];bits[1]=BIT_0 | BIT_1;bits[0]=(byte)(BIT_0 | BIT_1 | BIT_2| BIT_3| BIT_4| BIT_5| BIT_6| BIT_7);l_encoded=new String(BinaryCodec.toAsciiChars(bits));assertEquals("0000001111111111",l_encoded);bits=new byte[2];bits[1]=BIT_0 | BIT_1 | BIT_2;bits[0]=(byte)(BIT_0 | BIT_1 | BIT_2| BIT_3| BIT_4| BIT_5| BIT_6| BIT_7);l_encoded=new String(BinaryCodec.toAsciiChars(bits));assertEquals("0000011111111111",l_encoded);bits=new byte[2];bits[1]=BIT_0 | BIT_1 | BIT_2| BIT_3;bits[0]=(byte)(BIT_0 | BIT_1 | BIT_2| BIT_3| BIT_4| BIT_5| BIT_6| BIT_7);l_encoded=new String(BinaryCodec.toAsciiChars(bits));assertEquals("0000111111111111",l_encoded);bits=new byte[2];bits[1]=BIT_0 | BIT_1 | BIT_2| BIT_3| BIT_4;bits[0]=(byte)(BIT_0 | BIT_1 | BIT_2| BIT_3| BIT_4| BIT_5| BIT_6| BIT_7);l_encoded=new String(BinaryCodec.toAsciiChars(bits));assertEquals("0001111111111111",l_encoded);bits=new byte[2];bits[1]=BIT_0 | BIT_1 | BIT_2| BIT_3| BIT_4| BIT_5;bits[0]=(byte)(BIT_0 | BIT_1 | BIT_2| BIT_3| BIT_4| BIT_5| BIT_6| BIT_7);l_encoded=new String(BinaryCodec.toAsciiChars(bits));assertEquals("0011111111111111",l_encoded);bits=new byte[2];bits[1]=BIT_0 | BIT_1 | BIT_2| BIT_3| BIT_4| BIT_5| BIT_6;bits[0]=(byte)(BIT_0 | BIT_1 | BIT_2| BIT_3| BIT_4| BIT_5| BIT_6| BIT_7);l_encoded=new String(BinaryCodec.toAsciiChars(bits));assertEquals("0111111111111111",l_encoded);bits=new byte[2];bits[0]=(byte)(BIT_0 | BIT_1 | BIT_2| BIT_3| BIT_4| BIT_5| BIT_6| BIT_7);bits[1]=(byte)(BIT_0 | BIT_1 | BIT_2| BIT_3| BIT_4| BIT_5| BIT_6| BIT_7);l_encoded=new String(BinaryCodec.toAsciiChars(bits));assertEquals("1111111111111111",l_encoded);assertEquals(0,BinaryCodec.toAsciiChars((byte[])null).length);}
/** * Tests the toAsciiString(byte[])method*/@Test public void testToAsciiString(){byte[]bits=new byte[1];String l_encoded=BinaryCodec.toAsciiString(bits);assertEquals("00000000",l_encoded);bits=new byte[1];bits[0]=BIT_0;l_encoded=BinaryCodec.toAsciiString(bits);assertEquals("00000001",l_encoded);bits=new byte[1];bits[0]=BIT_0 | BIT_1;l_encoded=BinaryCodec.toAsciiString(bits);assertEquals("00000011",l_encoded);bits=new byte[1];bits[0]=BIT_0 | BIT_1 | BIT_2;l_encoded=BinaryCodec.toAsciiString(bits);assertEquals("00000111",l_encoded);bits=new byte[1];bits[0]=BIT_0 | BIT_1 | BIT_2| BIT_3;l_encoded=BinaryCodec.toAsciiString(bits);assertEquals("00001111",l_encoded);bits=new byte[1];bits[0]=BIT_0 | BIT_1 | BIT_2| BIT_3| BIT_4;l_encoded=BinaryCodec.toAsciiString(bits);assertEquals("00011111",l_encoded);bits=new byte[1];bits[0]=BIT_0 | BIT_1 | BIT_2| BIT_3| BIT_4| BIT_5;l_encoded=BinaryCodec.toAsciiString(bits);assertEquals("00111111",l_encoded);bits=new byte[1];bits[0]=BIT_0 | BIT_1 | BIT_2| BIT_3| BIT_4| BIT_5| BIT_6;l_encoded=BinaryCodec.toAsciiString(bits);assertEquals("01111111",l_encoded);bits=new byte[1];bits[0]=(byte)(BIT_0 | BIT_1 | BIT_2| BIT_3| BIT_4| BIT_5| BIT_6| BIT_7);l_encoded=BinaryCodec.toAsciiString(bits);assertEquals("11111111",l_encoded);bits=new byte[2];l_encoded=BinaryCodec.toAsciiString(bits);assertEquals("0000000000000000",l_encoded);bits=new byte[2];bits[0]=BIT_0;l_encoded=BinaryCodec.toAsciiString(bits);assertEquals("0000000000000001",l_encoded);bits=new byte[2];bits[0]=BIT_0 | BIT_1;l_encoded=BinaryCodec.toAsciiString(bits);assertEquals("0000000000000011",l_encoded);bits=new byte[2];bits[0]=BIT_0 | BIT_1 | BIT_2;l_encoded=BinaryCodec.toAsciiString(bits);assertEquals("0000000000000111",l_encoded);bits=new byte[2];bits[0]=BIT_0 | BIT_1 | BIT_2| BIT_3;l_encoded=BinaryCodec.toAsciiString(bits);assertEquals("0000000000001111",l_encoded);bits=new byte[2];bits[0]=BIT_0 | BIT_1 | BIT_2| BIT_3| BIT_4;l_encoded=BinaryCodec.toAsciiString(bits);assertEquals("0000000000011111",l_encoded);bits=new byte[2];bits[0]=BIT_0 | BIT_1 | BIT_2| BIT_3| BIT_4| BIT_5;l_encoded=BinaryCodec.toAsciiString(bits);assertEquals("0000000000111111",l_encoded);bits=new byte[2];bits[0]=BIT_0 | BIT_1 | BIT_2| BIT_3| BIT_4| BIT_5| BIT_6;l_encoded=BinaryCodec.toAsciiString(bits);assertEquals("0000000001111111",l_encoded);bits=new byte[2];bits[0]=(byte)(BIT_0 | BIT_1 | BIT_2| BIT_3| BIT_4| BIT_5| BIT_6| BIT_7);l_encoded=BinaryCodec.toAsciiString(bits);assertEquals("0000000011111111",l_encoded);bits=new byte[2];bits[1]=BIT_0;bits[0]=(byte)(BIT_0 | BIT_1 | BIT_2| BIT_3| BIT_4| BIT_5| BIT_6| BIT_7);l_encoded=BinaryCodec.toAsciiString(bits);assertEquals("0000000111111111",l_encoded);bits=new byte[2];bits[1]=BIT_0 | BIT_1;bits[0]=(byte)(BIT_0 | BIT_1 | BIT_2| BIT_3| BIT_4| BIT_5| BIT_6| BIT_7);l_encoded=BinaryCodec.toAsciiString(bits);assertEquals("0000001111111111",l_encoded);bits=new byte[2];bits[1]=BIT_0 | BIT_1 | BIT_2;bits[0]=(byte)(BIT_0 | BIT_1 | BIT_2| BIT_3| BIT_4| BIT_5| BIT_6| BIT_7);l_encoded=BinaryCodec.toAsciiString(bits);assertEquals("0000011111111111",l_encoded);bits=new byte[2];bits[1]=BIT_0 | BIT_1 | BIT_2| BIT_3;bits[0]=(byte)(BIT_0 | BIT_1 | BIT_2| BIT_3| BIT_4| BIT_5| BIT_6| BIT_7);l_encoded=BinaryCodec.toAsciiString(bits);assertEquals("0000111111111111",l_encoded);bits=new byte[2];bits[1]=BIT_0 | BIT_1 | BIT_2| BIT_3| BIT_4;bits[0]=(byte)(BIT_0 | BIT_1 | BIT_2| BIT_3| BIT_4| BIT_5| BIT_6| BIT_7);l_encoded=BinaryCodec.toAsciiString(bits);assertEquals("0001111111111111",l_encoded);bits=new byte[2];bits[1]=BIT_0 | BIT_1 | BIT_2| BIT_3| BIT_4| BIT_5;bits[0]=(byte)(BIT_0 | BIT_1 | BIT_2| BIT_3| BIT_4| BIT_5| BIT_6| BIT_7);l_encoded=BinaryCodec.toAsciiString(bits);assertEquals("0011111111111111",l_encoded);bits=new byte[2];bits[1]=BIT_0 | BIT_1 | BIT_2| BIT_3| BIT_4| BIT_5| BIT_6;bits[0]=(byte)(BIT_0 | BIT_1 | BIT_2| BIT_3| BIT_4| BIT_5| BIT_6| BIT_7);l_encoded=BinaryCodec.toAsciiString(bits);assertEquals("0111111111111111",l_encoded);bits=new byte[2];bits[0]=(byte)(BIT_0 | BIT_1 | BIT_2| BIT_3| BIT_4| BIT_5| BIT_6| BIT_7);bits[1]=(byte)(BIT_0 | BIT_1 | BIT_2| BIT_3| BIT_4| BIT_5| BIT_6| BIT_7);l_encoded=BinaryCodec.toAsciiString(bits);assertEquals("1111111111111111",l_encoded);}
@Test public void testEncodeObjectNull()throws Exception {final Object obj=new byte[0];assertEquals(0,((char[])instance.encode(obj)).length);}
@Test public void testEncodeObjectException(){try {instance.encode("");}catch(final EncoderException e){return;}fail("Expected EncoderException");}
@Test public void testEncodeObject()throws Exception {byte[]bits=new byte[1];String l_encoded=new String((char[])instance.encode((Object)bits));assertEquals("00000000",l_encoded);bits=new byte[1];bits[0]=BIT_0;l_encoded=new String((char[])instance.encode((Object)bits));assertEquals("00000001",l_encoded);bits=new byte[1];bits[0]=BIT_0 | BIT_1;l_encoded=new String((char[])instance.encode((Object)bits));assertEquals("00000011",l_encoded);bits=new byte[1];bits[0]=BIT_0 | BIT_1 | BIT_2;l_encoded=new String((char[])instance.encode((Object)bits));assertEquals("00000111",l_encoded);bits=new byte[1];bits[0]=BIT_0 | BIT_1 | BIT_2| BIT_3;l_encoded=new String((char[])instance.encode((Object)bits));assertEquals("00001111",l_encoded);bits=new byte[1];bits[0]=BIT_0 | BIT_1 | BIT_2| BIT_3| BIT_4;l_encoded=new String((char[])instance.encode((Object)bits));assertEquals("00011111",l_encoded);bits=new byte[1];bits[0]=BIT_0 | BIT_1 | BIT_2| BIT_3| BIT_4| BIT_5;l_encoded=new String((char[])instance.encode((Object)bits));assertEquals("00111111",l_encoded);bits=new byte[1];bits[0]=BIT_0 | BIT_1 | BIT_2| BIT_3| BIT_4| BIT_5| BIT_6;l_encoded=new String((char[])instance.encode((Object)bits));assertEquals("01111111",l_encoded);bits=new byte[1];bits[0]=(byte)(BIT_0 | BIT_1 | BIT_2| BIT_3| BIT_4| BIT_5| BIT_6| BIT_7);l_encoded=new String((char[])instance.encode((Object)bits));assertEquals("11111111",l_encoded);bits=new byte[2];l_encoded=new String((char[])instance.encode((Object)bits));assertEquals("0000000000000000",l_encoded);bits=new byte[2];bits[0]=BIT_0;l_encoded=new String((char[])instance.encode((Object)bits));assertEquals("0000000000000001",l_encoded);bits=new byte[2];bits[0]=BIT_0 | BIT_1;l_encoded=new String((char[])instance.encode((Object)bits));assertEquals("0000000000000011",l_encoded);bits=new byte[2];bits[0]=BIT_0 | BIT_1 | BIT_2;l_encoded=new String((char[])instance.encode((Object)bits));assertEquals("0000000000000111",l_encoded);bits=new byte[2];bits[0]=BIT_0 | BIT_1 | BIT_2| BIT_3;l_encoded=new String((char[])instance.encode((Object)bits));assertEquals("0000000000001111",l_encoded);bits=new byte[2];bits[0]=BIT_0 | BIT_1 | BIT_2| BIT_3| BIT_4;l_encoded=new String((char[])instance.encode((Object)bits));assertEquals("0000000000011111",l_encoded);bits=new byte[2];bits[0]=BIT_0 | BIT_1 | BIT_2| BIT_3| BIT_4| BIT_5;l_encoded=new String((char[])instance.encode((Object)bits));assertEquals("0000000000111111",l_encoded);bits=new byte[2];bits[0]=BIT_0 | BIT_1 | BIT_2| BIT_3| BIT_4| BIT_5| BIT_6;l_encoded=new String((char[])instance.encode((Object)bits));assertEquals("0000000001111111",l_encoded);bits=new byte[2];bits[0]=(byte)(BIT_0 | BIT_1 | BIT_2| BIT_3| BIT_4| BIT_5| BIT_6| BIT_7);l_encoded=new String((char[])instance.encode((Object)bits));assertEquals("0000000011111111",l_encoded);bits=new byte[2];bits[1]=BIT_0;bits[0]=(byte)(BIT_0 | BIT_1 | BIT_2| BIT_3| BIT_4| BIT_5| BIT_6| BIT_7);l_encoded=new String((char[])instance.encode((Object)bits));assertEquals("0000000111111111",l_encoded);bits=new byte[2];bits[1]=BIT_0 | BIT_1;bits[0]=(byte)(BIT_0 | BIT_1 | BIT_2| BIT_3| BIT_4| BIT_5| BIT_6| BIT_7);l_encoded=new String((char[])instance.encode((Object)bits));assertEquals("0000001111111111",l_encoded);bits=new byte[2];bits[1]=BIT_0 | BIT_1 | BIT_2;bits[0]=(byte)(BIT_0 | BIT_1 | BIT_2| BIT_3| BIT_4| BIT_5| BIT_6| BIT_7);l_encoded=new String((char[])instance.encode((Object)bits));assertEquals("0000011111111111",l_encoded);bits=new byte[2];bits[1]=BIT_0 | BIT_1 | BIT_2| BIT_3;bits[0]=(byte)(BIT_0 | BIT_1 | BIT_2| BIT_3| BIT_4| BIT_5| BIT_6| BIT_7);l_encoded=new String((char[])instance.encode((Object)bits));assertEquals("0000111111111111",l_encoded);bits=new byte[2];bits[1]=BIT_0 | BIT_1 | BIT_2| BIT_3| BIT_4;bits[0]=(byte)(BIT_0 | BIT_1 | BIT_2| BIT_3| BIT_4| BIT_5| BIT_6| BIT_7);l_encoded=new String((char[])instance.encode((Object)bits));assertEquals("0001111111111111",l_encoded);bits=new byte[2];bits[1]=BIT_0 | BIT_1 | BIT_2| BIT_3| BIT_4| BIT_5;bits[0]=(byte)(BIT_0 | BIT_1 | BIT_2| BIT_3| BIT_4| BIT_5| BIT_6| BIT_7);l_encoded=new String((char[])instance.encode((Object)bits));assertEquals("0011111111111111",l_encoded);bits=new byte[2];bits[1]=BIT_0 | BIT_1 | BIT_2| BIT_3| BIT_4| BIT_5| BIT_6;bits[0]=(byte)(BIT_0 | BIT_1 | BIT_2| BIT_3| BIT_4| BIT_5| BIT_6| BIT_7);l_encoded=new String((char[])instance.encode((Object)bits));assertEquals("0111111111111111",l_encoded);bits=new byte[2];bits[0]=(byte)(BIT_0 | BIT_1 | BIT_2| BIT_3| BIT_4| BIT_5| BIT_6| BIT_7);bits[1]=(byte)(BIT_0 | BIT_1 | BIT_2| BIT_3| BIT_4| BIT_5| BIT_6| BIT_7);l_encoded=new String((char[])instance.encode((Object)bits));assertEquals("1111111111111111",l_encoded);}
@Test public void testUTF8RoundTrip()throws Exception {final String ru_msg=constructString(RUSSIAN_STUFF_UNICODE);final String ch_msg=constructString(SWISS_GERMAN_STUFF_UNICODE);final QuotedPrintableCodec qpcodec=new QuotedPrintableCodec();assertEquals("=D0=92=D1=81=D0=B5=D0=BC_=D0=BF=D1=80=D0=B8=D0=B2=D0=B5=D1=82",qpcodec.encode(ru_msg,CharEncoding.UTF_8));assertEquals("Gr=C3=BCezi_z=C3=A4m=C3=A4",qpcodec.encode(ch_msg,CharEncoding.UTF_8));assertEquals(ru_msg,qpcodec.decode(qpcodec.encode(ru_msg,CharEncoding.UTF_8),CharEncoding.UTF_8));assertEquals(ch_msg,qpcodec.decode(qpcodec.encode(ch_msg,CharEncoding.UTF_8),CharEncoding.UTF_8));}
@Test public void testBasicEncodeDecode()throws Exception {final QuotedPrintableCodec qpcodec=new QuotedPrintableCodec();final String plain="= Hello there =\r\n";final String encoded=qpcodec.encode(plain);assertEquals("Basic quoted-printable encoding test","=3D Hello there =3D=0D=0A",encoded);assertEquals("Basic quoted-printable decoding test",plain,qpcodec.decode(encoded));}
@Test public void testSafeCharEncodeDecode()throws Exception {final QuotedPrintableCodec qpcodec=new QuotedPrintableCodec();final String plain="abc123_-.*~!@#$%^&()+{}\"\\;:`,/[]";final String encoded=qpcodec.encode(plain);assertEquals("Safe chars quoted-printable encoding test",plain,encoded);assertEquals("Safe chars quoted-printable decoding test",plain,qpcodec.decode(encoded));}
@Test public void testUnsafeEncodeDecode()throws Exception {final QuotedPrintableCodec qpcodec=new QuotedPrintableCodec();final String plain="=\r\n";final String encoded=qpcodec.encode(plain);assertEquals("Unsafe chars quoted-printable encoding test","=3D=0D=0A",encoded);assertEquals("Unsafe chars quoted-printable decoding test",plain,qpcodec.decode(encoded));}
@Test public void testEncodeDecodeNull()throws Exception {final QuotedPrintableCodec qpcodec=new QuotedPrintableCodec();assertNull("Null string quoted-printable encoding test",qpcodec.encode((String)null));assertNull("Null string quoted-printable decoding test",qpcodec.decode((String)null));}
@Test public void testDecodeInvalid()throws Exception {final QuotedPrintableCodec qpcodec=new QuotedPrintableCodec();try {qpcodec.decode("=");fail("DecoderException should have been thrown");}catch(final DecoderException e){}try {qpcodec.decode("=A");fail("DecoderException should have been thrown");}catch(final DecoderException e){}try {qpcodec.decode("=WW");fail("DecoderException should have been thrown");}catch(final DecoderException e){}}
@Test public void testEncodeNull()throws Exception {final QuotedPrintableCodec qpcodec=new QuotedPrintableCodec();final byte[]plain=null;final byte[]encoded=qpcodec.encode(plain);assertEquals("Encoding a null string should return null",null,encoded);}
@Test public void testEncodeUrlWithNullBitSet()throws Exception {final QuotedPrintableCodec qpcodec=new QuotedPrintableCodec();final String plain="1+1 = 2";final String encoded=new String(QuotedPrintableCodec.encodeQuotedPrintable(null,plain.getBytes(Charsets.UTF_8)));assertEquals("Basic quoted-printable encoding test","1+1 =3D 2",encoded);assertEquals("Basic quoted-printable decoding test",plain,qpcodec.decode(encoded));}
@Test public void testDecodeWithNullArray()throws Exception {final byte[]plain=null;final byte[]result=QuotedPrintableCodec.decodeQuotedPrintable(plain);assertEquals("Result should be null",null,result);}
@Test public void testEncodeStringWithNull()throws Exception {final QuotedPrintableCodec qpcodec=new QuotedPrintableCodec();final String test=null;final String result=qpcodec.encode(test,"charset");assertEquals("Result should be null",null,result);}
@Test public void testDecodeStringWithNull()throws Exception {final QuotedPrintableCodec qpcodec=new QuotedPrintableCodec();final String test=null;final String result=qpcodec.decode(test,"charset");assertEquals("Result should be null",null,result);}
@Test public void testEncodeObjects()throws Exception {final QuotedPrintableCodec qpcodec=new QuotedPrintableCodec();final String plain="1+1 = 2";String encoded=(String)qpcodec.encode((Object)plain);assertEquals("Basic quoted-printable encoding test","1+1 =3D 2",encoded);final byte[]plainBA=plain.getBytes(Charsets.UTF_8);final byte[]encodedBA=(byte[])qpcodec.encode((Object)plainBA);encoded=new String(encodedBA);assertEquals("Basic quoted-printable encoding test","1+1 =3D 2",encoded);final Object result=qpcodec.encode((Object)null);assertEquals("Encoding a null Object should return null",null,result);try {final Object dObj=new Double(3.0);qpcodec.encode(dObj);fail("Trying to url encode a Double object should cause an exception.");}catch(final EncoderException ee){}}
@Test(expected=UnsupportedCharsetException.class)public void testInvalidEncoding(){new QuotedPrintableCodec("NONSENSE");}
@Test public void testDecodeObjects()throws Exception {final QuotedPrintableCodec qpcodec=new QuotedPrintableCodec();final String plain="1+1 =3D 2";String decoded=(String)qpcodec.decode((Object)plain);assertEquals("Basic quoted-printable decoding test","1+1 = 2",decoded);final byte[]plainBA=plain.getBytes(Charsets.UTF_8);final byte[]decodedBA=(byte[])qpcodec.decode((Object)plainBA);decoded=new String(decodedBA);assertEquals("Basic quoted-printable decoding test","1+1 = 2",decoded);final Object result=qpcodec.decode((Object)null);assertEquals("Decoding a null Object should return null",null,result);try {final Object dObj=new Double(3.0);qpcodec.decode(dObj);fail("Trying to url encode a Double object should cause an exception.");}catch(final DecoderException ee){}}
@Test public void testDefaultEncoding()throws Exception {final String plain="Hello there!";final QuotedPrintableCodec qpcodec=new QuotedPrintableCodec("UnicodeBig");qpcodec.encode(plain);final String encoded1=qpcodec.encode(plain,"UnicodeBig");final String encoded2=qpcodec.encode(plain);assertEquals(encoded1,encoded2);}
@Test @Ignore public void testSoftLineBreakDecode()throws Exception {final String qpdata="If you believe that truth=3Dbeauty,then surely=20=\r\nmathematics is the most beautiful branch of philosophy.";final String expected="If you believe that truth=beauty,then surely mathematics is the most beautiful branch of philosophy.";assertEquals(expected,new QuotedPrintableCodec().decode(qpdata));}
@Test @Ignore public void testSoftLineBreakEncode()throws Exception {final String qpdata="If you believe that truth=3Dbeauty,then surely=20=\r\nmathematics is the most beautiful branch of philosophy.";final String expected="If you believe that truth=beauty,then surely mathematics is the most beautiful branch of philosophy.";assertEquals(qpdata,new QuotedPrintableCodec().encode(expected));}
@Test public void testNullInput()throws Exception {final RFC1522TestCodec testcodec=new RFC1522TestCodec();assertNull(testcodec.decodeText(null));assertNull(testcodec.encodeText(null,CharEncoding.UTF_8));}
@Test public void testDecodeInvalid()throws Exception {assertExpectedDecoderException("whatever");assertExpectedDecoderException("=?");assertExpectedDecoderException("?=");assertExpectedDecoderException("==");assertExpectedDecoderException("=??=");assertExpectedDecoderException("=?stuff?=");assertExpectedDecoderException("=?UTF-8??=");assertExpectedDecoderException("=?UTF-8?stuff?=");assertExpectedDecoderException("=?UTF-8?T?stuff");assertExpectedDecoderException("=??T?stuff?=");assertExpectedDecoderException("=?UTF-8??stuff?=");assertExpectedDecoderException("=?UTF-8?W?stuff?=");}
@Test public void testBaseNCodec(){assertNotNull(codec);}
@Test public void testIsWhiteSpace(){assertTrue(BaseNCodec.isWhiteSpace((byte)' '));assertTrue(BaseNCodec.isWhiteSpace((byte)'\n'));assertTrue(BaseNCodec.isWhiteSpace((byte)'\r'));assertTrue(BaseNCodec.isWhiteSpace((byte)'\t'));}
@Test public void testIsInAlphabetByte(){assertFalse(codec.isInAlphabet((byte)0));assertFalse(codec.isInAlphabet((byte)'a'));assertTrue(codec.isInAlphabet((byte)'O'));assertTrue(codec.isInAlphabet((byte)'K'));}
@Test public void testIsInAlphabetByteArrayBoolean(){assertTrue(codec.isInAlphabet(new byte[]{},false));assertTrue(codec.isInAlphabet(new byte[]{'O'},false));assertFalse(codec.isInAlphabet(new byte[]{'O',' '},false));assertFalse(codec.isInAlphabet(new byte[]{' '},false));assertTrue(codec.isInAlphabet(new byte[]{},true));assertTrue(codec.isInAlphabet(new byte[]{'O'},true));assertTrue(codec.isInAlphabet(new byte[]{'O',' '},true));assertTrue(codec.isInAlphabet(new byte[]{' '},true));}
@Test public void testIsInAlphabetString(){assertTrue(codec.isInAlphabet("OK"));assertTrue(codec.isInAlphabet("O=K= \t\n\r"));}
@Test public void testContainsAlphabetOrPad(){assertFalse(codec.containsAlphabetOrPad(null));assertFalse(codec.containsAlphabetOrPad(new byte[]{}));assertTrue(codec.containsAlphabetOrPad("OK".getBytes()));assertTrue(codec.containsAlphabetOrPad("OK ".getBytes()));assertFalse(codec.containsAlphabetOrPad("ok ".getBytes()));assertTrue(codec.containsAlphabetOrPad(new byte[]{codec.pad}));}
@Test public void testProvidePaddingByte(){codec=new BaseNCodec(0,0,0,0,(byte)0x25){@Override protected boolean isInAlphabet(final byte b){return b == 'O' || b == 'K';}@Override void encode(final byte[]pArray,final int i,final int length,final Context context){}@Override void decode(final byte[]pArray,final int i,final int length,final Context context){}};byte actualPaddingByte=codec.pad;assertEquals(0x25,actualPaddingByte);}
@Test public void testConstructor0(){final EncoderException e=new EncoderException();assertNull(e.getMessage());assertNull(e.getCause());}
@Test public void testConstructorString(){final EncoderException e=new EncoderException(MSG);assertEquals(MSG,e.getMessage());assertNull(e.getCause());}
@Test public void testConstructorStringThrowable(){final EncoderException e=new EncoderException(MSG,t);assertEquals(MSG,e.getMessage());assertEquals(t,e.getCause());}
@Test public void testConstructorThrowable(){final EncoderException e=new EncoderException(t);assertEquals(t.getClass().getName(),e.getMessage());assertEquals(t,e.getCause());}
@Test public void testNullInput()throws Exception {final BCodec bcodec=new BCodec();assertNull(bcodec.doDecoding(null));assertNull(bcodec.doEncoding(null));}
@Test public void testUTF8RoundTrip()throws Exception {final String ru_msg=constructString(RUSSIAN_STUFF_UNICODE);final String ch_msg=constructString(SWISS_GERMAN_STUFF_UNICODE);final BCodec bcodec=new BCodec(CharEncoding.UTF_8);assertEquals("=?UTF-8?B?0JLRgdC10Lxf0L/RgNC40LLQtdGC?=",bcodec.encode(ru_msg));assertEquals("=?UTF-8?B?R3LDvGV6aV96w6Rtw6Q=?=",bcodec.encode(ch_msg));assertEquals(ru_msg,bcodec.decode(bcodec.encode(ru_msg)));assertEquals(ch_msg,bcodec.decode(bcodec.encode(ch_msg)));}
@Test public void testBasicEncodeDecode()throws Exception {final BCodec bcodec=new BCodec();final String plain="Hello there";final String encoded=bcodec.encode(plain);assertEquals("Basic B encoding test","=?UTF-8?B?SGVsbG8gdGhlcmU=?=",encoded);assertEquals("Basic B decoding test",plain,bcodec.decode(encoded));}
@Test public void testEncodeDecodeNull()throws Exception {final BCodec bcodec=new BCodec();assertNull("Null string B encoding test",bcodec.encode((String)null));assertNull("Null string B decoding test",bcodec.decode((String)null));}
@Test public void testEncodeStringWithNull()throws Exception {final BCodec bcodec=new BCodec();final String test=null;final String result=bcodec.encode(test,"charset");assertEquals("Result should be null",null,result);}
@Test public void testDecodeStringWithNull()throws Exception {final BCodec bcodec=new BCodec();final String test=null;final String result=bcodec.decode(test);assertEquals("Result should be null",null,result);}
@Test public void testEncodeObjects()throws Exception {final BCodec bcodec=new BCodec();final String plain="what not";final String encoded=(String)bcodec.encode((Object)plain);assertEquals("Basic B encoding test","=?UTF-8?B?d2hhdCBub3Q=?=",encoded);final Object result=bcodec.encode((Object)null);assertEquals("Encoding a null Object should return null",null,result);try {final Object dObj=new Double(3.0);bcodec.encode(dObj);fail("Trying to url encode a Double object should cause an exception.");}catch(final EncoderException ee){}}
@Test(expected=UnsupportedCharsetException.class)public void testInvalidEncoding(){new BCodec("NONSENSE");}
@Test public void testDecodeObjects()throws Exception {final BCodec bcodec=new BCodec();final String decoded="=?UTF-8?B?d2hhdCBub3Q=?=";final String plain=(String)bcodec.decode((Object)decoded);assertEquals("Basic B decoding test","what not",plain);final Object result=bcodec.decode((Object)null);assertEquals("Decoding a null Object should return null",null,result);try {final Object dObj=new Double(3.0);bcodec.decode(dObj);fail("Trying to url encode a Double object should cause an exception.");}catch(final DecoderException ee){}}
@Test public void testUTF8RoundTrip()throws Exception {final String ru_msg=constructString(RUSSIAN_STUFF_UNICODE);final String ch_msg=constructString(SWISS_GERMAN_STUFF_UNICODE);final URLCodec urlCodec=new URLCodec();this.validateState(urlCodec);assertEquals("%D0%92%D1%81%D0%B5%D0%BC_%D0%BF%D1%80%D0%B8%D0%B2%D0%B5%D1%82",urlCodec.encode(ru_msg,CharEncoding.UTF_8));assertEquals("Gr%C3%BCezi_z%C3%A4m%C3%A4",urlCodec.encode(ch_msg,CharEncoding.UTF_8));assertEquals(ru_msg,urlCodec.decode(urlCodec.encode(ru_msg,CharEncoding.UTF_8),CharEncoding.UTF_8));assertEquals(ch_msg,urlCodec.decode(urlCodec.encode(ch_msg,CharEncoding.UTF_8),CharEncoding.UTF_8));this.validateState(urlCodec);}
@Test public void testBasicEncodeDecode()throws Exception {final URLCodec urlCodec=new URLCodec();final String plain="Hello there!";final String encoded=urlCodec.encode(plain);assertEquals("Basic URL encoding test","Hello+there%21",encoded);assertEquals("Basic URL decoding test",plain,urlCodec.decode(encoded));this.validateState(urlCodec);}
@Test public void testSafeCharEncodeDecode()throws Exception {final URLCodec urlCodec=new URLCodec();final String plain="abc123_-.*";final String encoded=urlCodec.encode(plain);assertEquals("Safe chars URL encoding test",plain,encoded);assertEquals("Safe chars URL decoding test",plain,urlCodec.decode(encoded));this.validateState(urlCodec);}
@Test public void testUnsafeEncodeDecode()throws Exception {final URLCodec urlCodec=new URLCodec();final String plain="~!@#$%^&()+{}\"\\;:`,/[]";final String encoded=urlCodec.encode(plain);assertEquals("Unsafe chars URL encoding test","%7E%21%40%23%24%25%5E%26%28%29%2B%7B%7D%22%5C%3B%3A%60%2C%2F%5B%5D",encoded);assertEquals("Unsafe chars URL decoding test",plain,urlCodec.decode(encoded));this.validateState(urlCodec);}
@Test public void testEncodeDecodeNull()throws Exception {final URLCodec urlCodec=new URLCodec();assertNull("Null string URL encoding test",urlCodec.encode((String)null));assertNull("Null string URL decoding test",urlCodec.decode((String)null));this.validateState(urlCodec);}
@Test public void testDecodeInvalid()throws Exception {final URLCodec urlCodec=new URLCodec();try {urlCodec.decode("%");fail("DecoderException should have been thrown");}catch(final DecoderException e){}try {urlCodec.decode("%A");fail("DecoderException should have been thrown");}catch(final DecoderException e){}try {urlCodec.decode("%WW");fail("DecoderException should have been thrown");}catch(final DecoderException e){}try {urlCodec.decode("%0W");fail("DecoderException should have been thrown");}catch(final DecoderException e){}this.validateState(urlCodec);}
@Test public void testDecodeInvalidContent()throws UnsupportedEncodingException,DecoderException {final String ch_msg=constructString(SWISS_GERMAN_STUFF_UNICODE);final URLCodec urlCodec=new URLCodec();final byte[]input=ch_msg.getBytes("ISO-8859-1");final byte[]output=urlCodec.decode(input);assertEquals(input.length,output.length);for (int i=0;i < input.length;i++){assertEquals(input[i],output[i]);}this.validateState(urlCodec);}
@Test public void testEncodeNull()throws Exception {final URLCodec urlCodec=new URLCodec();final byte[]plain=null;final byte[]encoded=urlCodec.encode(plain);assertEquals("Encoding a null string should return null",null,encoded);this.validateState(urlCodec);}
@Test public void testEncodeUrlWithNullBitSet()throws Exception {final URLCodec urlCodec=new URLCodec();final String plain="Hello there!";final String encoded=new String(URLCodec.encodeUrl(null,plain.getBytes(Charsets.UTF_8)));assertEquals("Basic URL encoding test","Hello+there%21",encoded);assertEquals("Basic URL decoding test",plain,urlCodec.decode(encoded));this.validateState(urlCodec);}
@Test public void testDecodeWithNullArray()throws Exception {final byte[]plain=null;final byte[]result=URLCodec.decodeUrl(plain);assertEquals("Result should be null",null,result);}
@Test public void testEncodeStringWithNull()throws Exception {final URLCodec urlCodec=new URLCodec();final String test=null;final String result=urlCodec.encode(test,"charset");assertEquals("Result should be null",null,result);}
@Test public void testDecodeStringWithNull()throws Exception {final URLCodec urlCodec=new URLCodec();final String test=null;final String result=urlCodec.decode(test,"charset");assertEquals("Result should be null",null,result);}
@Test public void testEncodeObjects()throws Exception {final URLCodec urlCodec=new URLCodec();final String plain="Hello there!";String encoded=(String)urlCodec.encode((Object)plain);assertEquals("Basic URL encoding test","Hello+there%21",encoded);final byte[]plainBA=plain.getBytes(Charsets.UTF_8);final byte[]encodedBA=(byte[])urlCodec.encode((Object)plainBA);encoded=new String(encodedBA);assertEquals("Basic URL encoding test","Hello+there%21",encoded);final Object result=urlCodec.encode((Object)null);assertEquals("Encoding a null Object should return null",null,result);try {final Object dObj=new Double(3.0);urlCodec.encode(dObj);fail("Trying to url encode a Double object should cause an exception.");}catch(final EncoderException ee){}this.validateState(urlCodec);}
@Test public void testInvalidEncoding(){final URLCodec urlCodec=new URLCodec("NONSENSE");final String plain="Hello there!";try {urlCodec.encode(plain);fail("We set the encoding to a bogus NONSENSE vlaue,this shouldn't have worked.");}catch(final EncoderException ee){}try {urlCodec.decode(plain);fail("We set the encoding to a bogus NONSENSE vlaue,this shouldn't have worked.");}catch(final DecoderException ee){}this.validateState(urlCodec);}
@Test public void testDecodeObjects()throws Exception {final URLCodec urlCodec=new URLCodec();final String plain="Hello+there%21";String decoded=(String)urlCodec.decode((Object)plain);assertEquals("Basic URL decoding test","Hello there!",decoded);final byte[]plainBA=plain.getBytes(Charsets.UTF_8);final byte[]decodedBA=(byte[])urlCodec.decode((Object)plainBA);decoded=new String(decodedBA);assertEquals("Basic URL decoding test","Hello there!",decoded);final Object result=urlCodec.decode((Object)null);assertEquals("Decoding a null Object should return null",null,result);try {final Object dObj=new Double(3.0);urlCodec.decode(dObj);fail("Trying to url encode a Double object should cause an exception.");}catch(final DecoderException ee){}this.validateState(urlCodec);}
@Test public void testDefaultEncoding()throws Exception {final String plain="Hello there!";final URLCodec urlCodec=new URLCodec("UnicodeBig");urlCodec.encode(plain);final String encoded1=urlCodec.encode(plain,"UnicodeBig");final String encoded2=urlCodec.encode(plain);assertEquals(encoded1,encoded2);this.validateState(urlCodec);}
@Test public final void testAccentRemoval_AllLower_SuccessfullyRemoved(){assertEquals("aeiou",this.getStringEncoder().removeAccents("áéíóú"));}
@Test public final void testAccentRemoval_WithSpaces_SuccessfullyRemovedAndSpacesInvariant(){assertEquals("ae io  u",this.getStringEncoder().removeAccents("áé íó  ú"));}
@Test public final void testAccentRemoval_UpperandLower_SuccessfullyRemovedAndCaseInvariant(){assertEquals("AeiOuu",this.getStringEncoder().removeAccents("ÁeíÓuu"));}
@Test public final void testAccentRemoval_MixedWithUnusualChars_SuccessfullyRemovedAndUnusualcharactersInvariant(){assertEquals("A-e'i.,o&u",this.getStringEncoder().removeAccents("Á-e'í.,ó&ú"));}
@Test public final void testAccentRemoval_GerSpanFrenMix_SuccessfullyRemoved(){assertEquals("aeoußAEOUnNa",this.getStringEncoder().removeAccents("äëöüßÄËÖÜñÑà"));}
@Test public final void testAccentRemoval_ComprehensiveAccentMix_AllSuccessfullyRemoved(){assertEquals("E,E,E,E,U,U,I,I,A,A,O,e,e,e,e,u,u,i,i,a,a,o,c",this.getStringEncoder().removeAccents("È,É,Ê,Ë,Û,Ù,Ï,Î,À,Â,Ô,è,é,ê,ë,û,ù,ï,î,à,â,ô,ç"));}
@Test public final void testAccentRemovalNormalString_NoChange(){assertEquals("Colorless green ideas sleep furiously",this.getStringEncoder().removeAccents("Colorless green ideas sleep furiously"));}
@Test public final void testAccentRemoval_NINO_NoChange(){assertEquals("",this.getStringEncoder().removeAccents(""));}
@Test public final void testAccentRemoval_NullValue_ReturnNullSuccessfully(){assertEquals(null,this.getStringEncoder().removeAccents(null));}
@Test public final void testRemoveSingleDoubleConsonants_BUBLE_RemovedSuccessfully(){assertEquals("BUBLE",this.getStringEncoder().removeDoubleConsonants("BUBBLE"));}
@Test public final void testRemoveDoubleConsonants_MISSISSIPPI_RemovedSuccessfully(){assertEquals("MISISIPI",this.getStringEncoder().removeDoubleConsonants("MISSISSIPPI"));}
@Test public final void testRemoveDoubleDoubleVowel_BEETLE_NotRemoved(){assertEquals("BEETLE",this.getStringEncoder().removeDoubleConsonants("BEETLE"));}
@Test public final void testIsVowel_CapitalA_ReturnsTrue(){assertTrue(this.getStringEncoder().isVowel("A"));}
@Test public final void testIsVowel_SmallD_ReturnsFalse(){assertFalse(this.getStringEncoder().isVowel("d"));}
@Test public final void testRemoveVowel_ALESSANDRA_Returns_ALSSNDR(){assertEquals("ALSSNDR",this.getStringEncoder().removeVowels("ALESSANDRA"));}
@Test public final void testRemoveVowel__AIDAN_Returns_ADN(){assertEquals("ADN",this.getStringEncoder().removeVowels("AIDAN"));}
@Test public final void testRemoveVowel__DECLAN_Returns_DCLN(){assertEquals("DCLN",this.getStringEncoder().removeVowels("DECLAN"));}
@Test public final void testGetFirstLast3__ALEXANDER_Returns_Aleder(){assertEquals("Aleder",this.getStringEncoder().getFirst3Last3("Alexzander"));}
@Test public final void testGetFirstLast3_PETE_Returns_PETE(){assertEquals("PETE",this.getStringEncoder().getFirst3Last3("PETE"));}
@Test public final void testleftTorightThenRightToLeft_ALEXANDER_ALEXANDRA_Returns4(){assertEquals(4,this.getStringEncoder().leftToRightThenRightToLeftProcessing("ALEXANDER","ALEXANDRA"));}
@Test public final void testleftTorightThenRightToLeft_EINSTEIN_MICHAELA_Returns0(){assertEquals(0,this.getStringEncoder().leftToRightThenRightToLeftProcessing("EINSTEIN","MICHAELA"));}
@Test public final void testGetMinRating_7_Return4_Successfully(){assertEquals(4,this.getStringEncoder().getMinRating(7));}
@Test public final void testGetMinRating_1_Returns5_Successfully(){assertEquals(5,this.getStringEncoder().getMinRating(1));}
@Test public final void testGetMinRating_2_Returns5_Successfully(){assertEquals(5,this.getStringEncoder().getMinRating(2));}
@Test public final void testgetMinRating_5_Returns4_Successfully(){assertEquals(4,this.getStringEncoder().getMinRating(5));}
@Test public final void testgetMinRating_5_Returns4_Successfully2(){assertEquals(4,this.getStringEncoder().getMinRating(5));}
@Test public final void testgetMinRating_6_Returns4_Successfully(){assertEquals(4,this.getStringEncoder().getMinRating(6));}
@Test public final void testgetMinRating_7_Returns4_Successfully(){assertEquals(4,this.getStringEncoder().getMinRating(7));}
@Test public final void testgetMinRating_8_Returns3_Successfully(){assertEquals(3,this.getStringEncoder().getMinRating(8));}
@Test public final void testgetMinRating_10_Returns3_Successfully(){assertEquals(3,this.getStringEncoder().getMinRating(10));}
@Test public final void testgetMinRating_11_Returns_3_Successfully(){assertEquals(3,this.getStringEncoder().getMinRating(11));}
@Test public final void testGetMinRating_13_Returns_1_Successfully(){assertEquals(1,this.getStringEncoder().getMinRating(13));}
@Test public final void testcleanName_SuccessfullyClean(){assertEquals("THISISATEST",this.getStringEncoder().cleanName("This-ís   a t.,es &t"));}
@Test public final void testisVowel_SingleVowel_ReturnsTrue(){assertTrue(this.getStringEncoder().isVowel(("I")));}
@Test public final void testisEncodeEquals_CornerCase_SecondNameNothing_ReturnsFalse(){assertFalse(this.getStringEncoder().isEncodeEquals("test",""));}
@Test public final void testisEncodeEquals_CornerCase_FirstNameNothing_ReturnsFalse(){assertFalse(this.getStringEncoder().isEncodeEquals("","test"));}
@Test public final void testisEncodeEquals_CornerCase_SecondNameJustSpace_ReturnsFalse(){assertFalse(this.getStringEncoder().isEncodeEquals("test"," "));}
@Test public final void testisEncodeEquals_CornerCase_FirstNameJustSpace_ReturnsFalse(){assertFalse(this.getStringEncoder().isEncodeEquals(" ","test"));}
@Test public final void testisEncodeEquals_CornerCase_SecondNameNull_ReturnsFalse(){assertFalse(this.getStringEncoder().isEncodeEquals("test",null));}
@Test public final void testisEncodeEquals_CornerCase_FirstNameNull_ReturnsFalse(){assertFalse(this.getStringEncoder().isEncodeEquals(null,"test"));}
@Test public final void testisEncodeEquals_CornerCase_FirstNameJust1Letter_ReturnsFalse(){assertFalse(this.getStringEncoder().isEncodeEquals("t","test"));}
@Test public final void testisEncodeEqualsSecondNameJust1Letter_ReturnsFalse(){assertFalse(this.getStringEncoder().isEncodeEquals("test","t"));}
@Test public final void testGetEncoding_HARPER_HRPR(){assertEquals("HRPR",this.getStringEncoder().encode("HARPER"));}
@Test public final void testGetEncoding_SMITH_to_SMTH(){assertEquals("SMTH",this.getStringEncoder().encode("Smith"));}
@Test public final void testGetEncoding_SMYTH_to_SMYTH(){assertEquals("SMYTH",this.getStringEncoder().encode("Smyth"));}
@Test public final void testGetEncoding_Space_to_Nothing(){assertEquals("",this.getStringEncoder().encode(" "));}
@Test public final void testGetEncoding_NoSpace_to_Nothing(){assertEquals("",this.getStringEncoder().encode(""));}
@Test public final void testGetEncoding_Null_to_Nothing(){assertEquals("",this.getStringEncoder().encode(null));}
@Test public final void testGetEncoding_One_Letter_to_Nothing(){assertEquals("",this.getStringEncoder().encode("E"));}
@Test public final void testCompareNameNullSpace_ReturnsFalseSuccessfully(){assertFalse(getStringEncoder().isEncodeEquals(null," "));}
@Test public final void testCompareNameSameNames_ReturnsFalseSuccessfully(){assertTrue(getStringEncoder().isEncodeEquals("John","John"));}
@Test public final void testCompare_SMITH_SMYTH_SuccessfullyMatched(){assertTrue(this.getStringEncoder().isEncodeEquals("smith","smyth"));}
@Test public final void testCompare_BURNS_BOURNE_SuccessfullyMatched(){assertTrue(this.getStringEncoder().isEncodeEquals("Burns","Bourne"));}
@Test public final void testCompare_ShortNames_AL_ED_WorksButNoMatch(){assertFalse(this.getStringEncoder().isEncodeEquals("Al","Ed"));}
@Test public final void testCompare_CATHERINE_KATHRYN_SuccessfullyMatched(){assertTrue(this.getStringEncoder().isEncodeEquals("Catherine","Kathryn"));}
@Test public final void testCompare_BRIAN_BRYAN_SuccessfullyMatched(){assertTrue(this.getStringEncoder().isEncodeEquals("Brian","Bryan"));}
@Test public final void testCompare_SEAN_SHAUN_SuccessfullyMatched(){assertTrue(this.getStringEncoder().isEncodeEquals("Séan","Shaun"));}
@Test public final void testCompare_COLM_COLIN_WithAccentsAndSymbolsAndSpaces_SuccessfullyMatched(){assertTrue(this.getStringEncoder().isEncodeEquals("Cólm.   ","C-olín"));}
@Test public final void testCompare_STEPHEN_STEVEN_SuccessfullyMatched(){assertTrue(this.getStringEncoder().isEncodeEquals("Stephen","Steven"));}
@Test public final void testCompare_STEVEN_STEFAN_SuccessfullyMatched(){assertTrue(this.getStringEncoder().isEncodeEquals("Steven","Stefan"));}
@Test public final void testCompare_STEPHEN_STEFAN_SuccessfullyMatched(){assertTrue(this.getStringEncoder().isEncodeEquals("Stephen","Stefan"));}
@Test public final void testCompare_SAM_SAMUEL_SuccessfullyMatched(){assertTrue(this.getStringEncoder().isEncodeEquals("Sam","Samuel"));}
@Test public final void testCompare_MICKY_MICHAEL_SuccessfullyMatched(){assertTrue(this.getStringEncoder().isEncodeEquals("Micky","Michael"));}
@Test public final void testCompare_OONA_OONAGH_SuccessfullyMatched(){assertTrue(this.getStringEncoder().isEncodeEquals("Oona","Oonagh"));}
@Test public final void testCompare_SOPHIE_SOFIA_SuccessfullyMatched(){assertTrue(this.getStringEncoder().isEncodeEquals("Sophie","Sofia"));}
@Test public final void testCompare_FRANCISZEK_FRANCES_SuccessfullyMatched(){assertTrue(this.getStringEncoder().isEncodeEquals("Franciszek","Frances"));}
@Test public final void testCompare_TOMASZ_TOM_SuccessfullyMatched(){assertTrue(this.getStringEncoder().isEncodeEquals("Tomasz","tom"));}
@Test public final void testCompare_SmallInput_CARK_Kl_SuccessfullyMatched(){assertTrue(this.getStringEncoder().isEncodeEquals("Kl","Karl"));}
@Test public final void testCompareNameToSingleLetter_KARL_C_DoesNotMatch(){assertFalse(this.getStringEncoder().isEncodeEquals("Karl","C"));}
@Test public final void testCompare_ZACH_ZAKARIA_SuccessfullyMatched(){assertTrue(this.getStringEncoder().isEncodeEquals("Zach","Zacharia"));}
@Test public final void testCompare_KARL_ALESSANDRO_DoesNotMatch(){assertFalse(this.getStringEncoder().isEncodeEquals("Karl","Alessandro"));}
@Test public final void testCompare_Forenames_UNA_OONAGH_ShouldSuccessfullyMatchButDoesNot(){assertFalse(this.getStringEncoder().isEncodeEquals("Úna","Oonagh"));}
@Test public final void testCompare_Surname_OSULLIVAN_OSUILLEABHAIN_SuccessfulMatch(){assertTrue(this.getStringEncoder().isEncodeEquals("O'Sullivan","Ó ' Súilleabháin"));}
@Test public final void testCompare_LongSurnames_MORIARTY_OMUIRCHEARTAIGH_DoesNotSuccessfulMatch(){assertFalse(this.getStringEncoder().isEncodeEquals("Moriarty","OMuircheartaigh"));}
@Test public final void testCompare_LongSurnames_OMUIRCHEARTAIGH_OMIREADHAIGH_SuccessfulMatch(){assertTrue(this.getStringEncoder().isEncodeEquals("o'muireadhaigh","Ó 'Muircheartaigh "));}
@Test public final void testCompare_Surname_COOPERFLYNN_SUPERLYN_SuccessfullyMatched(){assertTrue(this.getStringEncoder().isEncodeEquals("Cooper-Flynn","Super-Lyn"));}
@Test public final void testCompare_Surname_HAILEY_HALLEY_SuccessfullyMatched(){assertTrue(this.getStringEncoder().isEncodeEquals("Hailey","Halley"));}
@Test public final void testCompare_Surname_AUERBACH_UHRBACH_SuccessfullyMatched(){assertTrue(this.getStringEncoder().isEncodeEquals("Auerbach","Uhrbach"));}
@Test public final void testCompare_Surname_MOSKOWITZ_MOSKOVITZ_SuccessfullyMatched(){assertTrue(this.getStringEncoder().isEncodeEquals("Moskowitz","Moskovitz"));}
@Test public final void testCompare_Surname_LIPSHITZ_LIPPSZYC_SuccessfullyMatched(){assertTrue(this.getStringEncoder().isEncodeEquals("LIPSHITZ","LIPPSZYC"));}
@Test public final void testCompare_Surname_LEWINSKY_LEVINSKI_SuccessfullyMatched(){assertTrue(this.getStringEncoder().isEncodeEquals("LEWINSKY","LEVINSKI"));}
@Test public final void testCompare_Surname_SZLAMAWICZ_SHLAMOVITZ_SuccessfullyMatched(){assertTrue(this.getStringEncoder().isEncodeEquals("SZLAMAWICZ","SHLAMOVITZ"));}
@Test public final void testCompare_Surname_ROSOCHOWACIEC_ROSOKHOVATSETS_SuccessfullyMatched(){assertTrue(this.getStringEncoder().isEncodeEquals("R o s o ch o w a c ie c"," R o s o k ho v a ts e ts"));}
@Test public final void testCompare_Surname_PRZEMYSL_PSHEMESHIL_SuccessfullyMatched(){assertTrue(this.getStringEncoder().isEncodeEquals(" P rz e m y s l"," P sh e m e sh i l"));}
@Test public final void testCompare_PETERSON_PETERS_SuccessfullyMatched(){assertTrue(this.getStringEncoder().isEncodeEquals("Peterson","Peters"));}
@Test public final void testCompare_MCGOWAN_MCGEOGHEGAN_SuccessfullyMatched(){assertTrue(this.getStringEncoder().isEncodeEquals("McGowan","Mc Geoghegan"));}
@Test public final void testCompare_SurnamesCornerCase_MURPHY_Space_NoMatch(){assertFalse(this.getStringEncoder().isEncodeEquals("Murphy"," "));}
@Test public final void testCompare_SurnamesCornerCase_MURPHY_NoSpace_NoMatch(){assertFalse(this.getStringEncoder().isEncodeEquals("Murphy",""));}
@Test public final void testCompare_SurnameCornerCase_Nulls_NoMatch(){assertFalse(this.getStringEncoder().isEncodeEquals(null,null));}
@Test public final void testCompare_Surnames_MURPHY_LYNCH_NoMatchExpected(){assertFalse(this.getStringEncoder().isEncodeEquals("Murphy","Lynch"));}
@Test public final void testCompare_Forenames_SEAN_JOHN_MatchExpected(){assertTrue(this.getStringEncoder().isEncodeEquals("Sean","John"));}
@Test public final void testCompare_Forenames_SEAN_PETE_NoMatchExpected(){assertFalse(this.getStringEncoder().isEncodeEquals("Sean","Pete"));}
@Test public void testSha512CryptStrings(){assertEquals("$6$foo$Nywkte7LPWjaJhWjNeGJN.dFdY3pN1wYlGifyRLYOVlGS9EMSiZaDDe/BGSOYQ327q9.32I4UqQ5odsqvsBLX/",Crypt.crypt("","$6$foo"));assertEquals("$6$45678$f2en/Y053Knir/wu/T8DQKSbiUGcPcbXKsmyVlP820dIpXoY0KlqgUqRVFfavdRXwDMUZYsxPOymA4zgX0qE5.",Crypt.crypt("secret","$6$45678"));assertEquals("$6$45678$f2en/Y053Knir/wu/T8DQKSbiUGcPcbXKsmyVlP820dIpXoY0KlqgUqRVFfavdRXwDMUZYsxPOymA4zgX0qE5.",Crypt.crypt("secret","$6$45678$012"));assertEquals("$6$45678$f2en/Y053Knir/wu/T8DQKSbiUGcPcbXKsmyVlP820dIpXoY0KlqgUqRVFfavdRXwDMUZYsxPOymA4zgX0qE5.",Crypt.crypt("secret","$6$45678$012$456"));assertEquals("$6$1234567890123456$d2HCAnimIF5VMqUnwaZ/4JhNDJ.ttsjm0nbbmc9eE7xUYiw79GMvXUc5ZqG5BlqkXSbASZxrvR0QefAgdLbeH.",Crypt.crypt("secret","$6$1234567890123456"));assertEquals("$6$1234567890123456$d2HCAnimIF5VMqUnwaZ/4JhNDJ.ttsjm0nbbmc9eE7xUYiw79GMvXUc5ZqG5BlqkXSbASZxrvR0QefAgdLbeH.",Crypt.crypt("secret","$6$1234567890123456789"));}
@Test public void testSha512CryptBytes(){assertEquals("$6$foo$Nywkte7LPWjaJhWjNeGJN.dFdY3pN1wYlGifyRLYOVlGS9EMSiZaDDe/BGSOYQ327q9.32I4UqQ5odsqvsBLX/",Crypt.crypt(new byte[0],"$6$foo"));assertEquals("$6$./$fKtWqslQkwI8ZxjdWoeS.jHHrte97bZxiwB5gwCRHX6LG62fUhT6Bb5MRrjWvieh0C/gxh8ItFuTsVy80VrED1",Crypt.crypt("t\u00e4st","$6$./$"));assertEquals("$6$./$L49DSK.d2df/LxGLJQMyS5A/Um.TdHqgc46j5FpScEPlqQHP5dEazltaDNDZ6UEs2mmNI6kPwtH/rsP9g5zBI.",Crypt.crypt("t\u00e4st".getBytes(Charsets.ISO_8859_1),"$6$./$"));}
@Test public void testSha512CryptExplicitCall(){assertTrue(Sha2Crypt.sha512Crypt("secret".getBytes()).matches("^\\$6\\$[a-zA-Z0-9./]{0,16}\\$.{1,}$"));assertTrue(Sha2Crypt.sha512Crypt("secret".getBytes(),null).matches("^\\$6\\$[a-zA-Z0-9./]{0,16}\\$.{1,}$"));}
@Test(expected=NullPointerException.class)public void testSha512CryptNullData(){Sha2Crypt.sha512Crypt((byte[])null);}
@Ignore public void testSha512CryptNullSalt(){}
@Test public void testSha2CryptRounds(){assertEquals("$5$rounds=1000$abcd$b8MCU4GEeZIekOy5ahQ8EWfT330hvYGVeDYkBxXBva.",Sha2Crypt.sha256Crypt("secret".getBytes(Charsets.UTF_8),"$5$rounds=50$abcd$"));assertEquals("$5$rounds=1001$abcd$SQsJZs7KXKdd2DtklI3TY3tkD7UYA99RD0FBLm4Sk48",Sha2Crypt.sha256Crypt("secret".getBytes(Charsets.UTF_8),"$5$rounds=1001$abcd$"));assertEquals("$5$rounds=9999$abcd$Rh/8ngVh9oyuS6lL3.fsq.9xbvXJsfyKWxSjO2mPIa7",Sha2Crypt.sha256Crypt("secret".getBytes(Charsets.UTF_8),"$5$rounds=9999$abcd"));}
@Test(expected=IllegalArgumentException.class)public void testSha2CryptWrongSalt(){Sha2Crypt.sha512Crypt("secret".getBytes(Charsets.UTF_8),"xx");}
@Test(expected=IllegalArgumentException.class)public void testSha512CryptWithEmptySalt(){Sha2Crypt.sha512Crypt("secret".getBytes(),"");}
@Test public void testSha256LargetThanBlocksize(){final byte[]buffer=new byte[200];Arrays.fill(buffer,0,200,(byte)'A');assertEquals("$6$abc$oP/h8PRhCKIA66KSTjGwNsQMSLLZnuFOTjOhrqNrDkKgjTlpePSqibB0qtmDapMbP/zN1cUEYSeHFrpgqZ.GG1",Sha2Crypt.sha512Crypt(buffer,"$6$abc"));}
@Test public void testCustomCharset()throws UnsupportedEncodingException,DecoderException {for(final String name : Charset.availableCharsets().keySet()){testCustomCharset(name,"testCustomCharset");}}
@Test(expected=UnsupportedCharsetException.class)public void testCustomCharsetBadName(){new Hex(BAD_ENCODING_NAME);}
@Test public void testCustomCharsetToString(){assertTrue(new Hex().toString().indexOf(Hex.DEFAULT_CHARSET_NAME)>= 0);}
@Test public void testDecodeArrayOddCharacters(){try {new Hex().decode(new byte[]{65});fail("An exception wasn't thrown when trying to decode an odd number of characters");}catch(final DecoderException e){}}
@Test public void testDecodeBadCharacterPos0(){try {new Hex().decode("q0");fail("An exception wasn't thrown when trying to decode an illegal character");}catch(final DecoderException e){}}
@Test public void testDecodeBadCharacterPos1(){try {new Hex().decode("0q");fail("An exception wasn't thrown when trying to decode an illegal character");}catch(final DecoderException e){}}
@Test public void testDecodeClassCastException(){try {new Hex().decode(new int[]{65});fail("An exception wasn't thrown when trying to decode.");}catch(final DecoderException e){}}
@Test public void testDecodeHexOddCharacters1(){checkDecodeHexOddCharacters(new char[]{'A'});}
@Test public void testDecodeHexOddCharacters3(){checkDecodeHexOddCharacters(new char[]{'A','B','C'});}
@Test public void testDecodeHexOddCharacters5(){checkDecodeHexOddCharacters(new char[]{'A','B','C','D','E'});}
@Test public void testDecodeStringOddCharacters(){try {new Hex().decode("6");fail("An exception wasn't thrown when trying to decode an odd number of characters");}catch(final DecoderException e){}}
@Test public void testDencodeEmpty()throws DecoderException {assertTrue(Arrays.equals(new byte[0],Hex.decodeHex(new char[0])));assertTrue(Arrays.equals(new byte[0],new Hex().decode(new byte[0])));assertTrue(Arrays.equals(new byte[0],(byte[])new Hex().decode("")));}
@Test public void testEncodeClassCastException(){try {new Hex().encode(new int[]{65});fail("An exception wasn't thrown when trying to encode.");}catch(final EncoderException e){}}
@Test public void testEncodeDecodeRandom()throws DecoderException,EncoderException {final Random random=new Random();final Hex hex=new Hex();for (int i=5;i > 0;i--){final byte[]data=new byte[random.nextInt(10000)+ 1];random.nextBytes(data);final char[]encodedChars=Hex.encodeHex(data);byte[]decodedBytes=Hex.decodeHex(encodedChars);assertTrue(Arrays.equals(data,decodedBytes));final byte[]encodedStringBytes=hex.encode(data);decodedBytes=hex.decode(encodedStringBytes);assertTrue(Arrays.equals(data,decodedBytes));String dataString=new String(encodedChars);char[]encodedStringChars=(char[])hex.encode(dataString);decodedBytes=(byte[])hex.decode(encodedStringChars);assertTrue(Arrays.equals(StringUtils.getBytesUtf8(dataString),decodedBytes));dataString=new String(encodedChars);encodedStringChars=(char[])hex.encode(dataString);decodedBytes=(byte[])hex.decode(new String(encodedStringChars));assertTrue(Arrays.equals(StringUtils.getBytesUtf8(dataString),decodedBytes));}}
@Test public void testEncodeEmpty()throws EncoderException {assertTrue(Arrays.equals(new char[0],Hex.encodeHex(new byte[0])));assertTrue(Arrays.equals(new byte[0],new Hex().encode(new byte[0])));assertTrue(Arrays.equals(new char[0],(char[])new Hex().encode("")));}
@Test public void testEncodeZeroes(){final char[]c=Hex.encodeHex(new byte[36]);assertEquals("000000000000000000000000000000000000000000000000000000000000000000000000",new String(c));}
@Test public void testHelloWorldLowerCaseHex(){final byte[]b=StringUtils.getBytesUtf8("Hello World");final String expected="48656c6c6f20576f726c64";char[]actual;actual=Hex.encodeHex(b);assertEquals(expected,new String(actual));actual=Hex.encodeHex(b,true);assertEquals(expected,new String(actual));actual=Hex.encodeHex(b,false);assertFalse(expected.equals(new String(actual)));}
@Test public void testHelloWorldUpperCaseHex(){final byte[]b=StringUtils.getBytesUtf8("Hello World");final String expected="48656C6C6F20576F726C64";char[]actual;actual=Hex.encodeHex(b);assertFalse(expected.equals(new String(actual)));actual=Hex.encodeHex(b,true);assertFalse(expected.equals(new String(actual)));actual=Hex.encodeHex(b,false);assertTrue(expected.equals(new String(actual)));}
@Test public void testRequiredCharset()throws UnsupportedEncodingException,DecoderException {testCustomCharset("UTF-8","testRequiredCharset");testCustomCharset("UTF-16","testRequiredCharset");testCustomCharset("UTF-16BE","testRequiredCharset");testCustomCharset("UTF-16LE","testRequiredCharset");testCustomCharset("US-ASCII","testRequiredCharset");testCustomCharset("ISO8859_1","testRequiredCharset");}
@Test public void testSolrGENERIC(){Map<String,String> args;args=new TreeMap<String,String>();args.put("nameType","GENERIC");assertEquals(encode(args,true,"Angelo"),"agilo|angilo|aniilo|anilo|anxilo|anzilo|ogilo|ongilo|oniilo|onilo|onxilo|onzilo");args.put("ruleType","EXACT");assertEquals(encode(args,true,"Angelo"),"anZelo|andZelo|angelo|anhelo|anjelo|anxelo");assertEquals(encode(args,true,"D'Angelo"),"(anZelo|andZelo|angelo|anhelo|anjelo|anxelo)-(danZelo|dandZelo|dangelo|danhelo|danjelo|danxelo)");args.put("languageSet","italian,greek,spanish");assertEquals(encode(args,true,"Angelo"),"andZelo|angelo|anxelo");assertEquals(encode(args,true,"1234"),"");args=new TreeMap<String,String>();assertEquals(encode(args,false,"Angelo"),"agilo|angilo|aniilo|anilo|anxilo|anzilo|ogilo|ongilo|oniilo|onilo|onxilo|onzilo");args.put("ruleType","EXACT");assertEquals(encode(args,false,"Angelo"),"anZelo|andZelo|angelo|anhelo|anjelo|anxelo");assertEquals(encode(args,false,"D'Angelo"),"(anZelo|andZelo|angelo|anhelo|anjelo|anxelo)-(danZelo|dandZelo|dangelo|danhelo|danjelo|danxelo)");args.put("languageSet","italian,greek,spanish");assertEquals(encode(args,false,"Angelo"),"andZelo|angelo|anxelo");assertEquals(encode(args,false,"1234"),"");args=new TreeMap<String,String>();assertEquals(encode(args,true,"Angelo"),"agilo|angilo|aniilo|anilo|anxilo|anzilo|ogilo|ongilo|oniilo|onilo|onxilo|onzilo");args.put("ruleType","APPROX");assertEquals(encode(args,true,"Angelo"),"agilo|angilo|aniilo|anilo|anxilo|anzilo|ogilo|ongilo|oniilo|onilo|onxilo|onzilo");assertEquals(encode(args,true,"D'Angelo"),"(agilo|angilo|aniilo|anilo|anxilo|anzilo|ogilo|ongilo|oniilo|onilo|onxilo|onzilo)-(dagilo|dangilo|daniilo|danilo|danxilo|danzilo|dogilo|dongilo|doniilo|donilo|donxilo|donzilo)");args.put("languageSet","italian,greek,spanish");assertEquals(encode(args,true,"Angelo"),"angilo|anxilo|anzilo|ongilo|onxilo|onzilo");assertEquals(encode(args,true,"1234"),"");args=new TreeMap<String,String>();assertEquals(encode(args,false,"Angelo"),"agilo|angilo|aniilo|anilo|anxilo|anzilo|ogilo|ongilo|oniilo|onilo|onxilo|onzilo");args.put("ruleType","APPROX");assertEquals(encode(args,false,"Angelo"),"agilo|angilo|aniilo|anilo|anxilo|anzilo|ogilo|ongilo|oniilo|onilo|onxilo|onzilo");assertEquals(encode(args,false,"D'Angelo"),"(agilo|angilo|aniilo|anilo|anxilo|anzilo|ogilo|ongilo|oniilo|onilo|onxilo|onzilo)-(dagilo|dangilo|daniilo|danilo|danxilo|danzilo|dogilo|dongilo|doniilo|donilo|donxilo|donzilo)");args.put("languageSet","italian,greek,spanish");assertEquals(encode(args,false,"Angelo"),"angilo|anxilo|anzilo|ongilo|onxilo|onzilo");assertEquals(encode(args,false,"1234"),"");}
@Test public void testSolrASHKENAZI(){Map<String,String> args;args=new TreeMap<String,String>();args.put("nameType","ASHKENAZI");assertEquals(encode(args,true,"Angelo"),"AnElO|AnSelO|AngElO|AngzelO|AnkselO|AnzelO");args.put("ruleType","EXACT");assertEquals(encode(args,true,"Angelo"),"andZelo|angelo|anhelo|anxelo");assertEquals(encode(args,true,"D'Angelo"),"dandZelo|dangelo|danhelo|danxelo");args.put("languageSet","italian,greek,spanish");assertEquals(encode(args,true,"Angelo"),"angelo|anxelo");assertEquals(encode(args,true,"1234"),"");args=new TreeMap<String,String>();args.put("nameType","ASHKENAZI");assertEquals(encode(args,false,"Angelo"),"AnElO|AnSelO|AngElO|AngzelO|AnkselO|AnzelO");args.put("ruleType","EXACT");assertEquals(encode(args,false,"Angelo"),"andZelo|angelo|anhelo|anxelo");assertEquals(encode(args,false,"D'Angelo"),"dandZelo|dangelo|danhelo|danxelo");args.put("languageSet","italian,greek,spanish");assertEquals(encode(args,false,"Angelo"),"angelo|anxelo");assertEquals(encode(args,false,"1234"),"");args=new TreeMap<String,String>();args.put("nameType","ASHKENAZI");assertEquals(encode(args,true,"Angelo"),"AnElO|AnSelO|AngElO|AngzelO|AnkselO|AnzelO");args.put("ruleType","APPROX");assertEquals(encode(args,true,"Angelo"),"AnElO|AnSelO|AngElO|AngzelO|AnkselO|AnzelO");assertEquals(encode(args,true,"D'Angelo"),"dAnElO|dAnSelO|dAngElO|dAngzelO|dAnkselO|dAnzelO");args.put("languageSet","italian,greek,spanish");assertEquals(encode(args,true,"Angelo"),"AnSelO|AngElO|AngzelO|AnkselO");assertEquals(encode(args,true,"1234"),"");args=new TreeMap<String,String>();args.put("nameType","ASHKENAZI");assertEquals(encode(args,false,"Angelo"),"AnElO|AnSelO|AngElO|AngzelO|AnkselO|AnzelO");args.put("ruleType","APPROX");assertEquals(encode(args,false,"Angelo"),"AnElO|AnSelO|AngElO|AngzelO|AnkselO|AnzelO");assertEquals(encode(args,false,"D'Angelo"),"dAnElO|dAnSelO|dAngElO|dAngzelO|dAnkselO|dAnzelO");args.put("languageSet","italian,greek,spanish");assertEquals(encode(args,false,"Angelo"),"AnSelO|AngElO|AngzelO|AnkselO");assertEquals(encode(args,false,"1234"),"");}
@Test public void testSolrSEPHARDIC(){Map<String,String> args;args=new TreeMap<String,String>();args.put("nameType","SEPHARDIC");assertEquals(encode(args,true,"Angelo"),"anhila|anhilu|anzila|anzilu|nhila|nhilu|nzila|nzilu");args.put("ruleType","EXACT");assertEquals(encode(args,true,"Angelo"),"anZelo|andZelo|anxelo");assertEquals(encode(args,true,"D'Angelo"),"anZelo|andZelo|anxelo");args.put("languageSet","italian,greek,spanish");assertEquals(encode(args,true,"Angelo"),"andZelo|anxelo");assertEquals(encode(args,true,"1234"),"");args=new TreeMap<String,String>();args.put("nameType","SEPHARDIC");assertEquals(encode(args,false,"Angelo"),"anhila|anhilu|anzila|anzilu|nhila|nhilu|nzila|nzilu");args.put("ruleType","EXACT");assertEquals(encode(args,false,"Angelo"),"anZelo|andZelo|anxelo");assertEquals(encode(args,false,"D'Angelo"),"danZelo|dandZelo|danxelo");args.put("languageSet","italian,greek,spanish");assertEquals(encode(args,false,"Angelo"),"andZelo|anxelo");assertEquals(encode(args,false,"1234"),"");args=new TreeMap<String,String>();args.put("nameType","SEPHARDIC");assertEquals(encode(args,true,"Angelo"),"anhila|anhilu|anzila|anzilu|nhila|nhilu|nzila|nzilu");args.put("ruleType","APPROX");assertEquals(encode(args,true,"Angelo"),"anhila|anhilu|anzila|anzilu|nhila|nhilu|nzila|nzilu");assertEquals(encode(args,true,"D'Angelo"),"anhila|anhilu|anzila|anzilu|nhila|nhilu|nzila|nzilu");args.put("languageSet","italian,greek,spanish");assertEquals(encode(args,true,"Angelo"),"anhila|anhilu|anzila|anzilu|nhila|nhilu|nzila|nzilu");assertEquals(encode(args,true,"1234"),"");args=new TreeMap<String,String>();args.put("nameType","SEPHARDIC");assertEquals(encode(args,false,"Angelo"),"anhila|anhilu|anzila|anzilu|nhila|nhilu|nzila|nzilu");args.put("ruleType","APPROX");assertEquals(encode(args,false,"Angelo"),"anhila|anhilu|anzila|anzilu|nhila|nhilu|nzila|nzilu");assertEquals(encode(args,false,"D'Angelo"),"danhila|danhilu|danzila|danzilu|nhila|nhilu|nzila|nzilu");args.put("languageSet","italian,greek,spanish");assertEquals(encode(args,false,"Angelo"),"anhila|anhilu|anzila|anzilu|nhila|nhilu|nzila|nzilu");assertEquals(encode(args,false,"1234"),"");}
@Test public void testToCharset(){Assert.assertEquals(Charset.defaultCharset(),Charsets.toCharset((String)null));Assert.assertEquals(Charset.defaultCharset(),Charsets.toCharset((Charset)null));Assert.assertEquals(Charset.defaultCharset(),Charsets.toCharset(Charset.defaultCharset()));Assert.assertEquals(Charset.forName("UTF-8"),Charsets.toCharset(Charset.forName("UTF-8")));}
@Test public void testIso8859_1(){Assert.assertEquals("ISO-8859-1",Charsets.ISO_8859_1.name());}
@Test public void testUsAscii(){Assert.assertEquals("US-ASCII",Charsets.US_ASCII.name());}
@Test public void testUtf16(){Assert.assertEquals("UTF-16",Charsets.UTF_16.name());}
@Test public void testUtf16Be(){Assert.assertEquals("UTF-16BE",Charsets.UTF_16BE.name());}
@Test public void testUtf16Le(){Assert.assertEquals("UTF-16LE",Charsets.UTF_16LE.name());}
@Test public void testUtf8(){Assert.assertEquals("UTF-8",Charsets.UTF_8.name());}
@Test public void testBase32Samples()throws Exception {final Base32 codec=new Base32();for(final String[]element : BASE32_TEST_CASES){assertEquals(element[1],codec.encodeAsString(element[0].getBytes(Charsets.UTF_8)));}}
@Test public void testBase32HexSamples()throws Exception {final Base32 codec=new Base32(true);for(final String[]element : BASE32HEX_TEST_CASES){assertEquals(element[1],codec.encodeAsString(element[0].getBytes(Charsets.UTF_8)));}}
@Test public void testBase32Chunked()throws Exception {final Base32 codec=new Base32(20);for(final String[]element : BASE32_TEST_CASES_CHUNKED){assertEquals(element[1],codec.encodeAsString(element[0].getBytes(Charsets.UTF_8)));}}
@Test public void testSingleCharEncoding(){for (int i=0;i < 20;i++){Base32 codec=new Base32();final BaseNCodec.Context context=new BaseNCodec.Context();final byte unencoded[]=new byte[i];final byte allInOne[]=codec.encode(unencoded);codec=new Base32();for (int j=0;j < unencoded.length;j++){codec.encode(unencoded,j,1,context);}codec.encode(unencoded,0,-1,context);final byte singly[]=new byte[allInOne.length];codec.readResults(singly,0,100,context);if (!Arrays.equals(allInOne,singly)){fail();}}}
@Test public void testRandomBytes(){for (int i=0;i < 20;i++){final Base32 codec=new Base32();final byte[][]b=Base32TestData.randomData(codec,i);assertEquals("" + i + " "+ codec.lineLength,b[1].length,codec.getEncodedLength(b[0]));}}
@Test public void testRandomBytesChunked(){for (int i=0;i < 20;i++){final Base32 codec=new Base32(10);final byte[][]b=Base32TestData.randomData(codec,i);assertEquals("" + i + " "+ codec.lineLength,b[1].length,codec.getEncodedLength(b[0]));}}
@Test public void testRandomBytesHex(){for (int i=0;i < 20;i++){final Base32 codec=new Base32(true);final byte[][]b=Base32TestData.randomData(codec,i);assertEquals("" + i + " "+ codec.lineLength,b[1].length,codec.getEncodedLength(b[0]));}}
@Test public void testBase32SamplesNonDefaultPadding()throws Exception {final Base32 codec=new Base32((byte)0x25);for(final String[]element : BASE32_PAD_TEST_CASES){assertEquals(element[1],codec.encodeAsString(element[0].getBytes(Charsets.UTF_8)));}}
/** * Test the Base32OutputStream implementation against empty input.* @throws Exception for some failure scenarios.*/@Test public void testBase32EmptyOutputStreamMimeChunkSize()throws Exception {testBase32EmptyOutputStream(BaseNCodec.MIME_CHUNK_SIZE);}
/** * Test the Base32OutputStream implementation against empty input.* @throws Exception for some failure scenarios.*/@Test public void testBase32EmptyOutputStreamPemChunkSize()throws Exception {testBase32EmptyOutputStream(BaseNCodec.PEM_CHUNK_SIZE);}
/** * Test the Base32OutputStream implementation* @throws Exception for some failure scenarios.*/@Test public void testBase32OutputStreamByChunk()throws Exception {byte[]encoded=StringUtils.getBytesUtf8(Base32TestData.BASE32_FIXTURE);byte[]decoded=StringUtils.getBytesUtf8(Base32TestData.STRING_FIXTURE);testByChunk(encoded,decoded,BaseNCodec.MIME_CHUNK_SIZE,CRLF);final BaseNCodec codec=new Base32();for (int i=0;i <= 150;i++){final byte[][]randomData=Base32TestData.randomData(codec,i);encoded=randomData[1];decoded=randomData[0];testByChunk(encoded,decoded,0,LF);}}
/** * Test the Base32OutputStream implementation* @throws Exception for some failure scenarios.*/@Test public void testBase32OutputStreamByteByByte()throws Exception {byte[]encoded=StringUtils.getBytesUtf8(Base32TestData.BASE32_FIXTURE);byte[]decoded=StringUtils.getBytesUtf8(Base32TestData.STRING_FIXTURE);testByteByByte(encoded,decoded,76,CRLF);final BaseNCodec codec=new Base32();for (int i=0;i <= 150;i++){final byte[][]randomData=Base32TestData.randomData(codec,i);encoded=randomData[1];decoded=randomData[0];testByteByByte(encoded,decoded,0,LF);}}
/** * Tests Base32OutputStream.write for expected IndexOutOfBoundsException conditions.* @throws Exception for some failure scenarios.*/@Test public void testWriteOutOfBounds()throws Exception {final byte[]buf=new byte[1024];final ByteArrayOutputStream bout=new ByteArrayOutputStream();final Base32OutputStream out=new Base32OutputStream(bout);try {out.write(buf,-1,1);fail("Expected Base32OutputStream.write(buf,-1,1)to throw a IndexOutOfBoundsException");}catch(final IndexOutOfBoundsException ioobe){}try {out.write(buf,1,-1);fail("Expected Base32OutputStream.write(buf,1,-1)to throw a IndexOutOfBoundsException");}catch(final IndexOutOfBoundsException ioobe){}try {out.write(buf,buf.length + 1,0);fail("Expected Base32OutputStream.write(buf,buf.length + 1,0)to throw a IndexOutOfBoundsException");}catch(final IndexOutOfBoundsException ioobe){}try {out.write(buf,buf.length - 1,2);fail("Expected Base32OutputStream.write(buf,buf.length - 1,2)to throw a IndexOutOfBoundsException");}catch(final IndexOutOfBoundsException ioobe){}out.close();}
/** * Tests Base32OutputStream.write(null).* @throws Exception for some failure scenarios.*/@Test public void testWriteToNullCoverage()throws Exception {final ByteArrayOutputStream bout=new ByteArrayOutputStream();final Base32OutputStream out=new Base32OutputStream(bout);try {out.write(null,0,0);fail("Expcted Base32OutputStream.write(null)to throw a NullPointerException");}catch(final NullPointerException e){}out.close();}
/** * Test the Base64OutputStream implementation against the special NPE inducing input identified in the CODEC-98 bug.* @throws Exception for some failure scenarios.*/@Test public void testCodec98NPE()throws Exception {final byte[]codec98=StringUtils.getBytesUtf8(Base64TestData.CODEC_98_NPE);final byte[]codec98_1024=new byte[1024];System.arraycopy(codec98,0,codec98_1024,0,codec98.length);final ByteArrayOutputStream data=new ByteArrayOutputStream(1024);final Base64OutputStream stream=new Base64OutputStream(data,false);stream.write(codec98_1024,0,1024);stream.close();final byte[]decodedBytes=data.toByteArray();final String decoded=StringUtils.newStringUtf8(decodedBytes);assertEquals("codec-98 NPE Base64OutputStream",Base64TestData.CODEC_98_NPE_DECODED,decoded);}
/** * Test the Base64OutputStream implementation against empty input.* @throws Exception for some failure scenarios.*/@Test public void testBase64EmptyOutputStreamMimeChunkSize()throws Exception {testBase64EmptyOutputStream(BaseNCodec.MIME_CHUNK_SIZE);}
/** * Test the Base64OutputStream implementation against empty input.* @throws Exception for some failure scenarios.*/@Test public void testBase64EmptyOutputStreamPemChunkSize()throws Exception {testBase64EmptyOutputStream(BaseNCodec.PEM_CHUNK_SIZE);}
/** * Test the Base64OutputStream implementation* @throws Exception for some failure scenarios.*/@Test public void testBase64OutputStreamByChunk()throws Exception {byte[]encoded=StringUtils.getBytesUtf8("SGVsbG8gV29ybGQ=\r\n");byte[]decoded=StringUtils.getBytesUtf8(STRING_FIXTURE);testByChunk(encoded,decoded,BaseNCodec.MIME_CHUNK_SIZE,CRLF);encoded=StringUtils.getBytesUtf8("AA==\r\n");decoded=new byte[]{(byte)0};testByChunk(encoded,decoded,BaseNCodec.MIME_CHUNK_SIZE,CRLF);encoded=StringUtils.getBytesUtf8(Base64TestData.ENCODED_64_CHARS_PER_LINE);decoded=Base64TestData.DECODED;testByChunk(encoded,decoded,BaseNCodec.PEM_CHUNK_SIZE,LF);final String singleLine=Base64TestData.ENCODED_64_CHARS_PER_LINE.replaceAll("\n","");encoded=StringUtils.getBytesUtf8(singleLine);decoded=Base64TestData.DECODED;testByChunk(encoded,decoded,0,LF);for (int i=0;i <= 150;i++){final byte[][]randomData=Base64TestData.randomData(i,false);encoded=randomData[1];decoded=randomData[0];testByChunk(encoded,decoded,0,LF);}}
/** * Test the Base64OutputStream implementation* @throws Exception for some failure scenarios.*/@Test public void testBase64OutputStreamByteByByte()throws Exception {byte[]encoded=StringUtils.getBytesUtf8("SGVsbG8gV29ybGQ=\r\n");byte[]decoded=StringUtils.getBytesUtf8(STRING_FIXTURE);testByteByByte(encoded,decoded,76,CRLF);encoded=StringUtils.getBytesUtf8("AA==\r\n");decoded=new byte[]{(byte)0};testByteByByte(encoded,decoded,76,CRLF);encoded=StringUtils.getBytesUtf8(Base64TestData.ENCODED_64_CHARS_PER_LINE);decoded=Base64TestData.DECODED;testByteByByte(encoded,decoded,64,LF);final String singleLine=Base64TestData.ENCODED_64_CHARS_PER_LINE.replaceAll("\n","");encoded=StringUtils.getBytesUtf8(singleLine);decoded=Base64TestData.DECODED;testByteByByte(encoded,decoded,0,LF);for (int i=0;i <= 150;i++){final byte[][]randomData=Base64TestData.randomData(i,false);encoded=randomData[1];decoded=randomData[0];testByteByByte(encoded,decoded,0,LF);}}
/** * Tests Base64OutputStream.write for expected IndexOutOfBoundsException conditions.* @throws Exception for some failure scenarios.*/@Test public void testWriteOutOfBounds()throws Exception {final byte[]buf=new byte[1024];final ByteArrayOutputStream bout=new ByteArrayOutputStream();final Base64OutputStream out=new Base64OutputStream(bout);try {out.write(buf,-1,1);fail("Expected Base64OutputStream.write(buf,-1,1)to throw a IndexOutOfBoundsException");}catch(final IndexOutOfBoundsException ioobe){}try {out.write(buf,1,-1);fail("Expected Base64OutputStream.write(buf,1,-1)to throw a IndexOutOfBoundsException");}catch(final IndexOutOfBoundsException ioobe){}try {out.write(buf,buf.length + 1,0);fail("Expected Base64OutputStream.write(buf,buf.length + 1,0)to throw a IndexOutOfBoundsException");}catch(final IndexOutOfBoundsException ioobe){}try {out.write(buf,buf.length - 1,2);fail("Expected Base64OutputStream.write(buf,buf.length - 1,2)to throw a IndexOutOfBoundsException");}catch(final IndexOutOfBoundsException ioobe){}out.close();}
/** * Tests Base64OutputStream.write(null).* @throws Exception for some failure scenarios.*/@Test public void testWriteToNullCoverage()throws Exception {final ByteArrayOutputStream bout=new ByteArrayOutputStream();final Base64OutputStream out=new Base64OutputStream(bout);try {out.write(null,0,0);fail("Expcted Base64OutputStream.write(null)to throw a NullPointerException");}catch(final NullPointerException e){}finally {out.close();}}
@Test public void testCtor(){assertNotNull(new Md5Crypt());}
@Test public void testMd5CryptStrings(){assertEquals("$1$foo$9mS5ExwgIECGE5YKlD5o91",Crypt.crypt("","$1$foo"));assertEquals("$1$1234$ImZYBLmYC.rbBKg9ERxX70",Crypt.crypt("secret","$1$1234"));assertEquals("$1$1234$ImZYBLmYC.rbBKg9ERxX70",Crypt.crypt("secret","$1$1234$567"));assertEquals("$1$1234$ImZYBLmYC.rbBKg9ERxX70",Crypt.crypt("secret","$1$1234$567$890"));assertEquals("$1$12345678$hj0uLpdidjPhbMMZeno8X/",Crypt.crypt("secret","$1$1234567890123456"));assertEquals("$1$12345678$hj0uLpdidjPhbMMZeno8X/",Crypt.crypt("secret","$1$123456789012345678"));}
@Test public void testMd5CryptBytes(){assertEquals("$1$foo$9mS5ExwgIECGE5YKlD5o91",Crypt.crypt(new byte[0],"$1$foo"));assertEquals("$1$./$52agTEQZs877L9jyJnCNZ1",Crypt.crypt("t\u00e4st","$1$./$"));assertEquals("$1$./$J2UbKzGe0Cpe63WZAt6p//",Crypt.crypt("t\u00e4st".getBytes(Charsets.ISO_8859_1),"$1$./$"));}
@Test public void testMd5CryptExplicitCall(){assertTrue(Md5Crypt.md5Crypt("secret".getBytes()).matches("^\\$1\\$[a-zA-Z0-9./]{0,8}\\$.{1,}$"));assertTrue(Md5Crypt.md5Crypt("secret".getBytes(),null).matches("^\\$1\\$[a-zA-Z0-9./]{0,8}\\$.{1,}$"));}
@Test public void testMd5CryptLongInput(){assertEquals("$1$1234$MoxekaNNUgfPRVqoeYjCD/",Crypt.crypt("12345678901234567890","$1$1234"));}
@Test(expected=NullPointerException.class)public void testMd5CryptNullData(){Md5Crypt.md5Crypt((byte[])null);}
@Test(expected=IllegalArgumentException.class)public void testMd5CryptWithEmptySalt(){Md5Crypt.md5Crypt("secret".getBytes(),"");}
/** * We could make the constructor private but there does not seem to be a point to jumping through extra code hoops to restrict instantiation right now.*/@Test public void testConstructor(){new StringUtils();}
@Test public void testGetBytesIso8859_1()throws UnsupportedEncodingException {final String charsetName="ISO-8859-1";testGetBytesUnchecked(charsetName);final byte[]expected=STRING_FIXTURE.getBytes(charsetName);final byte[]actual=StringUtils.getBytesIso8859_1(STRING_FIXTURE);Assert.assertTrue(Arrays.equals(expected,actual));}
@Test public void testGetBytesUsAscii()throws UnsupportedEncodingException {final String charsetName="US-ASCII";testGetBytesUnchecked(charsetName);final byte[]expected=STRING_FIXTURE.getBytes(charsetName);final byte[]actual=StringUtils.getBytesUsAscii(STRING_FIXTURE);Assert.assertTrue(Arrays.equals(expected,actual));}
@Test public void testGetBytesUtf16()throws UnsupportedEncodingException {final String charsetName="UTF-16";testGetBytesUnchecked(charsetName);final byte[]expected=STRING_FIXTURE.getBytes(charsetName);final byte[]actual=StringUtils.getBytesUtf16(STRING_FIXTURE);Assert.assertTrue(Arrays.equals(expected,actual));}
@Test public void testGetBytesUtf16Be()throws UnsupportedEncodingException {final String charsetName="UTF-16BE";testGetBytesUnchecked(charsetName);final byte[]expected=STRING_FIXTURE.getBytes(charsetName);final byte[]actual=StringUtils.getBytesUtf16Be(STRING_FIXTURE);Assert.assertTrue(Arrays.equals(expected,actual));}
@Test public void testGetBytesUtf16Le()throws UnsupportedEncodingException {final String charsetName="UTF-16LE";testGetBytesUnchecked(charsetName);final byte[]expected=STRING_FIXTURE.getBytes(charsetName);final byte[]actual=StringUtils.getBytesUtf16Le(STRING_FIXTURE);Assert.assertTrue(Arrays.equals(expected,actual));}
@Test public void testGetBytesUtf8()throws UnsupportedEncodingException {final String charsetName="UTF-8";testGetBytesUnchecked(charsetName);final byte[]expected=STRING_FIXTURE.getBytes(charsetName);final byte[]actual=StringUtils.getBytesUtf8(STRING_FIXTURE);Assert.assertTrue(Arrays.equals(expected,actual));}
@Test public void testGetBytesUncheckedBadName(){try {StringUtils.getBytesUnchecked(STRING_FIXTURE,"UNKNOWN");Assert.fail("Expected " + IllegalStateException.class.getName());}catch(final IllegalStateException e){}}
@Test public void testGetBytesUncheckedNullInput(){Assert.assertNull(StringUtils.getBytesUnchecked(null,"UNKNOWN"));}
@Test public void testNewStringBadEnc(){try {StringUtils.newString(BYTES_FIXTURE,"UNKNOWN");Assert.fail("Expected " + IllegalStateException.class.getName());}catch(final IllegalStateException e){}}
@Test public void testNewStringNullInput(){Assert.assertNull(StringUtils.newString(null,"UNKNOWN"));}
@Test public void testNewStringIso8859_1()throws UnsupportedEncodingException {final String charsetName="ISO-8859-1";testNewString(charsetName);final String expected=new String(BYTES_FIXTURE,charsetName);final String actual=StringUtils.newStringIso8859_1(BYTES_FIXTURE);Assert.assertEquals(expected,actual);}
@Test public void testNewStringUsAscii()throws UnsupportedEncodingException {final String charsetName="US-ASCII";testNewString(charsetName);final String expected=new String(BYTES_FIXTURE,charsetName);final String actual=StringUtils.newStringUsAscii(BYTES_FIXTURE);Assert.assertEquals(expected,actual);}
@Test public void testNewStringUtf16()throws UnsupportedEncodingException {final String charsetName="UTF-16";testNewString(charsetName);final String expected=new String(BYTES_FIXTURE,charsetName);final String actual=StringUtils.newStringUtf16(BYTES_FIXTURE);Assert.assertEquals(expected,actual);}
@Test public void testNewStringUtf16Be()throws UnsupportedEncodingException {final String charsetName="UTF-16BE";testNewString(charsetName);final String expected=new String(BYTES_FIXTURE_16BE,charsetName);final String actual=StringUtils.newStringUtf16Be(BYTES_FIXTURE_16BE);Assert.assertEquals(expected,actual);}
@Test public void testNewStringUtf16Le()throws UnsupportedEncodingException {final String charsetName="UTF-16LE";testNewString(charsetName);final String expected=new String(BYTES_FIXTURE_16LE,charsetName);final String actual=StringUtils.newStringUtf16Le(BYTES_FIXTURE_16LE);Assert.assertEquals(expected,actual);}
@Test public void testNewStringUtf8()throws UnsupportedEncodingException {final String charsetName="UTF-8";testNewString(charsetName);final String expected=new String(BYTES_FIXTURE,charsetName);final String actual=StringUtils.newStringUtf8(BYTES_FIXTURE);Assert.assertEquals(expected,actual);}
/** * Tests we do not blow up.* @throws EncoderException*/@Test public void testAllChars()throws EncoderException {final BeiderMorseEncoder bmpm=createGenericApproxEncoder();for (char c=Character.MIN_VALUE;c < Character.MAX_VALUE;c++){bmpm.encode(Character.toString(c));}}
@Test public void testAsciiEncodeNotEmpty1Letter()throws EncoderException {final BeiderMorseEncoder bmpm=createGenericApproxEncoder();for (char c='a';c <= 'z';c++){final String value=Character.toString(c);final String valueU=value.toUpperCase();assertNotEmpty(bmpm,value);assertNotEmpty(bmpm,valueU);}}
@Test public void testAsciiEncodeNotEmpty2Letters()throws EncoderException {final BeiderMorseEncoder bmpm=createGenericApproxEncoder();for (char c1='a';c1 <= 'z';c1++){for (char c2='a';c2 <= 'z';c2++){final String value=new String(new char[]{c1,c2});final String valueU=value.toUpperCase();assertNotEmpty(bmpm,value);assertNotEmpty(bmpm,valueU);}}}
@Test public void testEncodeAtzNotEmpty()throws EncoderException {final BeiderMorseEncoder bmpm=createGenericApproxEncoder();final String[]names={"\u00e1cz","\u00e1tz","Ign\u00e1cz","Ign\u00e1tz","Ign\u00e1c"};for(final String name : names){assertNotEmpty(bmpm,name);}}
/** * Tests https://issues.apache.org/jira/browse/CODEC-125?focusedCommentId=13071566&page=com.atlassian.jira.plugin.system.issuetabpanels: comment-tabpanel#comment-13071566* @throws EncoderException*/@Test public void testEncodeGna()throws EncoderException {final BeiderMorseEncoder bmpm=createGenericApproxEncoder();bmpm.encode("gna");}
@Test(expected=IllegalArgumentException.class)public void testInvalidLangIllegalArgumentException(){Rule.getInstance(NameType.GENERIC,RuleType.APPROX,"noSuchLanguage");}
@Test(expected=IllegalStateException.class)public void testInvalidLangIllegalStateException(){Lang.loadFromResource("thisIsAMadeUpResourceName",Languages.getInstance(NameType.GENERIC));}
@Test(expected=IllegalArgumentException.class)public void testInvalidLanguageIllegalArgumentException(){Languages.getInstance("thereIsNoSuchLanguage");}
@Test(timeout=10000L)public void testLongestEnglishSurname()throws EncoderException {final BeiderMorseEncoder bmpm=createGenericApproxEncoder();bmpm.encode("MacGhilleseatheanaich");}
@Test(expected=IndexOutOfBoundsException.class)public void testNegativeIndexForRuleMatchIndexOutOfBoundsException(){final Rule r=new Rule("a","","",new Rule.Phoneme("",Languages.ANY_LANGUAGE));r.patternAndContextMatches("bob",-1);}
@Test public void testOOM()throws EncoderException {final String phrase="200697900'-->&#1913348150;</  bceaeef >aadaabcf\"aedfbff<!--\'-->?>cae" + "cfaaa><?&#<!--</script>&lang&fc;aadeaf?>>&bdquo<    cc =\"abff\"    /></   afe  >" + "<script><!-- f(';<    cf aefbeef = \"bfabadcf\" ebbfeedd = fccabeb >";final BeiderMorseEncoder encoder=new BeiderMorseEncoder();encoder.setNameType(NameType.GENERIC);encoder.setRuleType(RuleType.EXACT);encoder.setMaxPhonemes(10);final String phonemes=encoder.encode(phrase);assertTrue(phonemes.length()> 0);final String[]phonemeArr=phonemes.split("\\|");assertTrue(phonemeArr.length <= 10);}
@Test public void testSetConcat(){final BeiderMorseEncoder bmpm=new BeiderMorseEncoder();bmpm.setConcat(false);assertFalse("Should be able to set concat to false",bmpm.isConcat());}
@Test public void testSetNameTypeAsh(){final BeiderMorseEncoder bmpm=new BeiderMorseEncoder();bmpm.setNameType(NameType.ASHKENAZI);assertEquals("Name type should have been set to ash",NameType.ASHKENAZI,bmpm.getNameType());}
@Test public void testSetRuleTypeExact(){final BeiderMorseEncoder bmpm=new BeiderMorseEncoder();bmpm.setRuleType(RuleType.EXACT);assertEquals("Rule type should have been set to exact",RuleType.EXACT,bmpm.getRuleType());}
@Test(expected=IllegalArgumentException.class)public void testSetRuleTypeToRulesIllegalArgumentException(){final BeiderMorseEncoder bmpm=new BeiderMorseEncoder();bmpm.setRuleType(RuleType.RULES);}
/** * (Un)luckily,the worse performing test because of the data in  {@link #TEST_CHARS}* @throws EncoderException*/@Test()public void testSpeedCheck()throws EncoderException {final BeiderMorseEncoder bmpm=this.createGenericApproxEncoder();final StringBuilder stringBuffer=new StringBuilder();stringBuffer.append(TEST_CHARS[0]);for (int i=0,j=1;i < 40;i++,j++){if (j == TEST_CHARS.length){j=0;}bmpm.encode(stringBuffer.toString());stringBuffer.append(TEST_CHARS[j]);}}
@Test public void testSpeedCheck2()throws EncoderException {final BeiderMorseEncoder bmpm=this.createGenericApproxEncoder();final String phrase="ItstheendoftheworldasweknowitandIfeelfine";for (int i=1;i <= phrase.length();i++){bmpm.encode(phrase.subSequence(0,i));}}
@Test public void testSpeedCheck3()throws EncoderException {final BeiderMorseEncoder bmpm=this.createGenericApproxEncoder();final String phrase="abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz";for (int i=1;i <= phrase.length();i++){bmpm.encode(phrase.subSequence(0,i));}}
@Test public void testApr1CryptStrings(){assertEquals("$apr1$TqI9WECO$LHZB2DqRlk9nObiB6vJG9.",Md5Crypt.apr1Crypt("secret","$apr1$TqI9WECO"));assertEquals("$apr1$foo$P27KyD1htb4EllIPEYhqi0",Md5Crypt.apr1Crypt("","$apr1$foo"));assertEquals("$apr1$1234$mAlH7FRST6FiRZ.kcYL.j1",Md5Crypt.apr1Crypt("secret","$apr1$1234"));assertEquals("$apr1$1234$mAlH7FRST6FiRZ.kcYL.j1",Md5Crypt.apr1Crypt("secret","$apr1$1234$567"));assertEquals("$apr1$1234$mAlH7FRST6FiRZ.kcYL.j1",Md5Crypt.apr1Crypt("secret","$apr1$1234$567$890"));assertEquals("$apr1$12345678$0lqb/6VUFP8JY/s/jTrIk0",Md5Crypt.apr1Crypt("secret","$apr1$1234567890123456"));assertEquals("$apr1$12345678$0lqb/6VUFP8JY/s/jTrIk0",Md5Crypt.apr1Crypt("secret","$apr1$123456789012345678"));}
@Test public void testApr1CryptBytes(){final byte[]keyBytes=new byte[]{'!','b','c','.'};final String hash=Md5Crypt.apr1Crypt(keyBytes);assertEquals(hash,Md5Crypt.apr1Crypt("!bc.",hash));assertEquals("$apr1$foo$P27KyD1htb4EllIPEYhqi0",Md5Crypt.apr1Crypt(new byte[0],"$apr1$foo"));assertEquals("$apr1$./$EeFrYzWWbmTyGdf4xULYc.",Md5Crypt.apr1Crypt("t\u00e4st","$apr1$./$"));assertEquals("$apr1$./$kCwT1pY9qXAJElYG9q1QE1",Md5Crypt.apr1Crypt("t\u00e4st".getBytes(Charsets.ISO_8859_1),"$apr1$./$"));}
@Test public void testApr1CryptExplicitCall(){assertEquals("$apr1$1234$mAlH7FRST6FiRZ.kcYL.j1",Md5Crypt.apr1Crypt("secret","1234"));assertTrue(Md5Crypt.apr1Crypt("secret".getBytes()).matches("^\\$apr1\\$[a-zA-Z0-9./]{0,8}\\$.{1,}$"));assertTrue(Md5Crypt.apr1Crypt("secret".getBytes(),null).matches("^\\$apr1\\$[a-zA-Z0-9./]{0,8}\\$.{1,}$"));}
@Test public void testApr1LongSalt(){assertEquals("$apr1$12345678$0lqb/6VUFP8JY/s/jTrIk0",Md5Crypt.apr1Crypt("secret","12345678901234567890"));}
@Test(expected=NullPointerException.class)public void testApr1CryptNullData(){Md5Crypt.apr1Crypt((byte[])null);}
@Test(expected=IllegalArgumentException.class)public void testApr1CryptWithEmptySalt(){Md5Crypt.apr1Crypt("secret".getBytes(),"");}
@Test public void testApr1CryptWithoutSalt(){final String hash=Md5Crypt.apr1Crypt("secret");assertTrue(hash.matches("^\\$apr1\\$[a-zA-Z0-9\\./]{8}\\$[a-zA-Z0-9\\./]{22}$"));final String hash2=Md5Crypt.apr1Crypt("secret");assertNotSame(hash,hash2);}
@Test(expected=IllegalArgumentException.class)public void testApr1CryptWithInvalidSalt(){Md5Crypt.apr1Crypt(new byte[0],"!");}
@Test public void testConstructor0(){final DecoderException e=new DecoderException();assertNull(e.getMessage());assertNull(e.getCause());}
@Test public void testConstructorString(){final DecoderException e=new DecoderException(MSG);assertEquals(MSG,e.getMessage());assertNull(e.getCause());}
@Test public void testConstructorStringThrowable(){final DecoderException e=new DecoderException(MSG,t);assertEquals(MSG,e.getMessage());assertEquals(t,e.getCause());}
@Test public void testConstructorThrowable(){final DecoderException e=new DecoderException(t);assertEquals(t.getClass().getName(),e.getMessage());assertEquals(t,e.getCause());}
/** * Test alternative encoding.*/@Test public void testDoubleMetaphoneAlternate(){this.checkDoubleMetaphone(ALTERNATE_INDEX,true);}
/** * Test primary encoding.*/@Test public void testDoubleMetaphonePrimary(){this.checkDoubleMetaphone(PRIMARY_INDEX,false);}
@Test public void testPhonemeComparedToLaterIsNegative(){for(final Rule.Phoneme[]phs : makePhonemes()){for (int i=0;i < phs.length;i++){for (int j=i + 1;j < phs.length;j++){final int c=Rule.Phoneme.COMPARATOR.compare(phs[i],phs[j]);assertThat("Comparing " + phs[i].getPhonemeText()+ " to "+ phs[j].getPhonemeText()+ " should be negative",Integer.valueOf(c),new NegativeIntegerBaseMatcher());}}}}
@Test public void testPhonemeComparedToSelfIsZero(){for(final Rule.Phoneme[]phs : makePhonemes()){for(final Rule.Phoneme ph : phs){assertEquals("Phoneme compared to itself should be zero: " + ph.getPhonemeText(),0,Rule.Phoneme.COMPARATOR.compare(ph,ph));}}}
@Test public void testSubSequenceWorks(){final Rule.Phoneme a=new Rule.Phoneme("a",null);final Rule.Phoneme b=new Rule.Phoneme("b",null);final Rule.Phoneme cd=new Rule.Phoneme("cd",null);final Rule.Phoneme ef=new Rule.Phoneme("ef",null);final Rule.Phoneme ghi=new Rule.Phoneme("ghi",null);final Rule.Phoneme jkl=new Rule.Phoneme("jkl",null);assertEquals('a',a.getPhonemeText().charAt(0));assertEquals('b',b.getPhonemeText().charAt(0));assertEquals('c',cd.getPhonemeText().charAt(0));assertEquals('d',cd.getPhonemeText().charAt(1));assertEquals('e',ef.getPhonemeText().charAt(0));assertEquals('f',ef.getPhonemeText().charAt(1));assertEquals('g',ghi.getPhonemeText().charAt(0));assertEquals('h',ghi.getPhonemeText().charAt(1));assertEquals('i',ghi.getPhonemeText().charAt(2));assertEquals('j',jkl.getPhonemeText().charAt(0));assertEquals('k',jkl.getPhonemeText().charAt(1));assertEquals('l',jkl.getPhonemeText().charAt(2));final Rule.Phoneme a_b=new Rule.Phoneme(a,b);assertEquals('a',a_b.getPhonemeText().charAt(0));assertEquals('b',a_b.getPhonemeText().charAt(1));assertEquals("ab",a_b.getPhonemeText().subSequence(0,2).toString());assertEquals("a",a_b.getPhonemeText().subSequence(0,1).toString());assertEquals("b",a_b.getPhonemeText().subSequence(1,2).toString());final Rule.Phoneme cd_ef=new Rule.Phoneme(cd,ef);assertEquals('c',cd_ef.getPhonemeText().charAt(0));assertEquals('d',cd_ef.getPhonemeText().charAt(1));assertEquals('e',cd_ef.getPhonemeText().charAt(2));assertEquals('f',cd_ef.getPhonemeText().charAt(3));assertEquals("c",cd_ef.getPhonemeText().subSequence(0,1).toString());assertEquals("d",cd_ef.getPhonemeText().subSequence(1,2).toString());assertEquals("e",cd_ef.getPhonemeText().subSequence(2,3).toString());assertEquals("f",cd_ef.getPhonemeText().subSequence(3,4).toString());assertEquals("cd",cd_ef.getPhonemeText().subSequence(0,2).toString());assertEquals("de",cd_ef.getPhonemeText().subSequence(1,3).toString());assertEquals("ef",cd_ef.getPhonemeText().subSequence(2,4).toString());assertEquals("cde",cd_ef.getPhonemeText().subSequence(0,3).toString());assertEquals("def",cd_ef.getPhonemeText().subSequence(1,4).toString());assertEquals("cdef",cd_ef.getPhonemeText().subSequence(0,4).toString());final Rule.Phoneme a_b_cd=new Rule.Phoneme(new Rule.Phoneme(a,b),cd);assertEquals('a',a_b_cd.getPhonemeText().charAt(0));assertEquals('b',a_b_cd.getPhonemeText().charAt(1));assertEquals('c',a_b_cd.getPhonemeText().charAt(2));assertEquals('d',a_b_cd.getPhonemeText().charAt(3));assertEquals("a",a_b_cd.getPhonemeText().subSequence(0,1).toString());assertEquals("b",a_b_cd.getPhonemeText().subSequence(1,2).toString());assertEquals("c",a_b_cd.getPhonemeText().subSequence(2,3).toString());assertEquals("d",a_b_cd.getPhonemeText().subSequence(3,4).toString());assertEquals("ab",a_b_cd.getPhonemeText().subSequence(0,2).toString());assertEquals("bc",a_b_cd.getPhonemeText().subSequence(1,3).toString());assertEquals("cd",a_b_cd.getPhonemeText().subSequence(2,4).toString());assertEquals("abc",a_b_cd.getPhonemeText().subSequence(0,3).toString());assertEquals("bcd",a_b_cd.getPhonemeText().subSequence(1,4).toString());assertEquals("abcd",a_b_cd.getPhonemeText().subSequence(0,4).toString());}
/** * Tests example adapted from version 2.0  http://caversham.otago.ac.nz/files/working/ctp150804.pdf AT1111 words: add,aid,at,art,eat,earth,head,hit,hot,hold,hard,heart,it,out,old* @throws EncoderException*/@Test public void testCaverphoneRevisitedCommonCodeAT1111()throws EncoderException {this.checkEncodingVariations("AT1111",new String[]{"add","aid","at","art","eat","earth","head","hit","hot","hold","hard","heart","it","out","old"});}
@Test public void testEndMb()throws EncoderException {final String[][]data={{"mb","M11111"},{"mbmb","MPM111"}};this.checkEncodings(data);}
/** * Tests some examples from version 2.0 http://caversham.otago.ac.nz/files/working/ctp150804.pdf* @throws EncoderException*/@Test public void testIsCaverphoneEquals()throws EncoderException {final Caverphone1 caverphone=new Caverphone1();Assert.assertFalse("Caverphone encodings should not be equal",caverphone.isEncodeEqual("Peter","Stevenson"));Assert.assertTrue("Caverphone encodings should be equal",caverphone.isEncodeEqual("Peter","Peady"));}
/** * Tests example from http://caversham.otago.ac.nz/files/working/ctp060902.pdf* @throws EncoderException*/@Test public void testSpecificationV1Examples()throws EncoderException {final String[][]data={{"David","TFT111"},{"Whittle","WTL111"}};this.checkEncodings(data);}
/** * Tests examples from http://en.wikipedia.org/wiki/Caverphone* @throws EncoderException*/@Test public void testWikipediaExamples()throws EncoderException {final String[][]data={{"Lee","L11111"},{"Thompson","TMPSN1"}};this.checkEncodings(data);}
@Test public void testNullInput()throws Exception {final QCodec qcodec=new QCodec();assertNull(qcodec.doDecoding(null));assertNull(qcodec.doEncoding(null));}
@Test public void testUTF8RoundTrip()throws Exception {final String ru_msg=constructString(RUSSIAN_STUFF_UNICODE);final String ch_msg=constructString(SWISS_GERMAN_STUFF_UNICODE);final QCodec qcodec=new QCodec(CharEncoding.UTF_8);assertEquals("=?UTF-8?Q?=D0=92=D1=81=D0=B5=D0=BC=5F=D0=BF=D1=80=D0=B8=D0=B2=D0=B5=D1=82?=",qcodec.encode(ru_msg));assertEquals("=?UTF-8?Q?Gr=C3=BCezi=5Fz=C3=A4m=C3=A4?=",qcodec.encode(ch_msg));assertEquals(ru_msg,qcodec.decode(qcodec.encode(ru_msg)));assertEquals(ch_msg,qcodec.decode(qcodec.encode(ch_msg)));}
@Test public void testBasicEncodeDecode()throws Exception {final QCodec qcodec=new QCodec();final String plain="= Hello there =\r\n";final String encoded=qcodec.encode(plain);assertEquals("Basic Q encoding test","=?UTF-8?Q?=3D Hello there =3D=0D=0A?=",encoded);assertEquals("Basic Q decoding test",plain,qcodec.decode(encoded));}
@Test public void testUnsafeEncodeDecode()throws Exception {final QCodec qcodec=new QCodec();final String plain="?_=\r\n";final String encoded=qcodec.encode(plain);assertEquals("Unsafe chars Q encoding test","=?UTF-8?Q?=3F=5F=3D=0D=0A?=",encoded);assertEquals("Unsafe chars Q decoding test",plain,qcodec.decode(encoded));}
@Test public void testEncodeDecodeNull()throws Exception {final QCodec qcodec=new QCodec();assertNull("Null string Q encoding test",qcodec.encode((String)null));assertNull("Null string Q decoding test",qcodec.decode((String)null));}
@Test public void testEncodeStringWithNull()throws Exception {final QCodec qcodec=new QCodec();final String test=null;final String result=qcodec.encode(test,"charset");assertEquals("Result should be null",null,result);}
@Test public void testDecodeStringWithNull()throws Exception {final QCodec qcodec=new QCodec();final String test=null;final String result=qcodec.decode(test);assertEquals("Result should be null",null,result);}
@Test public void testEncodeObjects()throws Exception {final QCodec qcodec=new QCodec();final String plain="1+1 = 2";final String encoded=(String)qcodec.encode((Object)plain);assertEquals("Basic Q encoding test","=?UTF-8?Q?1+1 =3D 2?=",encoded);final Object result=qcodec.encode((Object)null);assertEquals("Encoding a null Object should return null",null,result);try {final Object dObj=new Double(3.0);qcodec.encode(dObj);fail("Trying to url encode a Double object should cause an exception.");}catch(final EncoderException ee){}}
@Test(expected=UnsupportedCharsetException.class)public void testInvalidEncoding(){new QCodec("NONSENSE");}
@Test public void testDecodeObjects()throws Exception {final QCodec qcodec=new QCodec();final String decoded="=?UTF-8?Q?1+1 =3D 2?=";final String plain=(String)qcodec.decode((Object)decoded);assertEquals("Basic Q decoding test","1+1 = 2",plain);final Object result=qcodec.decode((Object)null);assertEquals("Decoding a null Object should return null",null,result);try {final Object dObj=new Double(3.0);qcodec.decode(dObj);fail("Trying to url encode a Double object should cause an exception.");}catch(final DecoderException ee){}}
@Test public void testEncodeDecodeBlanks()throws Exception {final String plain="Mind those pesky blanks";final String encoded1="=?UTF-8?Q?Mind those pesky blanks?=";final String encoded2="=?UTF-8?Q?Mind_those_pesky_blanks?=";final QCodec qcodec=new QCodec();qcodec.setEncodeBlanks(false);String s=qcodec.encode(plain);assertEquals("Blanks encoding with the Q codec test",encoded1,s);qcodec.setEncodeBlanks(true);s=qcodec.encode(plain);assertEquals("Blanks encoding with the Q codec test",encoded2,s);s=qcodec.decode(encoded1);assertEquals("Blanks decoding with the Q codec test",plain,s);s=qcodec.decode(encoded2);assertEquals("Blanks decoding with the Q codec test",plain,s);}
@Test public void testLetUsMakeCloverHappy()throws Exception {final QCodec qcodec=new QCodec();qcodec.setEncodeBlanks(true);assertTrue(qcodec.isEncodeBlanks());qcodec.setEncodeBlanks(false);assertFalse(qcodec.isEncodeBlanks());}
@Test public void testCrypt(){assertNotNull(new Crypt());}
@Test public void testDefaultCryptVariant(){assertTrue(Crypt.crypt("secret").startsWith("$6$"));assertTrue(Crypt.crypt("secret",null).startsWith("$6$"));}
@Test public void testCryptWithBytes(){final byte[]keyBytes=new byte[]{'b','y','t','e'};final String hash=Crypt.crypt(keyBytes);assertEquals(hash,Crypt.crypt("byte",hash));}
/** * An empty string as salt is invalid. The C and Perl implementations return an empty string,PHP threads it as NULL. Our implementation should throw an Exception as any resulting hash would not be verifyable with other implementations of crypt().*/@Test(expected=IllegalArgumentException.class)public void testCryptWithEmptySalt(){Crypt.crypt("secret","");}
@Test public void testB650()throws EncoderException {this.checkEncodingVariations("B650",new String[]{"BARHAM","BARONE","BARRON","BERNA","BIRNEY","BIRNIE","BOOROM","BOREN","BORN","BOURN","BOURNE","BOWRON","BRAIN","BRAME","BRANN","BRAUN","BREEN","BRIEN","BRIM","BRIMM","BRINN","BRION","BROOM","BROOME","BROWN","BROWNE","BRUEN","BRUHN","BRUIN","BRUMM","BRUN","BRUNO","BRYAN","BURIAN","BURN","BURNEY","BYRAM","BYRNE","BYRON","BYRUM"});}
@Test public void testBadCharacters(){Assert.assertEquals("H452",this.getStringEncoder().encode("HOL>MES"));}
@Test public void testDifference()throws EncoderException {Assert.assertEquals(0,this.getStringEncoder().difference(null,null));Assert.assertEquals(0,this.getStringEncoder().difference("",""));Assert.assertEquals(0,this.getStringEncoder().difference(" "," "));Assert.assertEquals(4,this.getStringEncoder().difference("Smith","Smythe"));Assert.assertEquals(2,this.getStringEncoder().difference("Ann","Andrew"));Assert.assertEquals(1,this.getStringEncoder().difference("Margaret","Andrew"));Assert.assertEquals(0,this.getStringEncoder().difference("Janet","Margaret"));Assert.assertEquals(4,this.getStringEncoder().difference("Green","Greene"));Assert.assertEquals(0,this.getStringEncoder().difference("Blotchet-Halls","Greene"));Assert.assertEquals(4,this.getStringEncoder().difference("Smith","Smythe"));Assert.assertEquals(4,this.getStringEncoder().difference("Smithers","Smythers"));Assert.assertEquals(2,this.getStringEncoder().difference("Anothers","Brothers"));}
@Test public void testEncodeBasic(){Assert.assertEquals("T235",this.getStringEncoder().encode("testing"));Assert.assertEquals("T000",this.getStringEncoder().encode("The"));Assert.assertEquals("Q200",this.getStringEncoder().encode("quick"));Assert.assertEquals("B650",this.getStringEncoder().encode("brown"));Assert.assertEquals("F200",this.getStringEncoder().encode("fox"));Assert.assertEquals("J513",this.getStringEncoder().encode("jumped"));Assert.assertEquals("O160",this.getStringEncoder().encode("over"));Assert.assertEquals("T000",this.getStringEncoder().encode("the"));Assert.assertEquals("L200",this.getStringEncoder().encode("lazy"));Assert.assertEquals("D200",this.getStringEncoder().encode("dogs"));}
/** * Examples from http://www.bradandkathy.com/genealogy/overviewofsoundex.html*/@Test public void testEncodeBatch2(){Assert.assertEquals("A462",this.getStringEncoder().encode("Allricht"));Assert.assertEquals("E166",this.getStringEncoder().encode("Eberhard"));Assert.assertEquals("E521",this.getStringEncoder().encode("Engebrethson"));Assert.assertEquals("H512",this.getStringEncoder().encode("Heimbach"));Assert.assertEquals("H524",this.getStringEncoder().encode("Hanselmann"));Assert.assertEquals("H431",this.getStringEncoder().encode("Hildebrand"));Assert.assertEquals("K152",this.getStringEncoder().encode("Kavanagh"));Assert.assertEquals("L530",this.getStringEncoder().encode("Lind"));Assert.assertEquals("L222",this.getStringEncoder().encode("Lukaschowsky"));Assert.assertEquals("M235",this.getStringEncoder().encode("McDonnell"));Assert.assertEquals("M200",this.getStringEncoder().encode("McGee"));Assert.assertEquals("O155",this.getStringEncoder().encode("Opnian"));Assert.assertEquals("O155",this.getStringEncoder().encode("Oppenheimer"));Assert.assertEquals("R355",this.getStringEncoder().encode("Riedemanas"));Assert.assertEquals("Z300",this.getStringEncoder().encode("Zita"));Assert.assertEquals("Z325",this.getStringEncoder().encode("Zitzmeinn"));}
/** * Examples from http://www.archives.gov/research_room/genealogy/census/soundex.html*/@Test public void testEncodeBatch3(){Assert.assertEquals("W252",this.getStringEncoder().encode("Washington"));Assert.assertEquals("L000",this.getStringEncoder().encode("Lee"));Assert.assertEquals("G362",this.getStringEncoder().encode("Gutierrez"));Assert.assertEquals("P236",this.getStringEncoder().encode("Pfister"));Assert.assertEquals("J250",this.getStringEncoder().encode("Jackson"));Assert.assertEquals("T522",this.getStringEncoder().encode("Tymczak"));Assert.assertEquals("V532",this.getStringEncoder().encode("VanDeusen"));}
/** * Examples from: http://www.myatt.demon.co.uk/sxalg.htm*/@Test public void testEncodeBatch4(){Assert.assertEquals("H452",this.getStringEncoder().encode("HOLMES"));Assert.assertEquals("A355",this.getStringEncoder().encode("ADOMOMI"));Assert.assertEquals("V536",this.getStringEncoder().encode("VONDERLEHR"));Assert.assertEquals("B400",this.getStringEncoder().encode("BALL"));Assert.assertEquals("S000",this.getStringEncoder().encode("SHAW"));Assert.assertEquals("J250",this.getStringEncoder().encode("JACKSON"));Assert.assertEquals("S545",this.getStringEncoder().encode("SCANLON"));Assert.assertEquals("S532",this.getStringEncoder().encode("SAINTJOHN"));}
@Test public void testEncodeIgnoreApostrophes()throws EncoderException {this.checkEncodingVariations("O165",new String[]{"OBrien","'OBrien","O'Brien","OB'rien","OBr'ien","OBri'en","OBrie'n","OBrien'"});}
/** * Test data from http://www.myatt.demon.co.uk/sxalg.htm* @throws EncoderException*/@Test public void testEncodeIgnoreHyphens()throws EncoderException {this.checkEncodingVariations("K525",new String[]{"KINGSMITH","-KINGSMITH","K-INGSMITH","KI-NGSMITH","KIN-GSMITH","KING-SMITH","KINGS-MITH","KINGSM-ITH","KINGSMI-TH","KINGSMIT-H","KINGSMITH-"});}
@Test public void testEncodeIgnoreTrimmable(){Assert.assertEquals("W252",this.getStringEncoder().encode(" \t\n\r Washington \t\n\r "));}
/** * Consonants from the same code group separated by W or H are treated as one.*/@Test public void testHWRuleEx1(){Assert.assertEquals("A261",this.getStringEncoder().encode("Ashcraft"));}
/** * Consonants from the same code group separated by W or H are treated as one. Test data from http://www.myatt.demon.co.uk/sxalg.htm*/@Test public void testHWRuleEx2(){Assert.assertEquals("B312",this.getStringEncoder().encode("BOOTHDAVIS"));Assert.assertEquals("B312",this.getStringEncoder().encode("BOOTH-DAVIS"));}
/** * Consonants from the same code group separated by W or H are treated as one.* @throws EncoderException*/@Test public void testHWRuleEx3()throws EncoderException {Assert.assertEquals("S460",this.getStringEncoder().encode("Sgler"));Assert.assertEquals("S460",this.getStringEncoder().encode("Swhgler"));this.checkEncodingVariations("S460",new String[]{"SAILOR","SALYER","SAYLOR","SCHALLER","SCHELLER","SCHILLER","SCHOOLER","SCHULER","SCHUYLER","SEILER","SEYLER","SHOLAR","SHULER","SILAR","SILER","SILLER"});}
/** * Examples for MS SQLServer from http://msdn.microsoft.com/library/default.asp?url=/library/en-us/tsqlref/ts_setu-sus_3o6w.asp*/@Test public void testMsSqlServer1(){Assert.assertEquals("S530",this.getStringEncoder().encode("Smith"));Assert.assertEquals("S530",this.getStringEncoder().encode("Smythe"));}
/** * Examples for MS SQLServer from http://support.microsoft.com/default.aspx?scid=http://support.microsoft.com:80/support /kb/articles/Q100/3/65.asp&NoWebContent=1* @throws EncoderException*/@Test public void testMsSqlServer2()throws EncoderException {this.checkEncodingVariations("E625",new String[]{"Erickson","Erickson","Erikson","Ericson","Ericksen","Ericsen"});}
/** * Examples for MS SQLServer from http://databases.about.com/library/weekly/aa042901a.htm*/@Test public void testMsSqlServer3(){Assert.assertEquals("A500",this.getStringEncoder().encode("Ann"));Assert.assertEquals("A536",this.getStringEncoder().encode("Andrew"));Assert.assertEquals("J530",this.getStringEncoder().encode("Janet"));Assert.assertEquals("M626",this.getStringEncoder().encode("Margaret"));Assert.assertEquals("S315",this.getStringEncoder().encode("Steven"));Assert.assertEquals("M240",this.getStringEncoder().encode("Michael"));Assert.assertEquals("R163",this.getStringEncoder().encode("Robert"));Assert.assertEquals("L600",this.getStringEncoder().encode("Laura"));Assert.assertEquals("A500",this.getStringEncoder().encode("Anne"));}
/** * https://issues.apache.org/jira/browse/CODEC-54 https://issues.apache.org/jira/browse/CODEC-56*/@Test public void testNewInstance(){Assert.assertEquals("W452",new Soundex().soundex("Williams"));}
@Test public void testNewInstance2(){Assert.assertEquals("W452",new Soundex(Soundex.US_ENGLISH_MAPPING_STRING.toCharArray()).soundex("Williams"));}
@Test public void testNewInstance3(){Assert.assertEquals("W452",new Soundex(Soundex.US_ENGLISH_MAPPING_STRING).soundex("Williams"));}
@Test public void testSoundexUtilsConstructable(){new SoundexUtils();}
@Test public void testSoundexUtilsNullBehaviour(){Assert.assertEquals(null,SoundexUtils.clean(null));Assert.assertEquals("",SoundexUtils.clean(""));Assert.assertEquals(0,SoundexUtils.differenceEncoded(null,""));Assert.assertEquals(0,SoundexUtils.differenceEncoded("",null));}
/** * https://issues.apache.org/jira/browse/CODEC-54 https://issues.apache.org/jira/browse/CODEC-56*/@Test public void testUsEnglishStatic(){Assert.assertEquals("W452",Soundex.US_ENGLISH.soundex("Williams"));}
/** * Fancy characters are not mapped by the default US mapping. http://issues.apache.org/bugzilla/show_bug.cgi?id=29080*/@Test public void testUsMappingEWithAcute(){Assert.assertEquals("E000",this.getStringEncoder().encode("e"));if (Character.isLetter('\u00e9')){try {Assert.assertEquals("\u00c9000",this.getStringEncoder().encode("\u00e9"));Assert.fail("Expected IllegalArgumentException not thrown");}catch(final IllegalArgumentException e){}}else {Assert.assertEquals("",this.getStringEncoder().encode("\u00e9"));}}
/** * Fancy characters are not mapped by the default US mapping. http://issues.apache.org/bugzilla/show_bug.cgi?id=29080*/@Test public void testUsMappingOWithDiaeresis(){Assert.assertEquals("O000",this.getStringEncoder().encode("o"));if (Character.isLetter('\u00f6')){try {Assert.assertEquals("\u00d6000",this.getStringEncoder().encode("\u00f6"));Assert.fail("Expected IllegalArgumentException not thrown");}catch(final IllegalArgumentException e){}}else {Assert.assertEquals("",this.getStringEncoder().encode("\u00f6"));}}
public void doubleMetaphoneEqualTest(final String[][]pairs,final boolean useAlternate){this.validateFixture(pairs);for(final String[]pair : pairs){final String name0=pair[0];final String name1=pair[1];final String failMsg="Expected match between " + name0 + " and "+ name1+ " (use alternate: "+ useAlternate+ ")";assertTrue(failMsg,this.getStringEncoder().isDoubleMetaphoneEqual(name0,name1,useAlternate));assertTrue(failMsg,this.getStringEncoder().isDoubleMetaphoneEqual(name1,name0,useAlternate));if (!useAlternate){assertTrue(failMsg,this.getStringEncoder().isDoubleMetaphoneEqual(name0,name1));assertTrue(failMsg,this.getStringEncoder().isDoubleMetaphoneEqual(name1,name0));}}}
public void doubleMetaphoneNotEqualTest(final boolean alternate){assertFalse(this.getStringEncoder().isDoubleMetaphoneEqual("Brain","Band",alternate));assertFalse(this.getStringEncoder().isDoubleMetaphoneEqual("Band","Brain",alternate));if (!alternate){assertFalse(this.getStringEncoder().isDoubleMetaphoneEqual("Brain","Band"));assertFalse(this.getStringEncoder().isDoubleMetaphoneEqual("Band","Brain"));}}
@Test public void testCCedilla(){assertTrue(this.getStringEncoder().isDoubleMetaphoneEqual("\u00e7","S"));}
@Test public void testCodec184()throws Throwable {assertTrue(new DoubleMetaphone().isDoubleMetaphoneEqual("","",false));assertTrue(new DoubleMetaphone().isDoubleMetaphoneEqual("","",true));assertFalse(new DoubleMetaphone().isDoubleMetaphoneEqual("aa","",false));assertFalse(new DoubleMetaphone().isDoubleMetaphoneEqual("aa","",true));assertFalse(new DoubleMetaphone().isDoubleMetaphoneEqual("","aa",false));assertFalse(new DoubleMetaphone().isDoubleMetaphoneEqual("","aa",true));}
@Test public void testDoubleMetaphone(){assertDoubleMetaphone("TSTN","testing");assertDoubleMetaphone("0","The");assertDoubleMetaphone("KK","quick");assertDoubleMetaphone("PRN","brown");assertDoubleMetaphone("FKS","fox");assertDoubleMetaphone("JMPT","jumped");assertDoubleMetaphone("AFR","over");assertDoubleMetaphone("0","the");assertDoubleMetaphone("LS","lazy");assertDoubleMetaphone("TKS","dogs");assertDoubleMetaphone("MKFR","MacCafferey");assertDoubleMetaphone("STFN","Stephan");assertDoubleMetaphone("KSSK","Kuczewski");assertDoubleMetaphone("MKLL","McClelland");assertDoubleMetaphone("SNHS","san jose");assertDoubleMetaphone("SNFP","xenophobia");assertDoubleMetaphoneAlt("TSTN","testing");assertDoubleMetaphoneAlt("T","The");assertDoubleMetaphoneAlt("KK","quick");assertDoubleMetaphoneAlt("PRN","brown");assertDoubleMetaphoneAlt("FKS","fox");assertDoubleMetaphoneAlt("AMPT","jumped");assertDoubleMetaphoneAlt("AFR","over");assertDoubleMetaphoneAlt("T","the");assertDoubleMetaphoneAlt("LS","lazy");assertDoubleMetaphoneAlt("TKS","dogs");assertDoubleMetaphoneAlt("MKFR","MacCafferey");assertDoubleMetaphoneAlt("STFN","Stephan");assertDoubleMetaphoneAlt("KXFS","Kutchefski");assertDoubleMetaphoneAlt("MKLL","McClelland");assertDoubleMetaphoneAlt("SNHS","san jose");assertDoubleMetaphoneAlt("SNFP","xenophobia");assertDoubleMetaphoneAlt("FKR","Fokker");assertDoubleMetaphoneAlt("AK","Joqqi");assertDoubleMetaphoneAlt("HF","Hovvi");assertDoubleMetaphoneAlt("XRN","Czerny");}
@Test public void testEmpty(){assertEquals(null,this.getStringEncoder().doubleMetaphone(null));assertEquals(null,this.getStringEncoder().doubleMetaphone(""));assertEquals(null,this.getStringEncoder().doubleMetaphone(" "));assertEquals(null,this.getStringEncoder().doubleMetaphone("\t\n\r "));}
@Test public void testIsDoubleMetaphoneEqualBasic(){final String[][]testFixture=new String[][]{{"",""},{"Case","case"},{"CASE","Case"},{"caSe","cAsE"},{"cookie","quick"},{"quick","cookie"},{"Brian","Bryan"},{"Auto","Otto"},{"Steven","Stefan"},{"Philipowitz","Filipowicz"}};doubleMetaphoneEqualTest(testFixture,false);doubleMetaphoneEqualTest(testFixture,true);}
/** * Example in the original article but failures in this Java impl:*/@Test public void testIsDoubleMetaphoneEqualExtended1(){}
@Test public void testIsDoubleMetaphoneEqualExtended2(){final String[][]testFixture=new String[][]{{"Jablonski","Yablonsky"}};doubleMetaphoneEqualTest(testFixture,true);}
/** * Used to generate the MATCHES array and test possible matches from the FIXTURE array.*/@Test public void testIsDoubleMetaphoneEqualExtended3(){this.validateFixture(FIXTURE);final StringBuilder failures=new StringBuilder();final StringBuilder matches=new StringBuilder();final String cr=System.getProperty("line.separator");matches.append("private static final String[][]MATCHES = {" + cr);int failCount=0;for (int i=0;i < FIXTURE.length;i++){final String name0=FIXTURE[i][0];final String name1=FIXTURE[i][1];final boolean match1=this.getStringEncoder().isDoubleMetaphoneEqual(name0,name1,false);final boolean match2=this.getStringEncoder().isDoubleMetaphoneEqual(name0,name1,true);if (match1 == false && match2 == false){final String failMsg="[" + i + "]"+ name0+ " and "+ name1+ cr;failures.append(failMsg);failCount++;}else {matches.append("{\"" + name0 + "\",\""+ name1+ "\"},"+ cr);}}matches.append("};");if (failCount > 0){}}
@Test public void testIsDoubleMetaphoneEqualWithMATCHES(){this.validateFixture(MATCHES);for (int i=0;i < MATCHES.length;i++){final String name0=MATCHES[i][0];final String name1=MATCHES[i][1];final boolean match1=this.getStringEncoder().isDoubleMetaphoneEqual(name0,name1,false);final boolean match2=this.getStringEncoder().isDoubleMetaphoneEqual(name0,name1,true);if (match1 == false && match2 == false){fail("Expected match [" + i + "]"+ name0+ " and "+ name1);}}}
@Test public void testIsDoubleMetaphoneNotEqual(){doubleMetaphoneNotEqualTest(false);doubleMetaphoneNotEqualTest(true);}
@Test public void testNTilde(){assertTrue(this.getStringEncoder().isDoubleMetaphoneEqual("\u00f1","N"));}
/** * Test setting maximum length*/@Test public void testSetMaxCodeLength(){final String value="jumped";final DoubleMetaphone doubleMetaphone=new DoubleMetaphone();assertEquals("Default Max Code Length",4,doubleMetaphone.getMaxCodeLen());assertEquals("Default Primary","JMPT",doubleMetaphone.doubleMetaphone(value,false));assertEquals("Default Alternate","AMPT",doubleMetaphone.doubleMetaphone(value,true));doubleMetaphone.setMaxCodeLen(3);assertEquals("Set Max Code Length",3,doubleMetaphone.getMaxCodeLen());assertEquals("Max=3 Primary","JMP",doubleMetaphone.doubleMetaphone(value,false));assertEquals("Max=3 Alternate","AMP",doubleMetaphone.doubleMetaphone(value,true));}
@Test public void testCtor(){assertNotNull(new UnixCrypt());}
@Test public void testUnixCryptStrings(){assertEquals("xxWAum7tHdIUw",Crypt.crypt("secret","xx"));assertEquals("12UFlHxel6uMM",Crypt.crypt("","12"));assertEquals("12FJgqDtVOg7Q",Crypt.crypt("secret","12"));assertEquals("12FJgqDtVOg7Q",Crypt.crypt("secret","12345678"));}
@Test public void testUnixCryptBytes(){assertEquals("12UFlHxel6uMM",Crypt.crypt(new byte[0],"12"));assertEquals("./287bds2PjVw",Crypt.crypt("t\u00e4st","./"));assertEquals("./bLIFNqo9XKQ",Crypt.crypt("t\u00e4st".getBytes(Charsets.ISO_8859_1),"./"));assertEquals("./bLIFNqo9XKQ",Crypt.crypt(new byte[]{(byte)0x74,(byte)0xe4,(byte)0x73,(byte)0x74},"./"));}
/** * Some salts are invalid for crypt(3)but not for unixCrypt().*/@Test public void testUnixCryptExplicitCall(){assertTrue(UnixCrypt.crypt("secret".getBytes()).matches("^[a-zA-Z0-9./]{13}$"));assertTrue(UnixCrypt.crypt("secret".getBytes(),null).matches("^[a-zA-Z0-9./]{13}$"));}
/** * Single character salts are illegal! E.g. with glibc 2.13,crypt("secret","x")= "xxZREZpkHZpkI" but crypt("secret","xx")= "xxWAum7tHdIUw" which makes it unverifyable.*/@Test(expected=IllegalArgumentException.class)public void testUnixCryptWithHalfSalt(){UnixCrypt.crypt("secret","x");}
/** * Unimplemented "$foo$" salt prefixes would be threated as UnixCrypt salt.*/@Test(expected=IllegalArgumentException.class)public void testUnicCryptInvalidSalt(){UnixCrypt.crypt("secret","$a");}
@Test(expected=NullPointerException.class)public void testUnixCryptNullData(){UnixCrypt.crypt((byte[])null);}
@Test(expected=IllegalArgumentException.class)public void testUnixCryptWithEmptySalt(){UnixCrypt.crypt("secret","");}
@Test public void testUnixCryptWithoutSalt(){final String hash=UnixCrypt.crypt("foo");assertTrue(hash.matches("^[a-zA-Z0-9./]{13}$"));final String hash2=UnixCrypt.crypt("foo");assertNotSame(hash,hash2);}
@Test public void testComparatorWithSoundex()throws Exception {final StringEncoderComparator sCompare=new StringEncoderComparator(new Soundex());assertTrue("O'Brien and O'Brian didn't come out with " + "the same Soundex,something must be wrong here",0 == sCompare.compare("O'Brien","O'Brian"));}
@Test public void testComparatorWithDoubleMetaphone()throws Exception {final StringEncoderComparator sCompare=new StringEncoderComparator(new DoubleMetaphone());final String[]testArray={"Jordan","Sosa","Prior","Pryor"};final List<String> testList=Arrays.asList(testArray);final String[]controlArray={"Jordan","Prior","Pryor","Sosa"};Collections.sort(testList,sCompare);final String[]resultArray=testList.toArray(new String[0]);for (int i=0;i < resultArray.length;i++){assertEquals("Result Array not Equal to Control Array at index: " + i,controlArray[i],resultArray[i]);}}
@Test public void testComparatorWithDoubleMetaphoneAndInvalidInput()throws Exception {final StringEncoderComparator sCompare=new StringEncoderComparator(new DoubleMetaphone());final int compare=sCompare.compare(new Double(3.0),Long.valueOf(3));assertEquals("Trying to compare objects that make no sense to the underlying encoder should return a zero compare code",0,compare);}
/** * We could make the constructor private but there does not seem to be a point to jumping through extra code hoops to restrict instantiation right now.*/@Test public void testConstructor(){new Utils();}
/** * Tests to make sure Base64's implementation of the org.apache.commons.codec.Encoder interface is behaving identical to commons-codec-1.3.jar.* @throws EncoderException problem*/@Test public void testEncoder()throws EncoderException {final Encoder enc=new Base64();for (int i=0;i < STRINGS.length;i++){if (STRINGS[i]!= null){final byte[]base64=utf8(STRINGS[i]);final byte[]binary=BYTES[i];final boolean b=Arrays.equals(base64,(byte[])enc.encode(binary));assertTrue("Encoder test-" + i,b);}}}
/** * Tests to make sure Base64's implementation of the org.apache.commons.codec.Decoder interface is behaving identical to commons-codec-1.3.jar.* @throws DecoderException problem*/@Test public void testDecoder()throws DecoderException {final Decoder dec=new Base64();for (int i=0;i < STRINGS.length;i++){if (STRINGS[i]!= null){final byte[]base64=utf8(STRINGS[i]);final byte[]binary=BYTES[i];final boolean b=Arrays.equals(binary,(byte[])dec.decode(base64));assertTrue("Decoder test-" + i,b);}}}
/** * Tests to make sure Base64's implementation of the org.apache.commons.codec.BinaryEncoder interface is behaving identical to commons-codec-1.3.jar.* @throws EncoderException problem*/@Test public void testBinaryEncoder()throws EncoderException {final BinaryEncoder enc=new Base64();for (int i=0;i < STRINGS.length;i++){if (STRINGS[i]!= null){final byte[]base64=utf8(STRINGS[i]);final byte[]binary=BYTES[i];final boolean b=Arrays.equals(base64,enc.encode(binary));assertTrue("BinaryEncoder test-" + i,b);}}}
/** * Tests to make sure Base64's implementation of the org.apache.commons.codec.BinaryDecoder interface is behaving identical to commons-codec-1.3.jar.* @throws DecoderException problem*/@Test public void testBinaryDecoder()throws DecoderException {final BinaryDecoder dec=new Base64();for (int i=0;i < STRINGS.length;i++){if (STRINGS[i]!= null){final byte[]base64=utf8(STRINGS[i]);final byte[]binary=BYTES[i];final boolean b=Arrays.equals(binary,dec.decode(base64));assertTrue("BinaryDecoder test-" + i,b);}}}
/** * Tests to make sure Base64's implementation of Base64.encodeBase64()static method is behaving identical to commons-codec-1.3.jar.* @throws EncoderException problem*/@Test public void testStaticEncode()throws EncoderException {for (int i=0;i < STRINGS.length;i++){if (STRINGS[i]!= null){final byte[]base64=utf8(STRINGS[i]);final byte[]binary=BYTES[i];final boolean b=Arrays.equals(base64,Base64.encodeBase64(binary));assertTrue("static Base64.encodeBase64()test-" + i,b);}}}
/** * Tests to make sure Base64's implementation of Base64.decodeBase64()static method is behaving identical to commons-codec-1.3.jar.* @throws DecoderException problem*/@Test public void testStaticDecode()throws DecoderException {for (int i=0;i < STRINGS.length;i++){if (STRINGS[i]!= null){final byte[]base64=utf8(STRINGS[i]);final byte[]binary=BYTES[i];final boolean b=Arrays.equals(binary,Base64.decodeBase64(base64));assertTrue("static Base64.decodeBase64()test-" + i,b);}}}
/** * Tests to make sure Base64's implementation of Base64.encodeBase64Chunked()static method is behaving identical to commons-codec-1.3.jar.* @throws EncoderException problem*/@Test public void testStaticEncodeChunked()throws EncoderException {for (int i=0;i < STRINGS.length;i++){if (STRINGS[i]!= null){final byte[]base64Chunked=utf8(CHUNKED_STRINGS[i]);final byte[]binary=BYTES[i];final boolean b=Arrays.equals(base64Chunked,Base64.encodeBase64Chunked(binary));assertTrue("static Base64.encodeBase64Chunked()test-" + i,b);}}}
/** * Tests to make sure Base64's implementation of Base64.decodeBase64()static method is behaving identical to commons-codec-1.3.jar when supplied with chunked input.* @throws DecoderException problem*/@Test public void testStaticDecodeChunked()throws DecoderException {for (int i=0;i < STRINGS.length;i++){if (STRINGS[i]!= null){final byte[]base64Chunked=utf8(CHUNKED_STRINGS[i]);final byte[]binary=BYTES[i];final boolean b=Arrays.equals(binary,Base64.decodeBase64(base64Chunked));assertTrue("static Base64.decodeBase64Chunked()test-" + i,b);}}}
@Test public void testIsMetaphoneEqual1(){this.assertMetaphoneEqual(new String[][]{{"Case","case"},{"CASE","Case"},{"caSe","cAsE"},{"quick","cookie"}});}
/** * Matches computed from http://www.lanw.com/java/phonetic/default.htm*/@Test public void testIsMetaphoneEqual2(){this.assertMetaphoneEqual(new String[][]{{"Lawrence","Lorenza"},{"Gary","Cahra"}});}
/** * Initial AE case. Match data computed from http://www.lanw.com/java/phonetic/default.htm*/@Test public void testIsMetaphoneEqualAero(){this.assertIsMetaphoneEqual("Aero",new String[]{"Eure"});}
/** * Initial WH case. Match data computed from http://www.lanw.com/java/phonetic/default.htm*/@Test public void testIsMetaphoneEqualWhite(){this.assertIsMetaphoneEqual("White",new String[]{"Wade","Wait","Waite","Wat","Whit","Wiatt","Wit","Wittie","Witty","Wood","Woodie","Woody"});}
/** * Initial A,not followed by an E case. Match data computed from http://www.lanw.com/java/phonetic/default.htm*/@Test public void testIsMetaphoneEqualAlbert(){this.assertIsMetaphoneEqual("Albert",new String[]{"Ailbert","Alberik","Albert","Alberto","Albrecht"});}
/** * Match data computed from http://www.lanw.com/java/phonetic/default.htm*/@Test public void testIsMetaphoneEqualGary(){this.assertIsMetaphoneEqual("Gary",new String[]{"Cahra","Cara","Carey","Cari","Caria","Carie","Caro","Carree","Carri","Carrie","Carry","Cary","Cora","Corey","Cori","Corie","Correy","Corri","Corrie","Corry","Cory","Gray","Kara","Kare","Karee","Kari","Karia","Karie","Karrah","Karrie","Karry","Kary","Keri","Kerri","Kerrie","Kerry","Kira","Kiri","Kora","Kore","Kori","Korie","Korrie","Korry"});}
/** * Match data computed from http://www.lanw.com/java/phonetic/default.htm*/@Test public void testIsMetaphoneEqualJohn(){this.assertIsMetaphoneEqual("John",new String[]{"Gena","Gene","Genia","Genna","Genni","Gennie","Genny","Giana","Gianna","Gina","Ginni","Ginnie","Ginny","Jaine","Jan","Jana","Jane","Janey","Jania","Janie","Janna","Jany","Jayne","Jean","Jeana","Jeane","Jeanie","Jeanna","Jeanne","Jeannie","Jen","Jena","Jeni","Jenn","Jenna","Jennee","Jenni","Jennie","Jenny","Jinny","Jo Ann","Jo-Ann","Jo-Anne","Joan","Joana","Joane","Joanie","Joann","Joanna","Joanne","Joeann","Johna","Johnna","Joni","Jonie","Juana","June","Junia","Junie"});}
/** * Initial KN case. Match data computed from http://www.lanw.com/java/phonetic/default.htm*/@Test public void testIsMetaphoneEqualKnight(){this.assertIsMetaphoneEqual("Knight",new String[]{"Hynda","Nada","Nadia","Nady","Nat","Nata","Natty","Neda","Nedda","Nedi","Netta","Netti","Nettie","Netty","Nita","Nydia"});}
/** * Match data computed from http://www.lanw.com/java/phonetic/default.htm*/@Test public void testIsMetaphoneEqualMary(){this.assertIsMetaphoneEqual("Mary",new String[]{"Mair","Maire","Mara","Mareah","Mari","Maria","Marie","Mary","Maura","Maure","Meara","Merrie","Merry","Mira","Moira","Mora","Moria","Moyra","Muire","Myra","Myrah"});}
/** * Match data computed from http://www.lanw.com/java/phonetic/default.htm*/@Test public void testIsMetaphoneEqualParis(){this.assertIsMetaphoneEqual("Paris",new String[]{"Pearcy","Perris","Piercy","Pierz","Pryse"});}
/** * Match data computed from http://www.lanw.com/java/phonetic/default.htm*/@Test public void testIsMetaphoneEqualPeter(){this.assertIsMetaphoneEqual("Peter",new String[]{"Peadar","Peder","Pedro","Peter","Petr","Peyter","Pieter","Pietro","Piotr"});}
/** * Match data computed from http://www.lanw.com/java/phonetic/default.htm*/@Test public void testIsMetaphoneEqualRay(){this.assertIsMetaphoneEqual("Ray",new String[]{"Ray","Rey","Roi","Roy","Ruy"});}
/** * Match data computed from http://www.lanw.com/java/phonetic/default.htm*/@Test public void testIsMetaphoneEqualSusan(){this.assertIsMetaphoneEqual("Susan",new String[]{"Siusan","Sosanna","Susan","Susana","Susann","Susanna","Susannah","Susanne","Suzann","Suzanna","Suzanne","Zuzana"});}
/** * Initial WR case. Match data computed from http://www.lanw.com/java/phonetic/default.htm*/@Test public void testIsMetaphoneEqualWright(){this.assertIsMetaphoneEqual("Wright",new String[]{"Rota","Rudd","Ryde"});}
/** * Match data computed from http://www.lanw.com/java/phonetic/default.htm*/@Test public void testIsMetaphoneEqualXalan(){this.assertIsMetaphoneEqual("Xalan",new String[]{"Celene","Celina","Celine","Selena","Selene","Selina","Seline","Suellen","Xylina"});}
@Test public void testMetaphone(){assertEquals("HL",this.getStringEncoder().metaphone("howl"));assertEquals("TSTN",this.getStringEncoder().metaphone("testing"));assertEquals("0",this.getStringEncoder().metaphone("The"));assertEquals("KK",this.getStringEncoder().metaphone("quick"));assertEquals("BRN",this.getStringEncoder().metaphone("brown"));assertEquals("FKS",this.getStringEncoder().metaphone("fox"));assertEquals("JMPT",this.getStringEncoder().metaphone("jumped"));assertEquals("OFR",this.getStringEncoder().metaphone("over"));assertEquals("0",this.getStringEncoder().metaphone("the"));assertEquals("LS",this.getStringEncoder().metaphone("lazy"));assertEquals("TKS",this.getStringEncoder().metaphone("dogs"));}
@Test public void testWordEndingInMB(){assertEquals("KM",this.getStringEncoder().metaphone("COMB"));assertEquals("TM",this.getStringEncoder().metaphone("TOMB"));assertEquals("WM",this.getStringEncoder().metaphone("WOMB"));}
@Test public void testDiscardOfSCEOrSCIOrSCY(){assertEquals("SNS",this.getStringEncoder().metaphone("SCIENCE"));assertEquals("SN",this.getStringEncoder().metaphone("SCENE"));assertEquals("S",this.getStringEncoder().metaphone("SCY"));}
/** * Tests (CODEC-57)Metaphone.metaphone(String)returns an empty string when passed the word "why"*/@Test public void testWhy(){assertEquals("",this.getStringEncoder().metaphone("WHY"));}
@Test public void testWordsWithCIA(){assertEquals("XP",this.getStringEncoder().metaphone("CIAPO"));}
@Test public void testTranslateOfSCHAndCH(){assertEquals("SKTL",this.getStringEncoder().metaphone("SCHEDULE"));assertEquals("SKMT",this.getStringEncoder().metaphone("SCHEMATIC"));assertEquals("KRKT",this.getStringEncoder().metaphone("CHARACTER"));assertEquals("TX",this.getStringEncoder().metaphone("TEACH"));}
@Test public void testTranslateToJOfDGEOrDGIOrDGY(){assertEquals("TJ",this.getStringEncoder().metaphone("DODGY"));assertEquals("TJ",this.getStringEncoder().metaphone("DODGE"));assertEquals("AJMT",this.getStringEncoder().metaphone("ADGIEMTI"));}
@Test public void testDiscardOfSilentHAfterG(){assertEquals("KNT",this.getStringEncoder().metaphone("GHENT"));assertEquals("B",this.getStringEncoder().metaphone("BAUGH"));}
@Test public void testDiscardOfSilentGN(){assertEquals("N",this.getStringEncoder().metaphone("GNU"));assertEquals("SNT",this.getStringEncoder().metaphone("SIGNED"));}
@Test public void testPHTOF(){assertEquals("FX",this.getStringEncoder().metaphone("PHISH"));}
@Test public void testSHAndSIOAndSIAToX(){assertEquals("XT",this.getStringEncoder().metaphone("SHOT"));assertEquals("OTXN",this.getStringEncoder().metaphone("ODSIAN"));assertEquals("PLXN",this.getStringEncoder().metaphone("PULSION"));}
@Test public void testTIOAndTIAToX(){assertEquals("OX",this.getStringEncoder().metaphone("OTIA"));assertEquals("PRXN",this.getStringEncoder().metaphone("PORTION"));}
@Test public void testTCH(){assertEquals("RX",this.getStringEncoder().metaphone("RETCH"));assertEquals("WX",this.getStringEncoder().metaphone("WATCH"));}
@Test public void testExceedLength(){assertEquals("AKSK",this.getStringEncoder().metaphone("AXEAXE"));}
@Test public void testSetMaxLengthWithTruncation(){this.getStringEncoder().setMaxCodeLen(6);assertEquals("AKSKSK",this.getStringEncoder().metaphone("AXEAXEAXE"));}
