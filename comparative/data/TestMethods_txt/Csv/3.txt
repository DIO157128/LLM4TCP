@Test public void testCSVFile()throws Exception {String line=readTestData();assertNotNull("file must contain config line",line);final String[]split=line.split(" ");assertTrue(testName + " require 1 param",split.length >= 1);final BufferedReader csvFile=new BufferedReader(new FileReader(new File(BASE,split[0])));final CSVFormatBuilder builder=CSVFormat.newBuilder(',').withQuoteChar('"');CSVFormat format=builder.build();boolean checkComments=false;for (int i=1;i < split.length;i++){final String option=split[i];final String[]option_parts=option.split("=",2);if ("IgnoreEmpty".equalsIgnoreCase(option_parts[0])){format=builder.withIgnoreEmptyLines(Boolean.parseBoolean(option_parts[1])).build();}else     if ("IgnoreSpaces".equalsIgnoreCase(option_parts[0])){format=builder.withIgnoreSurroundingSpaces(Boolean.parseBoolean(option_parts[1])).build();}else     if ("CommentStart".equalsIgnoreCase(option_parts[0])){format=builder.withCommentStart(option_parts[1].charAt(0)).build();}else     if ("CheckComments".equalsIgnoreCase(option_parts[0])){checkComments=true;}else {fail(testName + " unexpected option: " + option);}}line=readTestData();assertEquals(testName + " Expected format ",line,format.toString());for(final CSVRecord record : format.parse(csvFile)){String parsed=record.toString();if (checkComments){final String comment=record.getComment().replace("\n","\\n");if (comment != null){parsed+="#" + comment;}}final int count=record.size();assertEquals(testName,readTestData(),count + ":" + parsed);}}
@Test public void testGetInt(){assertEquals(values[0],record.get(0));assertEquals(values[1],record.get(1));assertEquals(values[2],record.get(2));}
@Test public void testGetString(){assertEquals(values[0],recordWithHeader.get("first"));assertEquals(values[1],recordWithHeader.get("second"));assertEquals(values[2],recordWithHeader.get("third"));}
@Test(expected=IllegalStateException.class)public void testGetStringNoHeader(){record.get("first");}
@Test(expected=IllegalArgumentException.class)public void testGetStringInconsistentRecord(){header.put("fourth",Integer.valueOf(4));recordWithHeader.get("fourth");}
@Test public void testIsConsistent(){assertTrue(record.isConsistent());assertTrue(recordWithHeader.isConsistent());header.put("fourth",Integer.valueOf(4));assertFalse(recordWithHeader.isConsistent());}
@Test public void testIsMapped(){assertFalse(record.isMapped("first"));assertTrue(recordWithHeader.isMapped("first"));assertFalse(recordWithHeader.isMapped("fourth"));}
@Test public void testIsSet(){assertFalse(record.isSet("first"));assertTrue(recordWithHeader.isSet("first"));assertFalse(recordWithHeader.isSet("fourth"));}
@Test public void testIterator(){int i=0;for (Iterator<String> itr=record.iterator();itr.hasNext();){String value=itr.next();assertEquals(values[i],value);i++;}}
@Test public void testFormat(){final CSVFormat format=CSVFormat.DEFAULT;assertEquals("",format.format());assertEquals("a,b,c",format.format("a","b","c"));assertEquals("\"x,y\",z",format.format("x,y","z"));}
@SuppressWarnings("boxing")@Test public void testSerialization()throws Exception {final ByteArrayOutputStream out=new ByteArrayOutputStream();final ObjectOutputStream oos=new ObjectOutputStream(out);oos.writeObject(CSVFormat.DEFAULT);oos.flush();oos.close();final ObjectInputStream in=new ObjectInputStream(new ByteArrayInputStream(out.toByteArray()));final CSVFormat format=(CSVFormat)in.readObject();assertNotNull(format);assertEquals("delimiter",CSVFormat.DEFAULT.getDelimiter(),format.getDelimiter());assertEquals("encapsulator",CSVFormat.DEFAULT.getQuoteChar(),format.getQuoteChar());assertEquals("comment start",CSVFormat.DEFAULT.getCommentStart(),format.getCommentStart());assertEquals("line separator",CSVFormat.DEFAULT.getRecordSeparator(),format.getRecordSeparator());assertEquals("escape",CSVFormat.DEFAULT.getEscape(),format.getEscape());assertEquals("trim",CSVFormat.DEFAULT.getIgnoreSurroundingSpaces(),format.getIgnoreSurroundingSpaces());assertEquals("empty lines",CSVFormat.DEFAULT.getIgnoreEmptyLines(),format.getIgnoreEmptyLines());}
@Test public void testEquals(){final CSVFormat right=CSVFormat.DEFAULT;final CSVFormat left=CSVFormat.newBuilder().build();assertFalse(right.equals(null));assertFalse(right.equals("A String Instance"));assertEquals(right,right);assertEquals(right,left);assertEquals(left,right);assertEquals(right.hashCode(),right.hashCode());assertEquals(right.hashCode(),left.hashCode());}
@Test public void testEqualsDelimiter(){final CSVFormat right=CSVFormat.newBuilder('!').build();final CSVFormat left=CSVFormat.newBuilder('?').build();assertNotEquals(right,left);}
@Test public void testEqualsQuoteChar(){final CSVFormat right=CSVFormat.newBuilder('\'').withQuoteChar('"').build();final CSVFormat left=CSVFormat.newBuilder(right).withQuoteChar('!').build();assertNotEquals(right,left);}
@Test public void testEqualsQuotePolicy(){final CSVFormat right=CSVFormat.newBuilder('\'').withQuoteChar('"').withQuotePolicy(Quote.ALL).build();final CSVFormat left=CSVFormat.newBuilder(right).withQuotePolicy(Quote.MINIMAL).build();assertNotEquals(right,left);}
@Test public void testEqualsCommentStart(){final CSVFormat right=CSVFormat.newBuilder('\'').withQuoteChar('"').withQuotePolicy(Quote.ALL).withCommentStart('#').build();final CSVFormat left=CSVFormat.newBuilder(right).withCommentStart('!').build();assertNotEquals(right,left);}
@Test public void testEqualsEscape(){final CSVFormat right=CSVFormat.newBuilder('\'').withQuoteChar('"').withQuotePolicy(Quote.ALL).withCommentStart('#').withEscape('+').build();final CSVFormat left=CSVFormat.newBuilder(right).withEscape('!').build();assertNotEquals(right,left);}
@Test public void testEqualsIgnoreSurroundingSpaces(){final CSVFormat right=CSVFormat.newBuilder('\'').withQuoteChar('"').withQuotePolicy(Quote.ALL).withCommentStart('#').withEscape('+').withIgnoreSurroundingSpaces(true).build();final CSVFormat left=CSVFormat.newBuilder(right).withIgnoreSurroundingSpaces(false).build();assertNotEquals(right,left);}
@Test public void testEqualsIgnoreEmptyLines(){final CSVFormat right=CSVFormat.newBuilder('\'').withQuoteChar('"').withQuotePolicy(Quote.ALL).withCommentStart('#').withEscape('+').withIgnoreSurroundingSpaces(true).withIgnoreEmptyLines(true).build();final CSVFormat left=CSVFormat.newBuilder(right).withIgnoreEmptyLines(false).build();assertNotEquals(right,left);}
@Test public void testEqualsRecordSeparator(){final CSVFormat right=CSVFormat.newBuilder('\'').withQuoteChar('"').withQuotePolicy(Quote.ALL).withCommentStart('#').withEscape('+').withIgnoreSurroundingSpaces(true).withIgnoreEmptyLines(true).withRecordSeparator('*').build();final CSVFormat left=CSVFormat.newBuilder(right).withRecordSeparator('!').build();assertNotEquals(right,left);}
@Test public void testEqualsHeader(){final CSVFormat right=CSVFormat.newBuilder('\'').withQuoteChar('"').withQuotePolicy(Quote.ALL).withCommentStart('#').withEscape('+').withIgnoreSurroundingSpaces(true).withIgnoreEmptyLines(true).withRecordSeparator('*').withHeader("One","Two","Three").build();final CSVFormat left=CSVFormat.newBuilder(right).withHeader("Three","Two","One").build();assertNotEquals(right,left);}
@Test public void testEmptyInput()throws Exception {final ExtendedBufferedReader br=getBufferedReader("");assertEquals(END_OF_STREAM,br.read());assertEquals(END_OF_STREAM,br.lookAhead());assertEquals(END_OF_STREAM,br.getLastChar());assertNull(br.readLine());assertEquals(0,br.read(new char[10],0,0));}
@Test public void testReadLookahead1()throws Exception {final ExtendedBufferedReader br=getBufferedReader("1\n2\r3\n");assertEquals('1',br.lookAhead());assertEquals(UNDEFINED,br.getLastChar());assertEquals('1',br.read());assertEquals('1',br.getLastChar());assertEquals(0,br.getLineNumber());assertEquals('\n',br.lookAhead());assertEquals(0,br.getLineNumber());assertEquals('1',br.getLastChar());assertEquals('\n',br.read());assertEquals(1,br.getLineNumber());assertEquals('\n',br.getLastChar());assertEquals(1,br.getLineNumber());assertEquals('2',br.lookAhead());assertEquals(1,br.getLineNumber());assertEquals('\n',br.getLastChar());assertEquals(1,br.getLineNumber());assertEquals('2',br.read());assertEquals('2',br.getLastChar());assertEquals('\r',br.lookAhead());assertEquals('2',br.getLastChar());assertEquals('\r',br.read());assertEquals('\r',br.getLastChar());assertEquals('3',br.lookAhead());assertEquals('\r',br.getLastChar());assertEquals('3',br.read());assertEquals('3',br.getLastChar());assertEquals('\n',br.lookAhead());assertEquals(2,br.getLineNumber());assertEquals('3',br.getLastChar());assertEquals('\n',br.read());assertEquals(3,br.getLineNumber());assertEquals('\n',br.getLastChar());assertEquals(3,br.getLineNumber());assertEquals(END_OF_STREAM,br.lookAhead());assertEquals('\n',br.getLastChar());assertEquals(END_OF_STREAM,br.read());assertEquals(END_OF_STREAM,br.getLastChar());assertEquals(END_OF_STREAM,br.read());assertEquals(END_OF_STREAM,br.lookAhead());}
@Test public void testReadLookahead2()throws Exception {final char[]ref=new char[5];final char[]res=new char[5];final ExtendedBufferedReader br=getBufferedReader("abcdefg");ref[0]='a';ref[1]='b';ref[2]='c';assertEquals(3,br.read(res,0,3));assertArrayEquals(ref,res);assertEquals('c',br.getLastChar());assertEquals('d',br.lookAhead());ref[4]='d';assertEquals(1,br.read(res,4,1));assertArrayEquals(ref,res);assertEquals('d',br.getLastChar());}
@Test public void testReadLine()throws Exception {ExtendedBufferedReader br=getBufferedReader("");assertNull(br.readLine());br=getBufferedReader("\n");assertEquals("",br.readLine());assertNull(br.readLine());br=getBufferedReader("foo\n\nhello");assertEquals(0,br.getLineNumber());assertEquals("foo",br.readLine());assertEquals(1,br.getLineNumber());assertEquals("",br.readLine());assertEquals(2,br.getLineNumber());assertEquals("hello",br.readLine());assertEquals(3,br.getLineNumber());assertNull(br.readLine());assertEquals(3,br.getLineNumber());br=getBufferedReader("foo\n\nhello");assertEquals('f',br.read());assertEquals('o',br.lookAhead());assertEquals("oo",br.readLine());assertEquals(1,br.getLineNumber());assertEquals('\n',br.lookAhead());assertEquals("",br.readLine());assertEquals(2,br.getLineNumber());assertEquals('h',br.lookAhead());assertEquals("hello",br.readLine());assertNull(br.readLine());assertEquals(3,br.getLineNumber());br=getBufferedReader("foo\rbaar\r\nfoo");assertEquals("foo",br.readLine());assertEquals('b',br.lookAhead());assertEquals("baar",br.readLine());assertEquals('f',br.lookAhead());assertEquals("foo",br.readLine());assertNull(br.readLine());}
@Test public void testReadChar()throws Exception {final String LF="\n";final String CR="\r";final String CRLF=CR + LF;final String LFCR=LF + CR;final String test="a" + LF + "b"+ CR+ "c"+ LF+ LF+ "d"+ CR+ CR+ "e"+ LFCR+ "f "+ CRLF;final int EOLeolct=9;ExtendedBufferedReader br;br=getBufferedReader(test);assertEquals(0,br.getLineNumber());while (br.readLine()!= null){}assertEquals(EOLeolct,br.getLineNumber());br=getBufferedReader(test);assertEquals(0,br.getLineNumber());while (br.read()!= -1){}assertEquals(EOLeolct,br.getLineNumber());br=getBufferedReader(test);assertEquals(0,br.getLineNumber());final char[]buff=new char[10];while (br.read(buff,0,3)!= -1){}assertEquals(EOLeolct,br.getLineNumber());}
@Test public void testCommentStart(){assertEquals('?',builder.withCommentStart('?').build().getCommentStart().charValue());}
@Test public void testCopiedFormatIsEqualToOriginal(){final CSVFormat copyOfRCF4180=CSVFormat.newBuilder(RFC4180).build();assertEquals(RFC4180,copyOfRCF4180);final CSVFormat copy2OfRCF4180=RFC4180.toBuilder().build();assertEquals(RFC4180,copy2OfRCF4180);}
@Test public void testCopiedFormatWithChanges(){final CSVFormat newFormat=CSVFormat.newBuilder(RFC4180).withDelimiter('!').build();assertTrue(newFormat.getDelimiter()!= RFC4180.getDelimiter());final CSVFormat newFormat2=RFC4180.toBuilder().withDelimiter('!').build();assertTrue(newFormat2.getDelimiter()!= RFC4180.getDelimiter());}
@Test public void testDelimiter(){assertEquals('?',builder.withDelimiter('?').build().getDelimiter());}
@Test(expected=IllegalStateException.class)public void testDelimiterSameAsCommentStartThrowsException(){builder.withDelimiter('!').withCommentStart('!').build();}
@Test(expected=IllegalStateException.class)public void testDelimiterSameAsEscapeThrowsException(){builder.withDelimiter('!').withEscape('!').build();}
@Test public void testEscape(){assertEquals('?',builder.withEscape('?').build().getEscape().charValue());}
@Test(expected=IllegalStateException.class)public void testEscapeSameAsCommentStartThrowsException(){builder.withEscape('!').withCommentStart('!').build();}
@Test(expected=IllegalStateException.class)public void testEscapeSameAsCommentStartThrowsExceptionForWrapperType(){builder.withEscape(new Character('!')).withCommentStart(new Character('!')).build();}
@Test public void testHeaderReferenceCannotEscape(){final String[]header=new String[]{"one","tow","three"};builder.withHeader(header);final CSVFormat firstFormat=builder.build();final CSVFormat secondFormat=builder.build();assertNotSame(header,firstFormat.getHeader());assertNotSame(firstFormat,secondFormat.getHeader());}
@Test public void testIgnoreEmptyLines(){assertFalse(builder.withIgnoreEmptyLines(false).build().getIgnoreEmptyLines());}
@Test public void testIgnoreSurroundingSpaces(){assertFalse(builder.withIgnoreSurroundingSpaces(false).build().getIgnoreSurroundingSpaces());}
@Test(expected=IllegalArgumentException.class)public void testNewFormatCRThrowsException(){CSVFormat.newBuilder(CR);}
@Test(expected=IllegalArgumentException.class)public void testNewFormatLFThrowsException(){CSVFormat.newBuilder(LF);}
@Test public void testQuoteChar(){assertEquals('?',builder.withQuoteChar('?').build().getQuoteChar().charValue());}
@Test(expected=IllegalStateException.class)public void testQuoteCharSameAsCommentStartThrowsException(){builder.withQuoteChar('!').withCommentStart('!').build();}
@Test(expected=IllegalStateException.class)public void testQuoteCharSameAsCommentStartThrowsExceptionForWrapperType(){builder.withQuoteChar(new Character('!')).withCommentStart('!').build();}
@Test(expected=IllegalStateException.class)public void testQuoteCharSameAsDelimiterThrowsException(){builder.withQuoteChar('!').withDelimiter('!').build();}
@Test public void testQuotePolicy(){assertEquals(Quote.ALL,builder.withQuotePolicy(Quote.ALL).build().getQuotePolicy());}
@Test(expected=IllegalStateException.class)public void testQuotePolicyNoneWithoutEscapeThrowsException(){CSVFormat.newBuilder('!').withQuotePolicy(Quote.NONE).build();}
@Test public void testRecoardSeparator(){assertEquals("?",builder.withRecordSeparator("?").build().getRecordSeparator());}
@Test public void testRFC4180(){assertEquals(null,RFC4180.getCommentStart());assertEquals(',',RFC4180.getDelimiter());assertEquals(null,RFC4180.getEscape());assertFalse(RFC4180.getIgnoreEmptyLines());assertEquals(Character.valueOf('"'),RFC4180.getQuoteChar());assertEquals(null,RFC4180.getQuotePolicy());assertEquals("\r\n",RFC4180.getRecordSeparator());}
@Test(expected=IllegalArgumentException.class)public void testWithCommentStartCRThrowsException(){builder.withCommentStart(CR).build();}
@Test(expected=IllegalArgumentException.class)public void testWithDelimiterLFThrowsException(){builder.withDelimiter(LF).build();}
@Test(expected=IllegalArgumentException.class)public void testWithEscapeCRThrowsExceptions(){builder.withEscape(CR).build();}
@Test(expected=IllegalArgumentException.class)public void testWithQuoteLFThrowsException(){builder.withQuoteChar(LF).build();}
@Test public void testGetLine()throws IOException {final CSVParser parser=new CSVParser(new StringReader(CSVINPUT),CSVFormat.newBuilder().withIgnoreSurroundingSpaces(true).build());for(final String[]re : RESULT){assertArrayEquals(re,parser.nextRecord().values());}assertNull(parser.nextRecord());}
@Test public void testGetRecords()throws IOException {final CSVParser parser=new CSVParser(new StringReader(CSVINPUT),CSVFormat.newBuilder().withIgnoreSurroundingSpaces(true).build());final List<CSVRecord> records=parser.getRecords();assertEquals(RESULT.length,records.size());assertTrue(records.size()> 0);for (int i=0;i < RESULT.length;i++){assertArrayEquals(RESULT[i],records.get(i).values());}}
@Test public void testExcelFormat1()throws IOException {final String code="value1,value2,value3,value4\r\na,b,c,d\r\n  x,,," + "\r\n\r\n\"\"\"hello\"\"\",\"  \"\"world\"\"\",\"abc\ndef\",\r\n";final String[][]res={{"value1","value2","value3","value4"},{"a","b","c","d"},{"  x","","",""},{""},{"\"hello\"","  \"world\"","abc\ndef",""}};final CSVParser parser=new CSVParser(code,CSVFormat.EXCEL);final List<CSVRecord> records=parser.getRecords();assertEquals(res.length,records.size());assertTrue(records.size()> 0);for (int i=0;i < res.length;i++){assertArrayEquals(res[i],records.get(i).values());}}
@Test public void testExcelFormat2()throws Exception {final String code="foo,baar\r\n\r\nhello,\r\n\r\nworld,\r\n";final String[][]res={{"foo","baar"},{""},{"hello",""},{""},{"world",""}};final CSVParser parser=new CSVParser(code,CSVFormat.EXCEL);final List<CSVRecord> records=parser.getRecords();assertEquals(res.length,records.size());assertTrue(records.size()> 0);for (int i=0;i < res.length;i++){assertArrayEquals(res[i],records.get(i).values());}}
@Test public void testEndOfFileBehaviourExcel()throws Exception {final String[]codes={"hello,\r\n\r\nworld,\r\n","hello,\r\n\r\nworld,","hello,\r\n\r\nworld,\"\"\r\n","hello,\r\n\r\nworld,\"\"","hello,\r\n\r\nworld,\n","hello,\r\n\r\nworld,","hello,\r\n\r\nworld,\"\"\n","hello,\r\n\r\nworld,\"\""};final String[][]res={{"hello",""},{""},{"world",""}};for(final String code : codes){final CSVParser parser=new CSVParser(code,CSVFormat.EXCEL);final List<CSVRecord> records=parser.getRecords();assertEquals(res.length,records.size());assertTrue(records.size()> 0);for (int i=0;i < res.length;i++){assertArrayEquals(res[i],records.get(i).values());}}}
@Test public void testEndOfFileBehaviorCSV()throws Exception {final String[]codes={"hello,\r\n\r\nworld,\r\n","hello,\r\n\r\nworld,","hello,\r\n\r\nworld,\"\"\r\n","hello,\r\n\r\nworld,\"\"","hello,\r\n\r\nworld,\n","hello,\r\n\r\nworld,","hello,\r\n\r\nworld,\"\"\n","hello,\r\n\r\nworld,\"\""};final String[][]res={{"hello",""},{"world",""}};for(final String code : codes){final CSVParser parser=new CSVParser(new StringReader(code));final List<CSVRecord> records=parser.getRecords();assertEquals(res.length,records.size());assertTrue(records.size()> 0);for (int i=0;i < res.length;i++){assertArrayEquals(res[i],records.get(i).values());}}}
@Test public void testEmptyLineBehaviourExcel()throws Exception {final String[]codes={"hello,\r\n\r\n\r\n","hello,\n\n\n","hello,\"\"\r\n\r\n\r\n","hello,\"\"\n\n\n"};final String[][]res={{"hello",""},{""},{""}};for(final String code : codes){final CSVParser parser=new CSVParser(code,CSVFormat.EXCEL);final List<CSVRecord> records=parser.getRecords();assertEquals(res.length,records.size());assertTrue(records.size()> 0);for (int i=0;i < res.length;i++){assertArrayEquals(res[i],records.get(i).values());}}}
@Test public void testEmptyLineBehaviourCSV()throws Exception {final String[]codes={"hello,\r\n\r\n\r\n","hello,\n\n\n","hello,\"\"\r\n\r\n\r\n","hello,\"\"\n\n\n"};final String[][]res={{"hello",""}};for(final String code : codes){final CSVParser parser=new CSVParser(new StringReader(code));final List<CSVRecord> records=parser.getRecords();assertEquals(res.length,records.size());assertTrue(records.size()> 0);for (int i=0;i < res.length;i++){assertArrayEquals(res[i],records.get(i).values());}}}
@Test public void testEmptyFile()throws Exception {final CSVParser parser=new CSVParser("",CSVFormat.DEFAULT);assertNull(parser.nextRecord());}
@Test public void testCSV57()throws Exception {final CSVParser parser=new CSVParser("",CSVFormat.DEFAULT);final List<CSVRecord> list=parser.getRecords();assertNotNull(list);assertEquals(0,list.size());}
@Test @Ignore public void testBackslashEscapingOld()throws IOException {final String code="one,two,three\n" + "on\\\"e,two\n" + "on\"e,two\n"+ "one,\"tw\\\"o\"\n"+ "one,\"t\\,wo\"\n"+ "one,two,\"th,ree\"\n"+ "\"a\\\\\"\n"+ "a\\,b\n"+ "\"a\\\\,b\"";final String[][]res={{"one","two","three"},{"on\\\"e","two"},{"on\"e","two"},{"one","tw\"o"},{"one","t\\,wo"},{"one","two","th,ree"},{"a\\\\"},{"a\\","b"},{"a\\\\,b"}};final CSVParser parser=new CSVParser(new StringReader(code));final List<CSVRecord> records=parser.getRecords();assertEquals(res.length,records.size());assertTrue(records.size()> 0);for (int i=0;i < res.length;i++){assertArrayEquals(res[i],records.get(i).values());}}
@Test public void testBackslashEscaping()throws IOException {final String code="one,two,three\n" + "'',''\n" + "/',/'\n"+ "'/'','/''\n"+ "'''',''''\n"+ "/,,/,\n"+ "//,//\n"+ "'//','//'\n"+ "   8,\"quoted \"\" /\" // string\"   \n"+ "9,/\n   \n"+ "";final String[][]res={{"one","two","three"},{"",""},{"'","'"},{"'","'"},{"'","'"},{",",","},{"/","/"},{"/","/"},{"   8   ","   \"quoted \"\" /\" / string\"   "},{"9","   \n   "}};final CSVFormat format=CSVFormat.newBuilder(',').withQuoteChar('\'').withEscape('/').withIgnoreEmptyLines(true).withRecordSeparator(CRLF).build();final CSVParser parser=new CSVParser(code,format);final List<CSVRecord> records=parser.getRecords();assertTrue(records.size()> 0);Utils.compare("Records do not match expected result",res,records);}
@Test public void testBackslashEscaping2()throws IOException {final String code="" + ",,\n" + " \t,,\n"+ " //,/,,/,\n"+ "";final String[][]res={{" "," "," "},{" \t ","  "," "},{" / ",","," ,"}};final CSVFormat format=CSVFormat.newBuilder(',').withEscape('/').withIgnoreEmptyLines(true).withRecordSeparator(CRLF).build();final CSVParser parser=new CSVParser(code,format);final List<CSVRecord> records=parser.getRecords();assertTrue(records.size()> 0);Utils.compare("",res,records);}
@Test public void testDefaultFormat()throws IOException {final String code="" + "a,b#\n" + "\"\n\",\" \",#\n"+ "#,\"\"\n"+ "# Final comment\n";final String[][]res={{"a","b#"},{"\n"," ","#"},{"#",""},{"# Final comment"}};CSVFormat format=CSVFormat.DEFAULT;assertFalse(format.isCommentingEnabled());CSVParser parser=new CSVParser(code,format);List<CSVRecord> records=parser.getRecords();assertTrue(records.size()> 0);Utils.compare("Failed to parse without comments",res,records);final String[][]res_comments={{"a","b#"},{"\n"," ","#"}};format=CSVFormat.newBuilder().withCommentStart('#').build();parser=new CSVParser(code,format);records=parser.getRecords();Utils.compare("Failed to parse with comments",res_comments,records);}
@Test public void testCarriageReturnLineFeedEndings()throws IOException {final String code="foo\r\nbaar,\r\nhello,world\r\n,kanu";final CSVParser parser=new CSVParser(new StringReader(code));final List<CSVRecord> records=parser.getRecords();assertEquals(4,records.size());}
@Test public void testCarriageReturnEndings()throws IOException {final String code="foo\rbaar,\rhello,world\r,kanu";final CSVParser parser=new CSVParser(new StringReader(code));final List<CSVRecord> records=parser.getRecords();assertEquals(4,records.size());}
@Test public void testLineFeedEndings()throws IOException {final String code="foo\nbaar,\nhello,world\n,kanu";final CSVParser parser=new CSVParser(new StringReader(code));final List<CSVRecord> records=parser.getRecords();assertEquals(4,records.size());}
@Test public void testIgnoreEmptyLines()throws IOException {final String code="\nfoo,baar\n\r\n,\n\n,world\r\n\n";final CSVParser parser=new CSVParser(new StringReader(code));final List<CSVRecord> records=parser.getRecords();assertEquals(3,records.size());}
@Test public void testForEach()throws Exception {final List<CSVRecord> records=new ArrayList<CSVRecord>();final Reader in=new StringReader("a,b,c\n1,2,3\nx,y,z");for(final CSVRecord record : CSVFormat.DEFAULT.parse(in)){records.add(record);}assertEquals(3,records.size());assertArrayEquals(new String[]{"a","b","c"},records.get(0).values());assertArrayEquals(new String[]{"1","2","3"},records.get(1).values());assertArrayEquals(new String[]{"x","y","z"},records.get(2).values());}
@Test public void testRoundtrip()throws Exception {final StringWriter out=new StringWriter();final CSVPrinter printer=new CSVPrinter(out,CSVFormat.DEFAULT);final String input="a,b,c\r\n1,2,3\r\nx,y,z\r\n";for(final CSVRecord record : CSVFormat.DEFAULT.parse(new StringReader(input))){printer.printRecord(record);}assertEquals(input,out.toString());printer.close();}
@Test public void testIterator()throws Exception {final Reader in=new StringReader("a,b,c\n1,2,3\nx,y,z");final Iterator<CSVRecord> iterator=CSVFormat.DEFAULT.parse(in).iterator();assertTrue(iterator.hasNext());try {iterator.remove();fail("expected UnsupportedOperationException");}catch(final UnsupportedOperationException expected){}assertArrayEquals(new String[]{"a","b","c"},iterator.next().values());assertArrayEquals(new String[]{"1","2","3"},iterator.next().values());assertTrue(iterator.hasNext());assertTrue(iterator.hasNext());assertTrue(iterator.hasNext());assertArrayEquals(new String[]{"x","y","z"},iterator.next().values());assertFalse(iterator.hasNext());try {iterator.next();fail("NoSuchElementException expected");}catch(final NoSuchElementException e){}}
@Test public void testHeader()throws Exception {final Reader in=new StringReader("a,b,c\n1,2,3\nx,y,z");final Iterator<CSVRecord> records=CSVFormat.newBuilder().withHeader().parse(in).iterator();for (int i=0;i < 2;i++){assertTrue(records.hasNext());final CSVRecord record=records.next();assertEquals(record.get(0),record.get("a"));assertEquals(record.get(1),record.get("b"));assertEquals(record.get(2),record.get("c"));}assertFalse(records.hasNext());}
@Test public void testHeaderComment()throws Exception {final Reader in=new StringReader("# comment\na,b,c\n1,2,3\nx,y,z");final Iterator<CSVRecord> records=CSVFormat.newBuilder().withCommentStart('#').withHeader().parse(in).iterator();for (int i=0;i < 2;i++){assertTrue(records.hasNext());final CSVRecord record=records.next();assertEquals(record.get(0),record.get("a"));assertEquals(record.get(1),record.get("b"));assertEquals(record.get(2),record.get("c"));}assertFalse(records.hasNext());}
@Test public void testProvidedHeader()throws Exception {final Reader in=new StringReader("a,b,c\n1,2,3\nx,y,z");final Iterator<CSVRecord> records=CSVFormat.newBuilder().withHeader("A","B","C").parse(in).iterator();for (int i=0;i < 3;i++){assertTrue(records.hasNext());final CSVRecord record=records.next();assertTrue(record.isMapped("A"));assertTrue(record.isMapped("B"));assertTrue(record.isMapped("C"));assertFalse(record.isMapped("NOT MAPPED"));assertEquals(record.get(0),record.get("A"));assertEquals(record.get(1),record.get("B"));assertEquals(record.get(2),record.get("C"));}assertFalse(records.hasNext());}
@Test public void testMappedButNotSetAsOutlook2007ContactExport()throws Exception {final Reader in=new StringReader("a,b,c\n1,2\nx,y,z");final Iterator<CSVRecord> records=CSVFormat.newBuilder().withHeader("A","B","C").parse(in).iterator();assertTrue(records.hasNext());CSVRecord record=records.next();assertTrue(record.isMapped("A"));assertTrue(record.isMapped("B"));assertTrue(record.isMapped("C"));assertTrue(record.isSet("A"));assertTrue(record.isSet("B"));assertTrue(record.isSet("C"));assertEquals("a",record.get("A"));assertEquals("b",record.get("B"));assertEquals("c",record.get("C"));assertTrue(record.isConsistent());record=records.next();assertTrue(record.isMapped("A"));assertTrue(record.isMapped("B"));assertTrue(record.isMapped("C"));assertTrue(record.isSet("A"));assertTrue(record.isSet("B"));assertFalse(record.isSet("C"));assertEquals("1",record.get("A"));assertEquals("2",record.get("B"));assertFalse(record.isConsistent());record=records.next();assertTrue(record.isMapped("A"));assertTrue(record.isMapped("B"));assertTrue(record.isMapped("C"));assertTrue(record.isSet("A"));assertTrue(record.isSet("B"));assertTrue(record.isSet("C"));assertEquals("x",record.get("A"));assertEquals("y",record.get("B"));assertEquals("z",record.get("C"));assertTrue(record.isConsistent());assertFalse(records.hasNext());}
@Test public void testGetHeaderMap()throws Exception {final CSVParser parser=new CSVParser("a,b,c\n1,2,3\nx,y,z",CSVFormat.newBuilder().withHeader("A","B","C").build());final Map<String,Integer> headerMap=parser.getHeaderMap();final Iterator<String> columnNames=headerMap.keySet().iterator();Assert.assertEquals("A",columnNames.next());Assert.assertEquals("B",columnNames.next());Assert.assertEquals("C",columnNames.next());final Iterator<CSVRecord> records=parser.iterator();for (int i=0;i < 3;i++){assertTrue(records.hasNext());final CSVRecord record=records.next();assertEquals(record.get(0),record.get("A"));assertEquals(record.get(1),record.get("B"));assertEquals(record.get(2),record.get("C"));}assertFalse(records.hasNext());}
@Test public void testGetLineNumberWithLF()throws Exception {validateLineNumbers(String.valueOf(LF));}
@Test public void testGetLineNumberWithCRLF()throws Exception {validateLineNumbers(CRLF);}
@Test public void testGetLineNumberWithCR()throws Exception {validateLineNumbers(String.valueOf(CR));}
@Test public void testGetRecordNumberWithLF()throws Exception {validateRecordNumbers(String.valueOf(LF));}
@Test public void testGetRecordWithMultiiLineValues()throws Exception {final CSVParser parser=new CSVParser("\"a\r\n1\",\"a\r\n2\"" + CRLF + "\"b\r\n1\",\"b\r\n2\""+ CRLF+ "\"c\r\n1\",\"c\r\n2\"",CSVFormat.newBuilder().withRecordSeparator(CRLF).build());CSVRecord record;assertEquals(0,parser.getRecordNumber());assertEquals(0,parser.getLineNumber());assertNotNull(record=parser.nextRecord());assertEquals(3,parser.getLineNumber());assertEquals(1,record.getRecordNumber());assertEquals(1,parser.getRecordNumber());assertNotNull(record=parser.nextRecord());assertEquals(6,parser.getLineNumber());assertEquals(2,record.getRecordNumber());assertEquals(2,parser.getRecordNumber());assertNotNull(record=parser.nextRecord());assertEquals(8,parser.getLineNumber());assertEquals(3,record.getRecordNumber());assertEquals(3,parser.getRecordNumber());assertNull(record=parser.nextRecord());assertEquals(8,parser.getLineNumber());assertEquals(3,parser.getRecordNumber());}
@Test public void testGetRecordNumberWithCRLF()throws Exception {validateRecordNumbers(CRLF);}
@Test public void testGetRecordNumberWithCR()throws Exception {validateRecordNumbers(String.valueOf(CR));}
@Test public void testSurroundingSpacesAreDeleted()throws IOException {final String code="noSpaces,leadingSpaces,trailingSpaces,surroundingSpaces,,,";final Lexer parser=getLexer(code,CSVFormat.newBuilder().withIgnoreSurroundingSpaces(true).build());assertThat(parser.nextToken(new Token()),matches(TOKEN,"noSpaces"));assertThat(parser.nextToken(new Token()),matches(TOKEN,"leadingSpaces"));assertThat(parser.nextToken(new Token()),matches(TOKEN,"trailingSpaces"));assertThat(parser.nextToken(new Token()),matches(TOKEN,"surroundingSpaces"));assertThat(parser.nextToken(new Token()),matches(TOKEN,""));assertThat(parser.nextToken(new Token()),matches(TOKEN,""));assertThat(parser.nextToken(new Token()),matches(EOF,""));}
@Test public void testSurroundingTabsAreDeleted()throws IOException {final String code="noTabs,\tleadingTab,trailingTab\t,\tsurroundingTabs\t,\t\t,,";final Lexer parser=getLexer(code,CSVFormat.newBuilder().withIgnoreSurroundingSpaces(true).build());assertThat(parser.nextToken(new Token()),matches(TOKEN,"noTabs"));assertThat(parser.nextToken(new Token()),matches(TOKEN,"leadingTab"));assertThat(parser.nextToken(new Token()),matches(TOKEN,"trailingTab"));assertThat(parser.nextToken(new Token()),matches(TOKEN,"surroundingTabs"));assertThat(parser.nextToken(new Token()),matches(TOKEN,""));assertThat(parser.nextToken(new Token()),matches(TOKEN,""));assertThat(parser.nextToken(new Token()),matches(EOF,""));}
@Test public void testIgnoreEmptyLines()throws IOException {final String code="first,line,\n" + "\n" + "\n"+ "second,line\n"+ "\n"+ "\n"+ "third line \n"+ "\n"+ "\n"+ "last,line \n"+ "\n"+ "\n"+ "\n";final CSVFormat format=CSVFormat.newBuilder().withIgnoreEmptyLines(true).build();final Lexer parser=getLexer(code,format);assertThat(parser.nextToken(new Token()),matches(TOKEN,"first"));assertThat(parser.nextToken(new Token()),matches(TOKEN,"line"));assertThat(parser.nextToken(new Token()),matches(EORECORD,""));assertThat(parser.nextToken(new Token()),matches(TOKEN,"second"));assertThat(parser.nextToken(new Token()),matches(EORECORD,"line"));assertThat(parser.nextToken(new Token()),matches(EORECORD,"third line "));assertThat(parser.nextToken(new Token()),matches(TOKEN,"last"));assertThat(parser.nextToken(new Token()),matches(EORECORD," line "));assertThat(parser.nextToken(new Token()),matches(EOF,""));assertThat(parser.nextToken(new Token()),matches(EOF,""));}
@Test public void testComments()throws IOException {final String code="first,line,\n" + "second,line,tokenWith#no-comment\n" + "# comment line \n"+ "third,line,#no-comment\n"+ "# penultimate comment\n"+ "# Final comment\n";final CSVFormat format=CSVFormat.newBuilder().withCommentStart('#').build();final Lexer parser=getLexer(code,format);assertThat(parser.nextToken(new Token()),matches(TOKEN,"first"));assertThat(parser.nextToken(new Token()),matches(TOKEN,"line"));assertThat(parser.nextToken(new Token()),matches(EORECORD,""));assertThat(parser.nextToken(new Token()),matches(TOKEN,"second"));assertThat(parser.nextToken(new Token()),matches(TOKEN,"line"));assertThat(parser.nextToken(new Token()),matches(EORECORD,"tokenWith#no-comment"));assertThat(parser.nextToken(new Token()),matches(COMMENT,"comment line"));assertThat(parser.nextToken(new Token()),matches(TOKEN,"third"));assertThat(parser.nextToken(new Token()),matches(TOKEN,"line"));assertThat(parser.nextToken(new Token()),matches(EORECORD,"#no-comment"));assertThat(parser.nextToken(new Token()),matches(COMMENT,"penultimate comment"));assertThat(parser.nextToken(new Token()),matches(COMMENT,"Final comment"));assertThat(parser.nextToken(new Token()),matches(EOF,""));assertThat(parser.nextToken(new Token()),matches(EOF,""));}
@Test public void testCommentsAndEmptyLines()throws IOException {final String code="1,2,3,\n" + "\n" + "\n"+ "a,b x,c#no-comment\n"+ "#foo\n"+ "\n"+ "\n"+ "d,e,#no-comment\n"+ "\n"+ "\n"+ "# penultimate comment\n"+ "\n"+ "\n"+ "# Final comment\n";final CSVFormat format=CSVFormat.newBuilder().withCommentStart('#').withIgnoreEmptyLines(false).build();assertFalse("Should not ignore empty lines",format.getIgnoreEmptyLines());final Lexer parser=getLexer(code,format);assertThat(parser.nextToken(new Token()),matches(TOKEN,"1"));assertThat(parser.nextToken(new Token()),matches(TOKEN,"2"));assertThat(parser.nextToken(new Token()),matches(TOKEN,"3"));assertThat(parser.nextToken(new Token()),matches(EORECORD,""));assertThat(parser.nextToken(new Token()),matches(EORECORD,""));assertThat(parser.nextToken(new Token()),matches(EORECORD,""));assertThat(parser.nextToken(new Token()),matches(TOKEN,"a"));assertThat(parser.nextToken(new Token()),matches(TOKEN,"b x"));assertThat(parser.nextToken(new Token()),matches(EORECORD,"c#no-comment"));assertThat(parser.nextToken(new Token()),matches(COMMENT,"foo"));assertThat(parser.nextToken(new Token()),matches(EORECORD,""));assertThat(parser.nextToken(new Token()),matches(EORECORD,""));assertThat(parser.nextToken(new Token()),matches(TOKEN,"d"));assertThat(parser.nextToken(new Token()),matches(TOKEN,"e"));assertThat(parser.nextToken(new Token()),matches(EORECORD,"#no-comment"));assertThat(parser.nextToken(new Token()),matches(EORECORD,""));assertThat(parser.nextToken(new Token()),matches(EORECORD,""));assertThat(parser.nextToken(new Token()),matches(COMMENT,"penultimate comment"));assertThat(parser.nextToken(new Token()),matches(EORECORD,""));assertThat(parser.nextToken(new Token()),matches(EORECORD,""));assertThat(parser.nextToken(new Token()),matches(COMMENT,"Final comment"));assertThat(parser.nextToken(new Token()),matches(EOF,""));assertThat(parser.nextToken(new Token()),matches(EOF,""));}
@Test public void testBackslashWithoutEscaping()throws IOException {final String code="a,\\,,b\\\n\\,,";final CSVFormat format=CSVFormat.DEFAULT;assertFalse(format.isEscaping());final Lexer parser=getLexer(code,format);assertThat(parser.nextToken(new Token()),matches(TOKEN,"a"));assertThat(parser.nextToken(new Token()),matches(TOKEN,"\\"));assertThat(parser.nextToken(new Token()),matches(TOKEN,""));assertThat(parser.nextToken(new Token()),matches(EORECORD,"b\\"));assertThat(parser.nextToken(new Token()),matches(TOKEN,"\\"));assertThat(parser.nextToken(new Token()),matches(TOKEN,""));assertThat(parser.nextToken(new Token()),matches(EOF,""));}
@Test public void testBackslashWithEscaping()throws IOException {final String code="a,\\,,b\\\\\n\\,,\\\nc,d\\\r\ne";final CSVFormat format=formatWithEscaping.toBuilder().withIgnoreEmptyLines(false).build();assertTrue(format.isEscaping());final Lexer parser=getLexer(code,format);assertThat(parser.nextToken(new Token()),matches(TOKEN,"a"));assertThat(parser.nextToken(new Token()),matches(TOKEN,","));assertThat(parser.nextToken(new Token()),matches(EORECORD,"b\\"));assertThat(parser.nextToken(new Token()),matches(TOKEN,","));assertThat(parser.nextToken(new Token()),matches(TOKEN,"\nc"));assertThat(parser.nextToken(new Token()),matches(EORECORD,"d\r"));assertThat(parser.nextToken(new Token()),matches(EOF,"e"));}
@Test public void testNextToken4()throws IOException {final String code="a,\"foo\",b\na,\" foo\",b\na,\"foo \"  ,b\na,\" foo \"  ,b";final Lexer parser=getLexer(code,CSVFormat.newBuilder().withIgnoreSurroundingSpaces(true).build());assertThat(parser.nextToken(new Token()),matches(TOKEN,"a"));assertThat(parser.nextToken(new Token()),matches(TOKEN,"foo"));assertThat(parser.nextToken(new Token()),matches(EORECORD,"b"));assertThat(parser.nextToken(new Token()),matches(TOKEN,"a"));assertThat(parser.nextToken(new Token()),matches(TOKEN," foo"));assertThat(parser.nextToken(new Token()),matches(EORECORD,"b"));assertThat(parser.nextToken(new Token()),matches(TOKEN,"a"));assertThat(parser.nextToken(new Token()),matches(TOKEN,"foo "));assertThat(parser.nextToken(new Token()),matches(EORECORD,"b"));assertThat(parser.nextToken(new Token()),matches(TOKEN,"a"));assertThat(parser.nextToken(new Token()),matches(TOKEN," foo "));assertThat(parser.nextToken(new Token()),matches(EOF,"b"));}
@Test public void testNextToken5()throws IOException {final String code="a,\"foo\n\",b\n\"foo\n  baar ,,,\"\n\"\n\t \n\"";final Lexer parser=getLexer(code,CSVFormat.DEFAULT);assertThat(parser.nextToken(new Token()),matches(TOKEN,"a"));assertThat(parser.nextToken(new Token()),matches(TOKEN,"foo\n"));assertThat(parser.nextToken(new Token()),matches(EORECORD,"b"));assertThat(parser.nextToken(new Token()),matches(EORECORD,"foo\n  baar ,,,"));assertThat(parser.nextToken(new Token()),matches(EOF,"\n\t \n"));}
@Test public void testNextToken6()throws IOException {final String code="a;'b and '' more\n'\n!comment;;;;\n;;";final CSVFormat format=CSVFormat.newBuilder().withDelimiter(';').withQuoteChar('\'').withCommentStart('!').build();final Lexer parser=getLexer(code,format);assertThat(parser.nextToken(new Token()),matches(TOKEN,"a"));assertThat(parser.nextToken(new Token()),matches(EORECORD,"b and ' more\n"));}
@Test public void testDelimiterIsWhitespace()throws IOException {final String code="one\ttwo\t\tfour \t five\t six";final Lexer parser=getLexer(code,CSVFormat.TDF);assertThat(parser.nextToken(new Token()),matches(TOKEN,"one"));assertThat(parser.nextToken(new Token()),matches(TOKEN,"two"));assertThat(parser.nextToken(new Token()),matches(TOKEN,""));assertThat(parser.nextToken(new Token()),matches(TOKEN,"four"));assertThat(parser.nextToken(new Token()),matches(TOKEN,"five"));assertThat(parser.nextToken(new Token()),matches(EOF,"six"));}
@Test public void testEscapedCR()throws Exception {final Lexer lexer=getLexer("character\\" + CR + "Escaped",formatWithEscaping);assertThat(lexer.nextToken(new Token()),hasContent("character" + CR + "Escaped"));}
@Test public void testEscapedLF()throws Exception {final Lexer lexer=getLexer("character\\" + LF + "Escaped",formatWithEscaping);assertThat(lexer.nextToken(new Token()),hasContent("character" + LF + "Escaped"));}
@Test public void testEscapedTab()throws Exception {final Lexer lexer=getLexer("character\\" + TAB + "Escaped",formatWithEscaping);assertThat(lexer.nextToken(new Token()),hasContent("character" + TAB + "Escaped"));}
@Test public void testEscapeBackspace()throws Exception {final Lexer lexer=getLexer("character\\" + BACKSPACE + "Escaped",formatWithEscaping);assertThat(lexer.nextToken(new Token()),hasContent("character" + BACKSPACE + "Escaped"));}
@Test public void testEscapeFF()throws Exception {final Lexer lexer=getLexer("character\\" + FF + "Escaped",formatWithEscaping);assertThat(lexer.nextToken(new Token()),hasContent("character" + FF + "Escaped"));}
@Test public void testEscapedMySqlNullValue()throws Exception {final Lexer lexer=getLexer("character\\NEscaped",formatWithEscaping);assertThat(lexer.nextToken(new Token()),hasContent("character\\NEscaped"));}
@Test public void testEscapedCharacter()throws Exception {final Lexer lexer=getLexer("character\\aEscaped",formatWithEscaping);assertThat(lexer.nextToken(new Token()),hasContent("character\\aEscaped"));}
@Test public void testEscapedControlCharacter()throws Exception {final Lexer lexer=getLexer("character!rEscaped",CSVFormat.newBuilder().withEscape('!').build());assertThat(lexer.nextToken(new Token()),hasContent("character" + CR + "Escaped"));}
@Test public void testEscapedControlCharacter2()throws Exception {final Lexer lexer=getLexer("character\\rEscaped",CSVFormat.newBuilder().withEscape('\\').build());assertThat(lexer.nextToken(new Token()),hasContent("character" + CR + "Escaped"));}
@Test(expected=IOException.class)public void testEscapingAtEOF()throws Exception {final String code="escaping at EOF is evil\\";final Lexer lexer=getLexer(code,formatWithEscaping);lexer.nextToken(new Token());}
@Test public void testHasType(){assertFalse(hasType(Token.Type.COMMENT).matches(token));assertFalse(hasType(Token.Type.EOF).matches(token));assertFalse(hasType(Token.Type.EORECORD).matches(token));assertTrue(hasType(Token.Type.TOKEN).matches(token));}
@Test public void testHasContent(){assertFalse(hasContent("This is not the token's content").matches(token));assertTrue(hasContent("content").matches(token));}
@Test public void testIsReady(){assertTrue(isReady().matches(token));token.isReady=false;assertFalse(isReady().matches(token));}
@Test public void testMatches(){assertTrue(matches(Token.Type.TOKEN,"content").matches(token));assertFalse(matches(Token.Type.EOF,"content").matches(token));assertFalse(matches(Token.Type.TOKEN,"not the content").matches(token));assertFalse(matches(Token.Type.EORECORD,"not the content").matches(token));}
@Test public void testDisabledComment()throws IOException {final StringWriter sw=new StringWriter();final CSVPrinter printer=new CSVPrinter(sw,CSVFormat.DEFAULT);printer.printComment("This is a comment");assertEquals("",sw.toString());printer.close();}
@Test public void testExcelPrintAllArrayOfArrays()throws IOException {final StringWriter sw=new StringWriter();final CSVPrinter printer=new CSVPrinter(sw,CSVFormat.EXCEL);printer.printRecords(new String[][]{{"r1c1","r1c2"},{"r2c1","r2c2"}});assertEquals("r1c1,r1c2" + recordSeparator + "r2c1,r2c2"+ recordSeparator,sw.toString());printer.close();}
@Test public void testExcelPrintAllArrayOfLists()throws IOException {final StringWriter sw=new StringWriter();final CSVPrinter printer=new CSVPrinter(sw,CSVFormat.EXCEL);printer.printRecords(new List[]{Arrays.asList(new String[]{"r1c1","r1c2"}),Arrays.asList(new String[]{"r2c1","r2c2"})});assertEquals("r1c1,r1c2" + recordSeparator + "r2c1,r2c2"+ recordSeparator,sw.toString());printer.close();}
@Test public void testExcelPrintAllIterableOfArrays()throws IOException {final StringWriter sw=new StringWriter();final CSVPrinter printer=new CSVPrinter(sw,CSVFormat.EXCEL);printer.printRecords(Arrays.asList(new String[][]{{"r1c1","r1c2"},{"r2c1","r2c2"}}));assertEquals("r1c1,r1c2" + recordSeparator + "r2c1,r2c2"+ recordSeparator,sw.toString());printer.close();}
@Test public void testExcelPrintAllIterableOfLists()throws IOException {final StringWriter sw=new StringWriter();final CSVPrinter printer=new CSVPrinter(sw,CSVFormat.EXCEL);printer.printRecords(Arrays.asList(new List[]{Arrays.asList(new String[]{"r1c1","r1c2"}),Arrays.asList(new String[]{"r2c1","r2c2"})}));assertEquals("r1c1,r1c2" + recordSeparator + "r2c1,r2c2"+ recordSeparator,sw.toString());printer.close();}
@Test public void testExcelPrinter1()throws IOException {final StringWriter sw=new StringWriter();final CSVPrinter printer=new CSVPrinter(sw,CSVFormat.EXCEL);printer.printRecord("a","b");assertEquals("a,b" + recordSeparator,sw.toString());printer.close();}
@Test public void testExcelPrinter2()throws IOException {final StringWriter sw=new StringWriter();final CSVPrinter printer=new CSVPrinter(sw,CSVFormat.EXCEL);printer.printRecord("a,b","b");assertEquals("\"a,b\",b" + recordSeparator,sw.toString());printer.close();}
@Test public void testJdbcPrinter()throws IOException,ClassNotFoundException,SQLException {final StringWriter sw=new StringWriter();Class.forName("org.h2.Driver");final Connection connection=DriverManager.getConnection("jdbc:h2:mem:my_test;","sa","");try {final Statement stmt=connection.createStatement();stmt.execute("CREATE TABLE TEST(ID INT PRIMARY KEY,NAME VARCHAR(255))");stmt.execute("insert into TEST values(1,'r1')");stmt.execute("insert into TEST values(2,'r2')");final CSVPrinter printer=new CSVPrinter(sw,CSVFormat.DEFAULT);printer.printRecords(stmt.executeQuery("select ID,NAME from TEST"));assertEquals("1,r1" + recordSeparator + "2,r2"+ recordSeparator,sw.toString());printer.close();}finally {connection.close();}}
@Test public void testMultiLineComment()throws IOException {final StringWriter sw=new StringWriter();final CSVPrinter printer=new CSVPrinter(sw,CSVFormat.newBuilder().withCommentStart('#').build());printer.printComment("This is a comment\non multiple lines");assertEquals("# This is a comment" + recordSeparator + "# on multiple lines"+ recordSeparator,sw.toString());printer.close();}
@Test public void testPrinter1()throws IOException {final StringWriter sw=new StringWriter();final CSVPrinter printer=new CSVPrinter(sw,CSVFormat.DEFAULT);printer.printRecord("a","b");assertEquals("a,b" + recordSeparator,sw.toString());printer.close();}
@Test public void testPrinter2()throws IOException {final StringWriter sw=new StringWriter();final CSVPrinter printer=new CSVPrinter(sw,CSVFormat.DEFAULT);printer.printRecord("a,b","b");assertEquals("\"a,b\",b" + recordSeparator,sw.toString());printer.close();}
@Test public void testPrinter3()throws IOException {final StringWriter sw=new StringWriter();final CSVPrinter printer=new CSVPrinter(sw,CSVFormat.DEFAULT);printer.printRecord("a,b","b ");assertEquals("\"a,b\",\"b \"" + recordSeparator,sw.toString());printer.close();}
@Test public void testPrinter4()throws IOException {final StringWriter sw=new StringWriter();final CSVPrinter printer=new CSVPrinter(sw,CSVFormat.DEFAULT);printer.printRecord("a","b\"c");assertEquals("a,\"b\"\"c\"" + recordSeparator,sw.toString());printer.close();}
@Test public void testPrinter5()throws IOException {final StringWriter sw=new StringWriter();final CSVPrinter printer=new CSVPrinter(sw,CSVFormat.DEFAULT);printer.printRecord("a","b\nc");assertEquals("a,\"b\nc\"" + recordSeparator,sw.toString());printer.close();}
@Test public void testPrinter6()throws IOException {final StringWriter sw=new StringWriter();final CSVPrinter printer=new CSVPrinter(sw,CSVFormat.DEFAULT);printer.printRecord("a","b\r\nc");assertEquals("a,\"b\r\nc\"" + recordSeparator,sw.toString());printer.close();}
@Test public void testPrinter7()throws IOException {final StringWriter sw=new StringWriter();final CSVPrinter printer=new CSVPrinter(sw,CSVFormat.DEFAULT);printer.printRecord("a","b\\c");assertEquals("a,b\\c" + recordSeparator,sw.toString());printer.close();}
@Test public void testPrintNullValues()throws IOException {final StringWriter sw=new StringWriter();final CSVPrinter printer=new CSVPrinter(sw,CSVFormat.DEFAULT);printer.printRecord("a",null,"b");assertEquals("a,,b" + recordSeparator,sw.toString());printer.close();}
@Test public void testPrintCustomNullValues()throws IOException {final StringWriter sw=new StringWriter();final CSVPrinter printer=new CSVPrinter(sw,CSVFormat.DEFAULT.toBuilder().withNullToString("NULL").build());printer.printRecord("a",null,"b");assertEquals("a,NULL,b" + recordSeparator,sw.toString());printer.close();}
@Test public void testQuoteAll()throws IOException {final StringWriter sw=new StringWriter();final CSVPrinter printer=new CSVPrinter(sw,CSVFormat.newBuilder().withQuotePolicy(Quote.ALL).build());printer.printRecord("a","b\nc","d");assertEquals("\"a\",\"b\nc\",\"d\"" + recordSeparator,sw.toString());printer.close();}
@Test public void testQuoteNonNumeric()throws IOException {final StringWriter sw=new StringWriter();final CSVPrinter printer=new CSVPrinter(sw,CSVFormat.newBuilder().withQuotePolicy(Quote.NON_NUMERIC).build());printer.printRecord("a","b\nc",Integer.valueOf(1));assertEquals("\"a\",\"b\nc\",1" + recordSeparator,sw.toString());printer.close();}
@Test public void testRandom()throws Exception {final int iter=10000;doRandom(CSVFormat.DEFAULT,iter);doRandom(CSVFormat.EXCEL,iter);doRandom(CSVFormat.MYSQL,iter);}
@Test public void testSingleLineComment()throws IOException {final StringWriter sw=new StringWriter();final CSVPrinter printer=new CSVPrinter(sw,CSVFormat.newBuilder().withCommentStart('#').build());printer.printComment("This is a comment");assertEquals("# This is a comment" + recordSeparator,sw.toString());printer.close();}
