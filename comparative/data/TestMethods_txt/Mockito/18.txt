@Test public void shouldValidate(){assertFalse(creationValidator.extraInterfacesValidated);assertFalse(creationValidator.typeValidated);mockUtil.createMock(IMethods.class,new MockSettingsImpl());assertTrue(creationValidator.extraInterfacesValidated);assertTrue(creationValidator.typeValidated);}
@Test public void shouldGetHandler(){List mock=Mockito.mock(List.class);assertNotNull(mockUtil.getMockHandler(mock));}
@Test public void shouldScreamWhenEnhancedButNotAMockPassed(){Object o=Enhancer.create(ArrayList.class,NoOp.INSTANCE);try {mockUtil.getMockHandler(o);fail();}catch(NotAMockException e){}}
@Test(expected=NotAMockException.class)public void shouldScreamWhenNotAMockPassed(){mockUtil.getMockHandler("");}
@Test(expected=MockitoException.class)public void shouldScreamWhenNullPassed(){mockUtil.getMockHandler(null);}
@Test public void shouldValidateMock(){assertFalse(mockUtil.isMock("i mock a mock"));assertTrue(mockUtil.isMock(Mockito.mock(List.class)));}
@Test public void shouldStubWithThrowable()throws Exception {IllegalArgumentException expected=new IllegalArgumentException("thrown by mock");when(mock.add("throw")).thenThrow(expected);try {mock.add("throw");fail();}catch(IllegalArgumentException e){assertEquals(expected,e);}}
@Test public void shouldSetThrowableToVoidMethod()throws Exception {IllegalArgumentException expected=new IllegalArgumentException("thrown by mock");stubVoid(mock).toThrow(expected).on().clear();try {mock.clear();fail();}catch(Exception e){assertEquals(expected,e);}}
@Test public void shouldLastStubbingVoidBeImportant()throws Exception {stubVoid(mock).toThrow(new ExceptionOne()).on().clear();stubVoid(mock).toThrow(new ExceptionTwo()).on().clear();try {mock.clear();fail();}catch(ExceptionTwo e){}}
@Test public void shouldFailStubbingThrowableOnTheSameInvocationDueToAcceptableLimitation()throws Exception {when(mock.get(1)).thenThrow(new ExceptionOne());try {when(mock.get(1)).thenThrow(new ExceptionTwo());fail();}catch(ExceptionOne e){}}
@Test public void shouldAllowSettingCheckedException()throws Exception {Reader reader=mock(Reader.class);IOException ioException=new IOException();when(reader.read()).thenThrow(ioException);try {reader.read();fail();}catch(Exception e){assertEquals(ioException,e);}}
@Test public void shouldAllowSettingError()throws Exception {Error error=new Error();when(mock.add("quake")).thenThrow(error);try {mock.add("quake");fail();}catch(Error e){assertEquals(error,e);}}
@Test(expected=IllegalArgumentException.class)public void shouldInstantiateExceptionClassOnInteraction(){when(mock.add(null)).thenThrow(IllegalArgumentException.class);mock.add(null);}
@Test(expected=IllegalArgumentException.class)public void shouldInstantiateExceptionClassWithOngoingStubbingOnInteraction(){Mockito.doThrow(IllegalArgumentException.class).when(mock).add(null);mock.add(null);}
@Test(expected=MockitoException.class)public void shouldNotAllowSettingInvalidCheckedException()throws Exception {when(mock.add("monkey island")).thenThrow(new Exception());}
@Test(expected=MockitoException.class)public void shouldNotAllowSettingNullThrowable()throws Exception {when(mock.add("monkey island")).thenThrow((Throwable)null);}
@Test(expected=MockitoException.class)public void shouldNotAllowSettingNullThrowableArray()throws Exception {when(mock.add("monkey island")).thenThrow((Throwable[])null);}
@Test public void shouldMixThrowablesAndReturnsOnDifferentMocks()throws Exception {when(mock.add("ExceptionOne")).thenThrow(new ExceptionOne());when(mock.getLast()).thenReturn("last");stubVoid(mock).toThrow(new ExceptionTwo()).on().clear();stubVoid(mockTwo).toThrow(new ExceptionThree()).on().clear();when(mockTwo.containsValue("ExceptionFour")).thenThrow(new ExceptionFour());when(mockTwo.get("Are you there?")).thenReturn("Yes!");assertNull(mockTwo.get("foo"));assertTrue(mockTwo.keySet().isEmpty());assertEquals("Yes!",mockTwo.get("Are you there?"));try {mockTwo.clear();fail();}catch(ExceptionThree e){}try {mockTwo.containsValue("ExceptionFour");fail();}catch(ExceptionFour e){}assertNull(mock.getFirst());assertEquals("last",mock.getLast());try {mock.add("ExceptionOne");fail();}catch(ExceptionOne e){}try {mock.clear();fail();}catch(ExceptionTwo e){}}
@Test public void shouldStubbingWithThrowableBeVerifiable(){when(mock.size()).thenThrow(new RuntimeException());stubVoid(mock).toThrow(new RuntimeException()).on().clone();try {mock.size();fail();}catch(RuntimeException e){}try {mock.clone();fail();}catch(RuntimeException e){}verify(mock).size();verify(mock).clone();verifyNoMoreInteractions(mock);}
@Test public void shouldStubbingWithThrowableFailVerification(){when(mock.size()).thenThrow(new RuntimeException());stubVoid(mock).toThrow(new RuntimeException()).on().clone();verifyZeroInteractions(mock);mock.add("test");try {verify(mock).size();fail();}catch(WantedButNotInvoked e){}try {verify(mock).clone();fail();}catch(WantedButNotInvoked e){}try {verifyNoMoreInteractions(mock);fail();}catch(NoInteractionsWanted e){}}
@Test(expected=NaughtyException.class)public void shouldShowDecentMessageWhenExcepionIsNaughty()throws Exception {when(mock.add("")).thenThrow(NaughtyException.class);mock.add("");}
@Test public void shouldFilterOutCglibGarbage(){StackTraceElement[]t=new TraceBuilder().classes("MockitoExampleTest","List$$EnhancerByMockitoWithCGLIB$$2c406024").toTraceArray();StackTraceElement[]filtered=filter.filter(t,false);assertThat(filtered,hasOnlyThoseClasses("MockitoExampleTest"));}
@Test public void shouldFilterOutMockitoPackage(){StackTraceElement[]t=new TraceBuilder().classes("org.test.MockitoSampleTest","org.mockito.Mockito").toTraceArray();StackTraceElement[]filtered=filter.filter(t,false);assertThat(filtered,hasOnlyThoseClasses("org.test.MockitoSampleTest"));}
@Test public void shouldFilterOutTracesMiddleBadTraces(){StackTraceElement[]t=new TraceBuilder().classes("org.test.MockitoSampleTest","org.test.TestSupport","org.mockito.Mockito","org.test.TestSupport","org.mockito.Mockito").toTraceArray();StackTraceElement[]filtered=filter.filter(t,false);assertThat(filtered,hasOnlyThoseClasses("org.test.TestSupport","org.test.MockitoSampleTest"));}
@Test public void shouldKeepRunners(){StackTraceElement[]t=new TraceBuilder().classes("org.mockito.runners.Runner","junit.stuff","org.test.MockitoSampleTest","org.mockito.Mockito").toTraceArray();StackTraceElement[]filtered=filter.filter(t,false);assertThat(filtered,hasOnlyThoseClasses("org.test.MockitoSampleTest","junit.stuff","org.mockito.runners.Runner"));}
@Test public void shouldKeepInternalRunners(){StackTraceElement[]t=new TraceBuilder().classes("org.mockito.internal.runners.Runner","org.test.MockitoSampleTest").toTraceArray();StackTraceElement[]filtered=filter.filter(t,false);assertThat(filtered,hasOnlyThoseClasses("org.test.MockitoSampleTest","org.mockito.internal.runners.Runner"));}
@Test public void shouldStartFilteringAndKeepTop(){StackTraceElement[]t=new TraceBuilder().classes("org.test.Good","org.mockito.internal.Bad","org.test.MockitoSampleTest").toTraceArray();StackTraceElement[]filtered=filter.filter(t,true);assertThat(filtered,hasOnlyThoseClasses("org.test.MockitoSampleTest","org.test.Good"));}
@Test public void shouldKeepGoodTraceFromTheTopBecauseRealImplementationsOfSpiesSometimesThrowExceptions(){StackTraceElement[]t=new TraceBuilder().classes("org.good.Trace","org.yet.another.good.Trace","org.mockito.internal.to.be.Filtered","org.test.MockitoSampleTest").toTraceArray();StackTraceElement[]filtered=filter.filter(t,true);assertThat(filtered,hasOnlyThoseClasses("org.test.MockitoSampleTest","org.yet.another.good.Trace","org.good.Trace"));}
@Test public void shouldReturnEmptyArrayWhenInputIsEmpty()throws Exception {StackTraceElement[]filtered=filter.filter(new StackTraceElement[0],false);assertEquals(0,filtered.length);}
@Test public void shouldReturnConsecutiveValues()throws Exception {when(mock.simpleMethod()).thenReturn("one").thenReturn("two").thenReturn("three");assertEquals("one",mock.simpleMethod());assertEquals("two",mock.simpleMethod());assertEquals("three",mock.simpleMethod());assertEquals("three",mock.simpleMethod());assertEquals("three",mock.simpleMethod());}
@SuppressWarnings("all")@Test public void shouldReturnConsecutiveValuesForTwoNulls()throws Exception {when(mock.simpleMethod()).thenReturn(null,null);assertNull(mock.simpleMethod());assertNull(mock.simpleMethod());}
@Test public void shouldReturnConsecutiveValuesSetByShortenThenReturnMethod()throws Exception {when(mock.simpleMethod()).thenReturn("one","two","three");assertEquals("one",mock.simpleMethod());assertEquals("two",mock.simpleMethod());assertEquals("three",mock.simpleMethod());assertEquals("three",mock.simpleMethod());assertEquals("three",mock.simpleMethod());}
@Test public void shouldReturnConsecutiveValueAndThrowExceptionssSetByShortenReturnMethods()throws Exception {when(mock.simpleMethod()).thenReturn("zero").thenReturn("one","two").thenThrow(new NullPointerException(),new RuntimeException()).thenReturn("three").thenThrow(new IllegalArgumentException());assertEquals("zero",mock.simpleMethod());assertEquals("one",mock.simpleMethod());assertEquals("two",mock.simpleMethod());try {mock.simpleMethod();fail();}catch(NullPointerException e){}try {mock.simpleMethod();fail();}catch(RuntimeException e){}assertEquals("three",mock.simpleMethod());try {mock.simpleMethod();fail();}catch(IllegalArgumentException e){}}
@Test public void shouldThrowConsecutively()throws Exception {when(mock.simpleMethod()).thenThrow(new RuntimeException()).thenThrow(new IllegalArgumentException()).thenThrow(new NullPointerException());try {mock.simpleMethod();fail();}catch(RuntimeException e){}try {mock.simpleMethod();fail();}catch(IllegalArgumentException e){}try {mock.simpleMethod();fail();}catch(NullPointerException e){}try {mock.simpleMethod();fail();}catch(NullPointerException e){}}
@Test public void shouldThrowConsecutivelySetByShortenThenThrowMethod()throws Exception {when(mock.simpleMethod()).thenThrow(new RuntimeException(),new IllegalArgumentException(),new NullPointerException());try {mock.simpleMethod();fail();}catch(RuntimeException e){}try {mock.simpleMethod();fail();}catch(IllegalArgumentException e){}try {mock.simpleMethod();fail();}catch(NullPointerException e){}try {mock.simpleMethod();fail();}catch(NullPointerException e){}}
@Test public void shouldMixConsecutiveReturnsWithExcepions()throws Exception {when(mock.simpleMethod()).thenThrow(new IllegalArgumentException()).thenReturn("one").thenThrow(new NullPointerException()).thenReturn(null);try {mock.simpleMethod();fail();}catch(IllegalArgumentException e){}assertEquals("one",mock.simpleMethod());try {mock.simpleMethod();fail();}catch(NullPointerException e){}assertEquals(null,mock.simpleMethod());assertEquals(null,mock.simpleMethod());}
@Test(expected=MockitoException.class)public void shouldValidateConsecutiveException()throws Exception {when(mock.simpleMethod()).thenReturn("one").thenThrow(new Exception());}
@Test public void shouldStubVoidMethodAndContinueThrowing()throws Exception {stubVoid(mock).toThrow(new IllegalArgumentException()).toReturn().toThrow(new NullPointerException()).on().voidMethod();try {mock.voidMethod();fail();}catch(IllegalArgumentException e){}mock.voidMethod();try {mock.voidMethod();fail();}catch(NullPointerException e){}try {mock.voidMethod();fail();}catch(NullPointerException e){}}
@Test public void shouldStubVoidMethod()throws Exception {stubVoid(mock).toReturn().toThrow(new NullPointerException()).toReturn().on().voidMethod();mock.voidMethod();try {mock.voidMethod();fail();}catch(NullPointerException e){}mock.voidMethod();mock.voidMethod();}
@Test(expected=MockitoException.class)public void shouldValidateConsecutiveExceptionForVoidMethod()throws Exception {stubVoid(mock).toReturn().toThrow(new Exception()).on().voidMethod();}
@Test public void shouldPointToTooManyInvocationsChunkOnError(){try {verify(mock,times(0)).simpleMethod(1);fail();}catch(NeverWantedButInvoked e){assertContains("first(",e.getMessage());}}
@Test public void shouldNotPointStackTracesToRunnersCode(){try {verify(mock,times(0)).simpleMethod(1);fail();}catch(NeverWantedButInvoked e){assertNotContains(".runners.",e.getMessage());}}
@SuppressWarnings("deprecation")@Test public void shouldStubStringVarargs(){when(mock.withStringVarargsReturningString(1)).thenReturn("1");when(mock.withStringVarargsReturningString(2,"1","2","3")).thenReturn("2");RuntimeException expected=new RuntimeException();stubVoid(mock).toThrow(expected).on().withStringVarargs(3,"1","2","3","4");assertEquals("1",mock.withStringVarargsReturningString(1));assertEquals(null,mock.withStringVarargsReturningString(2));assertEquals("2",mock.withStringVarargsReturningString(2,"1","2","3"));assertEquals(null,mock.withStringVarargsReturningString(2,"1","2"));assertEquals(null,mock.withStringVarargsReturningString(2,"1","2","3","4"));assertEquals(null,mock.withStringVarargsReturningString(2,"1","2","9999"));mock.withStringVarargs(3,"1","2","3","9999");mock.withStringVarargs(9999,"1","2","3","4");try {mock.withStringVarargs(3,"1","2","3","4");fail();}catch(Exception e){assertEquals(expected,e);}}
@Test public void shouldStubBooleanVarargs(){when(mock.withBooleanVarargs(1)).thenReturn(true);when(mock.withBooleanVarargs(1,true,false)).thenReturn(true);assertEquals(true,mock.withBooleanVarargs(1));assertEquals(false,mock.withBooleanVarargs(9999));assertEquals(true,mock.withBooleanVarargs(1,true,false));assertEquals(false,mock.withBooleanVarargs(1,true,false,true));assertEquals(false,mock.withBooleanVarargs(2,true,false));assertEquals(false,mock.withBooleanVarargs(1,true));assertEquals(false,mock.withBooleanVarargs(1,false,false));}
@Test public void shouldVerifyStringVarargs(){mock.withStringVarargs(1);mock.withStringVarargs(2,"1","2","3");mock.withStringVarargs(3,"1","2","3","4");verify(mock).withStringVarargs(1);verify(mock).withStringVarargs(2,"1","2","3");try {verify(mock).withStringVarargs(2,"1","2","79","4");fail();}catch(ArgumentsAreDifferent e){}}
@Test public void shouldVerifyObjectVarargs(){mock.withObjectVarargs(1);mock.withObjectVarargs(2,"1",new ArrayList<Object>(),new Integer(1));mock.withObjectVarargs(3,new Integer(1));verify(mock).withObjectVarargs(1);verify(mock).withObjectVarargs(2,"1",new ArrayList<Object>(),new Integer(1));try {verifyNoMoreInteractions(mock);fail();}catch(NoInteractionsWanted e){}}
@Test public void shouldVerifyBooleanVarargs(){mock.withBooleanVarargs(1);mock.withBooleanVarargs(2,true,false,true);mock.withBooleanVarargs(3,true,true,true);verify(mock).withBooleanVarargs(1);verify(mock).withBooleanVarargs(2,true,false,true);try {verify(mock).withBooleanVarargs(3,true,true,true,true);fail();}catch(ArgumentsAreDifferent e){}}
@Test public void shouldVerifyWithAnyObject(){Foo foo=Mockito.mock(Foo.class);foo.varArgs("");Mockito.verify(foo).varArgs((String[])Mockito.anyObject());Mockito.verify(foo).varArgs((String)Mockito.anyObject());}
@Test public void shouldVerifyWithNullVarArgArray(){Foo foo=Mockito.mock(Foo.class);foo.varArgs((String[])null);Mockito.verify(foo).varArgs((String[])Mockito.anyObject());Mockito.verify(foo).varArgs((String[])null);}
@SuppressWarnings("all")@Test public void shouldStubCorrectlyWhenMixedVarargsUsed(){MixedVarargs mixedVarargs=mock(MixedVarargs.class);when(mixedVarargs.doSomething("hello",null)).thenReturn("hello");when(mixedVarargs.doSomething("goodbye",null)).thenReturn("goodbye");String result=mixedVarargs.doSomething("hello",null);assertEquals("hello",result);verify(mixedVarargs).doSomething("hello",null);}
@SuppressWarnings("all")@Test public void shouldStubCorrectlyWhenDoubleStringAndMixedVarargsUsed(){MixedVarargs mixedVarargs=mock(MixedVarargs.class);when(mixedVarargs.doSomething("one","two",null)).thenReturn("hello");when(mixedVarargs.doSomething("1","2",null)).thenReturn("goodbye");String result=mixedVarargs.doSomething("one","two",null);assertEquals("hello",result);}
@Test public void shouldMatchEasilyEmptyVararg()throws Exception {when(mock.foo(anyVararg())).thenReturn(-1);assertEquals(-1,mock.foo());}
@Test public void should_print_to_system_out(){assertThat(new VerboseMockInvocationLogger().printStream).isSameAs(System.out);}
@Test public void should_print_invocation_with_return_value(){listener.reportInvocation(new NotifiedMethodInvocationReport(invocation,"return value"));assertThat(printed()).contains(invocation.toString()).contains(invocation.getLocation().toString()).contains("return value");}
@Test public void should_print_invocation_with_exception(){listener.reportInvocation(new NotifiedMethodInvocationReport(invocation,new ThirdPartyException()));assertThat(printed()).contains(invocation.toString()).contains(invocation.getLocation().toString()).contains(ThirdPartyException.class.getName());}
@Test public void should_print_if_method_has_not_been_stubbed()throws Exception {listener.reportInvocation(new NotifiedMethodInvocationReport(invocation,"whatever"));assertThat(printed()).doesNotContain("stubbed");}
@Test public void should_print_stubbed_info_if_availbable()throws Exception {invocation.markStubbed(new StubInfo(stubbedInvocation));listener.reportInvocation(new NotifiedMethodInvocationReport(invocation,"whatever"));assertThat(printed()).contains("stubbed").contains(stubbedInvocation.getLocation().toString());}
@Test public void should_log_count_of_interactions(){listener.reportInvocation(new NotifiedMethodInvocationReport(invocation,new ThirdPartyException()));assertThat(printed()).contains("#1");listener.reportInvocation(new NotifiedMethodInvocationReport(invocation,new ThirdPartyException()));assertThat(printed()).contains("#2");listener.reportInvocation(new NotifiedMethodInvocationReport(invocation,new ThirdPartyException()));assertThat(printed()).contains("#3");}
void testMe(String simple,List<List<String>> genericList);
@Test public void testNormalUsage(){MockitoAnnotations.initMocks(this);assertNotNull(finalCaptor);assertNotNull(genericsCaptor);assertNotNull(nonGenericCaptorIsAllowed);assertNull(notAMock);String argForFinalCaptor="Hello";ArrayList<List<String>> argForGenericsCaptor=new ArrayList<List<String>>();mockInterface.testMe(argForFinalCaptor,argForGenericsCaptor);Mockito.verify(mockInterface).testMe(finalCaptor.capture(),genericsCaptor.capture());assertEquals(argForFinalCaptor,finalCaptor.getValue());assertEquals(argForGenericsCaptor,genericsCaptor.getValue());}
@Test public void shouldScreamWhenWrongTypeForCaptor(){try {MockitoAnnotations.initMocks(new WrongType());fail();}catch(MockitoException e){}}
@Test public void shouldScreamWhenMoreThanOneMockitoAnnotaton(){try {MockitoAnnotations.initMocks(new ToManyAnnotations());fail();}catch(MockitoException e){assertContains("missingGenericsField",e.getMessage());assertContains("multiple Mockito annotations",e.getMessage());}}
@Test public void shouldScreamWhenInitializingCaptorsForNullClass()throws Exception {try {MockitoAnnotations.initMocks(null);fail();}catch(MockitoException e){}}
@Test public void shouldLookForAnnotatedCaptorsInSuperClasses()throws Exception {Sub sub=new Sub();MockitoAnnotations.initMocks(sub);assertNotNull(sub.getCaptor());assertNotNull(sub.getBaseCaptor());assertNotNull(sub.getSuperBaseCaptor());}
@Test public void shouldMarkActualInvocationsAsVerified(){AtLeastXNumberOfInvocationsChecker c=new AtLeastXNumberOfInvocationsChecker();c.invocationMarker=Mockito.mock(InvocationMarker.class);Invocation invocation=new InvocationBuilder().simpleMethod().toInvocation();Invocation invocationTwo=new InvocationBuilder().differentMethod().toInvocation();c.check(asList(invocation,invocationTwo),new InvocationMatcher(invocation),1);Mockito.verify(c.invocationMarker).markVerified(eq(asList(invocation)),any(CapturesArgumensFromInvocation.class));}
@Test public void shouldCreateMockForDeprecatedMockAnnotation()throws Exception {assertNotNull(deprecatedMock);}
@Test public void shouldInjectDeprecatedMockAnnotation()throws Exception {assertNotNull(anInjectedObject.aFieldAwaitingInjection);}
@SuppressWarnings("unchecked")@Test public void shouldCompile(){when(sorter.convertDate(new Date())).thenReturn("one");when(sorter.convertDate((Date)anyObject())).thenReturn("two");when(sorter.sort(anyList())).thenReturn(null);}
@Test public void should_call_single_listener_when_mock_return_normally()throws Exception {Foo foo=mock(Foo.class,withSettings().invocationListeners(listener1));willReturn("basil").given(foo).giveMeSomeString("herb");foo.giveMeSomeString("herb");assertThatHasBeenNotified(listener1,"basil",getClass().getSimpleName());}
@Test public void should_call_all_listener_when_mock_return_normally()throws Exception {Foo foo=mock(Foo.class,withSettings().invocationListeners(listener1,listener2));given(foo.giveMeSomeString("herb")).willReturn("rosemary");foo.giveMeSomeString("herb");assertThatHasBeenNotified(listener1,"rosemary",getClass().getSimpleName());assertThatHasBeenNotified(listener2,"rosemary",getClass().getSimpleName());}
@Test public void should_call_all_listener_when_mock_throws_exception()throws Exception {InvocationListener listener1=mock(InvocationListener.class,"listener1");InvocationListener listener2=mock(InvocationListener.class,"listener2");Foo foo=mock(Foo.class,withSettings().invocationListeners(listener1,listener2));doThrow(new OvenNotWorking()).when(foo).doSomething("cook");try {foo.doSomething("cook");fail("Exception expected.");}catch(OvenNotWorking actualException){InOrder orderedVerify=inOrder(listener1,listener2);orderedVerify.verify(listener1).reportInvocation(any(MethodInvocationReport.class));orderedVerify.verify(listener2).reportInvocation(any(MethodInvocationReport.class));}}
@Test public void injectMocksShouldInjectMocksFromTestSuperClasses(){ImplicitTest it=new ImplicitTest();MockitoAnnotations.initMocks(it);assertNotNull(it.daoFromParent);assertNotNull(it.daoFromSub);assertNotNull(it.sut.daoFromParent);assertNotNull(it.sut.daoFromSub);}
@Test public void noNullPointerException(){sut.businessMethod();}
@Test public void shouldKeepUnfilteredStackTrace(){try {throwIt();fail();}catch(MockitoAssertionError e){assertEquals("throwIt",e.getUnfilteredStackTrace()[0].getMethodName());}}
@Test public void shouldInjectUsingPropertySetterIfAvailable(){assertTrue(awaitingInjection.propertySetterUsed);}
@Test public void shouldInjectFieldIfNoSetter(){assertEquals(fieldAccess,awaitingInjection.fieldAccess);}
@Test public void shouldWorkAsStandardMockito()throws Exception {List<Integer> list=asList(1,2,3);when(mock.objectReturningMethodNoArgs()).thenAnswer(new ReturnsElementsOf(list));assertEquals(1,mock.objectReturningMethodNoArgs());assertEquals(2,mock.objectReturningMethodNoArgs());assertEquals(3,mock.objectReturningMethodNoArgs());assertEquals(3,mock.objectReturningMethodNoArgs());assertEquals(3,mock.objectReturningMethodNoArgs());}
@Test public void shouldReturnNullIfNecessary()throws Exception {List<Integer> list=asList(1,null);when(mock.objectReturningMethodNoArgs()).thenAnswer(new ReturnsElementsOf(list));assertEquals(1,mock.objectReturningMethodNoArgs());assertEquals(null,mock.objectReturningMethodNoArgs());assertEquals(null,mock.objectReturningMethodNoArgs());}
@Test public void shouldScreamWhenNullPassed()throws Exception {try {new ReturnsElementsOf(null);fail();}catch(MockitoException e){}}
@Test public void shouldKnowIfIsEqualTo(){Invocation equal=new InvocationBuilder().args(" ").mock("mock").toInvocation();Invocation nonEqual=new InvocationBuilder().args("X").mock("mock").toInvocation();Invocation withNewStringInstance=new InvocationBuilder().args(new String(" ")).mock("mock").toInvocation();assertFalse(invocation.equals(null));assertFalse(invocation.equals(""));assertTrue(invocation.equals(equal));assertFalse(invocation.equals(nonEqual));assertTrue(invocation.equals(withNewStringInstance));}
@Test public void shouldEqualToNotConsiderSequenceNumber(){Invocation equal=new InvocationBuilder().args(" ").mock("mock").seq(2).toInvocation();assertTrue(invocation.equals(equal));assertTrue(invocation.getSequenceNumber()!= equal.getSequenceNumber());}
@Test public void shouldBeACitizenOfHashes(){Map map=new HashMap();map.put(invocation,"one");assertEquals("one",map.get(invocation));}
@Test public void shouldPrintMethodName(){invocation=new InvocationBuilder().toInvocation();assertEquals("iMethods.simpleMethod();",invocation.toString());}
@Test public void shouldPrintMethodArgs(){invocation=new InvocationBuilder().args("foo").toInvocation();assertThat(invocation.toString(),endsWith("simpleMethod(\"foo\");"));}
@Test public void shouldPrintMethodIntegerArgAndString(){invocation=new InvocationBuilder().args("foo",1).toInvocation();assertThat(invocation.toString(),endsWith("simpleMethod(\"foo\",1);"));}
@Test public void shouldPrintNull(){invocation=new InvocationBuilder().args((String)null).toInvocation();assertThat(invocation.toString(),endsWith("simpleMethod(null);"));}
@Test public void shouldPrintArray(){invocation=new InvocationBuilder().method("oneArray").args(new int[]{1,2,3}).toInvocation();assertThat(invocation.toString(),endsWith("oneArray([1,2,3]);"));}
@Test public void shouldPrintNullIfArrayIsNull()throws Exception {Method m=IMethods.class.getMethod("oneArray",Object[].class);invocation=new InvocationBuilder().method(m).args((Object)null).toInvocation();assertThat(invocation.toString(),endsWith("oneArray(null);"));}
@Test public void shouldPrintArgumentsInMultilinesWhenGetsTooBig(){invocation=new InvocationBuilder().args("veeeeery long string that makes it ugly in one line",1).toInvocation();assertThat(invocation.toString(),endsWith("simpleMethod(" + "\n" + "    \"veeeeery long string that makes it ugly in one line\","+ "\n"+ "    1"+ "\n"+ ");"));}
@Test public void shouldTransformArgumentsToMatchers()throws Exception {Invocation i=new InvocationBuilder().args("foo",new String[]{"bar"}).toInvocation();List matchers=i.argumentsToMatchers();assertEquals(2,matchers.size());assertEquals(Equals.class,matchers.get(0).getClass());assertEquals(ArrayEquals.class,matchers.get(1).getClass());}
@Test public void shouldKnowIfIsToString()throws Exception {Invocation toString=new InvocationBuilder().method("toString").toInvocation();assertTrue(toString.isToString());Invocation notToString=new InvocationBuilder().method("toString").arg("foo").toInvocation();assertFalse(notToString.isToString());}
@Test public void shouldKnowValidThrowables()throws Exception {Invocation invocation=new InvocationBuilder().method("canThrowException").toInvocation();assertFalse(invocation.isValidException(new Exception()));assertTrue(invocation.isValidException(new CharacterCodingException()));}
@Test public void shouldBeAbleToCallRealMethod()throws Throwable {Invocation invocation=invocationOf(Foo.class,"bark",new RealMethod(){public Object invoke(Object target,Object[]arguments)throws Throwable {return new Foo().bark();}});assertEquals("woof",invocation.callRealMethod());}
@Test public void shouldScreamWhenCallingRealMethodOnInterface()throws Throwable {Invocation invocationOnInterface=new InvocationBuilder().toInvocation();try {invocationOnInterface.callRealMethod();fail();}catch(MockitoException e){}}
@Test public void shouldEvaluateLatestStubbingFirst()throws Exception {when(mock.objectReturningMethod(isA(Integer.class))).thenReturn(100);when(mock.objectReturningMethod(200)).thenReturn(200);assertEquals(200,mock.objectReturningMethod(200));assertEquals(100,mock.objectReturningMethod(666));assertEquals("default behavior should return null",null,mock.objectReturningMethod("blah"));}
@Test public void shouldStubbingBeTreatedAsInteraction()throws Exception {when(mock.booleanReturningMethod()).thenReturn(true);mock.booleanReturningMethod();try {verifyNoMoreInteractions(mock);fail();}catch(NoInteractionsWanted e){}}
@Test public void shouldAllowStubbingToString()throws Exception {IMethods mockTwo=mock(IMethods.class);when(mockTwo.toString()).thenReturn("test");assertContains("Mock for IMethods",mock.toString());assertEquals("test",mockTwo.toString());}
@Test public void shouldStubbingNotBeTreatedAsInteraction(){when(mock.simpleMethod("one")).thenThrow(new RuntimeException());doThrow(new RuntimeException()).when(mock).simpleMethod("two");verifyZeroInteractions(mock);}
@Test public void unfinishedStubbingCleansUpTheState(){reset(mock);try {when("").thenReturn("");fail();}catch(MissingMethodInvocationException e){}verifyZeroInteractions(mock);}
@Test public void shouldToStringMockName(){IMethods mock=mock(IMethods.class,"mockie");IMethods mockTwo=mock(IMethods.class);assertContains("Mock for IMethods","" + mockTwo);assertEquals("mockie","" + mock);}
@Test public void shouldAllowMockingWhenToStringIsFinal()throws Exception {mock(Foo.class);}
@Test public void shouldKnowWhenArgumentsMatch(){Invocation invocation=new InvocationBuilder().args("1",100).toInvocation();InvocationMatcher invocationMatcher=new InvocationBuilder().args("1",100).toInvocationMatcher();boolean match=comparator.argumentsMatch(invocationMatcher,invocation);assertTrue(match);}
@Test public void shouldKnowWhenArgsDifferent(){Invocation invocation=new InvocationBuilder().args("1",100).toInvocation();InvocationMatcher invocationMatcher=new InvocationBuilder().args("100",100).toInvocationMatcher();boolean match=comparator.argumentsMatch(invocationMatcher,invocation);assertFalse(match);}
@Test public void shouldKnowWhenActualArgsSizeIsDifferent(){Invocation invocation=new InvocationBuilder().args("100",100).toInvocation();InvocationMatcher invocationMatcher=new InvocationBuilder().args("100").toInvocationMatcher();boolean match=comparator.argumentsMatch(invocationMatcher,invocation);assertFalse(match);}
@Test public void shouldKnowWhenMatchersSizeIsDifferent(){Invocation invocation=new InvocationBuilder().args("100").toInvocation();InvocationMatcher invocationMatcher=new InvocationBuilder().args("100",100).toInvocationMatcher();boolean match=comparator.argumentsMatch(invocationMatcher,invocation);assertFalse(match);}
@Test public void shouldKnowWhenVarargsMatch(){mock.varargs("1","2","3");Invocation invocation=getLastInvocation();InvocationMatcher invocationMatcher=new InvocationMatcher(invocation,(List)asList(new Equals("1"),Any.ANY,new InstanceOf(String.class)));boolean match=comparator.argumentsMatch(invocationMatcher,invocation);assertTrue(match);}
@Test public void shouldKnowWhenVarargsDifferent(){mock.varargs("1","2");Invocation invocation=getLastInvocation();InvocationMatcher invocationMatcher=new InvocationMatcher(invocation,(List)asList(new Equals("100"),Any.ANY));boolean match=comparator.argumentsMatch(invocationMatcher,invocation);assertFalse(match);}
@Test public void shouldNotAllowAnyObjectMatchEntireVararg(){mock.varargs("1","2");Invocation invocation=getLastInvocation();InvocationMatcher invocationMatcher=new InvocationMatcher(invocation,(List)asList(Any.ANY));boolean match=comparator.argumentsMatch(invocationMatcher,invocation);assertFalse(match);}
@Test public void shouldAllowAnyVarargMatchEntireVararg(){mock.varargs("1","2");Invocation invocation=getLastInvocation();InvocationMatcher invocationMatcher=new InvocationMatcher(invocation,(List)asList(AnyVararg.ANY_VARARG));boolean match=comparator.argumentsMatch(invocationMatcher,invocation);assertTrue(match);}
@Test public void shouldNotAllowAnyObjectWithMixedVarargs(){mock.mixedVarargs(1,"1","2");Invocation invocation=getLastInvocation();InvocationMatcher invocationMatcher=new InvocationMatcher(invocation,(List)asList(new Equals(1)));boolean match=comparator.argumentsMatch(invocationMatcher,invocation);assertFalse(match);}
@Test public void shouldAllowAnyObjectWithMixedVarargs(){mock.mixedVarargs(1,"1","2");Invocation invocation=getLastInvocation();InvocationMatcher invocationMatcher=new InvocationMatcher(invocation,(List)asList(new Equals(1),AnyVararg.ANY_VARARG));boolean match=comparator.argumentsMatch(invocationMatcher,invocation);assertTrue(match);}
@Test public void shouldNotMatchWhenSomeOtherArgumentDoesNotMatch(){mock.mixedVarargs(1,"1","2");Invocation invocation=getLastInvocation();InvocationMatcher invocationMatcher=new InvocationMatcher(invocation,(List)asList(new Equals(100),AnyVararg.ANY_VARARG));boolean match=comparator.argumentsMatch(invocationMatcher,invocation);assertFalse(match);}
@Test public void shouldAnyObjectVarargDealWithDifferentSizeOfArgs(){mock.mixedVarargs(1,"1","2");Invocation invocation=getLastInvocation();InvocationMatcher invocationMatcher=new InvocationMatcher(invocation,(List)asList(new Equals(1)));boolean match=comparator.argumentsMatch(invocationMatcher,invocation);assertFalse(match);}
@Test public void shouldMatchAnyVarargEvenIfOneOfTheArgsIsNull(){mock.mixedVarargs(null,null,"2");Invocation invocation=getLastInvocation();InvocationMatcher invocationMatcher=new InvocationMatcher(invocation,(List)asList(new Equals(null),AnyVararg.ANY_VARARG));boolean match=comparator.argumentsMatch(invocationMatcher,invocation);assertTrue(match);}
@Test public void shouldMatchAnyVarargEvenIfMatcherIsDecorated(){mock.varargs("1","2");Invocation invocation=getLastInvocation();InvocationMatcher invocationMatcher=new InvocationMatcher(invocation,(List)asList(new LocalizedMatcher(AnyVararg.ANY_VARARG)));boolean match=comparator.argumentsMatch(invocationMatcher,invocation);assertTrue(match);}
@Test public void shouldAllowStubbingMocksConfiguredWithRETURNS_MOCKS(){IMethods mock=mock(IMethods.class,RETURNS_MOCKS);when(mock.objectReturningMethodNoArgs()).thenReturn(null);}
@Test public void shouldAllowStubbingMocksConfiguredWithRETURNS_MOCKSWithDoApi(){IMethods mock=mock(IMethods.class,RETURNS_MOCKS);doReturn(null).when(mock).objectReturningMethodNoArgs();}
@Test public void shouldNotThrowNPEWhenIntegerPassed(){mock.intArgumentMethod(100);verify(mock).intArgumentMethod(isA(Integer.class));}
@Test public void shouldNotThrowNPEWhenIntPassed(){mock.intArgumentMethod(100);verify(mock).intArgumentMethod(isA(Integer.class));}
@Test public void shouldNotThrowNPEWhenIntegerPassedToEq(){mock.intArgumentMethod(100);verify(mock).intArgumentMethod(eq(new Integer(100)));}
@Test public void shouldNotThrowNPEWhenIntegerPassedToSame(){mock.intArgumentMethod(100);verify(mock,never()).intArgumentMethod(same(new Integer(100)));}
@Test(expected=AssertionError.class)public void shouldNotThrowNPEWhenNullPassedToEq(){mock.objectArgMethod("not null");verify(mock).objectArgMethod(eq(null));}
@Test(expected=AssertionError.class)public void shouldNotThrowNPEWhenNullPassedToSame(){mock.objectArgMethod("not null");verify(mock).objectArgMethod(same(null));}
@Test public void shouldPrintInvocationsWhenStubbingNotUsed()throws Exception {performStubbing();businessLogicWithAsking("arg");verify(mockTwo).doSomething("foo");}
@Test public void shouldInitMocksUsingRunner(){list.add("test");verify(list).add("test");}
@Test public void shouldInjectMocksUsingRunner(){assertNotNull(list);assertSame(list,listDependent.getList());}
@Test public void shouldFilterTestMethodsCorrectly()throws Exception {MockitoJUnitRunner runner=new MockitoJUnitRunner(this.getClass());runner.filter(methodNameContains("shouldInitMocksUsingRunner"));assertEquals(1,runner.testCount());}
@Test public void shouldKeepUnfilteredStackTrace(){try {throwIt();fail();}catch(MockitoException e){assertEquals("throwIt",e.getUnfilteredStackTrace()[0].getMethodName());}}
@Test public void shouldResetOngoingStubbingOnVerify(){mock.booleanReturningMethod();verify(mock).booleanReturningMethod();assertOngoingStubbingIsReset();}
@Test public void shouldResetOngoingStubbingOnInOrder(){mock.booleanReturningMethod();InOrder inOrder=inOrder(mock);inOrder.verify(mock).booleanReturningMethod();assertOngoingStubbingIsReset();}
@Test public void shouldResetOngoingStubbingOnDoReturn(){mock.booleanReturningMethod();doReturn(false).when(mock).booleanReturningMethod();assertOngoingStubbingIsReset();}
@Test public void shouldUseTheSetterOnTheTargetWithTheFieldType()throws Exception {SomeBean someBean=new SomeBean();Field theField=someBean.getClass().getDeclaredField("theField");File valueToInject=new File("path");boolean injected=new BeanPropertySetter(someBean,theField,true).set(valueToInject);assertTrue(injected);assertTrue(someBean.setTheFieldWasUsed);assertSame(valueToInject,someBean.getTheField());}
@Test public void shouldNotFailIfBeanHasOnlyASetter()throws Exception {SomeBeanWithJustASetter someBean=new SomeBeanWithJustASetter();Field theField=someBean.getClass().getDeclaredField("theField");File valueToInject=new File("path");boolean injected=new BeanPropertySetter(someBean,theField,true).set(valueToInject);assertTrue(injected);assertTrue(someBean.setTheFieldWasUsed);}
@Test public void shouldFailIfMatchingSetterCannotBeFoundAndIfReportFailureTrue()throws Exception {SomeBeanWithNoSetterMatchingFieldType bean=new SomeBeanWithNoSetterMatchingFieldType();Field theField=bean.getClass().getDeclaredField("theField");File valueToInject=new File("path");try {new BeanPropertySetter(bean,theField,true).set(valueToInject);fail();}catch(Exception e){Assertions.assertThat(e.getMessage()).contains("setter not found");}}
@Test public void shouldReturnFalseIfNoSetterFound()throws Exception {SomeBeanWithJustAGetter bean=new SomeBeanWithJustAGetter();Field theField=bean.getClass().getDeclaredField("theField");File valueToInject=new File("path");boolean injected=new BeanPropertySetter(bean,theField).set(valueToInject);assertFalse(injected);}
@Test public void shouldReturnFalseIfNoSetterWasFoundAndIfReportFailureFalse()throws Exception {SomeBeanWithNoSetterMatchingFieldType bean=new SomeBeanWithNoSetterMatchingFieldType();Field theField=bean.getClass().getDeclaredField("theField");File valueToInject=new File("path");boolean injected=new BeanPropertySetter(bean,theField,false).set(valueToInject);assertFalse(injected);}
@Test public void shouldNotFindAnySuspiciousMatchersWhenNumberOfArgumentsDoesntMatch(){List<Matcher> matchers=(List)Arrays.asList(new Equals(1));Integer[]suspicious=tool.getSuspiciouslyNotMatchingArgsIndexes(matchers,new Object[]{10,20});assertEquals(0,suspicious.length);}
@Test public void shouldNotFindAnySuspiciousMatchersWhenArgumentsMatch(){List<Matcher> matchers=(List)Arrays.asList(new Equals(10),new Equals(20));Integer[]suspicious=tool.getSuspiciouslyNotMatchingArgsIndexes(matchers,new Object[]{10,20});assertEquals(0,suspicious.length);}
@Test public void shouldFindSuspiciousMatchers(){Equals matcherInt20=new Equals(20);Long longPretendingAnInt=new Long(20);List<Matcher> matchers=(List)Arrays.asList(new Equals(10),matcherInt20);Integer[]suspicious=tool.getSuspiciouslyNotMatchingArgsIndexes(matchers,new Object[]{10,longPretendingAnInt});assertEquals(1,suspicious.length);assertEquals(new Integer(1),suspicious[0]);}
@Test public void shouldNotFindSuspiciousMatchersWhenTypesAreTheSame(){Equals matcherWithBadDescription=new Equals(20){public void describeTo(Description desc){desc.appendText("10");}};Integer argument=10;Integer[]suspicious=tool.getSuspiciouslyNotMatchingArgsIndexes((List)Arrays.asList(matcherWithBadDescription),new Object[]{argument});assertEquals(0,suspicious.length);}
@Test public void shouldWorkFineWhenGivenArgIsNull(){Integer[]suspicious=tool.getSuspiciouslyNotMatchingArgsIndexes((List)Arrays.asList(new Equals(20)),new Object[]{null});assertEquals(0,suspicious.length);}
@Test public void shouldUseMatchersSafely(){List<Matcher> matchers=(List)Arrays.asList(new BaseMatcher(){public boolean matches(Object item){throw new ClassCastException("nasty matcher");}public void describeTo(Description description){}});Integer[]suspicious=tool.getSuspiciouslyNotMatchingArgsIndexes(matchers,new Object[]{10});assertEquals(0,suspicious.length);}
@Test public void shouldMarkAsVerified(){Invocation invocation=new InvocationBuilder().toInvocation();assertFalse(invocation.isVerified());only.verify(new VerificationDataStub(new InvocationMatcher(invocation),invocation));assertTrue(invocation.isVerified());}
@Test public void shouldNotMarkAsVerifiedWhenAssertionFailed(){Invocation invocation=new InvocationBuilder().toInvocation();assertFalse(invocation.isVerified());try {only.verify(new VerificationDataStub(new InvocationBuilder().toInvocationMatcher(),invocation));fail();}catch(MockitoAssertionError e){}assertFalse(invocation.isVerified());}
@Test public void shouldFilterStackTraceOnVerify(){try {verify(mock).simpleMethod();fail();}catch(WantedButNotInvoked e){assertThat(e,hasFirstMethodInStackTrace("shouldFilterStackTraceOnVerify"));}}
@Test public void shouldFilterStackTraceOnVerifyNoMoreInteractions(){mock.oneArg(true);try {verifyNoMoreInteractions(mock);fail();}catch(NoInteractionsWanted e){assertThat(e,hasFirstMethodInStackTrace("shouldFilterStackTraceOnVerifyNoMoreInteractions"));}}
@Test public void shouldFilterStackTraceOnVerifyZeroInteractions(){mock.oneArg(true);try {verifyZeroInteractions(mock);fail();}catch(NoInteractionsWanted e){assertThat(e,hasFirstMethodInStackTrace("shouldFilterStackTraceOnVerifyZeroInteractions"));}}
@Test public void shouldFilterStacktraceOnMockitoException(){verify(mock);try {verify(mock).oneArg(true);fail();}catch(MockitoException expected){assertThat(expected,hasFirstMethodInStackTrace("shouldFilterStacktraceOnMockitoException"));}}
@Test public void shouldFilterStacktraceWhenVerifyingInOrder(){InOrder inOrder=inOrder(mock);mock.oneArg(true);mock.oneArg(false);inOrder.verify(mock).oneArg(false);try {inOrder.verify(mock).oneArg(true);fail();}catch(VerificationInOrderFailure e){assertThat(e,hasFirstMethodInStackTrace("shouldFilterStacktraceWhenVerifyingInOrder"));}}
@Test public void shouldFilterStacktraceWhenInOrderThrowsMockitoException(){try {inOrder();fail();}catch(MockitoException expected){assertThat(expected,hasFirstMethodInStackTrace("shouldFilterStacktraceWhenInOrderThrowsMockitoException"));}}
@Test public void shouldFilterStacktraceWhenInOrderVerifies(){try {InOrder inOrder=inOrder(mock);inOrder.verify(null);fail();}catch(MockitoException expected){assertThat(expected,hasFirstMethodInStackTrace("shouldFilterStacktraceWhenInOrderVerifies"));}}
@Test public void shouldFilterStackTraceWhenThrowingExceptionFromMockHandler(){try {when(mock.oneArg(true)).thenThrow(new Exception());fail();}catch(MockitoException expected){assertThat(expected,hasFirstMethodInStackTrace("shouldFilterStackTraceWhenThrowingExceptionFromMockHandler"));}}
@Test public void shouldShowProperExceptionStackTrace()throws Exception {when(mock.simpleMethod()).thenThrow(new RuntimeException());try {mock.simpleMethod();fail();}catch(RuntimeException e){assertThat(e,hasFirstMethodInStackTrace("shouldShowProperExceptionStackTrace"));}}
@Test public void shouldInitMocksUsingRunner(){list.add("test");verify(list).add("test");}
@Test public void shouldInjectMocksUsingRunner(){assertSame(list,listDependent.getList());}
@Test public void shouldFilterTestMethodsCorrectly()throws Exception {MockitoJUnit44Runner runner=new MockitoJUnit44Runner(this.getClass());runner.filter(methodNameContains("shouldInitMocksUsingRunner"));assertEquals(1,runner.testCount());}
@Test public void shouldVerifyInOrderAllInvocations(){inOrder.verify(mockOne).simpleMethod(1);inOrder.verify(mockTwo,times(2)).simpleMethod(2);inOrder.verify(mockThree).simpleMethod(3);inOrder.verify(mockTwo).simpleMethod(2);inOrder.verify(mockOne).simpleMethod(4);verifyNoMoreInteractions(mockOne,mockTwo,mockThree);}
@Test public void shouldVerifyInOrderAndBeRelaxed(){inOrder.verify(mockTwo,times(2)).simpleMethod(2);inOrder.verify(mockThree).simpleMethod(3);verifyNoMoreInteractions(mockThree);}
@Test public void shouldAllowFirstChunkBeforeLastInvocation(){inOrder.verify(mockTwo,times(2)).simpleMethod(2);inOrder.verify(mockOne).simpleMethod(4);try {verifyNoMoreInteractions(mockTwo);fail();}catch(NoInteractionsWanted e){}}
@Test public void shouldAllowAllChunksBeforeLastInvocation(){inOrder.verify(mockTwo,times(3)).simpleMethod(2);inOrder.verify(mockOne).simpleMethod(4);verifyNoMoreInteractions(mockTwo);}
@Test public void shouldVerifyDetectFirstChunkOfInvocationThatExistInManyChunks(){inOrder.verify(mockTwo,times(2)).simpleMethod(2);inOrder.verify(mockThree).simpleMethod(3);try {verifyNoMoreInteractions(mockTwo);fail();}catch(NoInteractionsWanted e){}}
@Test public void shouldVerifyDetectAllChunksOfInvocationThatExistInManyChunks(){inOrder.verify(mockTwo,times(3)).simpleMethod(2);inOrder.verify(mockOne).simpleMethod(4);verifyNoMoreInteractions(mockTwo);}
@Test public void shouldVerifyInteractionsFromAllChunksWhenAtLeastOnceMode(){inOrder.verify(mockTwo,atLeastOnce()).simpleMethod(2);verifyNoMoreInteractions(mockTwo);try {inOrder.verify(mockThree).simpleMethod(3);fail();}catch(VerificationInOrderFailure e){}}
@Test public void shouldVerifyInteractionsFromFirstChunk(){inOrder.verify(mockTwo,times(2)).simpleMethod(2);try {verifyNoMoreInteractions(mockTwo);fail();}catch(NoInteractionsWanted e){}}
@Test(expected=VerificationInOrderFailure.class)public void shouldFailVerificationOfNonFirstChunk(){inOrder.verify(mockTwo,times(1)).simpleMethod(2);}
@Test public void shouldPassOnCombinationOfTimesAndAtLeastOnce(){mockTwo.simpleMethod(2);inOrder.verify(mockTwo,times(2)).simpleMethod(2);inOrder.verify(mockTwo,atLeastOnce()).simpleMethod(2);verifyNoMoreInteractions(mockTwo);}
@Test public void shouldPassOnEdgyCombinationOfTimesAndAtLeastOnce(){mockTwo.simpleMethod(2);mockThree.simpleMethod(3);inOrder.verify(mockThree).simpleMethod(3);inOrder.verify(mockTwo,atLeastOnce()).simpleMethod(2);inOrder.verify(mockThree).simpleMethod(3);verifyNoMoreInteractions(mockThree);}
@Test public void shouldVerifyInOrderMockTwoAndThree(){inOrder.verify(mockTwo,times(2)).simpleMethod(2);inOrder.verify(mockThree).simpleMethod(3);inOrder.verify(mockTwo).simpleMethod(2);verifyNoMoreInteractions(mockTwo,mockThree);}
@Test public void shouldVerifyInOrderMockOneAndThree(){inOrder.verify(mockOne).simpleMethod(1);inOrder.verify(mockThree).simpleMethod(3);inOrder.verify(mockOne).simpleMethod(4);verifyNoMoreInteractions(mockOne,mockThree);}
@Test public void shouldVerifyInOrderOnlyTwoInvocations(){inOrder.verify(mockTwo,times(2)).simpleMethod(2);inOrder.verify(mockOne).simpleMethod(4);}
@Test public void shouldVerifyInOrderOnlyMockTwo(){inOrder.verify(mockTwo,times(2)).simpleMethod(2);inOrder.verify(mockTwo).simpleMethod(2);verifyNoMoreInteractions(mockTwo);}
@Test public void shouldVerifyMockTwoCalledTwice(){inOrder.verify(mockTwo,times(2)).simpleMethod(2);}
@Test public void shouldVerifyMockTwoCalledAtLeastOnce(){inOrder.verify(mockTwo,atLeastOnce()).simpleMethod(2);}
@Test(expected=WantedButNotInvoked.class)public void shouldFailOnWrongMethodCalledOnMockTwo(){inOrder.verify(mockTwo,atLeastOnce()).differentMethod();}
@Test public void shouldAllowTimesZeroButOnlyInOrder(){inOrder.verify(mockTwo,atLeastOnce()).simpleMethod(2);inOrder.verify(mockOne,times(0)).simpleMethod(1);try {verify(mockOne,times(0)).simpleMethod(1);fail();}catch(NeverWantedButInvoked e){}}
@Test public void shouldFailTimesZeroInOrder(){inOrder.verify(mockTwo,times(2)).simpleMethod(2);try {inOrder.verify(mockThree,times(0)).simpleMethod(3);fail();}catch(VerificationInOrderFailure e){}}
@Test(expected=VerificationInOrderFailure.class)public void shouldFailWhenMockTwoWantedZeroTimes(){inOrder.verify(mockTwo,times(0)).simpleMethod(2);}
@Test public void shouldVerifyLastInvocation(){inOrder.verify(mockOne).simpleMethod(4);}
@Test public void shouldVerifySecondAndLastInvocation(){inOrder.verify(mockTwo,atLeastOnce()).simpleMethod(2);inOrder.verify(mockOne).simpleMethod(4);}
@Test public void shouldVerifySecondAndLastInvocationWhenAtLeastOnceUsed(){inOrder.verify(mockTwo,atLeastOnce()).simpleMethod(2);inOrder.verify(mockOne).simpleMethod(4);}
@Test public void shouldFailOnLastTwoInvocationsInWrongOrder(){inOrder.verify(mockOne).simpleMethod(4);try {inOrder.verify(mockTwo,atLeastOnce()).simpleMethod(2);fail();}catch(VerificationInOrderFailure e){}}
@Test public void shouldFailOnLastAndFirstInWrongOrder(){inOrder.verify(mockOne).simpleMethod(4);try {inOrder.verify(mockOne).simpleMethod(1);fail();}catch(VerificationInOrderFailure e){}}
@Test public void shouldFailOnWrongMethodAfterLastInvocation(){inOrder.verify(mockOne).simpleMethod(4);try {inOrder.verify(mockOne).simpleMethod(999);fail();}catch(VerificationInOrderFailure e){}}
@Test public void shouldReturnMockValueForInterface()throws Exception {Object interfaceMock=values.returnValueFor(FooInterface.class);assertTrue(new MockUtil().isMock(interfaceMock));}
@Test public void shouldReturnNullForFinalClass()throws Exception {assertNull(values.returnValueFor(Baz.class));}
@Test public void shouldReturnTheUsualDefaultValuesForPrimitives()throws Throwable {ReturnsMocks answer=new ReturnsMocks();assertEquals(false,answer.answer(invocationOf(HasPrimitiveMethods.class,"booleanMethod")));assertEquals((char)0,answer.answer(invocationOf(HasPrimitiveMethods.class,"charMethod")));assertEquals(0,answer.answer(invocationOf(HasPrimitiveMethods.class,"intMethod")));assertEquals(0,answer.answer(invocationOf(HasPrimitiveMethods.class,"longMethod")));assertEquals(0,answer.answer(invocationOf(HasPrimitiveMethods.class,"floatMethod")));assertEquals(0,answer.answer(invocationOf(HasPrimitiveMethods.class,"doubleMethod")));}
@Test public void shouldReturnEmptyArray()throws Throwable {String[]ret=(String[])values.answer(invocationOf(StringMethods.class,"stringArrayMethod"));assertTrue(ret.getClass().isArray());assertTrue(ret.length == 0);}
@Test public void shouldReturnEmptyString()throws Throwable {assertEquals("",values.answer(invocationOf(StringMethods.class,"stringMethod")));}
@Test public void shouldPointStackTraceToPreviousVerified(){inOrder.verify(mock,atLeastOnce()).simpleMethod(anyInt());inOrder.verify(mockTwo).simpleMethod(anyInt());try {inOrder.verify(mock).simpleMethod(999);fail();}catch(VerificationInOrderFailure e){assertContains("fourth(",e.getMessage());}}
@Test public void shouldPointToThirdMethod(){inOrder.verify(mock,atLeastOnce()).simpleMethod(anyInt());try {inOrder.verify(mockTwo).simpleMethod(999);fail();}catch(VerificationInOrderFailure e){assertContains("third(",e.getMessage());}}
@Test public void shouldPointToSecondMethod(){inOrder.verify(mock).simpleMethod(anyInt());inOrder.verify(mockTwo).simpleMethod(anyInt());try {inOrder.verify(mockTwo,times(3)).simpleMethod(999);fail();}catch(VerificationInOrderFailure e){assertContains("second(",e.getMessage());}}
@Test public void shouldPointToFirstMethodBecauseOfTooManyActualInvocations(){try {inOrder.verify(mock,times(0)).simpleMethod(anyInt());fail();}catch(VerificationInOrderFailure e){assertContains("first(",e.getMessage());}}
@Test public void shouldPointToSecondMethodBecauseOfTooManyActualInvocations(){inOrder.verify(mock).simpleMethod(anyInt());try {inOrder.verify(mockTwo,times(0)).simpleMethod(anyInt());fail();}catch(VerificationInOrderFailure e){assertContains("second(",e.getMessage());}}
@Test public void shouldPointToFourthMethodBecauseOfTooLittleActualInvocations(){inOrder.verify(mock).simpleMethod(anyInt());inOrder.verify(mockTwo).simpleMethod(anyInt());inOrder.verify(mock).simpleMethod(anyInt());try {inOrder.verify(mockTwo,times(3)).simpleMethod(anyInt());fail();}catch(VerificationInOrderFailure e){assertContains("fourth(",e.getMessage());}}
@Test public void shouldPrintNiceName(){veryCoolSpy.add(1);try {verify(veryCoolSpy).add(2);fail();}catch(AssertionError e){Assertions.assertThat(e.getMessage()).contains("veryCoolSpy");}}
@Test public void shouldPrintMethodName(){try {verify(mock).simpleMethod();fail();}catch(WantedButNotInvoked e){String actualMessage=e.getMessage();String expectedMessage="\n" + "Wanted but not invoked:" + "\n"+ "iMethods.simpleMethod();"+ "\n"+ "-> at";assertContains(expectedMessage,actualMessage);}}
@Test public void shouldPrintMethodNameAndArguments(){try {verify(mock).threeArgumentMethod(12,new Foo(),"xx");fail();}catch(WantedButNotInvoked e){assertContains("iMethods.threeArgumentMethod(12,foo,\"xx\")",e.getMessage());}}
@Test public void shouldPrintActualAndWantedInLine(){mock.varargs(1,2);try {verify(mock).varargs(1,1000);fail();}catch(ArgumentsAreDifferent e){String wanted="\n" + "Argument(s)are different! Wanted:" + "\n"+ "iMethods.varargs(1,1000);";assertContains(wanted,e.getMessage());String actual="\n" + "Actual invocation has different arguments:" + "\n"+ "iMethods.varargs(1,2);";assertContains(actual,e.getMessage());}}
@Test public void shouldPrintActualAndWantedInMultipleLines(){mock.varargs("this is very long string","this is another very long string");try {verify(mock).varargs("x","y","z");fail();}catch(ArgumentsAreDifferent e){String wanted="\n" + "Argument(s)are different! Wanted:" + "\n"+ "iMethods.varargs("+ "\n"+ "    \"x\","+ "\n"+ "    \"y\","+ "\n"+ "    \"z\""+ "\n"+ ");";assertContains(wanted,e.getMessage());String actual="\n" + "Actual invocation has different arguments:" + "\n"+ "iMethods.varargs("+ "\n"+ "    \"this is very long string\","+ "\n"+ "    \"this is another very long string\""+ "\n"+ ");";assertContains(actual,e.getMessage());}}
@Test public void shouldPrintActualAndWantedWhenActualMethodNameAndWantedMethodNameAreTheSame(){mock.simpleMethod();try {verify(mock).simpleMethod(10);fail();}catch(ArgumentsAreDifferent e){assertContains("simpleMethod(10)",e.getMessage());assertContains("simpleMethod()",e.getMessage());}}
@Test public void shouldPrintActualAndUnverifiedWantedWhenTheDifferenceIsAboutArguments(){mock.twoArgumentMethod(1,1);mock.twoArgumentMethod(2,2);verify(mock).twoArgumentMethod(1,1);try {verify(mock).twoArgumentMethod(2,1000);fail();}catch(ArgumentsAreDifferent e){assertContains("(2,1000)",e.getMessage());assertContains("(2,2)",e.getMessage());}}
@Test public void shouldPrintFirstUnexpectedInvocation(){mock.oneArg(true);mock.oneArg(false);mock.threeArgumentMethod(1,"2","3");verify(mock).oneArg(true);try {verifyNoMoreInteractions(mock);fail();}catch(NoInteractionsWanted e){String expectedMessage="\n" + "No interactions wanted here:" + "\n"+ "-> at";assertContains(expectedMessage,e.getMessage());String expectedCause="\n" + "But found this interaction:" + "\n"+ "-> at";assertContains(expectedCause,e.getMessage());}}
@Test public void shouldPrintFirstUnexpectedInvocationWhenVerifyingZeroInteractions(){mock.twoArgumentMethod(1,2);mock.threeArgumentMethod(1,"2","3");try {verifyZeroInteractions(mock);fail();}catch(NoInteractionsWanted e){String expected="\n" + "No interactions wanted here:" + "\n"+ "-> at";assertContains(expected,e.getMessage());String expectedCause="\n" + "But found this interaction:" + "\n"+ "-> at";assertContains(expectedCause,e.getMessage());}}
@Test public void shouldPrintMethodNameWhenVerifyingAtLeastOnce()throws Exception {try {verify(mock,atLeastOnce()).twoArgumentMethod(1,2);fail();}catch(WantedButNotInvoked e){assertContains("twoArgumentMethod(1,2)",e.getMessage());}}
@Test public void shouldPrintMethodWhenMatcherUsed()throws Exception {try {verify(mock,atLeastOnce()).twoArgumentMethod(anyInt(),eq(100));fail();}catch(WantedButNotInvoked e){String actualMessage=e.getMessage();String expectedMessage="\n" + "Wanted but not invoked:" + "\n"+ "iMethods.twoArgumentMethod(<any>,100);";assertContains(expectedMessage,actualMessage);}}
@Test public void shouldPrintMethodWhenMissingInvocationWithArrayMatcher(){mock.oneArray(new boolean[]{true,false,false});try {verify(mock).oneArray(aryEq(new boolean[]{false,false,false}));fail();}catch(ArgumentsAreDifferent e){assertContains("[false,false,false]",e.getMessage());assertContains("[true,false,false]",e.getMessage());}}
@Test public void shouldPrintMethodWhenMissingInvocationWithVarargMatcher(){mock.varargsString(10,"xxx","yyy","zzz");try {verify(mock).varargsString(10,"111","222","333");fail();}catch(ArgumentsAreDifferent e){assertContains("111",e.getMessage());assertContains("\"xxx\"",e.getMessage());}}
@Test public void shouldPrintMethodWhenMissingInvocationWithMatcher(){mock.simpleMethod("foo");try {verify(mock).simpleMethod(matches("burrito from Exmouth"));fail();}catch(ArgumentsAreDifferent e){assertContains("matches(\"burrito from Exmouth\")",e.getMessage());assertContains("\"foo\"",e.getMessage());}}
@Test public void shouldPrintNullArguments()throws Exception {mock.simpleMethod(null,(Integer)null);try {verify(mock).simpleMethod("test");fail();}catch(ArgumentsAreDifferent e){assertContains("simpleMethod(null,null);",e.getMessage());}}
@Test public void shouldSayNeverWantedButInvoked()throws Exception {mock.simpleMethod(1);verify(mock,never()).simpleMethod(2);try {verify(mock,never()).simpleMethod(1);fail();}catch(NeverWantedButInvoked e){assertContains("Never wanted here:",e.getMessage());assertContains("But invoked here:",e.getMessage());}}
@Test public void shouldShowRightActualMethod()throws Exception {mock.simpleMethod(9191);mock.simpleMethod("foo");try {verify(mock).simpleMethod("bar");fail();}catch(ArgumentsAreDifferent e){assertContains("bar",e.getMessage());assertContains("foo",e.getMessage());}}
@Test public void shouldPrintFieldNameWhenAnnotationsUsed()throws Exception {iHavefunkyName.simpleMethod(10);try {verify(iHavefunkyName).simpleMethod(20);fail();}catch(ArgumentsAreDifferent e){assertContains("iHavefunkyName.simpleMethod(20)",e.getMessage());assertContains("iHavefunkyName.simpleMethod(10)",e.getMessage());}}
@Test public void shouldPrintInteractionsOnMockWhenOrdinaryVerificationFail()throws Exception {mock.otherMethod();mock.booleanReturningMethod();try {verify(mock).simpleMethod();fail();}catch(WantedButNotInvoked e){}}
@Test public void shouldNeverBreakMethodStringWhenNoArgsInMethod()throws Exception {try {verify(veeeeeeeeeeeeeeeeeeeeeeeerylongNameMock).simpleMethod();fail();}catch(WantedButNotInvoked e){assertContains("veeeeeeeeeeeeeeeeeeeeeeeerylongNameMock.simpleMethod()",e.getMessage());}}
@Test public void shouldStubUsingMatchers(){when(one.simpleMethod(2)).thenReturn("2");when(two.simpleMethod(anyString())).thenReturn("any");when(three.simpleMethod(startsWith("test"))).thenThrow(new RuntimeException());assertEquals(null,one.simpleMethod(1));assertEquals("2",one.simpleMethod(2));assertEquals("any",two.simpleMethod("two"));assertEquals("any",two.simpleMethod("two again"));assertEquals(null,three.simpleMethod("three"));assertEquals(null,three.simpleMethod("three again"));try {three.simpleMethod("test three again");fail();}catch(RuntimeException e){}}
@SuppressWarnings("deprecation")@Test public void shouldVerifyUsingMatchers(){stubVoid(one).toThrow(new RuntimeException()).on().oneArg(true);when(three.varargsObject(5,"first arg","second arg")).thenReturn("stubbed");try {one.oneArg(true);fail();}catch(RuntimeException e){}one.simpleMethod(100);two.simpleMethod("test Mockito");three.varargsObject(10,"first arg","second arg");assertEquals("stubbed",three.varargsObject(5,"first arg","second arg"));verify(one).oneArg(eq(true));verify(one).simpleMethod(anyInt());verify(two).simpleMethod(startsWith("test"));verify(three).varargsObject(5,"first arg","second arg");verify(three).varargsObject(eq(10),eq("first arg"),startsWith("second"));verifyNoMoreInteractions(one,two,three);try {verify(three).varargsObject(eq(10),eq("first arg"),startsWith("third"));fail();}catch(WantedButNotInvoked e){}}
@Test @Ignore public void testDeepMockWithClass(){final ListSet mock=Mockito.mock(ListSet.class,Mockito.RETURNS_DEEP_STUBS);final Set mock2=mock.get(0);}
@Test public void shouldSetInternalStateOnHierarchy(){DummyClassForTests dummy=new DummyClassForTests();Whitebox.setInternalState(dummy,"somePrivateField","cool!");Object internalState=org.powermock.reflect.Whitebox.getInternalState(dummy,"somePrivateField");assertEquals("cool!",internalState);}
@Test public void shouldGetInternalStateFromHierarchy(){DummyClassForTests dummy=new DummyClassForTests();org.powermock.reflect.Whitebox.setInternalState(dummy,"somePrivateField","boo!");Object internalState=Whitebox.getInternalState(dummy,"somePrivateField");assertEquals("boo!",internalState);}
@Test public void shouldUseCustomBooleanMatcher(){when(mock.oneArg(booleanThat(new IsAnyBoolean()))).thenReturn("foo");assertEquals("foo",mock.oneArg(true));assertEquals("foo",mock.oneArg(false));assertEquals(null,mock.oneArg("x"));}
@Test public void shouldUseCustomCharMatcher(){when(mock.oneArg(charThat(new IsSorZ()))).thenReturn("foo");assertEquals("foo",mock.oneArg('s'));assertEquals("foo",mock.oneArg('z'));assertEquals(null,mock.oneArg('x'));}
@Test public void shouldUseCustomPrimitiveNumberMatchers(){when(mock.oneArg(byteThat(new IsZeroOrOne<Byte>()))).thenReturn("byte");when(mock.oneArg(shortThat(new IsZeroOrOne<Short>()))).thenReturn("short");when(mock.oneArg(intThat(new IsZeroOrOne<Integer>()))).thenReturn("int");when(mock.oneArg(longThat(new IsZeroOrOne<Long>()))).thenReturn("long");when(mock.oneArg(floatThat(new IsZeroOrOne<Float>()))).thenReturn("float");when(mock.oneArg(doubleThat(new IsZeroOrOne<Double>()))).thenReturn("double");assertEquals("byte",mock.oneArg((byte)0));assertEquals("short",mock.oneArg((short)1));assertEquals("int",mock.oneArg(0));assertEquals("long",mock.oneArg(1L));assertEquals("float",mock.oneArg(0F));assertEquals("double",mock.oneArg(1.0));assertEquals(null,mock.oneArg(2));assertEquals(null,mock.oneArg("foo"));}
@Test public void shouldUseCustomObjectMatcher(){when(mock.oneArg(argThat(new ContainsFoo()))).thenReturn("foo");assertEquals("foo",mock.oneArg("foo"));assertEquals(null,mock.oneArg("bar"));}
@Test public void shouldCustomMatcherPrintDescriptionBasedOnName(){mock.simpleMethod("foo");try {verify(mock).simpleMethod(containsTest());fail();}catch(AssertionError e){assertContains("<String that contains xxx>",e.getMessage());}}
@Test public void shouldAnonymousCustomMatcherPrintDefaultDescription(){mock.simpleMethod("foo");try {verify(mock).simpleMethod((String)argThat(new ArgumentMatcher<Object>(){@Override public boolean matches(Object argument){return false;}}));fail();}catch(AssertionError e){assertContains("<custom argument matcher>",e.getMessage());assertContains("foo",e.getMessage());}}
@Test public void shouldAnswer()throws Exception {when(mock.simpleMethod(anyString())).thenAnswer(new Answer<String>(){public String answer(InvocationOnMock invocation)throws Throwable {String arg=(String)invocation.getArguments()[0];return invocation.getMethod().getName()+ "-" + arg;}});assertEquals("simpleMethod-test",mock.simpleMethod("test"));}
@Test public void shouldAnswerWithThenAnswerAlias()throws Exception {RecordCall recordCall=new RecordCall();Set mockedSet=when(mock(Set.class).isEmpty()).then(recordCall).getMock();mockedSet.isEmpty();assertTrue(recordCall.isCalled());}
@Test public void shouldAnswerConsecutively()throws Exception {when(mock.simpleMethod()).thenAnswer(new Answer<String>(){public String answer(InvocationOnMock invocation)throws Throwable {return invocation.getMethod().getName();}}).thenReturn("Hello").thenAnswer(new Answer<String>(){public String answer(InvocationOnMock invocation)throws Throwable {return invocation.getMethod().getName()+ "-1";}});assertEquals("simpleMethod",mock.simpleMethod());assertEquals("Hello",mock.simpleMethod());assertEquals("simpleMethod-1",mock.simpleMethod());assertEquals("simpleMethod-1",mock.simpleMethod());}
@Test public void shoudAnswerVoidMethod()throws Exception {RecordCall recordCall=new RecordCall();stubVoid(mock).toAnswer(recordCall).on().voidMethod();mock.voidMethod();assertTrue(recordCall.isCalled());}
@Test public void shouldAnswerVoidMethodConsecutively()throws Exception {RecordCall call1=new RecordCall();RecordCall call2=new RecordCall();stubVoid(mock).toAnswer(call1).toThrow(new UnsupportedOperationException()).toAnswer(call2).on().voidMethod();mock.voidMethod();assertTrue(call1.isCalled());assertFalse(call2.isCalled());try {mock.voidMethod();fail();}catch(UnsupportedOperationException e){}mock.voidMethod();assertTrue(call2.isCalled());}
@Test public void shouldMakeSureTheInterfaceDoesNotChange()throws Exception {when(mock.simpleMethod(anyString())).thenAnswer(new Answer<String>(){public String answer(InvocationOnMock invocation)throws Throwable {assertTrue(invocation.getArguments().getClass().isArray());assertEquals(Method.class,invocation.getMethod().getClass());return "assertions passed";}});assertEquals("assertions passed",mock.simpleMethod("test"));}
@Test public void shouldAnyXMatchersAcceptNull(){when(mock.oneArg(anyObject())).thenReturn("0");when(mock.oneArg(anyString())).thenReturn("1");when(mock.forList(anyList())).thenReturn("2");when(mock.forMap(anyMap())).thenReturn("3");when(mock.forCollection(anyCollection())).thenReturn("4");when(mock.forSet(anySet())).thenReturn("5");assertEquals("0",mock.oneArg((Object)null));assertEquals("1",mock.oneArg((String)null));assertEquals("2",mock.forList(null));assertEquals("3",mock.forMap(null));assertEquals("4",mock.forCollection(null));assertEquals("5",mock.forSet(null));}
@Test public void shouldAnyPrimiteWraperMatchersAcceptNull(){when(mock.forInteger(anyInt())).thenReturn("0");when(mock.forCharacter(anyChar())).thenReturn("1");when(mock.forShort(anyShort())).thenReturn("2");when(mock.forByte(anyByte())).thenReturn("3");when(mock.forBoolean(anyBoolean())).thenReturn("4");when(mock.forLong(anyLong())).thenReturn("5");when(mock.forFloat(anyFloat())).thenReturn("6");when(mock.forDouble(anyDouble())).thenReturn("7");assertEquals("0",mock.forInteger(null));assertEquals("1",mock.forCharacter(null));assertEquals("2",mock.forShort(null));assertEquals("3",mock.forByte(null));assertEquals("4",mock.forBoolean(null));assertEquals("5",mock.forLong(null));assertEquals("6",mock.forFloat(null));assertEquals("7",mock.forDouble(null));}
@Test public void shouldAllowStubbedMockReferenceAccess()throws Exception {Set expectedMock=mock(Set.class);Set returnedMock=when(expectedMock.isEmpty()).thenReturn(false).getMock();assertEquals(expectedMock,returnedMock);}
@Test public void stubbedMockShouldWorkAsUsual()throws Exception {Set returnedMock=when(mock(Set.class).isEmpty()).thenReturn(false,true).getMock();assertEquals(false,returnedMock.isEmpty());assertEquals(true,returnedMock.isEmpty());}
@Test public void shouldFailFastWhenArgumentMatchersAbused(){misplacedArgumentMatcher();try {mock(IMethods.class);fail();}catch(InvalidUseOfMatchersException e){assertContains("Misplaced argument matcher",e.getMessage());}}
@Test public void shouldSayUnfinishedVerificationButNotInvalidUseOfMatchers(){verify(withFinal).finalMethod(anyObject());try {verify(withFinal);fail();}catch(UnfinishedVerificationException e){}}
@Test(expected=MockitoException.class)public void shouldNotAllowMockAndSpy()throws Exception {MockitoAnnotations.initMocks(new Object(){@Mock @Spy List mock;});}
@Test(expected=MockitoException.class)public void shouldNotAllowSpyAndInjectMock()throws Exception {MockitoAnnotations.initMocks(new Object(){@InjectMocks @Spy List mock;});}
@Test(expected=MockitoException.class)public void shouldNotAllowMockAndInjectMock()throws Exception {MockitoAnnotations.initMocks(new Object(){@InjectMocks @Mock List mock;});}
@Test(expected=MockitoException.class)public void shouldNotAllowCaptorAndMock()throws Exception {MockitoAnnotations.initMocks(new Object(){@Mock @Captor ArgumentCaptor captor;});}
@Test(expected=MockitoException.class)public void shouldNotAllowCaptorAndSpy()throws Exception {MockitoAnnotations.initMocks(new Object(){@Spy @Captor ArgumentCaptor captor;});}
@Test(expected=MockitoException.class)public void shouldNotAllowCaptorAndInjectMock()throws Exception {MockitoAnnotations.initMocks(new Object(){@InjectMocks @Captor ArgumentCaptor captor;});}
@Test public void shouldPointOutMisplacedMatcher(){misplacedArgumentMatcherHere();try {verify(mock).simpleMethod();fail();}catch(InvalidUseOfMatchersException e){assertContains("-> at ",e.getMessage());assertContains("misplacedArgumentMatcherHere(",e.getMessage());}}
@Test public void shouldPointOutUnfinishedStubbing(){unfinishedStubbingHere();try {verify(mock).simpleMethod();fail();}catch(UnfinishedStubbingException e){assertContains("-> at ",e.getMessage());assertContains("unfinishedStubbingHere(",e.getMessage());}}
@Test public void shouldShowWhereIsUnfinishedVerification()throws Exception {unfinishedVerificationHere();try {mock(IMethods.class);fail();}catch(UnfinishedVerificationException e){assertContains("unfinishedVerificationHere(",e.getMessage());}}
@Test public void shouldCallRealMethdsEvenDelegatedToOtherSelfMethod(){String name=spy.getName();assertEquals("Default name",name);}
@Test public void shouldAllowStubbingOfMethodsThatDelegateToOtherMethods(){when(spy.getName()).thenReturn("foo");assertEquals("foo",spy.getName());}
@Test public void shouldAllowStubbingWithThrowablesMethodsThatDelegateToOtherMethods(){doThrow(new RuntimeException("appetite for destruction")).when(spy).getNameButDelegateToMethodThatThrows();try {spy.getNameButDelegateToMethodThatThrows();fail();}catch(Exception e){assertEquals("appetite for destruction",e.getMessage());}}
@Test public void shouldStackTraceGetFilteredOnUserExceptions(){try {spy.getNameButDelegateToMethodThatThrows();fail();}catch(Throwable t){assertThat(t,ExtraMatchers.hasMethodsInStackTrace("throwSomeException","getNameButDelegateToMethodThatThrows","shouldStackTraceGetFilteredOnUserExceptions"));}}
@Test public void shouldVerify(){spy.getName();verify(spy).guessName();}
@Test public void shouldStub(){when(spy.guessName()).thenReturn(new Name("John"));String name=spy.getName();assertEquals("John",name);}
@Test public void shouldDealWithPrivateFieldsOfSubclasses(){assertEquals("100$",spy.howMuchDidYouInherit());}
@Test public void shouldKnowAboutJUnit45()throws Exception {RunnerProvider provider=new RunnerProvider();assertTrue(provider.isJUnit45OrHigherAvailable());}
@Test public void shouldCreateRunnerInstance()throws Throwable {RunnerProvider provider=new RunnerProvider();RunnerImpl runner=provider.newInstance("org.mockito.internal.runners.JUnit45AndHigherRunnerImpl",this.getClass());assertNotNull(runner);}
@Test public void shouldReturnEmptyArray(){String[]ret=(String[])rv.returnValueFor((new String[0]).getClass());assertTrue(ret.getClass().isArray());assertTrue(ret.length == 0);}
@Test public void shouldReturnEmptyString(){assertEquals("",rv.returnValueFor(String.class));}
@Test public void shouldPointStackTraceToPreviousInvocation(){inOrder.verify(mock,times(2)).simpleMethod(anyInt());inOrder.verify(mockTwo,times(2)).simpleMethod(anyInt());try {inOrder.verify(mock).simpleMethod(999);fail();}catch(VerificationInOrderFailure e){assertContains("secondChunk(",e.getMessage());}}
@Test public void shouldPointToThirdInteractionBecauseAtLeastOnceUsed(){inOrder.verify(mock,atLeastOnce()).simpleMethod(anyInt());try {inOrder.verify(mockTwo).simpleMethod(999);fail();}catch(VerificationInOrderFailure e){assertContains("thirdChunk(",e.getMessage());}}
@Test public void shouldPointToThirdChunkWhenTooLittleActualInvocations(){inOrder.verify(mock,times(2)).simpleMethod(anyInt());inOrder.verify(mockTwo,times(2)).simpleMethod(anyInt());inOrder.verify(mock,atLeastOnce()).simpleMethod(anyInt());try {inOrder.verify(mockTwo,times(3)).simpleMethod(999);fail();}catch(VerificationInOrderFailure e){assertContains("thirdChunk(",e.getMessage());}}
@Test public void shouldPointToFourthChunkBecauseTooManyActualInvocations(){inOrder.verify(mock,atLeastOnce()).simpleMethod(anyInt());try {inOrder.verify(mockTwo,times(0)).simpleMethod(anyInt());fail();}catch(VerificationInOrderFailure e){assertContains("fourthChunk(",e.getMessage());}}
@Test public void shouldStubbingNotRegisterRedundantInteractions()throws Exception {when(mock.add("one")).thenReturn(true);when(mock.add("two")).thenReturn(true);mock.add("one");verify(mock).add("one");verifyNoMoreInteractions(mock);}
@Test public void shouldVerifyWhenWantedNumberOfInvocationsUsed()throws Exception {mock.add("one");mock.add("one");mock.add("one");verify(mock,times(3)).add("one");verifyNoMoreInteractions(mock);}
@Test public void shouldVerifyNoInteractionsAsManyTimesAsYouWant()throws Exception {verifyNoMoreInteractions(mock);verifyNoMoreInteractions(mock);verifyZeroInteractions(mock);verifyZeroInteractions(mock);}
@Test public void shouldFailZeroInteractionsVerification()throws Exception {mock.clear();try {verifyZeroInteractions(mock);fail();}catch(NoInteractionsWanted e){}}
@Test public void shouldFailNoMoreInteractionsVerification()throws Exception {mock.clear();try {verifyNoMoreInteractions(mock);fail();}catch(NoInteractionsWanted e){}}
@Test public void shouldPrintAllInvocationsWhenVerifyingNoMoreInvocations()throws Exception {mock.add(1);mock.add(2);mock.clear();verify(mock).add(2);try {verifyNoMoreInteractions(mock);fail();}catch(NoInteractionsWanted e){assertContains("list of all invocations",e.getMessage());}}
@Test public void shouldNotContainAllInvocationsWhenSingleUnwantedFound()throws Exception {mock.add(1);try {verifyNoMoreInteractions(mock);fail();}catch(NoInteractionsWanted e){assertNotContains("list of all invocations",e.getMessage());}}
@Test public void shouldVerifyOneMockButFailOnOther()throws Exception {List list=mock(List.class);Map map=mock(Map.class);list.add("one");list.add("one");map.put("one",1);verify(list,times(2)).add("one");verifyNoMoreInteractions(list);try {verifyZeroInteractions(map);fail();}catch(NoInteractionsWanted e){}}
@SuppressWarnings("all")@Test(expected=MockitoException.class)public void verifyNoMoreInteractionsShouldScreamWhenNullPassed()throws Exception {verifyNoMoreInteractions(null);}
@Test public void shouldNotThrowNPE()throws Exception {Foo foo=new Foo();Foo spy=spy(foo);spy.len(anyString());spy.size(anyMap());spy.size(anyList());spy.size(anyCollection());spy.size(anySet());}
@Test public void should_be_created_with_an_argument_resolver()throws Exception {new ParameterizedConstructorInstantiator(this,field("whateverForNow"),resolver);}
@Test public void should_fail_if_no_parameterized_constructor_found___excluding_inner_and_others_kind_of_types()throws Exception {try {new ParameterizedConstructorInstantiator(this,field("withNoArgConstructor"),resolver).instantiate();fail();}catch(MockitoException me){assertThat(me.getMessage()).contains("no parameterized constructor").contains("withNoArgConstructor").contains("NoArgConstructor");}}
@Test public void should_instantiate_type_if_resolver_provide_matching_types()throws Exception {Observer observer=mock(Observer.class);Map map=mock(Map.class);given(resolver.resolveTypeInstances(Matchers.<Class<?>[]>anyVararg())).willReturn(new Object[]{observer,map});new ParameterizedConstructorInstantiator(this,field("withMultipleConstructor"),resolver).instantiate();assertNotNull(withMultipleConstructor);assertNotNull(withMultipleConstructor.observer);assertNotNull(withMultipleConstructor.map);}
@Test public void should_fail_if_an_argument_instance_type_do_not_match_wanted_type()throws Exception {Observer observer=mock(Observer.class);Set wrongArg=mock(Set.class);given(resolver.resolveTypeInstances(Matchers.<Class<?>[]>anyVararg())).willReturn(new Object[]{observer,wrongArg});try {new ParameterizedConstructorInstantiator(this,field("withMultipleConstructor"),resolver).instantiate();fail();}catch(MockitoException e){assertThat(e.getMessage()).contains("argResolver").contains("incorrect types");}}
@Test public void should_report_failure_if_constructor_throws_exception()throws Exception {given(resolver.resolveTypeInstances(Matchers.<Class<?>[]>anyVararg())).willReturn(new Object[]{null});try {new ParameterizedConstructorInstantiator(this,field("withThrowingConstructor"),resolver).instantiate();fail();}catch(MockitoException e){assertThat(e.getMessage()).contains("constructor").contains("raised an exception");}}
@Test public void should_instantiate_type_with_vararg_constructor()throws Exception {Observer[]vararg=new Observer[]{};given(resolver.resolveTypeInstances(Matchers.<Class<?>[]>anyVararg())).willReturn(new Object[]{"",vararg});new ParameterizedConstructorInstantiator(this,field("withVarargConstructor"),resolver).instantiate();assertNotNull(withVarargConstructor);}
@Test public void shouldSmartNPEPointToUnstubbedCall()throws Exception {IMethods methods=unstubbedMethodInvokedHere(mock);try {methods.simpleMethod();fail();}catch(SmartNullPointerException e){assertContains("unstubbedMethodInvokedHere(",e.getMessage());}}
@Test public void shouldThrowSmartNPEWhenMethodReturnsClass()throws Exception {Foo mock=mock(Foo.class,RETURNS_SMART_NULLS);Foo foo=mock.getSomeClass();try {foo.boo();fail();}catch(SmartNullPointerException e){}}
@Test public void shouldThrowSmartNPEWhenMethodReturnsInterface()throws Exception {Foo mock=mock(Foo.class,RETURNS_SMART_NULLS);Bar bar=mock.getSomeInterface();try {bar.boo();fail();}catch(SmartNullPointerException e){}}
@Test public void shouldReturnOrdinaryEmptyValuesForOrdinaryTypes()throws Exception {IMethods mock=mock(IMethods.class,RETURNS_SMART_NULLS);assertEquals("",mock.stringReturningMethod());assertEquals(0,mock.intReturningMethod());assertEquals(true,mock.listReturningMethod().isEmpty());assertEquals(0,mock.arrayReturningMethod().length);}
@Test public void shouldNotThrowSmartNullPointerOnToString(){Object smartNull=mock.objectReturningMethod();try {verify(mock).simpleMethod(smartNull);fail();}catch(WantedButNotInvoked e){}}
@Test public void shouldNotThrowSmartNullPointerOnObjectMethods(){Object smartNull=mock.objectReturningMethod();smartNull.toString();}
@Test public void shouldShowParameters(){Foo foo=mock(Foo.class,RETURNS_SMART_NULLS);Bar smartNull=foo.getBarWithParams(10,"yes sir");try {smartNull.boo();fail();}catch(Exception e){assertContains("yes sir",e.getMessage());}}
@Test public void shouldShowParametersWhenParamsAreHuge(){Foo foo=mock(Foo.class,RETURNS_SMART_NULLS);String longStr="Lorem Ipsum is simply dummy text of the printing and typesetting industry. Lorem Ipsum has been the industry's standard dummy text ever since the 1500s,when an unknown printer took a galley of type and scrambled it to make a type specimen book. It has survived not only five centuries,but also the leap into electronic typesetting,remaining essentially unchanged. It was popularised in the 1960s with the release of Letraset sheets containing Lorem Ipsum passages,and more recently with desktop publishing software like Aldus PageMaker including versions of Lorem Ipsum.";Bar smartNull=foo.getBarWithParams(10,longStr);try {smartNull.boo();fail();}catch(Exception e){assertContains("Lorem Ipsum",e.getMessage());}}
@Test public void managerCountsArticlesAndSavesThemInTheDatabase(){when(mockCalculator.countArticles("Guardian")).thenReturn(12);when(mockCalculator.countArticlesInPolish(anyString())).thenReturn(5);articleManager.updateArticleCounters("Guardian");verify(mockDatabase).updateNumberOfArticles("Guardian",12);verify(mockDatabase).updateNumberOfPolishArticles("Guardian",5);verify(mockDatabase).updateNumberOfEnglishArticles("Guardian",7);}
@Test public void managerCountsArticlesUsingCalculator(){articleManager.updateArticleCounters("Guardian");verify(mockCalculator).countArticles("Guardian");verify(mockCalculator).countArticlesInPolish("Guardian");}
@Test public void managerSavesArticlesInTheDatabase(){articleManager.updateArticleCounters("Guardian");verify(mockDatabase).updateNumberOfArticles("Guardian",0);verify(mockDatabase).updateNumberOfPolishArticles("Guardian",0);verify(mockDatabase).updateNumberOfEnglishArticles("Guardian",0);}
@Test public void managerUpdatesNumberOfRelatedArticles(){Article articleOne=new Article();Article articleTwo=new Article();Article articleThree=new Article();when(mockCalculator.countNumberOfRelatedArticles(articleOne)).thenReturn(1);when(mockCalculator.countNumberOfRelatedArticles(articleTwo)).thenReturn(12);when(mockCalculator.countNumberOfRelatedArticles(articleThree)).thenReturn(0);when(mockDatabase.getArticlesFor("Guardian")).thenReturn(Arrays.asList(articleOne,articleTwo,articleThree));articleManager.updateRelatedArticlesCounters("Guardian");verify(mockDatabase).save(articleOne);verify(mockDatabase).save(articleTwo);verify(mockDatabase).save(articleThree);}
@Test public void shouldPersistRecalculatedArticle(){Article articleOne=new Article();Article articleTwo=new Article();when(mockCalculator.countNumberOfRelatedArticles(articleOne)).thenReturn(1);when(mockCalculator.countNumberOfRelatedArticles(articleTwo)).thenReturn(12);when(mockDatabase.getArticlesFor("Guardian")).thenReturn(Arrays.asList(articleOne,articleTwo));articleManager.updateRelatedArticlesCounters("Guardian");InOrder inOrder=inOrder(mockDatabase,mockCalculator);inOrder.verify(mockCalculator).countNumberOfRelatedArticles((Article)anyObject());inOrder.verify(mockDatabase,atLeastOnce()).save((Article)anyObject());}
@Test public void shouldCreateMockFromInterface()throws Exception {SomeInterface proxy=ClassImposterizer.INSTANCE.imposterise(new MethodInterceptorStub(),SomeInterface.class);Class superClass=proxy.getClass().getSuperclass();assertEquals(Object.class,superClass);}
@Test public void shouldCreateMockFromClass()throws Exception {ClassWithoutConstructor proxy=ClassImposterizer.INSTANCE.imposterise(new MethodInterceptorStub(),ClassWithoutConstructor.class);Class superClass=proxy.getClass().getSuperclass();assertEquals(ClassWithoutConstructor.class,superClass);}
@Test public void shouldCreateMockFromClassEvenWhenConstructorIsDodgy()throws Exception {try {new ClassWithDodgyConstructor();fail();}catch(Exception e){}ClassWithDodgyConstructor mock=ClassImposterizer.INSTANCE.imposterise(new MethodInterceptorStub(),ClassWithDodgyConstructor.class);assertNotNull(mock);}
@Test public void shouldMocksHaveDifferentInterceptors()throws Exception {SomeClass mockOne=ClassImposterizer.INSTANCE.imposterise(new MethodInterceptorStub(),SomeClass.class);SomeClass mockTwo=ClassImposterizer.INSTANCE.imposterise(new MethodInterceptorStub(),SomeClass.class);Factory cglibFactoryOne=(Factory)mockOne;Factory cglibFactoryTwo=(Factory)mockTwo;assertNotSame(cglibFactoryOne.getCallback(0),cglibFactoryTwo.getCallback(0));}
@Test public void shouldUseAnicilliaryTypes(){}
@Test public void shouldKnowIfCanImposterize()throws Exception {assertFalse(ClassImposterizer.INSTANCE.canImposterise(FinalClass.class));assertFalse(ClassImposterizer.INSTANCE.canImposterise(int.class));assertTrue(ClassImposterizer.INSTANCE.canImposterise(SomeClass.class));assertTrue(ClassImposterizer.INSTANCE.canImposterise(SomeInterface.class));}
@Test(expected=MockitoException.class)public void shouldNotAllowSettingNullInterface(){mockSettingsImpl.extraInterfaces(List.class,null);}
@Test(expected=MockitoException.class)public void shouldNotAllowNonInterfaces(){mockSettingsImpl.extraInterfaces(List.class,LinkedList.class);}
@Test(expected=MockitoException.class)public void shouldNotAllowUsingTheSameInterfaceAsExtra(){mockSettingsImpl.extraInterfaces(List.class,LinkedList.class);}
@Test(expected=MockitoException.class)public void shouldNotAllowEmptyExtraInterfaces(){mockSettingsImpl.extraInterfaces();}
@Test(expected=MockitoException.class)public void shouldNotAllowNullArrayOfExtraInterfaces(){mockSettingsImpl.extraInterfaces((Class[])null);}
@Test public void shouldAllowMultipleInterfaces(){mockSettingsImpl.extraInterfaces(List.class,Set.class);assertEquals(List.class,mockSettingsImpl.getExtraInterfaces()[0]);assertEquals(Set.class,mockSettingsImpl.getExtraInterfaces()[1]);}
@Test public void shouldSetMockToBeSerializable()throws Exception {mockSettingsImpl.serializable();assertTrue(mockSettingsImpl.isSerializable());}
@Test public void shouldKnowIfIsSerializable()throws Exception {assertFalse(mockSettingsImpl.isSerializable());mockSettingsImpl.serializable();assertTrue(mockSettingsImpl.isSerializable());}
@Test public void shouldAddVerboseLoggingListener(){assertFalse(mockSettingsImpl.hasInvocationListeners());mockSettingsImpl.verboseLogging();assertContainsType(mockSettingsImpl.getInvocationListeners(),VerboseMockInvocationLogger.class);}
@Test public void shouldAddVerboseLoggingListenerOnlyOnce(){assertFalse(mockSettingsImpl.hasInvocationListeners());mockSettingsImpl.verboseLogging().verboseLogging();Assertions.assertThat(mockSettingsImpl.getInvocationListeners()).hasSize(1);}
@Test(expected=MockitoException.class)public void shouldNotAllowNullListener(){mockSettingsImpl.invocationListeners(null);}
@Test public void shouldAddInvocationListener(){assertFalse(mockSettingsImpl.hasInvocationListeners());mockSettingsImpl.invocationListeners(invocationListener);Assertions.assertThat(mockSettingsImpl.getInvocationListeners()).contains(invocationListener);}
@Test public void canAddDuplicateInvocationListeners_ItsNotOurBusinessThere(){assertFalse(mockSettingsImpl.hasInvocationListeners());mockSettingsImpl.invocationListeners(invocationListener,invocationListener).invocationListeners(invocationListener);Assertions.assertThat(mockSettingsImpl.getInvocationListeners()).containsSequence(invocationListener,invocationListener,invocationListener);}
@Test public void shouldReportErrorWhenAddingNoInvocationListeners()throws Exception {try {mockSettingsImpl.invocationListeners();fail();}catch(Exception e){Assertions.assertThat(e.getMessage()).contains("at least one listener");}}
@Test public void shouldReportErrorWhenAddingANullInvocationListener()throws Exception {try {mockSettingsImpl.invocationListeners(invocationListener,null);fail();}catch(Exception e){Assertions.assertThat(e.getMessage()).contains("does not accept null");}}
@Test public void shouldCaptureArguments()throws Exception {CapturingMatcher m=new CapturingMatcher();m.captureFrom("foo");m.captureFrom("bar");Assertions.assertThat(m.getAllValues()).containsSequence("foo","bar");}
@Test public void shouldKnowLastCapturedValue()throws Exception {CapturingMatcher m=new CapturingMatcher();m.captureFrom("foo");m.captureFrom("bar");assertEquals("bar",m.getLastValue());}
@Test public void shouldScreamWhenNothingYetCaptured()throws Exception {CapturingMatcher m=new CapturingMatcher();try {m.getLastValue();fail();}catch(MockitoException e){}}
@Ignore("Use it for performance checks")@Test public void testSomething(){List mocks=new LinkedList();for (int i=0;i < 50000;i++){System.out.println("Mock no: " + i);IMethods mock=mock(IMethods.class);mocks.add(mock);when(mock.simpleMethod(1)).thenReturn("one");when(mock.simpleMethod(2)).thenReturn("two");assertEquals("one",mock.simpleMethod(1));assertEquals("two",mock.simpleMethod(2));verify(mock).simpleMethod(1);verify(mock).simpleMethod(2);}}
@Test public void shouldStub()throws Exception {doReturn("foo").when(mock).simpleMethod();doReturn("bar").when(mock).simpleMethod();assertEquals("bar",mock.simpleMethod());}
@Test public void shouldStubWithArgs()throws Exception {doReturn("foo").when(mock).simpleMethod("foo");doReturn("bar").when(mock).simpleMethod(eq("one"),anyInt());assertEquals("foo",mock.simpleMethod("foo"));assertEquals("bar",mock.simpleMethod("one",234));assertEquals(null,mock.simpleMethod("xxx",234));}
@Test public void shouldStubWithThrowable()throws Exception {doThrow(new FooRuntimeException()).when(mock).voidMethod();try {mock.voidMethod();fail();}catch(FooRuntimeException e){}}
@Test public void shouldAllowSettingValidCheckedException()throws Exception {doThrow(new IOException()).when(mock).throwsIOException(0);try {mock.throwsIOException(0);fail();}catch(IOException e){}}
@Test public void shouldDetectInvalidCheckedException()throws Exception {try {doThrow(new FooCheckedException()).when(mock).throwsIOException(0);fail();}catch(Exception e){assertContains("Checked exception is invalid",e.getMessage());}}
@Test public void shouldScreamWhenReturnSetForVoid()throws Exception {try {doReturn("foo").when(mock).voidMethod();fail();}catch(MockitoException e){assertContains("void method",e.getMessage());assertContains("cannot",e.getMessage());}}
@Test public void shouldScreamWhenNotAMockPassed()throws Exception {try {doReturn("foo").when("foo").toString();fail();}catch(Exception e){assertContains("Argument passed to when()is not a mock",e.getMessage());}}
@Test public void shouldScreamWhenNullPassed()throws Exception {try {doReturn("foo").when((Object)null).toString();fail();}catch(Exception e){assertContains("Argument passed to when()is null",e.getMessage());}}
@Test public void shouldAllowChainedStubbing(){doReturn("foo").doThrow(new RuntimeException()).doReturn("bar").when(mock).simpleMethod();assertEquals("foo",mock.simpleMethod());try {mock.simpleMethod();fail();}catch(RuntimeException e){}assertEquals("bar",mock.simpleMethod());assertEquals("bar",mock.simpleMethod());}
@Test(expected=IllegalArgumentException.class)public void shouldAllowChainedStubbingWithExceptionClass()throws Exception {doReturn("whatever").doThrow(IllegalArgumentException.class).when(mock).simpleMethod();assertEquals("whatever",mock.simpleMethod());mock.simpleMethod();}
@Test public void shouldAllowChainedStubbingOnVoidMethods(){doNothing().doNothing().doThrow(new RuntimeException()).when(mock).voidMethod();mock.voidMethod();mock.voidMethod();try {mock.voidMethod();fail();}catch(RuntimeException e){}try {mock.voidMethod();fail();}catch(RuntimeException e){}}
@Test public void shouldStubWithGenericAnswer(){doAnswer(new Answer<Object>(){public Object answer(InvocationOnMock invocation)throws Throwable {return "foo";}}).when(mock).simpleMethod();assertEquals("foo",mock.simpleMethod());}
@Test public void shouldNotAllowDoNothingOnNonVoids(){try {doNothing().when(mock).simpleMethod();fail();}catch(MockitoException e){assertContains("Only void methods can doNothing()",e.getMessage());}}
@Test public void shouldStubbingBeTreatedAsInteraction()throws Exception {doReturn("foo").when(mock).simpleMethod();mock.simpleMethod();try {verifyNoMoreInteractions(mock);fail();}catch(NoInteractionsWanted e){}}
@Test public void shouldVerifyStubbedCall()throws Exception {doReturn("foo").when(mock).simpleMethod();mock.simpleMethod();mock.simpleMethod();verify(mock,times(2)).simpleMethod();verifyNoMoreInteractions(mock);}
@Test public void shouldAllowStubbingToString()throws Exception {doReturn("test").when(mock).toString();assertEquals("test",mock.toString());}
@Test public void shouldDetectInvalidReturnType()throws Exception {try {doReturn("foo").when(mock).booleanObjectReturningMethod();fail();}catch(Exception e){assertContains("String cannot be returned by booleanObjectReturningMethod()" + "\n" + "booleanObjectReturningMethod()should return Boolean",e.getMessage());}}
@Test public void shouldDetectWhenNullAssignedToBoolean()throws Exception {try {doReturn(null).when(mock).intReturningMethod();fail();}catch(Exception e){assertContains("null cannot be returned by intReturningMethod",e.getMessage());}}
@Test public void shouldAllowStubbingWhenTypesMatchSignature()throws Exception {doReturn("foo").when(mock).objectReturningMethodNoArgs();doReturn("foo").when(mock).simpleMethod();doReturn(1).when(mock).intReturningMethod();doReturn(new Integer(2)).when(mock).intReturningMethod();}
@Test public void shouldLocationNotContainGetStackTraceMethod(){assertContains("shouldLocationNotContainGetStackTraceMethod",new Location().toString());}
@Test public void shouldBeSafeInCaseForSomeReasonFilteredStackTraceIsEmpty(){StackTraceFilter filterReturningEmptyArray=new StackTraceFilter(){@Override public StackTraceElement[]filter(StackTraceElement[]target,boolean keepTop){return new StackTraceElement[0];}};String loc=new Location(filterReturningEmptyArray).toString();assertEquals("-> at <<unknown line>>",loc);}
@Test public void shouldBeThreadSafe()throws Throwable {Thread[]t=new Thread[200];for (int i=0;i < t.length;i++){t[i]=new Thread(){public void run(){try {Thread.sleep(10);}catch(InterruptedException e){throw new RuntimeException(e);}container.setInvocationForPotentialStubbing(new InvocationMatcher(invocation));container.addAnswer(new Returns("foo"));container.findAnswerFor(invocation);}};t[i].setUncaughtExceptionHandler(new Thread.UncaughtExceptionHandler(){public void uncaughtException(Thread t,Throwable e){exceptions.add(e);}});t[i].start();}for(Thread aT : t){aT.join();}if (exceptions.size()!= 0){throw exceptions.getFirst();}}
@Test public void shouldReturnInvokedMock()throws Exception {container.setInvocationForPotentialStubbing(new InvocationMatcher(invocation));assertEquals(invocation.getMock(),container.invokedMock());}
@Test public void should_tell_if_has_invocation_for_potential_stubbing()throws Exception {container.setInvocationForPotentialStubbing(new InvocationBuilder().toInvocationMatcher());assertTrue(container.hasInvocationForPotentialStubbing());container.addAnswer(new ReturnsEmptyValues());assertFalse(container.hasInvocationForPotentialStubbing());}
@Test public void shouldProvideTheNameForClass()throws Exception {String name=new MockName(null,SomeClass.class).toString();assertEquals("someClass",name);}
@Test public void shouldProvideTheNameForAnonymousClass()throws Exception {SomeInterface anonymousInstance=new SomeInterface(){};String name=new MockName(null,anonymousInstance.getClass()).toString();assertEquals("someInterface",name);}
@Test public void shouldProvideTheGivenName()throws Exception {String name=new MockName("The Hulk",SomeClass.class).toString();assertEquals("The Hulk",name);}
@Test public void shouldGetArgumentsLine(){String line=printer.getArgumentsLine((List)Arrays.asList(new Equals(1),new Equals(2)),new PrintSettings());assertEquals("(1,2);",line);}
@Test public void shouldGetArgumentsBlock(){String line=printer.getArgumentsBlock((List)Arrays.asList(new Equals(1),new Equals(2)),new PrintSettings());assertEquals("(\n    1,\n    2\n);",line);}
@Test public void shouldDescribeTypeInfoOnlyMarkedMatchers(){String line=printer.getArgumentsLine((List)Arrays.asList(new Equals(1L),new Equals(2)),PrintSettings.verboseMatchers(1));assertEquals("(1,(Integer)2);",line);}
@Test public void shouldGetVerboseArgumentsInBlock(){String line=printer.getArgumentsBlock((List)Arrays.asList(new Equals(1L),new Equals(2)),PrintSettings.verboseMatchers(0,1));assertEquals("(\n    (Long)1,\n    (Integer)2\n);",line);}
@Test public void shouldGetVerboseArgumentsEvenIfSomeMatchersAreNotVerbose(){String line=printer.getArgumentsLine((List)Arrays.asList(new Equals(1L),NotNull.NOT_NULL),PrintSettings.verboseMatchers(0));assertEquals("((Long)1,notNull());",line);}
@Test public void shouldGetAllInvocationsInOrder()throws Exception {mockOne.simpleMethod(100);mockTwo.simpleMethod(200);mockOne.simpleMethod(300);List<Invocation> invocations=finder.find(asList(mockOne,mockTwo));assertEquals(3,invocations.size());assertArgumentEquals(100,invocations.get(0));assertArgumentEquals(200,invocations.get(1));assertArgumentEquals(300,invocations.get(2));}
@Test public void shouldNotCountDuplicatedInteractions()throws Exception {mockOne.simpleMethod(100);List<Invocation> invocations=finder.find(asList(mockOne,mockOne,mockOne));assertEquals(1,invocations.size());}
@Test public void shouldNotReturnToStringMethod()throws Exception {Invocation toString=new InvocationBuilder().method("toString").toInvocation();Invocation simpleMethod=new InvocationBuilder().simpleMethod().toInvocation();invocations.add(toString);invocations.add(simpleMethod);assertTrue(invocations.getAll().contains(simpleMethod));assertFalse(invocations.getAll().contains(toString));}
@Test public void shouldAllowPassingNullArgument(){Fun mockFun=mock(Fun.class);when(mockFun.doFun((String)anyObject())).thenReturn("value");mockFun.doFun(null);try {verify(mockFun).doFun("hello");fail();}catch(AssertionError r){}}
@Test public void shouldShowActualAndExpectedWhenArgumentsAreDifferent(){callMethodOnMock("foo");try {verifyTheMock(1,"not foo");fail();}catch(ArgumentsAreDifferent e){assertContains("callMethodOnMock(",e.getMessage());assertContains("verifyTheMock(",e.getMessage());}}
@Test public void listener()throws Exception {InvocationListener invocationListener=mock(InvocationListener.class);List mockedList=mock(List.class,withSettings().invocationListeners(invocationListener));reset(mockedList);mockedList.clear();verify(invocationListener).reportInvocation(any(MethodInvocationReport.class));}
@Test public void shouldLogUnusedStubbingWarningWhenTestFails()throws Exception {when(mock.simpleMethod(1)).thenReturn("foo");when(mock.otherMethod()).thenReturn("foo");when(mock.booleanObjectReturningMethod()).thenReturn(false);String ret=mock.simpleMethod(2);assertEquals("foo",ret);}
@Test public void shouldNotLogAnythingWhenNoWarnings()throws Exception {when(mock.simpleMethod()).thenReturn("foo");mock.simpleMethod();verify(mock).simpleMethod();fail();}
@Test public void shouldMixVerificationInOrderAndOrdinaryVerification(){inOrder.verify(mockOne,atLeastOnce()).simpleMethod(1);inOrder.verify(mockThree).simpleMethod(3);inOrder.verify(mockThree).simpleMethod(4);verify(mockTwo).simpleMethod(2);verifyNoMoreInteractions(mockOne,mockTwo,mockThree);}
@Test public void shouldAllowOrdinarilyVerifyingMockPassedToInOrderObject(){inOrder.verify(mockOne,atLeastOnce()).simpleMethod(1);verify(mockThree).simpleMethod(3);verify(mockThree).simpleMethod(4);verify(mockTwo).simpleMethod(2);verifyNoMoreInteractions(mockOne,mockTwo,mockThree);}
@Test public void shouldAllowRedundantVerifications(){verify(mockOne,atLeastOnce()).simpleMethod(1);verify(mockTwo).simpleMethod(2);verify(mockThree).simpleMethod(3);verify(mockThree).simpleMethod(4);inOrder.verify(mockOne,atLeastOnce()).simpleMethod(1);inOrder.verify(mockThree).simpleMethod(3);inOrder.verify(mockThree).simpleMethod(4);verifyNoMoreInteractions(mockOne,mockTwo,mockThree);}
@Test public void shouldFailOnNoMoreInteractions(){inOrder.verify(mockOne,atLeastOnce()).simpleMethod(1);inOrder.verify(mockThree).simpleMethod(3);inOrder.verify(mockThree).simpleMethod(4);try {verifyNoMoreInteractions(mockOne,mockTwo,mockThree);fail();}catch(NoInteractionsWanted e){}}
@Test public void shouldFailOnNoMoreInteractionsOnMockVerifiedInOrder(){inOrder.verify(mockOne,atLeastOnce()).simpleMethod(1);inOrder.verify(mockThree).simpleMethod(3);verify(mockTwo).simpleMethod(2);try {verifyNoMoreInteractions(mockOne,mockTwo,mockThree);fail();}catch(NoInteractionsWanted e){}}
@Test public void shouldAllowOneMethodVerifiedInOrder(){verify(mockTwo).simpleMethod(2);verify(mockOne,atLeastOnce()).simpleMethod(1);inOrder.verify(mockOne,atLeastOnce()).simpleMethod(1);}
@Test public void shouldFailOnLastInvocationTooEarly(){inOrder.verify(mockThree).simpleMethod(4);verify(mockThree).simpleMethod(4);verify(mockTwo).simpleMethod(2);try {inOrder.verify(mockOne,atLeastOnce()).simpleMethod(1);fail();}catch(VerificationInOrderFailure e){}}
@Test(expected=MockitoException.class)public void shouldScreamWhenUnfamiliarMockPassedToInOrderObject(){inOrder.verify(mockTwo,atLeastOnce()).simpleMethod(1);}
@Test public void shouldUseEqualsToVerifyMethodArguments(){mockOne=mock(IMethods.class);String textOne="test";String textTwo=new String(textOne);assertEquals(textOne,textTwo);assertNotSame(textOne,textTwo);mockOne.simpleMethod(textOne);mockOne.simpleMethod(textTwo);verify(mockOne,times(2)).simpleMethod(textOne);inOrder=inOrder(mockOne);inOrder.verify(mockOne,times(2)).simpleMethod(textOne);}
@Test public void shouldUseEqualsToVerifyMethodVarargs(){mockOne=mock(IMethods.class);String textOne="test";String textTwo=new String(textOne);assertEquals(textOne,textTwo);assertNotSame(textOne,textTwo);mockOne.varargsObject(1,textOne,textOne);mockOne.varargsObject(1,textTwo,textTwo);verify(mockOne,times(2)).varargsObject(1,textOne,textOne);inOrder=inOrder(mockOne);inOrder.verify(mockOne,times(2)).varargsObject(1,textOne,textOne);}
@Test public void inOrderTest(){List list=mock(List.class);list.add("a");list.add("x");list.add("b");list.add("y");InOrder inOrder=inOrder(list);InOrder inAnotherOrder=inOrder(list);assertNotSame(inOrder,inAnotherOrder);inOrder.verify(list).add("a");inOrder.verify(list).add("b");inAnotherOrder.verify(list).add("x");inAnotherOrder.verify(list).add("y");}
@Test public void shouldFailFastWhenCallingRealMethodOnInterface()throws Exception {List list=mock(List.class);try {when(list.get(0)).thenCallRealMethod();fail();}catch(MockitoException e){}}
@Test public void shouldFailInRuntimeWhenCallingRealMethodOnInterface()throws Exception {List list=mock(List.class);when(list.get(0)).thenAnswer(new Answer(){public Object answer(InvocationOnMock invocation)throws Throwable {return invocation.callRealMethod();}});try {list.get(0);fail();}catch(MockitoException e){}}
@Test public void shouldVerifyActualNumberOfInvocationsSmallerThanWanted()throws Exception {mock.clear();mock.clear();mock.clear();Mockito.verify(mock,times(3)).clear();try {Mockito.verify(mock,times(100)).clear();fail();}catch(TooLittleActualInvocations e){assertContains("mock.clear();",e.getMessage());assertContains("Wanted 100 times",e.getMessage());assertContains("was 3",e.getMessage());}}
@Test public void shouldVerifyActualNumberOfInvocationsLargerThanWanted()throws Exception {mock.clear();mock.clear();mock.clear();mock.clear();Mockito.verify(mock,times(4)).clear();try {Mockito.verify(mock,times(1)).clear();fail();}catch(TooManyActualInvocations e){assertContains("mock.clear();",e.getMessage());assertContains("Wanted 1 time",e.getMessage());assertContains("was 4",e.getMessage());}}
@Test public void shouldAllowCapturingArguments(){mock.simpleMethod("o");ArgumentCaptor<String> arg=ArgumentCaptor.forClass(String.class);verify(mock,only()).simpleMethod(arg.capture());assertEquals("o",arg.getValue());}
@Test public void shouldCreateCorrectCreationInfo()throws Exception {MethodProxy proxy=MethodProxy.create(String.class,Integer.class,"","","");SerializableMockitoMethodProxy serializableMockitoMethodProxy=new SerializableMockitoMethodProxy(proxy);Object methodProxy=Whitebox.invokeMethod(serializableMockitoMethodProxy,"getMethodProxy",new Object[0]);Object info=Whitebox.getInternalState(methodProxy,"createInfo");assertEquals(String.class,Whitebox.getInternalState(info,"c1"));assertEquals(Integer.class,Whitebox.getInternalState(info,"c2"));}
@Test public void shouldCreateCorrectSignatures()throws Exception {MethodProxy proxy=MethodProxy.create(String.class,Integer.class,"a","b","c");SerializableMockitoMethodProxy serializableMockitoMethodProxy=new SerializableMockitoMethodProxy(proxy);MethodProxy methodProxy=(MethodProxy)Whitebox.invokeMethod(serializableMockitoMethodProxy,"getMethodProxy",new Object[0]);assertEquals("a",methodProxy.getSignature().getDescriptor());assertEquals("b",methodProxy.getSignature().getName());assertEquals("c",methodProxy.getSuperName());}
@Test public void shouldInjectMocksIfThereIsNoUserDefinedEngine()throws Exception {AnnotationEngine defaultEngine=new DefaultMockitoConfiguration().getAnnotationEngine();ConfigurationAccess.getConfig().overrideAnnotationEngine(defaultEngine);SimpleTestCase test=new SimpleTestCase();MockitoAnnotations.initMocks(test);assertNotNull(test.mock);assertNotNull(test.tested.dependency);assertSame(test.mock,test.tested.dependency);}
@Test public void shouldRespectUsersEngine()throws Exception {AnnotationEngine customizedEngine=new DefaultAnnotationEngine(){};ConfigurationAccess.getConfig().overrideAnnotationEngine(customizedEngine);SimpleTestCase test=new SimpleTestCase();MockitoAnnotations.initMocks(test);assertNotNull(test.mock);assertNull(test.tested.dependency);}
@Test(expected=NullPointerException.class)public void should_not_allow_null_on_field(){MockInjection.onField((Field)null,this);}
@Test(expected=NullPointerException.class)public void should_not_allow_null_on_fields(){MockInjection.onFields((Set<Field>)null,this);}
@Test(expected=NullPointerException.class)public void should_not_allow_null_on_instance_owning_the_field()throws Exception {MockInjection.onField(field("withConstructor"),null);}
@Test(expected=NullPointerException.class)public void should_not_allow_null_on_mocks()throws Exception {MockInjection.onField(field("withConstructor"),this).withMocks(null);}
@Test public void can_try_constructor_injection()throws Exception {MockInjection.onField(field("withConstructor"),this).withMocks(oneSetMock()).tryConstructorInjection().apply();assertThat(withConstructor.initializedWithConstructor).isEqualTo(true);}
@Test public void should_not_fail_if_constructor_injection_is_not_possible()throws Exception {MockInjection.onField(field("withoutConstructor"),this).withMocks(otherKindOfMocks()).tryConstructorInjection().apply();assertThat(withoutConstructor).isNull();}
@Test public void can_try_property_or_setter_injection()throws Exception {MockInjection.onField(field("withoutConstructor"),this).withMocks(oneSetMock()).tryPropertyOrFieldInjection().apply();assertThat(withoutConstructor.theSet).isNotNull();}
@Test public void should_not_fail_if_property_or_field_injection_is_not_possible()throws Exception {MockInjection.onField(field("withoutConstructor"),this).withMocks(otherKindOfMocks()).tryPropertyOrFieldInjection().apply();assertThat(withoutConstructor.theSet).isNull();}
@Test public void shouldReplaceException()throws Exception {RuntimeException actualExc=new RuntimeException("foo");Failure failure=new Failure(Description.EMPTY,actualExc);hacker.appendWarnings(failure,"unused stubbing");assertEquals(ExceptionIncludingMockitoWarnings.class,failure.getException().getClass());assertEquals(actualExc,failure.getException().getCause());Assertions.assertThat(actualExc.getStackTrace()).isEqualTo(failure.getException().getStackTrace());}
@Test public void shouldAppendWarning()throws Exception {Failure failure=new Failure(Description.EMPTY,new RuntimeException("foo"));hacker.appendWarnings(failure,"unused stubbing blah");assertContains("unused stubbing blah",failure.getException().getMessage());}
@Test public void shouldNotAppendWhenNoWarnings()throws Exception {RuntimeException ex=new RuntimeException("foo");Failure failure=new Failure(Description.EMPTY,ex);hacker.appendWarnings(failure,"");assertEquals(ex,failure.getException());}
@Test public void shouldNotAppendWhenNullWarnings()throws Exception {RuntimeException ex=new RuntimeException("foo");Failure failure=new Failure(Description.EMPTY,ex);hacker.appendWarnings(failure,null);assertEquals(ex,failure.getException());}
@Test public void shouldPrintTheWarningSoICanSeeIt()throws Exception {Failure failure=new Failure(Description.EMPTY,new RuntimeException("foo"));hacker.appendWarnings(failure,"unused stubbing blah");System.out.println(failure.getException());}
@Test public void shouldShowAllInteractionsOnMockWhenOrdinaryVerificationFail()throws Exception {firstInteraction();secondInteraction();try {verify(mock).simpleMethod();fail();}catch(WantedButNotInvoked e){assertContains("However,there were other interactions with this mock",e.getMessage());assertContains("firstInteraction(",e.getMessage());assertContains("secondInteraction(",e.getMessage());}}
@Test public void shouldNotShowAllInteractionsOnDifferentMock()throws Exception {differentMockInteraction();firstInteraction();try {verify(mock).simpleMethod();fail();}catch(WantedButNotInvoked e){assertContains("firstInteraction(",e.getMessage());assertNotContains("differentMockInteraction(",e.getMessage());}}
@Test public void shouldNotShowAllInteractionsHeaderWhenNoOtherInteractions()throws Exception {try {verify(mock).simpleMethod();fail();}catch(WantedButNotInvoked e){assertContains("there were zero interactions with this mock.",e.getMessage());}}
@Test public void shouldBeSerializable()throws Exception {new ObjectOutputStream(new ByteArrayOutputStream()).writeObject(new MethodInterceptorFilter(null,null));}
@Test public void shouldProvideOwnImplementationOfHashCode()throws Throwable {Object ret=filter.intercept(new MethodsImpl(),MethodsImpl.class.getMethod("hashCode"),new Object[0],null);assertTrue((Integer)ret != 0);Mockito.verify(handler,never()).handle(any(Invocation.class));}
@Test public void shouldProvideOwnImplementationOfEquals()throws Throwable {MethodsImpl proxy=new MethodsImpl();Object ret=filter.intercept(proxy,MethodsImpl.class.getMethod("equals",Object.class),new Object[]{proxy},null);assertTrue((Boolean)ret);Mockito.verify(handler,never()).handle(any(Invocation.class));}
@Test public void shouldCreateSerializableMethodProxyIfIsSerializableMock(){}
@Test public void shouldCreateNONSerializableMethodProxyIfIsNotSerializableMock(){}
@Test public void shouldCreateSerializableMethodIfIsSerializableMock(){}
@Test public void shouldCreateJustDelegatingMethodIfIsNotSerializableMock(){}
@Test public void shouldReportTooLittleActual()throws Exception {finderStub.actualToReturn.add(new InvocationBuilder().toInvocation());checker.check(invocations,wanted,100);assertEquals(1,reporterStub.actualCount);assertEquals(100,reporterStub.wantedCount);assertEquals(wanted,reporterStub.wanted);}
@Test public void shouldReportWithLastInvocationStackTrace()throws Exception {Invocation first=new InvocationBuilder().toInvocation();Invocation second=new InvocationBuilder().toInvocation();finderStub.actualToReturn.addAll(asList(first,second));checker.check(invocations,wanted,100);assertSame(second.getLocation(),reporterStub.location);}
@Test public void shouldNotReportWithLastInvocationStackTraceIfNoInvocationsFound()throws Exception {assertTrue(finderStub.actualToReturn.isEmpty());checker.check(invocations,wanted,100);assertNull(reporterStub.location);}
@Test public void shouldReportWithFirstUndesiredInvocationStackTrace()throws Exception {Invocation first=new InvocationBuilder().toInvocation();Invocation second=new InvocationBuilder().toInvocation();Invocation third=new InvocationBuilder().toInvocation();finderStub.actualToReturn.addAll(asList(first,second,third));checker.check(invocations,wanted,2);assertSame(third.getLocation(),reporterStub.location);}
@Test public void shouldReportTooManyActual()throws Exception {finderStub.actualToReturn.add(new InvocationBuilder().toInvocation());finderStub.actualToReturn.add(new InvocationBuilder().toInvocation());checker.check(invocations,wanted,1);assertEquals(2,reporterStub.actualCount);assertEquals(1,reporterStub.wantedCount);assertEquals(wanted,reporterStub.wanted);}
@Test public void shouldReportNeverWantedButInvoked()throws Exception {Invocation invocation=new InvocationBuilder().toInvocation();finderStub.actualToReturn.add(invocation);checker.check(invocations,wanted,0);assertEquals(wanted,reporterStub.wanted);assertEquals(invocation.getLocation(),reporterStub.location);}
@Test public void shouldMarkInvocationsAsVerified()throws Exception {Invocation invocation=new InvocationBuilder().toInvocation();finderStub.actualToReturn.add(invocation);assertFalse(invocation.isVerified());checker.check(invocations,wanted,1);assertTrue(invocation.isVerified());}
@Test public void andOverloaded(){when(mock.oneArg(and(eq(false),eq(false)))).thenReturn("0");when(mock.oneArg(and(eq((byte)1),eq((byte)1)))).thenReturn("1");when(mock.oneArg(and(eq('a'),eq('a')))).thenReturn("2");when(mock.oneArg(and(eq((double)1),eq((double)1)))).thenReturn("3");when(mock.oneArg(and(eq((float)1),eq((float)1)))).thenReturn("4");when(mock.oneArg(and(eq((int)1),eq((int)1)))).thenReturn("5");when(mock.oneArg(and(eq((long)1),eq((long)1)))).thenReturn("6");when(mock.oneArg(and(eq((short)1),eq((short)1)))).thenReturn("7");when(mock.oneArg(and(Matchers.contains("a"),Matchers.contains("d")))).thenReturn("8");when(mock.oneArg(and(isA(Class.class),eq(Object.class)))).thenReturn("9");assertEquals("0",mock.oneArg(false));assertEquals(null,mock.oneArg(true));assertEquals("1",mock.oneArg((byte)1));assertEquals("2",mock.oneArg('a'));assertEquals("3",mock.oneArg((double)1));assertEquals("4",mock.oneArg((float)1));assertEquals("5",mock.oneArg((int)1));assertEquals("6",mock.oneArg((long)1));assertEquals("7",mock.oneArg((short)1));assertEquals("8",mock.oneArg("abcde"));assertEquals(null,mock.oneArg("aaaaa"));assertEquals("9",mock.oneArg(Object.class));}
@Test public void orOverloaded(){when(mock.oneArg(or(eq(false),eq(true)))).thenReturn("0");when(mock.oneArg(or(eq((byte)1),eq((byte)2)))).thenReturn("1");when(mock.oneArg(or(eq((char)1),eq((char)2)))).thenReturn("2");when(mock.oneArg(or(eq((double)1),eq((double)2)))).thenReturn("3");when(mock.oneArg(or(eq((float)1),eq((float)2)))).thenReturn("4");when(mock.oneArg(or(eq((int)1),eq((int)2)))).thenReturn("5");when(mock.oneArg(or(eq((long)1),eq((long)2)))).thenReturn("6");when(mock.oneArg(or(eq((short)1),eq((short)2)))).thenReturn("7");when(mock.oneArg(or(eq("asd"),eq("jkl")))).thenReturn("8");when(mock.oneArg(or(eq(this.getClass()),eq(Object.class)))).thenReturn("9");assertEquals("0",mock.oneArg(true));assertEquals("0",mock.oneArg(false));assertEquals("1",mock.oneArg((byte)2));assertEquals("2",mock.oneArg((char)1));assertEquals("3",mock.oneArg((double)2));assertEquals("4",mock.oneArg((float)1));assertEquals("5",mock.oneArg((int)2));assertEquals("6",mock.oneArg((long)1));assertEquals("7",mock.oneArg((short)1));assertEquals("8",mock.oneArg("jkl"));assertEquals("8",mock.oneArg("asd"));assertEquals(null,mock.oneArg("asdjkl"));assertEquals("9",mock.oneArg(Object.class));assertEquals(null,mock.oneArg(String.class));}
@Test public void notOverloaded(){when(mock.oneArg(not(eq(false)))).thenReturn("0");when(mock.oneArg(not(eq((byte)1)))).thenReturn("1");when(mock.oneArg(not(eq('a')))).thenReturn("2");when(mock.oneArg(not(eq((double)1)))).thenReturn("3");when(mock.oneArg(not(eq((float)1)))).thenReturn("4");when(mock.oneArg(not(eq((int)1)))).thenReturn("5");when(mock.oneArg(not(eq((long)1)))).thenReturn("6");when(mock.oneArg(not(eq((short)1)))).thenReturn("7");when(mock.oneArg(not(Matchers.contains("a")))).thenReturn("8");when(mock.oneArg(not(isA(Class.class)))).thenReturn("9");assertEquals("0",mock.oneArg(true));assertEquals(null,mock.oneArg(false));assertEquals("1",mock.oneArg((byte)2));assertEquals("2",mock.oneArg('b'));assertEquals("3",mock.oneArg((double)2));assertEquals("4",mock.oneArg((float)2));assertEquals("5",mock.oneArg((int)2));assertEquals("6",mock.oneArg((long)2));assertEquals("7",mock.oneArg((short)2));assertEquals("8",mock.oneArg("bcde"));assertEquals("9",mock.oneArg(new Object()));assertEquals(null,mock.oneArg(Class.class));}
@Test public void lessOrEqualOverloaded(){when(mock.oneArg(leq((byte)1))).thenReturn("1");when(mock.oneArg(leq((double)1))).thenReturn("3");when(mock.oneArg(leq((float)1))).thenReturn("4");when(mock.oneArg(leq((int)1))).thenReturn("5");when(mock.oneArg(leq((long)1))).thenReturn("6");when(mock.oneArg(leq((short)1))).thenReturn("7");when(mock.oneArg(leq(new BigDecimal("1")))).thenReturn("8");assertEquals("1",mock.oneArg((byte)1));assertEquals(null,mock.oneArg((byte)2));assertEquals("3",mock.oneArg((double)1));assertEquals("7",mock.oneArg((short)0));assertEquals("4",mock.oneArg((float)-5));assertEquals("5",mock.oneArg((int)-2));assertEquals("6",mock.oneArg((long)-3));assertEquals("8",mock.oneArg(new BigDecimal("0.5")));assertEquals(null,mock.oneArg(new BigDecimal("1.1")));}
@Test public void lessThanOverloaded(){when(mock.oneArg(lt((byte)1))).thenReturn("1");when(mock.oneArg(lt((double)1))).thenReturn("3");when(mock.oneArg(lt((float)1))).thenReturn("4");when(mock.oneArg(lt((int)1))).thenReturn("5");when(mock.oneArg(lt((long)1))).thenReturn("6");when(mock.oneArg(lt((short)1))).thenReturn("7");when(mock.oneArg(lt(new BigDecimal("1")))).thenReturn("8");assertEquals("1",mock.oneArg((byte)0));assertEquals(null,mock.oneArg((byte)1));assertEquals("3",mock.oneArg((double)0));assertEquals("7",mock.oneArg((short)0));assertEquals("4",mock.oneArg((float)-4));assertEquals("5",mock.oneArg((int)-34));assertEquals("6",mock.oneArg((long)-6));assertEquals("8",mock.oneArg(new BigDecimal("0.5")));assertEquals(null,mock.oneArg(new BigDecimal("23")));}
@Test public void greaterOrEqualMatcherOverloaded(){when(mock.oneArg(geq((byte)1))).thenReturn("1");when(mock.oneArg(geq((double)1))).thenReturn("3");when(mock.oneArg(geq((float)1))).thenReturn("4");when(mock.oneArg(geq((int)1))).thenReturn("5");when(mock.oneArg(geq((long)1))).thenReturn("6");when(mock.oneArg(geq((short)1))).thenReturn("7");when(mock.oneArg(geq(new BigDecimal("1")))).thenReturn("8");assertEquals("1",mock.oneArg((byte)2));assertEquals(null,mock.oneArg((byte)0));assertEquals("3",mock.oneArg((double)1));assertEquals("7",mock.oneArg((short)2));assertEquals("4",mock.oneArg((float)3));assertEquals("5",mock.oneArg((int)4));assertEquals("6",mock.oneArg((long)5));assertEquals("8",mock.oneArg(new BigDecimal("1.00")));assertEquals(null,mock.oneArg(new BigDecimal("0.9")));}
@Test public void greaterThanMatcherOverloaded(){when(mock.oneArg(gt((byte)1))).thenReturn("1");when(mock.oneArg(gt((double)1))).thenReturn("3");when(mock.oneArg(gt((float)1))).thenReturn("4");when(mock.oneArg(gt((int)1))).thenReturn("5");when(mock.oneArg(gt((long)1))).thenReturn("6");when(mock.oneArg(gt((short)1))).thenReturn("7");when(mock.oneArg(gt(new BigDecimal("1")))).thenReturn("8");assertEquals("1",mock.oneArg((byte)2));assertEquals(null,mock.oneArg((byte)1));assertEquals("3",mock.oneArg((double)2));assertEquals("7",mock.oneArg((short)2));assertEquals("4",mock.oneArg((float)3));assertEquals("5",mock.oneArg((int)2));assertEquals("6",mock.oneArg((long)5));assertEquals("8",mock.oneArg(new BigDecimal("1.5")));assertEquals(null,mock.oneArg(new BigDecimal("0.9")));}
@Test public void compareToMatcher(){when(mock.oneArg(cmpEq(new BigDecimal("1.5")))).thenReturn("0");assertEquals("0",mock.oneArg(new BigDecimal("1.50")));assertEquals(null,mock.oneArg(new BigDecimal("1.51")));}
@Test public void anyStringMatcher(){when(mock.oneArg(anyString())).thenReturn("1");assertEquals("1",mock.oneArg(""));assertEquals("1",mock.oneArg("any string"));assertEquals(null,mock.oneArg((Object)null));}
@Test public void anyMatcher(){when(mock.oneArg(anyBoolean())).thenReturn("0");when(mock.oneArg(anyByte())).thenReturn("1");when(mock.oneArg(anyChar())).thenReturn("2");when(mock.oneArg(anyDouble())).thenReturn("3");when(mock.oneArg(anyFloat())).thenReturn("4");when(mock.oneArg(anyInt())).thenReturn("5");when(mock.oneArg(anyLong())).thenReturn("6");when(mock.oneArg(anyShort())).thenReturn("7");when(mock.oneArg((String)anyObject())).thenReturn("8");when(mock.oneArg(anyObject())).thenReturn("9");assertEquals("0",mock.oneArg(true));assertEquals("0",mock.oneArg(false));assertEquals("1",mock.oneArg((byte)1));assertEquals("2",mock.oneArg((char)1));assertEquals("3",mock.oneArg((double)1));assertEquals("4",mock.oneArg((float)889));assertEquals("5",mock.oneArg((int)1));assertEquals("6",mock.oneArg((long)1));assertEquals("7",mock.oneArg((short)1));assertEquals("8",mock.oneArg("Test"));assertEquals("9",mock.oneArg(new Object()));assertEquals("9",mock.oneArg(new HashMap()));}
@Test public void shouldArrayEqualsDealWithNullArray()throws Exception {Object[]nullArray=null;when(mock.oneArray(aryEq(nullArray))).thenReturn("null");assertEquals("null",mock.oneArray(nullArray));mock=mock(IMethods.class);try {verify(mock).oneArray(aryEq(nullArray));fail();}catch(WantedButNotInvoked e){assertContains("oneArray(null)",e.getMessage());}}
@Test public void shouldUseSmartEqualsForArrays()throws Exception {mock.arrayMethod(new String[]{"one"});verify(mock).arrayMethod(eq(new String[]{"one"}));verify(mock).arrayMethod(new String[]{"one"});}
@Test public void shouldUseSmartEqualsForPrimitiveArrays()throws Exception {mock.objectArgMethod(new int[]{1,2});verify(mock).objectArgMethod(eq(new int[]{1,2}));verify(mock).objectArgMethod(new int[]{1,2});}
@Test(expected=ArgumentsAreDifferent.class)public void arrayEqualsShouldThrowArgumentsAreDifferentExceptionForNonMatchingArguments(){List list=Mockito.mock(List.class);list.add("test");list.contains(new Object[]{"1"});Mockito.verify(list).contains(new Object[]{"1","2","3"});}
@Test public void arrayEqualsMatcher(){when(mock.oneArray(aryEq(new boolean[]{true,false,false}))).thenReturn("0");when(mock.oneArray(aryEq(new byte[]{1}))).thenReturn("1");when(mock.oneArray(aryEq(new char[]{1}))).thenReturn("2");when(mock.oneArray(aryEq(new double[]{1}))).thenReturn("3");when(mock.oneArray(aryEq(new float[]{1}))).thenReturn("4");when(mock.oneArray(aryEq(new int[]{1}))).thenReturn("5");when(mock.oneArray(aryEq(new long[]{1}))).thenReturn("6");when(mock.oneArray(aryEq(new short[]{1}))).thenReturn("7");when(mock.oneArray(aryEq(new String[]{"Test"}))).thenReturn("8");when(mock.oneArray(aryEq(new Object[]{"Test",new Integer(4)}))).thenReturn("9");assertEquals("0",mock.oneArray(new boolean[]{true,false,false}));assertEquals("1",mock.oneArray(new byte[]{1}));assertEquals("2",mock.oneArray(new char[]{1}));assertEquals("3",mock.oneArray(new double[]{1}));assertEquals("4",mock.oneArray(new float[]{1}));assertEquals("5",mock.oneArray(new int[]{1}));assertEquals("6",mock.oneArray(new long[]{1}));assertEquals("7",mock.oneArray(new short[]{1}));assertEquals("8",mock.oneArray(new String[]{"Test"}));assertEquals("9",mock.oneArray(new Object[]{"Test",new Integer(4)}));assertEquals(null,mock.oneArray(new Object[]{"Test",new Integer(999)}));assertEquals(null,mock.oneArray(new Object[]{"Test",new Integer(4),"x"}));assertEquals(null,mock.oneArray(new boolean[]{true,false}));assertEquals(null,mock.oneArray(new boolean[]{true,true,false}));}
@Test public void greaterOrEqualMatcher(){when(mock.oneArg(geq(7))).thenReturn(">= 7");when(mock.oneArg(lt(7))).thenReturn("< 7");assertEquals(">= 7",mock.oneArg(7));assertEquals(">= 7",mock.oneArg(8));assertEquals(">= 7",mock.oneArg(9));assertEquals("< 7",mock.oneArg(6));assertEquals("< 7",mock.oneArg(6));}
@Test public void greaterThanMatcher(){when(mock.oneArg(gt(7))).thenReturn("> 7");when(mock.oneArg(leq(7))).thenReturn("<= 7");assertEquals("> 7",mock.oneArg(8));assertEquals("> 7",mock.oneArg(9));assertEquals("> 7",mock.oneArg(10));assertEquals("<= 7",mock.oneArg(7));assertEquals("<= 7",mock.oneArg(6));}
@Test public void lessOrEqualMatcher(){when(mock.oneArg(leq(7))).thenReturn("<= 7");when(mock.oneArg(gt(7))).thenReturn("> 7");assertEquals("<= 7",mock.oneArg(7));assertEquals("<= 7",mock.oneArg(6));assertEquals("<= 7",mock.oneArg(5));assertEquals("> 7",mock.oneArg(8));assertEquals("> 7",mock.oneArg(9));}
@Test public void lessThanMatcher(){when(mock.oneArg(lt(7))).thenReturn("< 7");when(mock.oneArg(geq(7))).thenReturn(">= 7");assertEquals("< 7",mock.oneArg(5));assertEquals("< 7",mock.oneArg(6));assertEquals("< 7",mock.oneArg(4));assertEquals(">= 7",mock.oneArg(7));assertEquals(">= 7",mock.oneArg(8));}
@Test public void orMatcher(){when(mock.oneArg(anyInt())).thenReturn("other");when(mock.oneArg(or(eq(7),eq(9)))).thenReturn("7 or 9");assertEquals("other",mock.oneArg(10));assertEquals("7 or 9",mock.oneArg(7));assertEquals("7 or 9",mock.oneArg(9));}
@Test public void nullMatcher(){when(mock.threeArgumentMethod(eq(1),isNull(),eq(""))).thenReturn("1");when(mock.threeArgumentMethod(eq(1),not(isNull()),eq(""))).thenReturn("2");assertEquals("1",mock.threeArgumentMethod(1,null,""));assertEquals("2",mock.threeArgumentMethod(1,new Object(),""));}
@Test public void notNullMatcher(){when(mock.threeArgumentMethod(eq(1),notNull(),eq(""))).thenReturn("1");when(mock.threeArgumentMethod(eq(1),not(isNotNull()),eq(""))).thenReturn("2");assertEquals("1",mock.threeArgumentMethod(1,new Object(),""));assertEquals("2",mock.threeArgumentMethod(1,null,""));}
@Test public void findMatcher(){when(mock.oneArg(find("([a-z]+)\\d"))).thenReturn("1");assertEquals("1",mock.oneArg("ab12"));assertEquals(null,mock.oneArg("12345"));assertEquals(null,mock.oneArg((Object)null));}
@Test public void matchesMatcher(){when(mock.oneArg(matches("[a-z]+\\d\\d"))).thenReturn("1");when(mock.oneArg(matches("\\d\\d\\d"))).thenReturn("2");assertEquals("1",mock.oneArg("a12"));assertEquals("2",mock.oneArg("131"));assertEquals(null,mock.oneArg("blah"));}
@Test public void containsMatcher(){when(mock.oneArg(Matchers.contains("ell"))).thenReturn("1");when(mock.oneArg(Matchers.contains("ld"))).thenReturn("2");assertEquals("1",mock.oneArg("hello"));assertEquals("2",mock.oneArg("world"));assertEquals(null,mock.oneArg("xlx"));}
@Test public void startsWithMatcher(){when(mock.oneArg(startsWith("ab"))).thenReturn("1");when(mock.oneArg(startsWith("bc"))).thenReturn("2");assertEquals("1",mock.oneArg("ab quake"));assertEquals("2",mock.oneArg("bc quake"));assertEquals(null,mock.oneArg("ba quake"));}
@Test public void endsWithMatcher(){when(mock.oneArg(Matchers.endsWith("ab"))).thenReturn("1");when(mock.oneArg(Matchers.endsWith("bc"))).thenReturn("2");assertEquals("1",mock.oneArg("xab"));assertEquals("2",mock.oneArg("xbc"));assertEquals(null,mock.oneArg("ac"));}
@Test public void deltaMatcher(){when(mock.oneArg(eq(1.0D,0.1D))).thenReturn("1");when(mock.oneArg(eq(2.0D,0.1D))).thenReturn("2");when(mock.oneArg(eq(1.0F,0.1F))).thenReturn("3");when(mock.oneArg(eq(2.0F,0.1F))).thenReturn("4");when(mock.oneArg(eq(2.0F,0.1F))).thenReturn("4");assertEquals("1",mock.oneArg(1.0));assertEquals("1",mock.oneArg(0.91));assertEquals("1",mock.oneArg(1.09));assertEquals("2",mock.oneArg(2.0));assertEquals("3",mock.oneArg(1.0F));assertEquals("3",mock.oneArg(0.91F));assertEquals("3",mock.oneArg(1.09F));assertEquals("4",mock.oneArg(2.1F));assertEquals(null,mock.oneArg(2.2F));}
@Test public void deltaMatcherPrintsItself(){try {verify(mock).oneArg(eq(1.0D,0.1D));fail();}catch(WantedButNotInvoked e){assertContains("eq(1.0,0.1)",e.getMessage());}}
@Test public void sameMatcher(){Object one=new String("1243");Object two=new String("1243");Object three=new String("1243");assertNotSame(one,two);assertEquals(one,two);assertEquals(two,three);when(mock.oneArg(same(one))).thenReturn("1");when(mock.oneArg(same(two))).thenReturn("2");assertEquals("1",mock.oneArg(one));assertEquals("2",mock.oneArg(two));assertEquals(null,mock.oneArg(three));}
@Test public void eqMatcherAndNulls(){mock.simpleMethod((Object)null);verify(mock).simpleMethod((Object)eq(null));}
@Test public void sameMatcherAndNulls(){mock.simpleMethod((Object)null);verify(mock).simpleMethod(same(null));}
@Test public void shouldNotAllowNegativeNumberOfMinimumInvocations()throws Exception {try {VerificationModeFactory.atLeast(-50);fail();}catch(MockitoException e){assertEquals("Negative value is not allowed here",e.getMessage());}}
@Test public void shouldAllowZeroInvocations()throws Exception {VerificationModeFactory.atLeast(0);}
@Test public void shouldVerify(){spy.add("one");spy.add("two");assertEquals("one",spy.get(0));assertEquals("two",spy.get(1));verify(spy).add("one");verify(spy).add("two");}
@Test public void shouldBeAbleToMockObjectBecauseWhyNot(){spy(new Object());}
@Test public void shouldStub(){spy.add("one");when(spy.get(0)).thenReturn("1").thenReturn("1 again");assertEquals("1",spy.get(0));assertEquals("1 again",spy.get(0));assertEquals("one",spy.iterator().next());assertEquals(1,spy.size());}
@Test public void shouldAllowOverridingStubs(){when(spy.contains(anyObject())).thenReturn(true);when(spy.contains("foo")).thenReturn(false);assertTrue(spy.contains("bar"));assertFalse(spy.contains("foo"));}
@SuppressWarnings("deprecation")@Test public void shouldStubVoid(){stubVoid(spy).toReturn().toThrow(new RuntimeException()).on().clear();spy.add("one");spy.clear();try {spy.clear();fail();}catch(RuntimeException e){}assertEquals(1,spy.size());}
@Test public void shouldStubWithDoReturnAndVerify(){doReturn("foo").doReturn("bar").when(spy).get(0);assertEquals("foo",spy.get(0));assertEquals("bar",spy.get(0));verify(spy,times(2)).get(0);verifyNoMoreInteractions(spy);}
@Test public void shouldVerifyInOrder(){spy.add("one");spy.add("two");InOrder inOrder=inOrder(spy);inOrder.verify(spy).add("one");inOrder.verify(spy).add("two");verifyNoMoreInteractions(spy);}
@Test public void shouldVerifyInOrderAndFail(){spy.add("one");spy.add("two");InOrder inOrder=inOrder(spy);inOrder.verify(spy).add("two");try {inOrder.verify(spy).add("one");fail();}catch(VerificationInOrderFailure f){}}
@Test public void shouldVerifyNumberOfTimes(){spy.add("one");spy.add("one");verify(spy,times(2)).add("one");verifyNoMoreInteractions(spy);}
@Test public void shouldVerifyNumberOfTimesAndFail(){spy.add("one");spy.add("one");try {verify(spy,times(3)).add("one");fail();}catch(TooLittleActualInvocations e){}}
@Test public void shouldVerifyNoMoreInteractionsAndFail(){spy.add("one");spy.add("two");verify(spy).add("one");try {verifyNoMoreInteractions(spy);fail();}catch(NoInteractionsWanted e){}}
@Test public void shouldToString(){spy.add("foo");assertEquals("[foo]",spy.toString());}
@Test public void shouldAllowSpyingAnonymousClasses(){Foo spy=spy(new Foo(){public String print(){return "foo";}});assertEquals("foo",spy.print());}
@Test public void shouldSayNiceMessageWhenSpyingOnPrivateClass()throws Exception {List real=Arrays.asList("first","second");try {spy(real);fail();}catch(MockitoException e){assertContains("Most likely it is a private class that is not visible by Mockito",e.getMessage());}}
@Test public void shouldRunInMultipleThreads(){}
@Test public void testname()throws Exception {}
@Test public void testReflectionEquals(){TestObject o1=new TestObject(4);TestObject o2=new TestObject(5);assertTrue(EqualsBuilder.reflectionEquals(o1,o1));assertTrue(!EqualsBuilder.reflectionEquals(o1,o2));o2.setA(4);assertTrue(EqualsBuilder.reflectionEquals(o1,o2));assertTrue(!EqualsBuilder.reflectionEquals(o1,this));assertTrue(!EqualsBuilder.reflectionEquals(o1,null));assertTrue(!EqualsBuilder.reflectionEquals(null,o2));assertTrue(EqualsBuilder.reflectionEquals((Object)null,(Object)null));}
@Test public void testReflectionHierarchyEquals(){testReflectionHierarchyEquals(false);testReflectionHierarchyEquals(true);assertTrue(EqualsBuilder.reflectionEquals(new TestTTLeafObject(1,2,3,4),new TestTTLeafObject(1,2,3,4),true));assertTrue(EqualsBuilder.reflectionEquals(new TestTTLeafObject(1,2,3,4),new TestTTLeafObject(1,2,3,4),false));assertTrue(!EqualsBuilder.reflectionEquals(new TestTTLeafObject(1,0,0,4),new TestTTLeafObject(1,2,3,4),true));assertTrue(!EqualsBuilder.reflectionEquals(new TestTTLeafObject(1,2,3,4),new TestTTLeafObject(1,2,3,0),true));assertTrue(!EqualsBuilder.reflectionEquals(new TestTTLeafObject(0,2,3,4),new TestTTLeafObject(1,2,3,4),true));}
@Test public void testSuper(){TestObject o1=new TestObject(4);TestObject o2=new TestObject(5);assertEquals(true,new EqualsBuilder().appendSuper(true).append(o1,o1).isEquals());assertEquals(false,new EqualsBuilder().appendSuper(false).append(o1,o1).isEquals());assertEquals(false,new EqualsBuilder().appendSuper(true).append(o1,o2).isEquals());assertEquals(false,new EqualsBuilder().appendSuper(false).append(o1,o2).isEquals());}
@Test public void testObject(){TestObject o1=new TestObject(4);TestObject o2=new TestObject(5);assertTrue(new EqualsBuilder().append(o1,o1).isEquals());assertTrue(!new EqualsBuilder().append(o1,o2).isEquals());o2.setA(4);assertTrue(new EqualsBuilder().append(o1,o2).isEquals());assertTrue(!new EqualsBuilder().append(o1,this).isEquals());assertTrue(!new EqualsBuilder().append(o1,null).isEquals());assertTrue(!new EqualsBuilder().append(null,o2).isEquals());assertTrue(new EqualsBuilder().append((Object)null,(Object)null).isEquals());}
@Test public void testLong(){long o1=1L;long o2=2L;assertTrue(new EqualsBuilder().append(o1,o1).isEquals());assertTrue(!new EqualsBuilder().append(o1,o2).isEquals());}
@Test public void testInt(){int o1=1;int o2=2;assertTrue(new EqualsBuilder().append(o1,o1).isEquals());assertTrue(!new EqualsBuilder().append(o1,o2).isEquals());}
@Test public void testShort(){short o1=1;short o2=2;assertTrue(new EqualsBuilder().append(o1,o1).isEquals());assertTrue(!new EqualsBuilder().append(o1,o2).isEquals());}
@Test public void testChar(){char o1=1;char o2=2;assertTrue(new EqualsBuilder().append(o1,o1).isEquals());assertTrue(!new EqualsBuilder().append(o1,o2).isEquals());}
@Test public void testByte(){byte o1=1;byte o2=2;assertTrue(new EqualsBuilder().append(o1,o1).isEquals());assertTrue(!new EqualsBuilder().append(o1,o2).isEquals());}
@Test public void testDouble(){double o1=1;double o2=2;assertTrue(new EqualsBuilder().append(o1,o1).isEquals());assertTrue(!new EqualsBuilder().append(o1,o2).isEquals());assertTrue(!new EqualsBuilder().append(o1,Double.NaN).isEquals());assertTrue(new EqualsBuilder().append(Double.NaN,Double.NaN).isEquals());assertTrue(new EqualsBuilder().append(Double.POSITIVE_INFINITY,Double.POSITIVE_INFINITY).isEquals());}
@Test public void testFloat(){float o1=1;float o2=2;assertTrue(new EqualsBuilder().append(o1,o1).isEquals());assertTrue(!new EqualsBuilder().append(o1,o2).isEquals());assertTrue(!new EqualsBuilder().append(o1,Float.NaN).isEquals());assertTrue(new EqualsBuilder().append(Float.NaN,Float.NaN).isEquals());assertTrue(new EqualsBuilder().append(Float.POSITIVE_INFINITY,Float.POSITIVE_INFINITY).isEquals());}
@Test public void testBigDecimal(){BigDecimal o1=new BigDecimal("2.0");BigDecimal o2=new BigDecimal("2.00");assertTrue(new EqualsBuilder().append(o1,o1).isEquals());assertTrue(new EqualsBuilder().append(o1,o2).isEquals());}
@Test public void testAccessors(){EqualsBuilder equalsBuilder=new EqualsBuilder();assertTrue(equalsBuilder.isEquals());equalsBuilder.setEquals(true);assertTrue(equalsBuilder.isEquals());equalsBuilder.setEquals(false);assertFalse(equalsBuilder.isEquals());}
@Test public void testBoolean(){boolean o1=true;boolean o2=false;assertTrue(new EqualsBuilder().append(o1,o1).isEquals());assertTrue(!new EqualsBuilder().append(o1,o2).isEquals());}
@Test public void testObjectArray(){TestObject[]obj1=new TestObject[3];obj1[0]=new TestObject(4);obj1[1]=new TestObject(5);obj1[2]=null;TestObject[]obj2=new TestObject[3];obj2[0]=new TestObject(4);obj2[1]=new TestObject(5);obj2[2]=null;assertTrue(new EqualsBuilder().append(obj1,obj1).isEquals());assertTrue(new EqualsBuilder().append(obj2,obj2).isEquals());assertTrue(new EqualsBuilder().append(obj1,obj2).isEquals());obj1[1].setA(6);assertTrue(!new EqualsBuilder().append(obj1,obj2).isEquals());obj1[1].setA(5);assertTrue(new EqualsBuilder().append(obj1,obj2).isEquals());obj1[2]=obj1[1];assertTrue(!new EqualsBuilder().append(obj1,obj2).isEquals());obj1[2]=null;assertTrue(new EqualsBuilder().append(obj1,obj2).isEquals());obj2=null;assertTrue(!new EqualsBuilder().append(obj1,obj2).isEquals());obj1=null;assertTrue(new EqualsBuilder().append(obj1,obj2).isEquals());}
@Test public void testLongArray(){long[]obj1=new long[2];obj1[0]=5L;obj1[1]=6L;long[]obj2=new long[2];obj2[0]=5L;obj2[1]=6L;assertTrue(new EqualsBuilder().append(obj1,obj1).isEquals());assertTrue(new EqualsBuilder().append(obj1,obj2).isEquals());obj1[1]=7;assertTrue(!new EqualsBuilder().append(obj1,obj2).isEquals());obj2=null;assertTrue(!new EqualsBuilder().append(obj1,obj2).isEquals());obj1=null;assertTrue(new EqualsBuilder().append(obj1,obj2).isEquals());}
@Test public void testIntArray(){int[]obj1=new int[2];obj1[0]=5;obj1[1]=6;int[]obj2=new int[2];obj2[0]=5;obj2[1]=6;assertTrue(new EqualsBuilder().append(obj1,obj1).isEquals());assertTrue(new EqualsBuilder().append(obj1,obj2).isEquals());obj1[1]=7;assertTrue(!new EqualsBuilder().append(obj1,obj2).isEquals());obj2=null;assertTrue(!new EqualsBuilder().append(obj1,obj2).isEquals());obj1=null;assertTrue(new EqualsBuilder().append(obj1,obj2).isEquals());}
@Test public void testShortArray(){short[]obj1=new short[2];obj1[0]=5;obj1[1]=6;short[]obj2=new short[2];obj2[0]=5;obj2[1]=6;assertTrue(new EqualsBuilder().append(obj1,obj1).isEquals());assertTrue(new EqualsBuilder().append(obj1,obj2).isEquals());obj1[1]=7;assertTrue(!new EqualsBuilder().append(obj1,obj2).isEquals());obj2=null;assertTrue(!new EqualsBuilder().append(obj1,obj2).isEquals());obj1=null;assertTrue(new EqualsBuilder().append(obj1,obj2).isEquals());}
@Test public void testCharArray(){char[]obj1=new char[2];obj1[0]=5;obj1[1]=6;char[]obj2=new char[2];obj2[0]=5;obj2[1]=6;assertTrue(new EqualsBuilder().append(obj1,obj1).isEquals());assertTrue(new EqualsBuilder().append(obj1,obj2).isEquals());obj1[1]=7;assertTrue(!new EqualsBuilder().append(obj1,obj2).isEquals());obj2=null;assertTrue(!new EqualsBuilder().append(obj1,obj2).isEquals());obj1=null;assertTrue(new EqualsBuilder().append(obj1,obj2).isEquals());}
@Test public void testByteArray(){byte[]obj1=new byte[2];obj1[0]=5;obj1[1]=6;byte[]obj2=new byte[2];obj2[0]=5;obj2[1]=6;assertTrue(new EqualsBuilder().append(obj1,obj1).isEquals());assertTrue(new EqualsBuilder().append(obj1,obj2).isEquals());obj1[1]=7;assertTrue(!new EqualsBuilder().append(obj1,obj2).isEquals());obj2=null;assertTrue(!new EqualsBuilder().append(obj1,obj2).isEquals());obj1=null;assertTrue(new EqualsBuilder().append(obj1,obj2).isEquals());}
@Test public void testDoubleArray(){double[]obj1=new double[2];obj1[0]=5;obj1[1]=6;double[]obj2=new double[2];obj2[0]=5;obj2[1]=6;assertTrue(new EqualsBuilder().append(obj1,obj1).isEquals());assertTrue(new EqualsBuilder().append(obj1,obj2).isEquals());obj1[1]=7;assertTrue(!new EqualsBuilder().append(obj1,obj2).isEquals());obj2=null;assertTrue(!new EqualsBuilder().append(obj1,obj2).isEquals());obj1=null;assertTrue(new EqualsBuilder().append(obj1,obj2).isEquals());}
@Test public void testFloatArray(){float[]obj1=new float[2];obj1[0]=5;obj1[1]=6;float[]obj2=new float[2];obj2[0]=5;obj2[1]=6;assertTrue(new EqualsBuilder().append(obj1,obj1).isEquals());assertTrue(new EqualsBuilder().append(obj1,obj2).isEquals());obj1[1]=7;assertTrue(!new EqualsBuilder().append(obj1,obj2).isEquals());obj2=null;assertTrue(!new EqualsBuilder().append(obj1,obj2).isEquals());obj1=null;assertTrue(new EqualsBuilder().append(obj1,obj2).isEquals());}
@Test public void testBooleanArray(){boolean[]obj1=new boolean[2];obj1[0]=true;obj1[1]=false;boolean[]obj2=new boolean[2];obj2[0]=true;obj2[1]=false;assertTrue(new EqualsBuilder().append(obj1,obj1).isEquals());assertTrue(new EqualsBuilder().append(obj1,obj2).isEquals());obj1[1]=true;assertTrue(!new EqualsBuilder().append(obj1,obj2).isEquals());obj2=null;assertTrue(!new EqualsBuilder().append(obj1,obj2).isEquals());obj1=null;assertTrue(new EqualsBuilder().append(obj1,obj2).isEquals());}
@Test public void testMultiLongArray(){long[][]array1=new long[2][2];long[][]array2=new long[2][2];for (int i=0;i < array1.length;++i){for (int j=0;j < array1[0].length;j++){array1[i][j]=(i + 1)* (j + 1);array2[i][j]=(i + 1)* (j + 1);}}assertTrue(new EqualsBuilder().append(array1,array1).isEquals());assertTrue(new EqualsBuilder().append(array1,array2).isEquals());array1[1][1]=0;assertTrue(!new EqualsBuilder().append(array1,array2).isEquals());}
@Test public void testMultiIntArray(){int[][]array1=new int[2][2];int[][]array2=new int[2][2];for (int i=0;i < array1.length;++i){for (int j=0;j < array1[0].length;j++){array1[i][j]=(i + 1)* (j + 1);array2[i][j]=(i + 1)* (j + 1);}}assertTrue(new EqualsBuilder().append(array1,array1).isEquals());assertTrue(new EqualsBuilder().append(array1,array2).isEquals());array1[1][1]=0;assertTrue(!new EqualsBuilder().append(array1,array2).isEquals());}
@Test public void testMultiShortArray(){short[][]array1=new short[2][2];short[][]array2=new short[2][2];for (short i=0;i < array1.length;++i){for (short j=0;j < array1[0].length;j++){array1[i][j]=i;array2[i][j]=i;}}assertTrue(new EqualsBuilder().append(array1,array1).isEquals());assertTrue(new EqualsBuilder().append(array1,array2).isEquals());array1[1][1]=0;assertTrue(!new EqualsBuilder().append(array1,array2).isEquals());}
@Test public void testMultiCharArray(){char[][]array1=new char[2][2];char[][]array2=new char[2][2];for (char i=0;i < array1.length;++i){for (char j=0;j < array1[0].length;j++){array1[i][j]=i;array2[i][j]=i;}}assertTrue(new EqualsBuilder().append(array1,array1).isEquals());assertTrue(new EqualsBuilder().append(array1,array2).isEquals());array1[1][1]=0;assertTrue(!new EqualsBuilder().append(array1,array2).isEquals());}
@Test public void testMultiByteArray(){byte[][]array1=new byte[2][2];byte[][]array2=new byte[2][2];for (byte i=0;i < array1.length;++i){for (byte j=0;j < array1[0].length;j++){array1[i][j]=i;array2[i][j]=i;}}assertTrue(new EqualsBuilder().append(array1,array1).isEquals());assertTrue(new EqualsBuilder().append(array1,array2).isEquals());array1[1][1]=0;assertTrue(!new EqualsBuilder().append(array1,array2).isEquals());}
@Test public void testMultiFloatArray(){float[][]array1=new float[2][2];float[][]array2=new float[2][2];for (int i=0;i < array1.length;++i){for (int j=0;j < array1[0].length;j++){array1[i][j]=(i + 1)* (j + 1);array2[i][j]=(i + 1)* (j + 1);}}assertTrue(new EqualsBuilder().append(array1,array1).isEquals());assertTrue(new EqualsBuilder().append(array1,array2).isEquals());array1[1][1]=0;assertTrue(!new EqualsBuilder().append(array1,array2).isEquals());}
@Test public void testMultiDoubleArray(){double[][]array1=new double[2][2];double[][]array2=new double[2][2];for (int i=0;i < array1.length;++i){for (int j=0;j < array1[0].length;j++){array1[i][j]=(i + 1)* (j + 1);array2[i][j]=(i + 1)* (j + 1);}}assertTrue(new EqualsBuilder().append(array1,array1).isEquals());assertTrue(new EqualsBuilder().append(array1,array2).isEquals());array1[1][1]=0;assertTrue(!new EqualsBuilder().append(array1,array2).isEquals());}
@Test public void testMultiBooleanArray(){boolean[][]array1=new boolean[2][2];boolean[][]array2=new boolean[2][2];for (int i=0;i < array1.length;++i){for (int j=0;j < array1[0].length;j++){array1[i][j]=(i == 1)|| (j == 1);array2[i][j]=(i == 1)|| (j == 1);}}assertTrue(new EqualsBuilder().append(array1,array1).isEquals());assertTrue(new EqualsBuilder().append(array1,array2).isEquals());array1[1][1]=false;assertTrue(!new EqualsBuilder().append(array1,array2).isEquals());boolean[]array3=new boolean[]{true,true};assertFalse(new EqualsBuilder().append(array1,array3).isEquals());assertFalse(new EqualsBuilder().append(array3,array1).isEquals());assertFalse(new EqualsBuilder().append(array2,array3).isEquals());assertFalse(new EqualsBuilder().append(array3,array2).isEquals());}
@Test public void testRaggedArray(){long[][]array1=new long[2][];long[][]array2=new long[2][];for (int i=0;i < array1.length;++i){array1[i]=new long[2];array2[i]=new long[2];for (int j=0;j < array1[i].length;++j){array1[i][j]=(i + 1)* (j + 1);array2[i][j]=(i + 1)* (j + 1);}}assertTrue(new EqualsBuilder().append(array1,array1).isEquals());assertTrue(new EqualsBuilder().append(array1,array2).isEquals());array1[1][1]=0;assertTrue(!new EqualsBuilder().append(array1,array2).isEquals());}
@Test public void testMixedArray(){Object[]array1=new Object[2];Object[]array2=new Object[2];for (int i=0;i < array1.length;++i){array1[i]=new long[2];array2[i]=new long[2];for (int j=0;j < 2;++j){((long[])array1[i])[j]=(i + 1)* (j + 1);((long[])array2[i])[j]=(i + 1)* (j + 1);}}assertTrue(new EqualsBuilder().append(array1,array1).isEquals());assertTrue(new EqualsBuilder().append(array1,array2).isEquals());((long[])array1[1])[1]=0;assertTrue(!new EqualsBuilder().append(array1,array2).isEquals());}
@Test public void testObjectArrayHiddenByObject(){TestObject[]array1=new TestObject[2];array1[0]=new TestObject(4);array1[1]=new TestObject(5);TestObject[]array2=new TestObject[2];array2[0]=new TestObject(4);array2[1]=new TestObject(5);Object obj1=array1;Object obj2=array2;assertTrue(new EqualsBuilder().append(obj1,obj1).isEquals());assertTrue(new EqualsBuilder().append(obj1,array1).isEquals());assertTrue(new EqualsBuilder().append(obj1,obj2).isEquals());assertTrue(new EqualsBuilder().append(obj1,array2).isEquals());array1[1].setA(6);assertTrue(!new EqualsBuilder().append(obj1,obj2).isEquals());}
@Test public void testLongArrayHiddenByObject(){long[]array1=new long[2];array1[0]=5L;array1[1]=6L;long[]array2=new long[2];array2[0]=5L;array2[1]=6L;Object obj1=array1;Object obj2=array2;assertTrue(new EqualsBuilder().append(obj1,obj1).isEquals());assertTrue(new EqualsBuilder().append(obj1,array1).isEquals());assertTrue(new EqualsBuilder().append(obj1,obj2).isEquals());assertTrue(new EqualsBuilder().append(obj1,array2).isEquals());array1[1]=7;assertTrue(!new EqualsBuilder().append(obj1,obj2).isEquals());}
@Test public void testIntArrayHiddenByObject(){int[]array1=new int[2];array1[0]=5;array1[1]=6;int[]array2=new int[2];array2[0]=5;array2[1]=6;Object obj1=array1;Object obj2=array2;assertTrue(new EqualsBuilder().append(obj1,obj1).isEquals());assertTrue(new EqualsBuilder().append(obj1,array1).isEquals());assertTrue(new EqualsBuilder().append(obj1,obj2).isEquals());assertTrue(new EqualsBuilder().append(obj1,array2).isEquals());array1[1]=7;assertTrue(!new EqualsBuilder().append(obj1,obj2).isEquals());}
@Test public void testShortArrayHiddenByObject(){short[]array1=new short[2];array1[0]=5;array1[1]=6;short[]array2=new short[2];array2[0]=5;array2[1]=6;Object obj1=array1;Object obj2=array2;assertTrue(new EqualsBuilder().append(obj1,obj1).isEquals());assertTrue(new EqualsBuilder().append(obj1,array1).isEquals());assertTrue(new EqualsBuilder().append(obj1,obj2).isEquals());assertTrue(new EqualsBuilder().append(obj1,array2).isEquals());array1[1]=7;assertTrue(!new EqualsBuilder().append(obj1,obj2).isEquals());}
@Test public void testCharArrayHiddenByObject(){char[]array1=new char[2];array1[0]=5;array1[1]=6;char[]array2=new char[2];array2[0]=5;array2[1]=6;Object obj1=array1;Object obj2=array2;assertTrue(new EqualsBuilder().append(obj1,obj1).isEquals());assertTrue(new EqualsBuilder().append(obj1,array1).isEquals());assertTrue(new EqualsBuilder().append(obj1,obj2).isEquals());assertTrue(new EqualsBuilder().append(obj1,array2).isEquals());array1[1]=7;assertTrue(!new EqualsBuilder().append(obj1,obj2).isEquals());}
@Test public void testByteArrayHiddenByObject(){byte[]array1=new byte[2];array1[0]=5;array1[1]=6;byte[]array2=new byte[2];array2[0]=5;array2[1]=6;Object obj1=array1;Object obj2=array2;assertTrue(new EqualsBuilder().append(obj1,obj1).isEquals());assertTrue(new EqualsBuilder().append(obj1,array1).isEquals());assertTrue(new EqualsBuilder().append(obj1,obj2).isEquals());assertTrue(new EqualsBuilder().append(obj1,array2).isEquals());array1[1]=7;assertTrue(!new EqualsBuilder().append(obj1,obj2).isEquals());}
@Test public void testDoubleArrayHiddenByObject(){double[]array1=new double[2];array1[0]=5;array1[1]=6;double[]array2=new double[2];array2[0]=5;array2[1]=6;Object obj1=array1;Object obj2=array2;assertTrue(new EqualsBuilder().append(obj1,obj1).isEquals());assertTrue(new EqualsBuilder().append(obj1,array1).isEquals());assertTrue(new EqualsBuilder().append(obj1,obj2).isEquals());assertTrue(new EqualsBuilder().append(obj1,array2).isEquals());array1[1]=7;assertTrue(!new EqualsBuilder().append(obj1,obj2).isEquals());}
@Test public void testFloatArrayHiddenByObject(){float[]array1=new float[2];array1[0]=5;array1[1]=6;float[]array2=new float[2];array2[0]=5;array2[1]=6;Object obj1=array1;Object obj2=array2;assertTrue(new EqualsBuilder().append(obj1,obj1).isEquals());assertTrue(new EqualsBuilder().append(obj1,array1).isEquals());assertTrue(new EqualsBuilder().append(obj1,obj2).isEquals());assertTrue(new EqualsBuilder().append(obj1,array2).isEquals());array1[1]=7;assertTrue(!new EqualsBuilder().append(obj1,obj2).isEquals());}
@Test public void testBooleanArrayHiddenByObject(){boolean[]array1=new boolean[2];array1[0]=true;array1[1]=false;boolean[]array2=new boolean[2];array2[0]=true;array2[1]=false;Object obj1=array1;Object obj2=array2;assertTrue(new EqualsBuilder().append(obj1,obj1).isEquals());assertTrue(new EqualsBuilder().append(obj1,array1).isEquals());assertTrue(new EqualsBuilder().append(obj1,obj2).isEquals());assertTrue(new EqualsBuilder().append(obj1,array2).isEquals());array1[1]=true;assertTrue(!new EqualsBuilder().append(obj1,obj2).isEquals());}
/** * Tests two instances of classes that can be equal and that are not "related". The two classes are not subclasses of each other and do not share a parent aside from Object. See http://issues.apache.org/bugzilla/show_bug.cgi?id=33069*/@Test public void testUnrelatedClasses(){Object[]x=new Object[]{new TestACanEqualB(1)};Object[]y=new Object[]{new TestBCanEqualA(1)};assertTrue(Arrays.equals(x,x));assertTrue(Arrays.equals(y,y));assertTrue(Arrays.equals(x,y));assertTrue(Arrays.equals(y,x));assertTrue(x[0].equals(x[0]));assertTrue(y[0].equals(y[0]));assertTrue(x[0].equals(y[0]));assertTrue(y[0].equals(x[0]));assertTrue(new EqualsBuilder().append(x,x).isEquals());assertTrue(new EqualsBuilder().append(y,y).isEquals());assertTrue(new EqualsBuilder().append(x,y).isEquals());assertTrue(new EqualsBuilder().append(y,x).isEquals());}
/** * Test from http://issues.apache.org/bugzilla/show_bug.cgi?id=33067*/@Test public void testNpeForNullElement(){Object[]x1=new Object[]{new Integer(1),null,new Integer(3)};Object[]x2=new Object[]{new Integer(1),new Integer(2),new Integer(3)};new EqualsBuilder().append(x1,x2);}
@Test public void testReflectionEqualsExcludeFields()throws Exception {TestObjectWithMultipleFields x1=new TestObjectWithMultipleFields(1,2,3);TestObjectWithMultipleFields x2=new TestObjectWithMultipleFields(1,3,4);assertTrue(!EqualsBuilder.reflectionEquals(x1,x2));assertTrue(!EqualsBuilder.reflectionEquals(x1,x2,(String[])null));assertTrue(!EqualsBuilder.reflectionEquals(x1,x2,new String[]{}));assertTrue(!EqualsBuilder.reflectionEquals(x1,x2,new String[]{"xxx"}));assertTrue(!EqualsBuilder.reflectionEquals(x1,x2,new String[]{"two"}));assertTrue(!EqualsBuilder.reflectionEquals(x1,x2,new String[]{"three"}));assertTrue(EqualsBuilder.reflectionEquals(x1,x2,new String[]{"two","three"}));assertTrue(EqualsBuilder.reflectionEquals(x1,x2,new String[]{"one","two","three"}));assertTrue(EqualsBuilder.reflectionEquals(x1,x2,new String[]{"one","two","three","xxx"}));}
@Test public void should_do_the_trick_of_instantiating()throws Exception {given(resolver.resolveTypeInstances(Matchers.<Class<?>[]>anyVararg())).willReturn(new Object[]{observer});boolean result=underTest.process(field("whatever"),this,newSetOf(observer));assertTrue(result);assertNotNull(whatever);}
@Test public void myTest()throws Exception {SocketFactory sf=mock(SocketFactory.class,RETURNS_DEEP_STUBS);when(sf.createSocket(anyString(),eq(80))).thenReturn(null);sf.createSocket("what",80);}
@Test public void simpleCase()throws Exception {OutputStream out=new ByteArrayOutputStream();Socket socket=mock(Socket.class);when(socket.getOutputStream()).thenReturn(out);assertSame(out,socket.getOutputStream());}
/** * Test that deep stubbing works for one intermediate level*/@Test public void oneLevelDeep()throws Exception {OutputStream out=new ByteArrayOutputStream();SocketFactory socketFactory=mock(SocketFactory.class,RETURNS_DEEP_STUBS);when(socketFactory.createSocket().getOutputStream()).thenReturn(out);assertSame(out,socketFactory.createSocket().getOutputStream());}
/** * Test that stubbing of two mocks stubs don't interfere*/@Test public void interactions()throws Exception {OutputStream out1=new ByteArrayOutputStream();OutputStream out2=new ByteArrayOutputStream();SocketFactory sf1=mock(SocketFactory.class,RETURNS_DEEP_STUBS);when(sf1.createSocket().getOutputStream()).thenReturn(out1);SocketFactory sf2=mock(SocketFactory.class,RETURNS_DEEP_STUBS);when(sf2.createSocket().getOutputStream()).thenReturn(out2);assertSame(out1,sf1.createSocket().getOutputStream());assertSame(out2,sf2.createSocket().getOutputStream());}
/** * Test that stubbing of methods of different arguments don't interfere*/@Test public void withArguments()throws Exception {OutputStream out1=new ByteArrayOutputStream();OutputStream out2=new ByteArrayOutputStream();OutputStream out3=new ByteArrayOutputStream();SocketFactory sf=mock(SocketFactory.class,RETURNS_DEEP_STUBS);when(sf.createSocket().getOutputStream()).thenReturn(out1);when(sf.createSocket("google.com",80).getOutputStream()).thenReturn(out2);when(sf.createSocket("stackoverflow.com",80).getOutputStream()).thenReturn(out3);assertSame(out1,sf.createSocket().getOutputStream());assertSame(out2,sf.createSocket("google.com",80).getOutputStream());assertSame(out3,sf.createSocket("stackoverflow.com",80).getOutputStream());}
/** * Test that deep stubbing work with argument patterns*/@Test public void withAnyPatternArguments()throws Exception {OutputStream out=new ByteArrayOutputStream();SocketFactory sf=mock(SocketFactory.class,RETURNS_DEEP_STUBS);when(sf.createSocket(anyString(),anyInt()).getOutputStream()).thenReturn(out);assertSame(out,sf.createSocket("google.com",80).getOutputStream());assertSame(out,sf.createSocket("stackoverflow.com",8080).getOutputStream());}
/** * Test that deep stubbing work with argument patterns*/@Test public void withComplexPatternArguments()throws Exception {OutputStream out1=new ByteArrayOutputStream();OutputStream out2=new ByteArrayOutputStream();SocketFactory sf=mock(SocketFactory.class,RETURNS_DEEP_STUBS);when(sf.createSocket(anyString(),eq(80)).getOutputStream()).thenReturn(out1);when(sf.createSocket(anyString(),eq(8080)).getOutputStream()).thenReturn(out2);assertSame(out2,sf.createSocket("stackoverflow.com",8080).getOutputStream());assertSame(out1,sf.createSocket("google.com",80).getOutputStream());assertSame(out2,sf.createSocket("google.com",8080).getOutputStream());assertSame(out1,sf.createSocket("stackoverflow.com",80).getOutputStream());}
/** * Test that deep stubbing work with primitive expected values*/@Test public void withSimplePrimitive()throws Exception {int a=32;SocketFactory sf=mock(SocketFactory.class,RETURNS_DEEP_STUBS);when(sf.createSocket().getPort()).thenReturn(a);assertEquals(a,sf.createSocket().getPort());}
/** * Test that deep stubbing work with primitive expected values with pattern method arguments*/@Test public void withPatternPrimitive()throws Exception {int a=12,b=23,c=34;SocketFactory sf=mock(SocketFactory.class,RETURNS_DEEP_STUBS);when(sf.createSocket(eq("stackoverflow.com"),eq(80)).getPort()).thenReturn(a);when(sf.createSocket(eq("google.com"),anyInt()).getPort()).thenReturn(b);when(sf.createSocket(eq("stackoverflow.com"),eq(8080)).getPort()).thenReturn(c);assertEquals(b,sf.createSocket("google.com",80).getPort());assertEquals(c,sf.createSocket("stackoverflow.com",8080).getPort());assertEquals(a,sf.createSocket("stackoverflow.com",80).getPort());}
@Test public void shouldStubbingBasicallyWorkFine()throws Exception {given(person.getAddress().getStreet().getName()).willReturn("Norymberska");String street=person.getAddress().getStreet().getName();assertEquals("Norymberska",street);}
@Test public void shouldVerificationBasicallyWorkFine()throws Exception {person.getAddress().getStreet().getName();verify(person.getAddress().getStreet()).getName();}
@Test public void shouldFailGracefullyWhenClassIsFinal()throws Exception {FinalClass value=new FinalClass();given(person.getFinalClass()).willReturn(value);assertEquals(value,person.getFinalClass());}
@SuppressWarnings("deprecation")@Test public void shouldAllowAssertionsOnCapturedArgument(){emailer.email(12);ArgumentCaptor<Person> argument=new ArgumentCaptor<Person>();verify(emailService).sendEmailTo(argument.capture());assertEquals(12,argument.getValue().getAge());}
@Test public void shouldAllowAssertionsOnAllCapturedArguments(){emailer.email(11,12);ArgumentCaptor<Person> argument=ArgumentCaptor.forClass(Person.class);verify(emailService,atLeastOnce()).sendEmailTo(argument.capture());List<Person> allValues=argument.getAllValues();assertEquals(11,allValues.get(0).getAge());assertEquals(12,allValues.get(1).getAge());}
@Test public void shouldAllowAssertionsOnLastArgument(){emailer.email(11,12,13);ArgumentCaptor<Person> argument=ArgumentCaptor.forClass(Person.class);verify(emailService,atLeastOnce()).sendEmailTo(argument.capture());assertEquals(13,argument.getValue().getAge());}
@Test public void shouldPrintCaptorMatcher(){ArgumentCaptor<Person> person=ArgumentCaptor.forClass(Person.class);try {verify(emailService).sendEmailTo(person.capture());fail();}catch(WantedButNotInvoked e){assertContains("<Capturing argument>",e.getMessage());}}
@Test public void shouldAllowAssertionsOnCapturedNull(){emailService.sendEmailTo(null);ArgumentCaptor<Person> argument=ArgumentCaptor.forClass(Person.class);verify(emailService).sendEmailTo(argument.capture());assertEquals(null,argument.getValue());}
@Test public void shouldAllowCapturingForStubbing(){ArgumentCaptor<Person> argument=ArgumentCaptor.forClass(Person.class);when(emailService.sendEmailTo(argument.capture())).thenReturn(false);emailService.sendEmailTo(new Person(10));assertEquals(10,argument.getValue().getAge());}
@Test public void shouldCaptureWhenStubbingOnlyWhenEntireInvocationMatches(){ArgumentCaptor<String> argument=ArgumentCaptor.forClass(String.class);when(mock.simpleMethod(argument.capture(),eq(2))).thenReturn("blah");mock.simpleMethod("foo",200);mock.simpleMethod("bar",2);Assertions.assertThat(argument.getAllValues()).containsOnly("bar");}
@Test public void shouldSaySomethingSmartWhenMisused(){ArgumentCaptor<Person> argument=ArgumentCaptor.forClass(Person.class);try {argument.getValue();fail();}catch(MockitoException e){}}
@Test public void shouldCaptureWhenFullArgListMatches()throws Exception {mock.simpleMethod("foo",1);mock.simpleMethod("bar",2);ArgumentCaptor<String> captor=ArgumentCaptor.forClass(String.class);verify(mock).simpleMethod(captor.capture(),eq(1));assertEquals(1,captor.getAllValues().size());assertEquals("foo",captor.getValue());}
@Test public void shouldCaptureIntByCreatingCaptorWithPrimitiveWrapper(){IMethods mock=mock(IMethods.class);ArgumentCaptor<Integer> argument=ArgumentCaptor.forClass(Integer.class);mock.intArgumentMethod(10);verify(mock).intArgumentMethod(argument.capture());assertEquals(10,(int)argument.getValue());}
@Test public void shouldCaptureIntByCreatingCaptorWithPrimitive()throws Exception {IMethods mock=mock(IMethods.class);ArgumentCaptor<Integer> argument=ArgumentCaptor.forClass(int.class);mock.intArgumentMethod(10);verify(mock).intArgumentMethod(argument.capture());assertEquals(10,(int)argument.getValue());}
@Test public void shouldSetMockitoNamingPolicy()throws Exception {MockitoMethodProxy methodProxy=new MethodProxyBuilder().build();new CGLIBHacker().setMockitoNamingPolicy(methodProxy);Object realMethodProxy=Whitebox.invokeMethod(methodProxy,"getMethodProxy",new Object[0]);Object createInfo=Whitebox.getInternalState(realMethodProxy,"createInfo");NamingPolicy namingPolicy=(NamingPolicy)Whitebox.getInternalState(createInfo,"namingPolicy");assertEquals(MockitoNamingPolicy.INSTANCE,namingPolicy);}
@Test public void shouldSetMockitoNamingPolicyEvenIfMethodProxyIsProxied()throws Exception {MockitoMethodProxy proxiedMethodProxy=spy(new MethodProxyBuilder().build());new CGLIBHacker().setMockitoNamingPolicy(proxiedMethodProxy);Object realMethodProxy=Whitebox.invokeMethod(proxiedMethodProxy,"getMethodProxy",new Object[0]);Object createInfo=Whitebox.getInternalState(realMethodProxy,"createInfo");NamingPolicy namingPolicy=(NamingPolicy)Whitebox.getInternalState(createInfo,"namingPolicy");assertEquals(MockitoNamingPolicy.INSTANCE,namingPolicy);}
@Test public void shouldRemoveStubbableFromProgressAfterStubbing(){List mock=Mockito.mock(List.class);Mockito.when(mock.add("test")).thenReturn(true);assertNull(new ThreadSafeMockingProgress().pullOngoingStubbing());}
@Test(expected=NotAMockException.class)public void shouldValidateMockWhenVerifying(){Mockito.verify("notMock");}
@Test(expected=NotAMockException.class)public void shouldValidateMockWhenVerifyingWithExpectedNumberOfInvocations(){Mockito.verify("notMock",times(19));}
@Test(expected=NotAMockException.class)public void shouldValidateMockWhenVerifyingNoMoreInteractions(){Mockito.verifyNoMoreInteractions("notMock");}
@Test(expected=NotAMockException.class)public void shouldValidateMockWhenVerifyingZeroInteractions(){Mockito.verifyZeroInteractions("notMock");}
@SuppressWarnings("deprecation")@Test(expected=NotAMockException.class)public void shouldValidateMockWhenStubbingVoid(){Mockito.stubVoid("notMock");}
@Test(expected=NotAMockException.class)public void shouldValidateMockWhenCreatingInOrderObject(){Mockito.inOrder("notMock");}
@Test public void shouldStartingMockSettingsContainDefaultBehavior(){MockSettingsImpl settings=(MockSettingsImpl)Mockito.withSettings();assertEquals(Mockito.RETURNS_DEFAULTS,settings.getDefaultAnswer());}
@Test public void shouldReturnAllKindsOfPrimitives()throws Exception {assertEquals((byte)0,mock.byteReturningMethod());assertEquals((short)0,mock.shortReturningMethod());assertEquals(0,mock.intReturningMethod());assertEquals(0L,mock.longReturningMethod());assertEquals(0.0F,mock.floatReturningMethod(),0.0F);assertEquals(0.0D,mock.doubleReturningMethod(),0.0D);assertEquals((char)0,mock.charReturningMethod());assertEquals(false,mock.booleanReturningMethod());assertEquals(null,mock.objectReturningMethod());}
@Test public void shouldReturnTheSameValuesForWrapperClasses()throws Exception {assertEquals(new Byte((byte)0),mock.byteObjectReturningMethod());assertEquals(new Short((short)0),mock.shortObjectReturningMethod());assertEquals(new Integer(0),mock.integerReturningMethod());assertEquals(new Long(0L),mock.longObjectReturningMethod());assertEquals(new Float(0.0F),mock.floatObjectReturningMethod(),0.0F);assertEquals(new Double(0.0D),mock.doubleObjectReturningMethod(),0.0D);assertEquals(new Character((char)0),mock.charObjectReturningMethod());assertEquals(new Boolean(false),mock.booleanObjectReturningMethod());}
@Test public void shouldReturnEmptyCollections(){CollectionsServer mock=Mockito.mock(CollectionsServer.class);assertTrue(mock.list().isEmpty());assertTrue(mock.linkedList().isEmpty());assertTrue(mock.map().isEmpty());assertTrue(mock.hashSet().isEmpty());}
@Test public void shouldReturnMutableEmptyCollection(){CollectionsServer mock=Mockito.mock(CollectionsServer.class);List list=mock.list();list.add("test");assertTrue(mock.list().isEmpty());}
@Test public void shouldShallowCopyBasicFinalField()throws Exception {assertEquals(100,from.finalField);assertNotEquals(100,to.finalField);tool.copyToMock(from,to);assertEquals(100,to.finalField);}
@Test public void shouldShallowCopyTransientPrivateFields()throws Exception {from.privateTransientField=1000;assertNotEquals(1000,to.privateTransientField);tool.copyToMock(from,to);assertEquals(1000,to.privateTransientField);}
@Test public void shouldShallowCopyLinkedListIntoMock()throws Exception {LinkedList fromList=new LinkedList();LinkedList toList=mock(LinkedList.class);tool.copyToMock(fromList,toList);}
@Test public void shouldShallowCopyFieldValuesIntoMock()throws Exception {from.defaultField="foo";from.instancePublicField=new SomeOtherObject();from.privateField=1;from.privateTransientField=2;from.protectedField=3;assertNotEquals(from.defaultField,to.defaultField);assertNotEquals(from.instancePublicField,to.instancePublicField);assertNotEquals(from.privateField,to.privateField);assertNotEquals(from.privateTransientField,to.privateTransientField);assertNotEquals(from.protectedField,to.protectedField);tool.copyToMock(from,to);assertEquals(from.defaultField,to.defaultField);assertEquals(from.instancePublicField,to.instancePublicField);assertEquals(from.privateField,to.privateField);assertEquals(from.privateTransientField,to.privateTransientField);assertEquals(from.protectedField,to.protectedField);}
@Test public void shouldCopyValuesOfInheritedFields()throws Exception {((InheritMe)from).privateInherited="foo";((InheritMe)from).protectedInherited="bar";assertNotEquals(((InheritMe)from).privateInherited,((InheritMe)to).privateInherited);assertNotEquals(((InheritMe)from).privateInherited,((InheritMe)to).privateInherited);tool.copyToMock(from,to);assertEquals(((InheritMe)from).privateInherited,((InheritMe)to).privateInherited);assertEquals(((InheritMe)from).privateInherited,((InheritMe)to).privateInherited);}
@Test public void shouldEnableAndThenDisableAccessibility()throws Exception {Field privateField=SomeObject.class.getDeclaredField("privateField");assertFalse(privateField.isAccessible());tool.copyToMock(from,to);privateField=SomeObject.class.getDeclaredField("privateField");assertFalse(privateField.isAccessible());}
@Test public void shouldContinueEvenIfThereAreProblemsCopyingSingleFieldValue()throws Exception {tool.fieldCopier=mock(FieldCopier.class);doNothing().doThrow(new IllegalAccessException()).doNothing().when(tool.fieldCopier).copyValue(anyObject(),anyObject(),any(Field.class));tool.copyToMock(from,to);verify(tool.fieldCopier,atLeast(3)).copyValue(any(),any(),any(Field.class));}
@Test public void shouldBeAbleToCopyFromRealObjectToRealObject()throws Exception {from.defaultField="defaultField";from.instancePublicField=new SomeOtherObject();from.privateField=1;from.privateTransientField=2;from.protectedField="protectedField";from.protectedInherited="protectedInherited";to=new SomeObject(0);tool.copyToRealObject(from,to);assertEquals(from.defaultField,to.defaultField);assertEquals(from.instancePublicField,to.instancePublicField);assertEquals(from.privateField,to.privateField);assertEquals(from.privateTransientField,to.privateTransientField);assertEquals(from.protectedField,to.protectedField);assertEquals(from.protectedInherited,to.protectedInherited);}
@Test public void shouldUseFinderCorrectly(){WarningsPrinterImpl printer=new WarningsPrinterImpl(false,finder);printer.print(logger);ArgumentCaptor<LoggingListener> arg=ArgumentCaptor.forClass(LoggingListener.class);verify(finder).find(arg.capture());assertEquals(logger,arg.getValue().getLogger());assertEquals(false,arg.getValue().isWarnAboutUnstubbed());}
@Test public void shouldPassCorrectWarningFlag(){WarningsPrinterImpl printer=new WarningsPrinterImpl(true,finder);printer.print(logger);ArgumentCaptor<LoggingListener> arg=ArgumentCaptor.forClass(LoggingListener.class);verify(finder).find(arg.capture());assertEquals(true,arg.getValue().isWarnAboutUnstubbed());}
@Test public void shouldPrintToString(){WarningsPrinterImpl printer=spy(new WarningsPrinterImpl(true,finder));String out=printer.print();verify(printer).print((MockitoLogger)notNull());assertNotNull(out);}
@Test public void shouldCreateRunnerForJUnit44(){}
@Test public void shouldCreateRunnerForJUnit45(){}
@Test public void shouldThrowMeaningfulMockitoExceptionIfNoValidJUnitFound()throws Exception {RunnerProvider provider=new RunnerProvider(){public boolean isJUnit45OrHigherAvailable(){return false;}public RunnerImpl newInstance(String runnerClassName,Class<?> constructorParam)throws Exception {throw new InitializationError("Where is JUnit,dude?");}};RunnerFactory factory=new RunnerFactory(provider);try {factory.create(RunnerFactoryTest.class);fail();}catch(MockitoException e){assertContains("upgrade your JUnit version",e.getMessage());}}
@Test public void shouldSaySomethingMeaningfulWhenNoTestMethods()throws Exception {RunnerFactory factory=new RunnerFactory(new RunnerProvider());try {factory.create(NoTestMethods.class);fail();}catch(MockitoException e){assertContains("No tests",e.getMessage());}}
@Test public void shouldForwardInvocationTargetException()throws Exception {RunnerFactory factory=new RunnerFactory(new RunnerProvider(){@Override public RunnerImpl newInstance(String runnerClassName,Class<?> constructorParam)throws Exception {throw new InvocationTargetException(new RuntimeException());}});try {factory.create(this.getClass());fail();}catch(InvocationTargetException e){}}
@Test public void shouldGetPluralizedNumber(){new Pluralizer();assertEquals("0 times",Pluralizer.pluralize(0));assertEquals("1 time",Pluralizer.pluralize(1));assertEquals("2 times",Pluralizer.pluralize(2));assertEquals("20 times",Pluralizer.pluralize(20));}
@Test public void shouldAutoboxSafely(){fun.doFun(1.0);verify(fun).doFun(captor.capture());assertEquals((Double)1.0,captor.getValue());}
@Test public void shouldAutoboxAllPrimitives(){verify(fun,never()).moreFun(intCaptor.capture());}
@Test public void shouldProvideMockyImplementationOfToString(){DummyClass dummyClass=Mockito.mock(DummyClass.class);assertEquals("Mock for DummyClass,hashCode: " + dummyClass.hashCode(),dummyClass.toString());DummyInterface dummyInterface=Mockito.mock(DummyInterface.class);assertEquals("Mock for DummyInterface,hashCode: " + dummyInterface.hashCode(),dummyInterface.toString());}
@Test public void shouldReplaceObjectMethods(){}
@Test public void shouldReplaceObjectMethodsWhenOverridden(){}
@Test public void shouldStartVerificationAndPullVerificationMode()throws Exception {assertNull(mockingProgress.pullVerificationMode());VerificationMode mode=VerificationModeFactory.times(19);mockingProgress.verificationStarted(mode);assertSame(mode,mockingProgress.pullVerificationMode());assertNull(mockingProgress.pullVerificationMode());}
@Test public void shouldCheckIfVerificationWasFinished()throws Exception {mockingProgress.verificationStarted(VerificationModeFactory.atLeastOnce());try {mockingProgress.verificationStarted(VerificationModeFactory.atLeastOnce());fail();}catch(MockitoException e){}}
@Test public void shouldNotifyListenerWhenMockingStarted()throws Exception {MockingStartedListener listener=mock(MockingStartedListener.class);mockingProgress.setListener(listener);mockingProgress.mockingStarted("foo",List.class,new MockSettingsImpl());verify(listener).mockingStarted(eq("foo"),eq(List.class),(MockSettingsImpl)notNull());}
@Test public void shouldNotifyListenerSafely()throws Exception {mockingProgress.setListener(null);mockingProgress.mockingStarted(null,null,null);}
@Test public void makeSureStateIsValidatedInTheVeryFirstTestThanksToTheRunner(){verify(mock);}
@Test public void shouldSayWantedButNotInvoked(){verify(mock).otherMethod();}
@Test public void shouldPointOutInteractionsOnMockWhenOrdinaryVerificationFails(){mock.otherMethod();mock.booleanObjectReturningMethod();verify(mock).simpleMethod();}
@Test public void shouldShowActualAndExpected(){mock.simpleMethod("blah");verify(mock).simpleMethod();}
@Test public void shouldSayTooLittleInvocations(){mock.simpleMethod();verify(mock,times(2)).simpleMethod();}
@Test public void shouldSayTooManyInvocations(){mock.simpleMethod();mock.simpleMethod();verify(mock,times(1)).simpleMethod();}
@Test public void shouldSayWantedButNotInvokedInOrder(){mock.simpleMethod();mock.otherMethod();InOrder inOrder=inOrder(mock);inOrder.verify(mock).otherMethod();inOrder.verify(mock).simpleMethod();}
@Test public void shouldSayTooLittleInvocationsInOrder(){mock.simpleMethod();mock.otherMethod();mock.otherMethod();InOrder inOrder=inOrder(mock);inOrder.verify(mock).simpleMethod();inOrder.verify(mock,times(3)).otherMethod();}
@Test public void shouldSayTooManyInvocationsInOrder(){mock.otherMethod();mock.otherMethod();InOrder inOrder=inOrder(mock);inOrder.verify(mock,times(1)).otherMethod();}
@Test public void shouldSayNeverWantedButInvokedHere(){mock.otherMethod();verify(mock,never()).otherMethod();}
@Test public void shouldSayTooLittleInvocationsInAtLeastModeInOrder(){mock.simpleMethod();InOrder inOrder=inOrder(mock);inOrder.verify(mock,atLeast(2)).simpleMethod();}
@Test public void shouldSayTooLittleInvocationsInAtLeastMode(){mock.simpleMethod();verify(mock,atLeast(2)).simpleMethod();}
@Test public void shouldSayNoMoreInteractions(){mock.simpleMethod();verifyNoMoreInteractions(mock);}
@Test public void shouldSayUnstubbedMethodWasInvokedHere(){mock=mock(IMethods.class,RETURNS_SMART_NULLS);IMethods m=mock.iMethodsReturningMethod();m.simpleMethod();}
@Test public void shouldPointOutUnfinishedStubbing(){when(mock.simpleMethod());verify(mock).simpleMethod();}
@Test public void shouldMentionFinalAndObjectMethodsWhenMissingMockCall(){when("".equals(null)).thenReturn(false);}
@Test public void shouldMentionFinalAndObjectMethodsWhenVerifying(){verify(mock).equals(null);verify(mock).simpleMethod();}
@Test public void shouldMentionFinalAndObjectMethodsWhenMisplacedArgumentMatcher(){when(mock.equals(anyObject())).thenReturn(false);}
@Test public void shouldShowExampleOfCorrectArgumentCapturing(){ArgumentCaptor<String> argument=ArgumentCaptor.forClass(String.class);argument.capture();argument.getValue();}
@Test public void shouldScreamWhenNullPassedInsteadOfAnInterface(){mock(IMethods.class,withSettings().extraInterfaces(List.class,null));}
@Test public void shouldScreamWhenNonInterfacePassed(){mock(IMethods.class,withSettings().extraInterfaces(LinkedList.class));}
@Test public void shouldScreamWhenExtraIsTheSame(){mock(IMethods.class,withSettings().extraInterfaces(IMethods.class));}
@Test public void shouldScreamWhenExtraInterfacesEmpty(){mock(IMethods.class,withSettings().extraInterfaces());}
@Test public void shouldScreamWhenExtraInterfacesIsANullArray(){mock(IMethods.class,withSettings().extraInterfaces((Class[])null));}
@Test public void shouldMentionSpiesWhenVoidMethodIsToldToReturnValue(){List list=mock(List.class);doReturn("foo").when(list).clear();}
@Test public void shouldDetectUnfinishedStubbing(){when(mock.simpleMethod());detectsAndCleansUp(new OnMethodCallOnMock(),UnfinishedStubbingException.class);when(mock.simpleMethod());detectsAndCleansUp(new OnStub(),UnfinishedStubbingException.class);when(mock.simpleMethod());detectsAndCleansUp(new OnStubVoid(),UnfinishedStubbingException.class);when(mock.simpleMethod());detectsAndCleansUp(new OnVerify(),UnfinishedStubbingException.class);when(mock.simpleMethod());detectsAndCleansUp(new OnVerifyInOrder(),UnfinishedStubbingException.class);when(mock.simpleMethod());detectsAndCleansUp(new OnVerifyZeroInteractions(),UnfinishedStubbingException.class);when(mock.simpleMethod());detectsAndCleansUp(new OnVerifyNoMoreInteractions(),UnfinishedStubbingException.class);when(mock.simpleMethod());detectsAndCleansUp(new OnDoAnswer(),UnfinishedStubbingException.class);}
@Test public void shouldDetectUnfinishedStubbingVoid(){stubVoid(mock);detectsAndCleansUp(new OnMethodCallOnMock(),UnfinishedStubbingException.class);stubVoid(mock);detectsAndCleansUp(new OnStub(),UnfinishedStubbingException.class);stubVoid(mock);detectsAndCleansUp(new OnStubVoid(),UnfinishedStubbingException.class);stubVoid(mock);detectsAndCleansUp(new OnVerify(),UnfinishedStubbingException.class);stubVoid(mock);detectsAndCleansUp(new OnVerifyInOrder(),UnfinishedStubbingException.class);stubVoid(mock);detectsAndCleansUp(new OnVerifyZeroInteractions(),UnfinishedStubbingException.class);stubVoid(mock);detectsAndCleansUp(new OnVerifyNoMoreInteractions(),UnfinishedStubbingException.class);stubVoid(mock);detectsAndCleansUp(new OnDoAnswer(),UnfinishedStubbingException.class);}
@Test public void shouldDetectUnfinishedDoAnswerStubbing(){doAnswer(null);detectsAndCleansUp(new OnMethodCallOnMock(),UnfinishedStubbingException.class);doAnswer(null);detectsAndCleansUp(new OnStub(),UnfinishedStubbingException.class);doAnswer(null);detectsAndCleansUp(new OnStubVoid(),UnfinishedStubbingException.class);doAnswer(null);detectsAndCleansUp(new OnVerify(),UnfinishedStubbingException.class);doAnswer(null);detectsAndCleansUp(new OnVerifyInOrder(),UnfinishedStubbingException.class);doAnswer(null);detectsAndCleansUp(new OnVerifyZeroInteractions(),UnfinishedStubbingException.class);doAnswer(null);detectsAndCleansUp(new OnVerifyNoMoreInteractions(),UnfinishedStubbingException.class);doAnswer(null);detectsAndCleansUp(new OnDoAnswer(),UnfinishedStubbingException.class);}
@Test public void shouldDetectUnfinishedVerification(){verify(mock);detectsAndCleansUp(new OnStub(),UnfinishedVerificationException.class);verify(mock);detectsAndCleansUp(new OnStubVoid(),UnfinishedVerificationException.class);verify(mock);detectsAndCleansUp(new OnVerify(),UnfinishedVerificationException.class);verify(mock);detectsAndCleansUp(new OnVerifyInOrder(),UnfinishedVerificationException.class);verify(mock);detectsAndCleansUp(new OnVerifyZeroInteractions(),UnfinishedVerificationException.class);verify(mock);detectsAndCleansUp(new OnVerifyNoMoreInteractions(),UnfinishedVerificationException.class);verify(mock);detectsAndCleansUp(new OnDoAnswer(),UnfinishedVerificationException.class);}
@Test public void shouldDetectMisplacedArgumentMatcher(){anyObject();detectsAndCleansUp(new OnStubVoid(),InvalidUseOfMatchersException.class);anyObject();detectsAndCleansUp(new OnVerify(),InvalidUseOfMatchersException.class);anyObject();detectsAndCleansUp(new OnVerifyInOrder(),InvalidUseOfMatchersException.class);anyObject();detectsAndCleansUp(new OnVerifyZeroInteractions(),InvalidUseOfMatchersException.class);anyObject();detectsAndCleansUp(new OnVerifyNoMoreInteractions(),InvalidUseOfMatchersException.class);anyObject();detectsAndCleansUp(new OnDoAnswer(),InvalidUseOfMatchersException.class);}
@Test public void shouldCorrectStateAfterDetectingUnfinishedStubbing(){stubVoid(mock).toThrow(new RuntimeException());try {stubVoid(mock).toThrow(new RuntimeException()).on().oneArg(true);fail();}catch(UnfinishedStubbingException e){}stubVoid(mock).toThrow(new RuntimeException()).on().oneArg(true);try {mock.oneArg(true);fail();}catch(RuntimeException e){}}
@Test public void shouldCorrectStateAfterDetectingUnfinishedVerification(){mock.simpleMethod();verify(mock);try {verify(mock).simpleMethod();fail();}catch(UnfinishedVerificationException e){}verify(mock).simpleMethod();}
@Test public void should_notify_all_listeners_when_calling_delegate_handler()throws Throwable {given(mockHandler.handle(invocation)).willReturn("returned value");notifier.handle(invocation);verify(listener1).reportInvocation(new NotifiedMethodInvocationReport(invocation,"returned value"));verify(listener2).reportInvocation(new NotifiedMethodInvocationReport(invocation,"returned value"));}
@Test public void should_notify_all_listeners_when_called_delegate_handler_returns_ex()throws Throwable {Exception computedException=new Exception("computed");given(mockHandler.handle(invocation)).willReturn(computedException);notifier.handle(invocation);verify(listener1).reportInvocation(new NotifiedMethodInvocationReport(invocation,(Object)computedException));verify(listener2).reportInvocation(new NotifiedMethodInvocationReport(invocation,(Object)computedException));}
@Test(expected=ParseException.class)public void should_notify_all_listeners_when_called_delegate_handler_throws_exception_and_rethrow_it()throws Throwable {ParseException parseException=new ParseException("",0);given(mockHandler.handle(invocation)).willThrow(parseException);try {notifier.handle(invocation);fail();}finally {verify(listener1).reportInvocation(new NotifiedMethodInvocationReport(invocation,parseException));verify(listener2).reportInvocation(new NotifiedMethodInvocationReport(invocation,parseException));}}
@Test public void should_report_listener_exception()throws Throwable {willThrow(new NullPointerException()).given(customListener).reportInvocation(any(MethodInvocationReport.class));try {notifier.handle(invocation);fail();}catch(MockitoException me){assertThat(me.getMessage()).contains("invocation listener").contains("CustomListener").contains("threw an exception").contains("NullPointerException");}}
@Test public void should_delegate_all_MockHandlerInterface_to_the_parameterized_MockHandler()throws Exception {notifier.getInvocationContainer();notifier.getMockSettings();notifier.voidMethodStubbable(mock(IMethods.class));notifier.setAnswersForStubbing(new ArrayList<Answer>());verify(mockHandler).getInvocationContainer();verify(mockHandler).getMockSettings();verify(mockHandler).voidMethodStubbable(any());verify(mockHandler).setAnswersForStubbing(anyList());}
@Test public void shouldNotFailWhenNotInitialized(){assertNotNull(articleManager);}
@Test(expected=IllegalArgumentException.class)public void innerMockShouldRaiseAnExceptionThatChangesOuterMockBehavior(){when(calculator.countArticles("new")).thenThrow(new IllegalArgumentException());articleManager.updateArticleCounters("new");}
@Test public void mockJustWorks(){articleManager.updateArticleCounters("new");}
@Test public void constructor_is_called_for_each_test()throws Exception {int minimum_number_of_test_before=3;Assertions.assertThat(articleVisitorInstantiationCount).isGreaterThan(minimum_number_of_test_before);Assertions.assertThat(articleVisitorMockInjectedInstances.size()).isGreaterThan(minimum_number_of_test_before);}
@Test public void objects_created_with_constructor_initialization_can_be_spied()throws Exception {assertFalse(mockUtil.isMock(articleManager));assertTrue(mockUtil.isMock(spiedArticleManager));}
@Test public void should_report_failure_only_when_object_initialization_throws_exception()throws Exception {try {MockitoAnnotations.initMocks(new ATest());fail();}catch(MockitoException e){Assertions.assertThat(e.getMessage()).contains("failingConstructor").contains("constructor").contains("threw an exception");Assertions.assertThat(e.getCause()).isInstanceOf(IllegalStateException.class);}}
@Test public void shouldDisableTimeout(){try {verify(mock,timeout(30000).atMost(1)).simpleMethod();fail();}catch(FriendlyReminderException e){}}
@Test public void second_stubbing_throws_IndexOutOfBoundsException()throws Exception {Map<String,String> map=mock(Map.class);OngoingStubbing<String> mapOngoingStubbing=when(map.get(anyString()));mapOngoingStubbing.thenReturn("first stubbing");try {mapOngoingStubbing.thenReturn("second stubbing");fail();}catch(MockitoException e){assertThat(e.getMessage()).contains("Incorrect use of API detected here").contains(this.getClass().getSimpleName());}}
@Test public void shouldDelegateToGetDescription()throws Exception {final Description expectedDescription=Description.createSuiteDescription(this.getClass());runner=new ConsoleSpammingMockitoJUnitRunner(loggerStub,new RunnerImplStub(){public Description getDescription(){return expectedDescription;}});Description description=runner.getDescription();assertEquals(expectedDescription,description);}
@Test public void shouldPrintVerificationInOrderErrorAndShowBothWantedAndPrevious(){inOrder.verify(one).simpleMethod(1);inOrder.verify(two,atLeastOnce()).simpleMethod(2);try {inOrder.verify(one,atLeastOnce()).simpleMethod(11);fail();}catch(VerificationInOrderFailure e){String expected="\n" + "Verification in order failure" + "\n"+ "Wanted but not invoked:"+ "\n"+ "iMethods.simpleMethod(11);"+ "\n"+ "-> at ";assertContains(expected,e.getMessage());String expectedCause="\n" + "Wanted anywhere AFTER following interaction:" + "\n"+ "iMethods.simpleMethod(2);"+ "\n"+ "-> at ";assertContains(expectedCause,e.getMessage());}}
@Test public void shouldPrintVerificationInOrderErrorAndShowWantedOnly(){try {inOrder.verify(one).differentMethod();fail();}catch(WantedButNotInvoked e){String expected="\n" + "Wanted but not invoked:" + "\n"+ "iMethods.differentMethod();"+ "\n"+ "-> at";assertContains(expected,e.getMessage());}}
@Test public void shouldPrintVerificationInOrderErrorAndShowWantedAndActual(){try {inOrder.verify(one).simpleMethod(999);fail();}catch(org.mockito.exceptions.verification.junit.ArgumentsAreDifferent e){assertContains("has different arguments",e.getMessage());}}
@Test public void shouldNotSayArgumentsAreDifferent(){inOrder.verify(three).simpleMethod(3);try {inOrder.verify(one).simpleMethod(999);fail();}catch(VerificationInOrderFailure e){assertContains("Wanted but not invoked",e.getMessage());}}
@Test public void shouldPrintMethodThatWasNotInvoked(){inOrder.verify(one).simpleMethod(1);inOrder.verify(one).simpleMethod(11);inOrder.verify(two,times(2)).simpleMethod(2);inOrder.verify(three).simpleMethod(3);try {inOrder.verify(three).simpleMethod(999);fail();}catch(VerificationInOrderFailure e){String actualMessage=e.getMessage();String expectedMessage="\n" + "Verification in order failure" + "\n"+ "Wanted but not invoked:"+ "\n"+ "iMethods.simpleMethod(999);";assertContains(expectedMessage,actualMessage);}}
@Test public void shouldPrintTooManyInvocations(){inOrder.verify(one).simpleMethod(1);inOrder.verify(one).simpleMethod(11);try {inOrder.verify(two,times(1)).simpleMethod(2);fail();}catch(VerificationInOrderFailure e){String actualMessage=e.getMessage();String expectedMessage="\n" + "Verification in order failure:" + "\n"+ "iMethods.simpleMethod(2);"+ "\n"+ "Wanted 1 time:"+ "\n"+ "-> at";assertContains(expectedMessage,actualMessage);String expectedCause="\n" + "But was 2 times. Undesired invocation:" + "\n"+ "-> at";assertContains(expectedCause,e.getMessage());}}
@Test public void shouldPrintTooLittleInvocations(){two.simpleMethod(2);inOrder.verify(one,atLeastOnce()).simpleMethod(anyInt());inOrder.verify(two,times(2)).simpleMethod(2);inOrder.verify(three,atLeastOnce()).simpleMethod(3);try {inOrder.verify(two,times(2)).simpleMethod(2);fail();}catch(VerificationInOrderFailure e){String actualMessage=e.getMessage();String expectedMessage="\n" + "Verification in order failure:" + "\n"+ "iMethods.simpleMethod(2);"+ "\n"+ "Wanted 2 times:"+ "\n"+ "-> at";assertContains(expectedMessage,actualMessage);String expectedCause="\n" + "But was 1 time:" + "\n"+ "-> at";assertContains(expectedCause,e.getMessage());}}
@Test public void shouldNotThrowNPE(){when(mock.simpleMethod()).thenThrow(mock2);try {mock.simpleMethod();fail();}catch(DummyException e){}}
@Test public void shouldAskFinderForActualInvocations(){finderStub.actualToReturn.add(new InvocationBuilder().toInvocation());checker.check(invocations,wanted);assertSame(invocations,finderStub.invocations);}
@Test public void shouldPassBecauseActualInvocationFound(){finderStub.actualToReturn.add(new InvocationBuilder().toInvocation());checker.check(invocations,wanted);}
@Test public void shouldAskAnalyzerForSimilarInvocation(){checker.check(invocations,wanted);assertSame(invocations,finderStub.invocations);}
@Test public void shouldReportWantedButNotInvoked(){assertTrue(finderStub.actualToReturn.isEmpty());finderStub.similarToReturn=null;checker.check(invocations,wanted);assertEquals(wanted,reporterStub.wanted);assertNull(reporterStub.actualLocation);}
@Test public void shouldReportWantedInvocationDiffersFromActual(){assertTrue(finderStub.actualToReturn.isEmpty());Invocation actualInvocation=new InvocationBuilder().toInvocation();finderStub.similarToReturn=actualInvocation;checker.check(invocations,wanted);assertNotNull(reporterStub.wanted);assertNotNull(reporterStub.actual);assertSame(actualInvocation.getLocation(),reporterStub.actualLocation);}
@Test(expected=MockitoException.class)public void shouldRequireArgumentsWhenVerifyingNoMoreInteractions(){verifyNoMoreInteractions();}
@Test(expected=MockitoException.class)public void shouldRequireArgumentsWhenVerifyingZeroInteractions(){verifyZeroInteractions();}
@Test(expected=MockitoException.class)public void shouldNotCreateInOrderObjectWithoutMocks(){inOrder();}
@Test(expected=MockitoException.class)public void shouldNotAllowVerifyingInOrderUnfamilarMocks(){InOrder inOrder=inOrder(mock);inOrder.verify(mockTwo).simpleMethod();}
@Test(expected=MissingMethodInvocationException.class)public void shouldReportMissingMethodInvocationWhenStubbing(){when(mock.simpleMethod()).thenReturn("this stubbing is required to make sure Stubbable is pulled");when("".toString()).thenReturn("x");}
@Test(expected=MockitoException.class)public void shouldNotAllowSettingInvalidCheckedException()throws Exception {when(mock.simpleMethod()).thenThrow(new Exception());}
@Test(expected=MockitoException.class)public void shouldNotAllowSettingNullThrowable()throws Exception {when(mock.simpleMethod()).thenThrow(new Throwable[]{null});}
@SuppressWarnings("all")@Test(expected=MockitoException.class)public void shouldNotAllowSettingNullThrowableVararg()throws Exception {when(mock.simpleMethod()).thenThrow((Throwable)null);}
@Test(expected=MockitoException.class)public void shouldNotAllowSettingNullConsecutiveThrowable()throws Exception {when(mock.simpleMethod()).thenThrow(new RuntimeException(),null);}
@Test(expected=MockitoException.class)public void shouldNotAllowMockingFinalClasses()throws Exception {mock(FinalClass.class);}
@Test(expected=MockitoException.class)public void shouldNotAllowMockingPrimitves()throws Exception {mock(Integer.TYPE);}
@Test public void shouldNotMockObjectMethodsOnInterface()throws Exception {ObjectLikeInterface inter=mock(ObjectLikeInterface.class);inter.equals(null);inter.toString();inter.hashCode();verifyZeroInteractions(inter);}
@Test public void shouldMatchTypesWhenActualMatcherHasCorrectType()throws Exception {ContainsExtraTypeInformation equals10=new Equals(10);LocalizedMatcher m=new LocalizedMatcher((Matcher)equals10);assertTrue(m.typeMatches(10));assertFalse(m.typeMatches(10L));}
@Test public void shouldNotMatchTypesWhenActualMatcherDoesNotHaveCorrectType()throws Exception {LocalizedMatcher m=new LocalizedMatcher(Any.ANY);assertFalse(m.typeMatches(10));}
@Test public void shouldDescribeWithTypeInfoWhenActualMatcherHasCorrectType()throws Exception {ContainsExtraTypeInformation equals10=new Equals(10);LocalizedMatcher m=new LocalizedMatcher((Matcher)equals10);assertEquals("(Integer)10",describe(m.withExtraTypeInfo()));}
@Test public void shouldNotDescribeWithTypeInfoWhenActualMatcherDoesNotHaveCorrectType()throws Exception {LocalizedMatcher m=new LocalizedMatcher(Any.ANY);assertSame(m,m.withExtraTypeInfo());}
@Test public void shouldDelegateToCapturingMatcher()throws Exception {CapturingMatcher capturingMatcher=new CapturingMatcher();LocalizedMatcher m=new LocalizedMatcher(capturingMatcher);m.captureFrom("boo");assertEquals("boo",capturingMatcher.getLastValue());}
@Test public void shouldVerifySingleMockInOrderAndNotInOrder(){mockOne=mock(IMethods.class);inOrder=inOrder(mockOne);mockOne.simpleMethod(1);mockOne.simpleMethod(2);verify(mockOne).simpleMethod(2);verify(mockOne).simpleMethod(1);inOrder.verify(mockOne).simpleMethod(2);try {inOrder.verify(mockOne).simpleMethod(1);fail();}catch(VerificationInOrderFailure e){}}
@Test public void shouldMessagesPointToProperMethod(){mockTwo.differentMethod();mockOne.simpleMethod();try {inOrder.verify(mockOne,atLeastOnce()).differentMethod();fail();}catch(WantedButNotInvoked e){assertContains("differentMethod()",e.getMessage());}}
@Test public void shouldVerifyInOrderWhenTwoChunksAreEqual(){mockOne.simpleMethod();mockOne.simpleMethod();mockTwo.differentMethod();mockOne.simpleMethod();mockOne.simpleMethod();inOrder.verify(mockOne,times(2)).simpleMethod();inOrder.verify(mockTwo).differentMethod();inOrder.verify(mockOne,times(2)).simpleMethod();try {inOrder.verify(mockOne,atLeastOnce()).simpleMethod();fail();}catch(VerificationInOrderFailure e){}}
@Test public void shouldVerifyInOrderUsingMatcher(){mockOne.simpleMethod(1);mockOne.simpleMethod(2);mockTwo.differentMethod();mockOne.simpleMethod(3);mockOne.simpleMethod(4);verify(mockOne,times(4)).simpleMethod(anyInt());inOrder.verify(mockOne,times(2)).simpleMethod(anyInt());inOrder.verify(mockTwo).differentMethod();inOrder.verify(mockOne,times(2)).simpleMethod(anyInt());try {inOrder.verify(mockOne,times(3)).simpleMethod(anyInt());fail();}catch(VerificationInOrderFailure e){}}
@Test public void shouldVerifyInOrderWhenMultipleThreadsInteractWithMock()throws Exception {final Foo testInf=mock(Foo.class);Thread threadOne=new Thread(new Runnable(){public void run(){testInf.methodOne();}});threadOne.start();threadOne.join();Thread threadTwo=new Thread(new Runnable(){public void run(){testInf.methodTwo();}});threadTwo.start();threadTwo.join();InOrder inOrder=inOrder(testInf);inOrder.verify(testInf).methodOne();inOrder.verify(testInf).methodTwo();}
@Test public void shouldScreamWhenVerifyToString(){try {verify(mock).toString();fail();}catch(MockitoException e){assertContains("cannot verify",e.getMessage());}}
@Test public void shouldBeSilentWhenVerifyHashCode(){verify(mock).hashCode();}
@Test public void shouldBeSilentWhenVerifyEquals(){verify(mock).equals(null);}
@Test public void shouldBeSilentWhenVerifyEqualsInOrder(){InOrder inOrder=inOrder(mock);inOrder.verify(mock).equals(null);}
@Test public void shouldStubbingWork(){Mockito.when(iterable.iterator()).thenReturn(myIterator);Assert.assertNotNull(((Iterable)iterable).iterator());Assert.assertNotNull(iterable.iterator());}
@Test public void shouldVerificationWorks(){iterable.iterator();verify(iterable).iterator();verify((Iterable)iterable).iterator();}
@Test public void shouldWorkExactlyAsJavaProxyWould(){final List<Method> methods=new LinkedList<Method>();InvocationHandler handler=new InvocationHandler(){public Object invoke(Object proxy,Method method,Object[]args)throws Throwable {methods.add(method);return null;}};iterable=(MyIterable)Proxy.newProxyInstance(this.getClass().getClassLoader(),new Class[]{MyIterable.class},handler);iterable.iterator();((Iterable)iterable).iterator();assertEquals(2,methods.size());assertEquals(methods.get(0),methods.get(1));}
@Test public void shouldAcceptHamcrestMatcher(){when(mock.simpleMethod(argThat(new ContainsX()))).thenReturn("X");assertNull(mock.simpleMethod("blah"));assertEquals("X",mock.simpleMethod("blah X blah"));}
@Test public void shouldVerifyUsingHamcrestMatcher(){mock.simpleMethod("blah");try {verify(mock).simpleMethod(argThat(new ContainsX()));fail();}catch(ArgumentsAreDifferent e){assertContains("contains 'X'",e.getMessage());}}
@Test public void shouldIncludeInitialLog(){int importType=0;Date currentDate=new GregorianCalendar(2009,10,12).getTime();ImportLogBean initialLog=new ImportLogBean(currentDate,importType);initialLog.setStatus(1);given(importLogDao.anyImportRunningOrRunnedToday(importType,currentDate)).willReturn(false);willAnswer(byCheckingLogEquals(initialLog)).given(importLogDao).include(any(ImportLogBean.class));importManager.startImportProcess(importType,currentDate);verify(importLogDao).include(any(ImportLogBean.class));}
@Test public void shouldAlterFinalLog(){int importType=0;Date currentDate=new GregorianCalendar(2009,10,12).getTime();ImportLogBean finalLog=new ImportLogBean(currentDate,importType);finalLog.setStatus(9);given(importLogDao.anyImportRunningOrRunnedToday(importType,currentDate)).willReturn(false);willAnswer(byCheckingLogEquals(finalLog)).given(importLogDao).alter(any(ImportLogBean.class));importManager.startImportProcess(importType,currentDate);verify(importLogDao).alter(any(ImportLogBean.class));}
@Test public void shouldAllowAnyList(){when(mock.forList(anyList())).thenReturn("x");assertEquals("x",mock.forList(null));assertEquals("x",mock.forList(Arrays.asList("x","y")));verify(mock,times(2)).forList(anyList());}
@Test public void shouldAllowAnyCollection(){when(mock.forCollection(anyCollection())).thenReturn("x");assertEquals("x",mock.forCollection(null));assertEquals("x",mock.forCollection(Arrays.asList("x","y")));verify(mock,times(2)).forCollection(anyCollection());}
@Test public void shouldAllowAnyMap(){when(mock.forMap(anyMap())).thenReturn("x");assertEquals("x",mock.forMap(null));assertEquals("x",mock.forMap(new HashMap<String,String>()));verify(mock,times(2)).forMap(anyMap());}
@Test public void shouldAllowAnySet(){when(mock.forSet(anySet())).thenReturn("x");assertEquals("x",mock.forSet(null));assertEquals("x",mock.forSet(new HashSet<String>()));verify(mock,times(2)).forSet(anySet());}
@Test public void shouldUseCaptorInOrdinaryWay(){createPerson("Wes","Williams");ArgumentCaptor<Person> captor=ArgumentCaptor.forClass(Person.class);verify(peopleRepository).save(captor.capture());assertEquals("Wes",captor.getValue().getName());assertEquals("Williams",captor.getValue().getSurname());}
@Test public void shouldUseAnnotatedCaptor(){createPerson("Wes","Williams");verify(peopleRepository).save(captor.capture());assertEquals("Wes",captor.getValue().getName());assertEquals("Williams",captor.getValue().getSurname());}
@Test public void shouldUseGenericlessAnnotatedCaptor(){createPerson("Wes","Williams");verify(peopleRepository).save((Person)genericLessCaptor.capture());assertEquals("Wes",((Person)genericLessCaptor.getValue()).getName());assertEquals("Williams",((Person)genericLessCaptor.getValue()).getSurname());}
@Test public void shouldCaptureGenericList(){List<String> list=new LinkedList<String>();mock.listArgMethod(list);verify(mock).listArgMethod(genericListCaptor.capture());assertSame(list,genericListCaptor.getValue());}
@Test public void testLessThan(){test(new LessThan<String>("b"),true,false,false,"lt");}
@Test public void testGreateThan(){test(new GreaterThan<String>("b"),false,true,false,"gt");}
@Test public void testLessOrEqual(){test(new LessOrEqual<String>("b"),true,false,true,"leq");}
@Test public void testGreateOrEqual(){test(new GreaterOrEqual<String>("b"),false,true,true,"geq");}
@Test public void testCompareEqual(){test(new CompareEqual<String>("b"),false,false,true,"cmpEq");CompareEqual<BigDecimal> cmpEq=new CompareEqual<BigDecimal>(new BigDecimal("5.00"));assertTrue(cmpEq.matches(new BigDecimal("5")));}
@Test public void shouldNotReturnNullForPrimitivesWprappers()throws Exception {assertNotNull(h.returnFor(Boolean.class));assertNotNull(h.returnFor(Character.class));assertNotNull(h.returnFor(Byte.class));assertNotNull(h.returnFor(Short.class));assertNotNull(h.returnFor(Integer.class));assertNotNull(h.returnFor(Long.class));assertNotNull(h.returnFor(Float.class));assertNotNull(h.returnFor(Double.class));}
@Test public void shouldNotReturnNullForPrimitives()throws Exception {assertNotNull(h.returnFor(boolean.class));assertNotNull(h.returnFor(char.class));assertNotNull(h.returnFor(byte.class));assertNotNull(h.returnFor(short.class));assertNotNull(h.returnFor(int.class));assertNotNull(h.returnFor(long.class));assertNotNull(h.returnFor(float.class));assertNotNull(h.returnFor(double.class));}
@Test public void shouldReturnNullForEverythingElse()throws Exception {assertNull(h.returnFor(Object.class));assertNull(h.returnFor(String.class));assertNull(h.returnFor(null));}
@Test public void shouldReturnHandyValueForInstances()throws Exception {assertNull(h.returnFor(new Object()));assertNull(h.returnFor((Object)null));assertNotNull(h.returnFor(10.0));assertNotNull(h.returnFor(Boolean.FALSE));}
@Test public void spyInAction(){}
@Test public void partialMockInAction(){}
@Ignore("stubbing from multiple threads is not supported")@Test public void shouldStubFineConcurrently()throws Exception {for (int i=0;i < 100;i++){performTest();}}
@Test public void shouldVerifyAtMostXTimes()throws Exception {mock.clear();mock.clear();verify(mock,atMost(2)).clear();verify(mock,atMost(3)).clear();try {verify(mock,atMost(1)).clear();fail();}catch(MockitoAssertionError e){}}
@Test public void shouldWorkWithArgumentMatchers()throws Exception {mock.add("one");verify(mock,atMost(5)).add(anyString());try {verify(mock,atMost(0)).add(anyString());fail();}catch(MockitoAssertionError e){}}
@Test public void shouldNotAllowNegativeNumber()throws Exception {try {verify(mock,atMost(-1)).clear();fail();}catch(MockitoException e){assertEquals("Negative value is not allowed here",e.getMessage());}}
@Test public void shouldPrintDecentMessage()throws Exception {mock.clear();mock.clear();try {verify(mock,atMost(1)).clear();fail();}catch(MockitoAssertionError e){assertEquals("\nWanted at most 1 time but was 2",e.getMessage());}}
@Test public void shouldNotAllowInOrderMode()throws Exception {mock.clear();InOrder inOrder=inOrder(mock);try {inOrder.verify(mock,atMost(1)).clear();fail();}catch(MockitoException e){assertEquals("AtMost is not implemented to work with InOrder",e.getMessage());}}
@Test public void shouldMarkInteractionsAsVerified()throws Exception {mock.clear();mock.clear();verify(mock,atMost(3)).clear();verifyNoMoreInteractions(mock);}
@Test public void shouldDetectUnverifiedInMarkInteractionsAsVerified()throws Exception {mock.clear();mock.clear();undesiredInteraction();verify(mock,atMost(3)).clear();try {verifyNoMoreInteractions(mock);fail();}catch(NoInteractionsWanted e){assertContains("undesiredInteraction(",e.getMessage());}}
@Test public void shouldFindActualInvocations()throws Exception {List<Invocation> actual=finder.findInvocations(invocations,new InvocationMatcher(simpleMethodInvocation));assertThat(actual,hasExactlyInOrder(simpleMethodInvocation,simpleMethodInvocationTwo));actual=finder.findInvocations(invocations,new InvocationMatcher(differentMethodInvocation));assertThat(actual,hasExactlyInOrder(differentMethodInvocation));}
@Test public void shouldFindFirstUnverifiedInvocation()throws Exception {assertSame(simpleMethodInvocation,finder.findFirstUnverified(invocations));simpleMethodInvocationTwo.markVerified();simpleMethodInvocation.markVerified();assertSame(differentMethodInvocation,finder.findFirstUnverified(invocations));differentMethodInvocation.markVerified();assertNull(finder.findFirstUnverified(invocations));}
@Test public void shouldFindFirstUnverifiedInOrder()throws Exception {InOrderContextImpl context=new InOrderContextImpl();assertSame(simpleMethodInvocation,finder.findFirstUnverifiedInOrder(context,invocations));context.markVerified(simpleMethodInvocationTwo);context.markVerified(simpleMethodInvocation);assertSame(differentMethodInvocation,finder.findFirstUnverifiedInOrder(context,invocations));context.markVerified(differentMethodInvocation);assertNull(finder.findFirstUnverifiedInOrder(context,invocations));}
@Test public void shouldFindFirstUnverifiedInOrderAndRespectSequenceNumber()throws Exception {InOrderContextImpl context=new InOrderContextImpl();assertSame(simpleMethodInvocation,finder.findFirstUnverifiedInOrder(context,invocations));context.markVerified(simpleMethodInvocationTwo);context.markVerified(differentMethodInvocation);assertSame(null,finder.findFirstUnverifiedInOrder(context,invocations));}
@Test public void shouldFindFirstUnverifiedInvocationOnMock()throws Exception {assertSame(simpleMethodInvocation,finder.findFirstUnverified(invocations,simpleMethodInvocation.getMock()));assertNull(finder.findFirstUnverified(invocations,"different mock"));}
@Test public void shouldFindFirstSimilarInvocationByName()throws Exception {Invocation overloadedSimpleMethod=new InvocationBuilder().mock(mock).simpleMethod().arg("test").toInvocation();Invocation found=finder.findSimilarInvocation(invocations,new InvocationMatcher(overloadedSimpleMethod));assertSame(found,simpleMethodInvocation);}
@Test public void shouldFindInvocationWithTheSameMethod()throws Exception {Invocation overloadedDifferentMethod=new InvocationBuilder().differentMethod().arg("test").toInvocation();invocations.add(overloadedDifferentMethod);Invocation found=finder.findSimilarInvocation(invocations,new InvocationMatcher(overloadedDifferentMethod));assertSame(found,overloadedDifferentMethod);}
@Test public void shouldGetLastStackTrace()throws Exception {Location last=finder.getLastLocation(invocations);assertSame(differentMethodInvocation.getLocation(),last);assertNull(finder.getLastLocation(Collections.<Invocation>emptyList()));}
@Test public void shouldFindAllMatchingUnverifiedChunks()throws Exception {List<Invocation> allMatching=finder.findAllMatchingUnverifiedChunks(invocations,new InvocationMatcher(simpleMethodInvocation),context);assertThat(allMatching,hasExactlyInOrder(simpleMethodInvocation,simpleMethodInvocationTwo));context.markVerified(simpleMethodInvocation);allMatching=finder.findAllMatchingUnverifiedChunks(invocations,new InvocationMatcher(simpleMethodInvocation),context);assertThat(allMatching,hasExactlyInOrder(simpleMethodInvocationTwo));context.markVerified(simpleMethodInvocationTwo);allMatching=finder.findAllMatchingUnverifiedChunks(invocations,new InvocationMatcher(simpleMethodInvocation),context);assertTrue(allMatching.isEmpty());}
@Test public void shouldFindMatchingChunk()throws Exception {List<Invocation> chunk=finder.findMatchingChunk(invocations,new InvocationMatcher(simpleMethodInvocation),2,context);assertThat(chunk,hasExactlyInOrder(simpleMethodInvocation,simpleMethodInvocationTwo));}
@Test public void shouldReturnAllChunksWhenModeIsAtLeastOnce()throws Exception {Invocation simpleMethodInvocationThree=new InvocationBuilder().mock(mock).toInvocation();invocations.add(simpleMethodInvocationThree);List<Invocation> chunk=finder.findMatchingChunk(invocations,new InvocationMatcher(simpleMethodInvocation),1,context);assertThat(chunk,hasExactlyInOrder(simpleMethodInvocation,simpleMethodInvocationTwo,simpleMethodInvocationThree));}
@Test public void shouldReturnAllChunksWhenWantedCountDoesntMatch()throws Exception {Invocation simpleMethodInvocationThree=new InvocationBuilder().mock(mock).toInvocation();invocations.add(simpleMethodInvocationThree);List<Invocation> chunk=finder.findMatchingChunk(invocations,new InvocationMatcher(simpleMethodInvocation),1,context);assertThat(chunk,hasExactlyInOrder(simpleMethodInvocation,simpleMethodInvocationTwo,simpleMethodInvocationThree));}
@Test public void shouldFindPreviousInOrder()throws Exception {Invocation previous=finder.findPreviousVerifiedInOrder(invocations,context);assertNull(previous);context.markVerified(simpleMethodInvocation);context.markVerified(simpleMethodInvocationTwo);previous=finder.findPreviousVerifiedInOrder(invocations,context);assertSame(simpleMethodInvocationTwo,previous);}
@Test public void isValidMocked(){ClassForMocking clazzMock=mock(ClassForMocking.class);Mockito.when(clazzMock.isValid()).thenReturn(true);}
@Test public void shouldValidateNullThrowable()throws Throwable {try {validator.validate(new ThrowsException(null),null);fail();}catch(MockitoException e){}}
@Test public void shouldPassProperCheckedException()throws Throwable {validator.validate(new ThrowsException(new CharacterCodingException()),invocation);}
@Test(expected=MockitoException.class)public void shouldFailInvalidCheckedException()throws Throwable {validator.validate(new ThrowsException(new IOException()),invocation);}
@Test public void shouldPassRuntimeExceptions()throws Throwable {validator.validate(new ThrowsException(new Error()),invocation);validator.validate(new ThrowsException(new RuntimeException()),invocation);}
@Test(expected=MockitoException.class)public void shouldFailWhenReturnValueIsSetForVoidMethod()throws Throwable {validator.validate(new Returns("one"),new InvocationBuilder().method("voidMethod").toInvocation());}
@Test(expected=MockitoException.class)public void shouldFailWhenNonVoidMethodDoesNothing()throws Throwable {validator.validate(new DoesNothing(),new InvocationBuilder().simpleMethod().toInvocation());}
@Test public void shouldAllowVoidReturnForVoidMethod()throws Throwable {validator.validate(new DoesNothing(),new InvocationBuilder().method("voidMethod").toInvocation());}
@Test public void shouldAllowCorrectTypeOfReturnValue()throws Throwable {validator.validate(new Returns("one"),new InvocationBuilder().simpleMethod().toInvocation());validator.validate(new Returns(false),new InvocationBuilder().method("booleanReturningMethod").toInvocation());validator.validate(new Returns(new Boolean(true)),new InvocationBuilder().method("booleanObjectReturningMethod").toInvocation());validator.validate(new Returns(1),new InvocationBuilder().method("integerReturningMethod").toInvocation());validator.validate(new Returns(1L),new InvocationBuilder().method("longReturningMethod").toInvocation());validator.validate(new Returns(1L),new InvocationBuilder().method("longObjectReturningMethod").toInvocation());validator.validate(new Returns(null),new InvocationBuilder().method("objectReturningMethodNoArgs").toInvocation());validator.validate(new Returns(1),new InvocationBuilder().method("objectReturningMethodNoArgs").toInvocation());}
@Test(expected=MockitoException.class)public void shouldFailOnReturnTypeMismatch()throws Throwable {validator.validate(new Returns("String"),new InvocationBuilder().method("booleanReturningMethod").toInvocation());}
@Test(expected=MockitoException.class)public void shouldFailOnWrongPrimitive()throws Throwable {validator.validate(new Returns(1),new InvocationBuilder().method("doubleReturningMethod").toInvocation());}
@Test(expected=MockitoException.class)public void shouldFailOnNullWithPrimitive()throws Throwable {validator.validate(new Returns(null),new InvocationBuilder().method("booleanReturningMethod").toInvocation());}
@Test public void shouldFailWhenCallingRealMethodOnIterface()throws Throwable {Invocation inovcationOnIterface=new InvocationBuilder().method("simpleMethod").toInvocation();try {validator.validate(new CallsRealMethods(),inovcationOnIterface);fail();}catch(MockitoException e){}}
@Test public void shouldBeOKWhenCallingRealMethodOnConcreteClass()throws Throwable {ArrayList mock=mock(ArrayList.class);mock.clear();Invocation invocationOnClass=getLastInvocation();validator.validate(new CallsRealMethods(),invocationOnClass);}
@Test public void shouldNotThrowNPE(){Foo f=mock(Foo.class);f.bar(1);verify(f).bar(any(Long.class));}
@Test public void shouldCreateMockWhenConstructorIsPrivate(){assertNotNull(Mockito.mock(HasPrivateConstructor.class));}
@Test public void shouldCombineMockNameAndSmartNulls(){IMethods mock=mock(IMethods.class,withSettings().defaultAnswer(RETURNS_SMART_NULLS).name("great mockie"));IMethods smartNull=mock.iMethodsReturningMethod();String name=mock.toString();assertContains("great mockie",name);try {smartNull.simpleMethod();fail();}catch(SmartNullPointerException e){}}
@Test public void shouldCombineMockNameAndExtraInterfaces(){}
@Test public void shouldSpecifyMockNameViaSettings(){IMethods mock=mock(IMethods.class,withSettings().name("great mockie"));String name=mock.toString();assertContains("great mockie",name);}
@Test public void shouldScreamWhenSpyCreatedWithWrongType(){List list=new LinkedList();try {mock(List.class,withSettings().spiedInstance(list));fail();}catch(MockitoException e){}}
@Test public void shouldAllowCreatingSpiesWithCorrectType(){List list=new LinkedList();mock(LinkedList.class,withSettings().spiedInstance(list));}
@Test public void shouldAllowInlineMockCreation()throws Exception {when(mock(Set.class).isEmpty()).thenReturn(false);}
@Test public void shouldVerifyMethodWasInvokedExclusively(){mock.clear();verify(mock,only()).clear();}
@Test public void shouldVerifyMethodWasInvokedExclusivelyWithMatchersUsage(){mock.get(0);verify(mock,only()).get(anyInt());}
@Test public void shouldFailIfMethodWasNotInvoked(){mock.clear();try {verify(mock,only()).get(0);fail();}catch(WantedButNotInvoked e){}}
@Test public void shouldFailIfMethodWasInvokedMoreThanOnce(){mock.clear();mock.clear();try {verify(mock,only()).clear();fail();}catch(NoInteractionsWanted e){}}
@Test public void shouldFailIfMethodWasInvokedButWithDifferentArguments(){mock.get(0);mock.get(2);try {verify(mock,only()).get(999);fail();}catch(WantedButNotInvoked e){}}
@Test public void shouldFailIfExtraMethodWithDifferentArgsFound(){mock.get(0);mock.get(2);try {verify(mock,only()).get(2);fail();}catch(NoInteractionsWanted e){}}
@Test public void shouldVerifyMethodWasInvokedExclusivelyWhenTwoMocksInUse(){mock.clear();mock2.get(0);verify(mock,only()).clear();verify(mock2,only()).get(0);}
@Test public void shouldReturnTheUsualDefaultValuesForPrimitives()throws Throwable {Answer<Object> answer=new ReturnsSmartNulls();assertEquals(false,answer.answer(invocationOf(HasPrimitiveMethods.class,"booleanMethod")));assertEquals((char)0,answer.answer(invocationOf(HasPrimitiveMethods.class,"charMethod")));assertEquals(0,answer.answer(invocationOf(HasPrimitiveMethods.class,"intMethod")));assertEquals(0,answer.answer(invocationOf(HasPrimitiveMethods.class,"longMethod")));assertEquals(0,answer.answer(invocationOf(HasPrimitiveMethods.class,"floatMethod")));assertEquals(0,answer.answer(invocationOf(HasPrimitiveMethods.class,"doubleMethod")));}
@Test public void shouldReturnAnObjectThatFailsOnAnyMethodInvocationForNonPrimitives()throws Throwable {Answer<Object> answer=new ReturnsSmartNulls();Foo smartNull=(Foo)answer.answer(invocationOf(Foo.class,"get"));try {smartNull.get();fail();}catch(SmartNullPointerException expected){}}
@Test public void shouldReturnAnObjectThatAllowsObjectMethods()throws Throwable {Answer<Object> answer=new ReturnsSmartNulls();Foo smartNull=(Foo)answer.answer(invocationOf(Foo.class,"get"));assertContains("SmartNull returned by",smartNull + "");assertContains("foo.get()",smartNull + "");}
@Test public void shouldPrintTheParametersWhenCallingAMethodWithArgs()throws Throwable {Answer<Object> answer=new ReturnsSmartNulls();Foo smartNull=(Foo)answer.answer(invocationOf(Foo.class,"withArgs","oompa","lumpa"));assertContains("foo.withArgs",smartNull + "");assertContains("oompa",smartNull + "");assertContains("lumpa",smartNull + "");}
@Test public void shouldPrintTheParametersOnSmartNullPointerExceptionMessage()throws Throwable {Answer<Object> answer=new ReturnsSmartNulls();Foo smartNull=(Foo)answer.answer(invocationOf(Foo.class,"withArgs","oompa","lumpa"));try {smartNull.get();fail();}catch(SmartNullPointerException e){assertContains("oompa",e.getMessage());assertContains("lumpa",e.getMessage());}}
@Test public void shouldKnowIfObjectsAreEqual()throws Exception {int[]arr=new int[]{1,2};assertTrue(areEqual(arr,arr));assertTrue(areEqual(new int[]{1,2},new int[]{1,2}));assertTrue(areEqual(new Double[]{1.0},new Double[]{1.0}));assertTrue(areEqual(new String[0],new String[0]));assertTrue(areEqual(new Object[10],new Object[10]));assertTrue(areEqual(new int[]{1},new Integer[]{1}));assertTrue(areEqual(new Object[]{"1"},new String[]{"1"}));assertFalse(areEqual(new Object[9],new Object[10]));assertFalse(areEqual(new int[]{1,2},new int[]{1}));assertFalse(areEqual(new int[]{1},new double[]{1.0}));}
@Test public void shouldFilterList()throws Exception {List list=asList("one","x","two","x","three");List filtered=ListUtil.filter(list,new Filter(){public boolean isOut(Object object){return object == "x";}});assertThat(filtered,hasExactlyInOrder("one","two","three"));}
@Test public void shouldReturnEmptyIfEmptyListGiven()throws Exception {List list=new LinkedList();List filtered=ListUtil.filter(list,null);assertTrue(filtered.isEmpty());}
@Test public void shouldAllowCallingInternalMethod(){when(mock.getValue()).thenReturn("foo");when(mock.callInternalMethod()).thenCallRealMethod();assertEquals("foo",mock.callInternalMethod());}
@Test public void shouldReturnRealValue(){when(mock.getValue()).thenCallRealMethod();Assert.assertEquals("HARD_CODED_RETURN_VALUE",mock.getValue());}
@Test public void shouldExecuteRealMethod(){doCallRealMethod().when(mock).setValue(anyString());mock.setValue("REAL_VALUE");Assert.assertEquals("REAL_VALUE",mock.value);}
@Test public void shouldCallRealMethodByDefault(){TestedObject mock=mock(TestedObject.class,CALLS_REAL_METHODS);Assert.assertEquals("HARD_CODED_RETURN_VALUE",mock.getValue());}
@Test public void shouldNotCallRealMethodWhenStubbedLater(){TestedObject mock=mock(TestedObject.class);when(mock.getValue()).thenCallRealMethod();when(mock.getValue()).thenReturn("FAKE_VALUE");Assert.assertEquals("FAKE_VALUE",mock.getValue());}
@Test public void shouldKnowToStringMethod()throws Exception {assertFalse(guru.isToString(Object.class.getMethod("equals",Object.class)));assertFalse(guru.isToString(IMethods.class.getMethod("toString",String.class)));assertTrue(guru.isToString(IMethods.class.getMethod("toString")));}
@Test public void shouldKnowEqualsMethod()throws Exception {assertFalse(guru.isEqualsMethod(IMethods.class.getMethod("equals",String.class)));assertFalse(guru.isEqualsMethod(IMethods.class.getMethod("equals")));assertFalse(guru.isEqualsMethod(Object.class.getMethod("toString")));assertTrue(guru.isEqualsMethod(Object.class.getMethod("equals",Object.class)));}
@Test public void shouldKnowHashCodeMethod()throws Exception {assertFalse(guru.isHashCodeMethod(IMethods.class.getMethod("toString")));assertFalse(guru.isHashCodeMethod(IMethods.class.getMethod("hashCode",String.class)));assertTrue(guru.isHashCodeMethod(Object.class.getDeclaredMethod("hashCode")));}
@Test public void shouldKnowCompareToMethod()throws Exception {assertFalse(guru.isCompareToMethod(Date.class.getMethod("toString")));assertFalse(guru.isCompareToMethod(HasCompare.class.getMethod("foo",HasCompare.class)));assertFalse(guru.isCompareToMethod(HasCompare.class.getMethod("compareTo",HasCompare.class,String.class)));assertFalse(guru.isCompareToMethod(HasCompare.class.getMethod("compareTo",String.class)));assertFalse(guru.isCompareToMethod(HasCompareToButDoesNotImplementComparable.class.getDeclaredMethod("compareTo",HasCompareToButDoesNotImplementComparable.class)));assertTrue(guru.isCompareToMethod(HasCompare.class.getMethod("compareTo",HasCompare.class)));}
@Test public void shouldAllowVerifyingInThreads()throws Exception {for (int i=0;i < 50;i++){performTest();}}
@Test public void basicCheck(){Mockito.when((someSubInterface).factory()).thenReturn(extendedFactory);SomeInterface si=someSubInterface;assertTrue(si.factory()!= null);}
@Test public void checkWithExtraCast(){Mockito.when(((SomeInterface)someSubInterface).factory()).thenReturn(extendedFactory);SomeInterface si=someSubInterface;assertTrue(si.factory()!= null);}
@Test public void shouldMatchAnyVararg(){mock.run("a","b");verify(mock).run(anyString(),anyString());verify(mock).run((String)anyObject(),(String)anyObject());verify(mock).run((String[])anyVararg());verify(mock,never()).run();verify(mock,never()).run(anyString(),eq("f"));}
@Test public void shouldNotAllowUsingAnyObjectForVarArgs(){mock.run("a","b");try {verify(mock).run((String[])anyObject());fail();}catch(AssertionError e){}}
@Test public void shouldStubUsingAnyVarargs(){when(mock.run((String[])anyVararg())).thenReturn("foo");assertEquals("foo",mock.run("a","b"));}
@Test public void shouldKeepSameInstanceIfFieldInitialized(){assertSame(baseUnderTestingInstance,initializedBase);}
@Test public void shouldInitializeAnnotatedFieldIfNull(){assertNotNull(notInitializedBase);}
@Test public void shouldIInjectMocksInSpy(){assertNotNull(initializedSpy.getAList());assertTrue(mockUtil.isMock(initializedSpy));}
@Test public void shouldInitializeSpyIfNullAndInjectMocks(){assertNotNull(notInitializedSpy);assertNotNull(notInitializedSpy.getAList());assertTrue(mockUtil.isMock(notInitializedSpy));}
@Test public void shouldInjectMocksIfAnnotated(){MockitoAnnotations.initMocks(this);assertSame(list,superUnderTest.getAList());}
@Test public void shouldNotInjectIfNotAnnotated(){MockitoAnnotations.initMocks(this);assertNull(superUnderTestWithoutInjection.getAList());}
@Test public void shouldInjectMocksForClassHierarchyIfAnnotated(){MockitoAnnotations.initMocks(this);assertSame(list,baseUnderTest.getAList());assertSame(map,baseUnderTest.getAMap());}
@Test public void shouldInjectMocksByName(){MockitoAnnotations.initMocks(this);assertSame(histogram1,subUnderTest.getHistogram1());assertSame(histogram2,subUnderTest.getHistogram2());}
@Test public void shouldInjectSpies(){MockitoAnnotations.initMocks(this);assertSame(searchTree,otherBaseUnderTest.getSearchTree());}
@Test public void shouldInstantiateInjectMockFieldIfPossible()throws Exception {assertNotNull(notInitializedBase);}
@Test public void shouldKeepInstanceOnInjectMockFieldIfPresent()throws Exception {assertSame(baseUnderTestingInstance,initializedBase);}
@Test public void shouldReportNicely()throws Exception {Object failing=new Object(){@InjectMocks ThrowingConstructor failingConstructor;};try {MockitoAnnotations.initMocks(failing);fail();}catch(MockitoException e){Assertions.assertThat(e.getMessage()).contains("failingConstructor").contains("constructor").contains("threw an exception");Assertions.assertThat(e.getCause()).isInstanceOf(RuntimeException.class);}}
@Test public void shouldVerifyCorrectlyWithAnyVarargs(){table.newRow("qux","foo","bar","baz");table.newRow("abc","def");verify(table,times(2)).newRow(anyString(),(String[])anyVararg());}
@Test public void shouldVerifyCorrectlyNumberOfInvocationsUsingAnyVarargAndEqualArgument(){table.newRow("x","foo","bar","baz");table.newRow("x","def");verify(table,times(2)).newRow(eq("x"),(String[])anyVararg());}
@Test public void shouldVerifyCorrectlyNumberOfInvocationsWithVarargs(){table.newRow("qux","foo","bar","baz");table.newRow("abc","def");verify(table).newRow(anyString(),eq("foo"),anyString(),anyString());verify(table).newRow(anyString(),anyString());}
@Test public void shouldHelpOutWithUnnecessaryCasting(){when(mock.objectArgMethod(any(String.class))).thenReturn("string");assertEquals("string",mock.objectArgMethod("foo"));}
@Test public void shouldAnyBeActualAliasToAnyObject(){mock.simpleMethod((Object)null);verify(mock).simpleMethod(anyObject());verify(mock).simpleMethod(any(Object.class));}
@Test public void shouldHelpOutWithUnnecessaryCastingOfLists(){when(mock.listArgMethod(anyListOf(String.class))).thenReturn("list");assertEquals("list",mock.listArgMethod(new LinkedList<String>()));assertEquals("list",mock.listArgMethod(Collections.<String>emptyList()));}
@Test public void shouldHelpOutWithUnnecessaryCastingOfSets(){when(mock.setArgMethod(anySetOf(String.class))).thenReturn("set");assertEquals("set",mock.setArgMethod(new HashSet<String>()));assertEquals("set",mock.setArgMethod(Collections.<String>emptySet()));}
@Test public void shouldHelpOutWithUnnecessaryCastingOfMaps(){when(mock.forMap(anyMapOf(String.class,String.class))).thenReturn("map");assertEquals("map",mock.forMap(new HashMap<String,String>()));assertEquals("map",mock.forMap(Collections.<String,String>emptyMap()));}
@Test public void shouldHelpOutWithUnnecessaryCastingOfCollections(){when(mock.collectionArgMethod(anyCollectionOf(String.class))).thenReturn("col");assertEquals("col",mock.collectionArgMethod(new ArrayList<String>()));assertEquals("col",mock.collectionArgMethod(Collections.<String>emptyList()));}
@Test public void shouldHelpOutWithUnnecessaryCastingOfNullityChecks(){when(mock.objectArgMethod(isNull(LinkedList.class))).thenReturn("string");when(mock.objectArgMethod(notNull(LinkedList.class))).thenReturn("string");when(mock.objectArgMethod(isNotNull(LinkedList.class))).thenReturn("string");assertEquals("string",mock.objectArgMethod(null));assertEquals("string",mock.objectArgMethod("foo"));assertEquals("string",mock.objectArgMethod("foo"));}
@Test public void should_keep_same_instance_if_field_initialized()throws Exception {final StaticClass backupInstance=alreadyInstantiated;FieldInitializer fieldInitializer=new FieldInitializer(this,field("alreadyInstantiated"));FieldInitializationReport report=fieldInitializer.initialize();assertSame(backupInstance,report.fieldInstance());assertFalse(report.fieldWasInitialized());}
@Test public void should_instantiate_field_when_type_has_no_constructor()throws Exception {FieldInitializer fieldInitializer=new FieldInitializer(this,field("noConstructor"));FieldInitializationReport report=fieldInitializer.initialize();assertNotNull(report.fieldInstance());assertTrue(report.fieldWasInitialized());}
@Test public void should_instantiate_field_with_default_constructor()throws Exception {FieldInitializer fieldInitializer=new FieldInitializer(this,field("defaultConstructor"));FieldInitializationReport report=fieldInitializer.initialize();assertNotNull(report.fieldInstance());assertTrue(report.fieldWasInitialized());}
@Test public void should_instantiate_field_with_private_default_constructor()throws Exception {FieldInitializer fieldInitializer=new FieldInitializer(this,field("privateDefaultConstructor"));FieldInitializationReport report=fieldInitializer.initialize();assertNotNull(report.fieldInstance());assertTrue(report.fieldWasInitialized());}
@Test(expected=MockitoException.class)public void should_fail_to_instantiate_field_if_no_default_constructor()throws Exception {FieldInitializer fieldInitializer=new FieldInitializer(this,field("noDefaultConstructor"));fieldInitializer.initialize();}
@Test public void should_fail_to_instantiate_field_if_default_constructor_throws_exception()throws Exception {FieldInitializer fieldInitializer=new FieldInitializer(this,field("throwingExDefaultConstructor"));try {fieldInitializer.initialize();fail();}catch(MockitoException e){InvocationTargetException ite=(InvocationTargetException)e.getCause();assertTrue(ite.getTargetException()instanceof NullPointerException);assertEquals("business logic failed",ite.getTargetException().getMessage());}}
@Test(expected=MockitoException.class)public void should_fail_for_abstract_field()throws Exception {new FieldInitializer(this,field("abstractType"));}
@Test public void should_not_fail_if_abstract_field_is_instantiated()throws Exception {new FieldInitializer(this,field("instantiatedAbstractType"));}
@Test(expected=MockitoException.class)public void should_fail_for_interface_field()throws Exception {new FieldInitializer(this,field("interfaceType"));}
@Test public void should_not_fail_if_interface_field_is_instantiated()throws Exception {new FieldInitializer(this,field("instantiatedInterfaceType"));}
@Test(expected=MockitoException.class)public void should_fail_for_local_type_field()throws Exception {class LocalType {}class TheTestWithLocalType {@InjectMocks LocalType field;}TheTestWithLocalType testWithLocalType=new TheTestWithLocalType();new FieldInitializer(testWithLocalType,testWithLocalType.getClass().getDeclaredField("field"));}
@Test public void should_not_fail_if_local_type_field_is_instantiated()throws Exception {class LocalType {}class TheTestWithLocalType {@InjectMocks LocalType field=new LocalType();}TheTestWithLocalType testWithLocalType=new TheTestWithLocalType();new FieldInitializer(testWithLocalType,testWithLocalType.getClass().getDeclaredField("field"));}
@Test(expected=MockitoException.class)public void should_fail_for_inner_class_field()throws Exception {new FieldInitializer(this,field("innerClassType"));}
@Test public void should_not_fail_if_inner_class_field_is_instantiated()throws Exception {new FieldInitializer(this,field("instantiatedInnerClassType"));}
@Test public void can_instantiate_class_with_parameterized_constructor()throws Exception {ConstructorArgumentResolver resolver=given(mock(ConstructorArgumentResolver.class).resolveTypeInstances(any(Class[].class))).willReturn(new Object[]{null}).getMock();new FieldInitializer(this,field("noDefaultConstructor"),resolver).initialize();assertNotNull(noDefaultConstructor);}
@Test public void dont_fail_with_CONSTANTS()throws Exception {}
@Test public void dont_inject_in_final(){assertNotSame(unrelatedSet,exampleService.aSet);}
@Test public void shouldPrintUnusedStub(){Invocation unusedStub=new InvocationBuilder().simpleMethod().toInvocation();WarningsFinder finder=new WarningsFinder(asList(unusedStub),Arrays.<InvocationMatcher>asList());finder.find(listener);verify(listener,only()).foundUnusedStub(unusedStub);}
@Test public void shouldPrintUnstubbedInvocation(){InvocationMatcher unstubbedInvocation=new InvocationBuilder().differentMethod().toInvocationMatcher();WarningsFinder finder=new WarningsFinder(Arrays.<Invocation>asList(),Arrays.<InvocationMatcher>asList(unstubbedInvocation));finder.find(listener);verify(listener,only()).foundUnstubbed(unstubbedInvocation);}
@Test public void shouldPrintStubWasUsedWithDifferentArgs(){Invocation stub=new InvocationBuilder().arg("foo").mock(mock).toInvocation();InvocationMatcher wrongArg=new InvocationBuilder().arg("bar").mock(mock).toInvocationMatcher();WarningsFinder finder=new WarningsFinder(Arrays.<Invocation>asList(stub),Arrays.<InvocationMatcher>asList(wrongArg));finder.find(listener);verify(listener,only()).foundStubCalledWithDifferentArgs(stub,wrongArg);}
@Test public void shouldUseArgumentTypeWhenOverloadingPuzzleDetected()throws Exception {Sub sub=mock(Sub.class);setMockWithDowncast(sub);say("Hello");try {verify(sub).say("Hello");fail();}catch(WantedButNotInvoked e){}}
@Test public void shouldRemoveVerificationModeEvenWhenInvalidMatchers()throws Throwable {Invocation invocation=new InvocationBuilder().toInvocation();@SuppressWarnings("rawtypes")MockHandler<?> handler=new MockHandler();handler.mockingProgress.verificationStarted(VerificationModeFactory.atLeastOnce());handler.matchersBinder=new MatchersBinder(){public InvocationMatcher bindMatchers(ArgumentMatcherStorage argumentMatcherStorage,Invocation invocation){throw new InvalidUseOfMatchersException();}};try {handler.handle(invocation);fail();}catch(InvalidUseOfMatchersException e){}assertNull(handler.mockingProgress.pullVerificationMode());}
@Test(expected=MockitoException.class)public void shouldThrowMockitoExceptionWhenInvocationHandlerThrowsAnything()throws Throwable {InvocationListener throwingListener=mock(InvocationListener.class);doThrow(new Throwable()).when(throwingListener).reportInvocation(any(MethodInvocationReport.class));MockHandler<?> handler=createCorrectlyStubbedHandler(throwingListener);handler.handle(invocation);}
@Test public void shouldNotFilterWhenConfigurationSaysNo(){ConfigurationAccess.getConfig().overrideCleansStackTrace(false);Throwable t=new TraceBuilder().classes("org.test.MockitoSampleTest","org.mockito.Mockito").toThrowable();filter.filter(t);assertThat(t,hasOnlyThoseClassesInStackTrace("org.mockito.Mockito","org.test.MockitoSampleTest"));}
@Test public void shouldFilterWhenConfigurationSaysYes(){ConfigurationAccess.getConfig().overrideCleansStackTrace(true);Throwable t=new TraceBuilder().classes("org.test.MockitoSampleTest","org.mockito.Mockito").toThrowable();filter.filter(t);assertThat(t,hasOnlyThoseClassesInStackTrace("org.test.MockitoSampleTest"));}
@Test public void shouldPrintBothInMultilinesWhenFirstIsMulti(){SmartPrinter printer=new SmartPrinter(multi,shortie);assertContains("\n",printer.getWanted().toString());assertContains("\n",printer.getActual().toString());}
@Test public void shouldPrintBothInMultilinesWhenSecondIsMulti(){SmartPrinter printer=new SmartPrinter(shortie,multi);assertContains("\n",printer.getWanted().toString());assertContains("\n",printer.getActual().toString());}
@Test public void shouldPrintBothInMultilinesWhenBothAreMulti(){SmartPrinter printer=new SmartPrinter(multi,multi);assertContains("\n",printer.getWanted().toString());assertContains("\n",printer.getActual().toString());}
@Test public void shouldPrintBothInSingleLineWhenBothAreShort(){SmartPrinter printer=new SmartPrinter(shortie,shortie);assertNotContains("\n",printer.getWanted().toString());assertNotContains("\n",printer.getActual().toString());}
@Test public void shouldNotThrowAnyException()throws Exception {Foo foo=mock(Foo.class);when(foo.blah(anyString(),anyString())).thenCallRealMethod();assertEquals(1,foo.blah("foo","bar"));}
@Test public void shouldNotPrintInvocationOnMockWithoutSetting(){Foo foo=mock(Foo.class,withSettings().verboseLogging());foo.giveMeSomeString("Klipsch");unrelatedMock.unrelatedMethod("Apple");Assertions.assertThat(printed()).doesNotContain(mockName(unrelatedMock)).doesNotContain("unrelatedMethod").doesNotContain("Apple");}
@Test public void shouldPrintUnstubbedInvocationOnMockToStdOut(){Foo foo=mock(Foo.class,withSettings().verboseLogging());foo.doSomething("Klipsch");Assertions.assertThat(printed()).contains(getClass().getName()).contains(mockName(foo)).contains("doSomething").contains("Klipsch");}
@Test public void shouldPrintStubbedInvocationOnMockToStdOut(){Foo foo=mock(Foo.class,withSettings().verboseLogging());given(foo.giveMeSomeString("Klipsch")).willReturn("earbuds");foo.giveMeSomeString("Klipsch");Assertions.assertThat(printed()).contains(getClass().getName()).contains(mockName(foo)).contains("giveMeSomeString").contains("Klipsch").contains("earbuds");}
@Test public void shouldPrintThrowingInvocationOnMockToStdOut(){Foo foo=mock(Foo.class,withSettings().verboseLogging());doThrow(new ThirdPartyException()).when(foo).doSomething("Klipsch");try {foo.doSomething("Klipsch");fail("Exception excepted.");}catch(ThirdPartyException e){Assertions.assertThat(printed()).contains(getClass().getName()).contains(mockName(foo)).contains("doSomething").contains("Klipsch").contains(ThirdPartyException.class.getName());}}
@Test public void shouldPrintRealInvocationOnSpyToStdOut(){FooImpl fooSpy=mock(FooImpl.class,withSettings().spiedInstance(new FooImpl()).verboseLogging());doCallRealMethod().when(fooSpy).doSomething("Klipsch");fooSpy.doSomething("Klipsch");Assertions.assertThat(printed()).contains(getClass().getName()).contains(mockName(fooSpy)).contains("doSomething").contains("Klipsch");}
@Test public void usage(){Foo foo=mock(Foo.class,withSettings().verboseLogging());given(foo.giveMeSomeString("Apple")).willReturn("earbuds");foo.giveMeSomeString("Shure");foo.giveMeSomeString("Apple");foo.doSomething("Klipsch");}
@Test public void shouldLogUnusedStub(){LoggingListener listener=new LoggingListener(false,logger);listener.foundUnusedStub(new InvocationBuilder().toInvocation());verify(logger).log(notNull());}
@Test public void shouldLogUnstubbed(){LoggingListener listener=new LoggingListener(true,logger);listener.foundUnstubbed(new InvocationBuilder().toInvocationMatcher());verify(logger).log(notNull());}
@Test public void shouldNotLogUnstubbed(){LoggingListener listener=new LoggingListener(false,logger);listener.foundUnstubbed(new InvocationBuilder().toInvocationMatcher());verify(logger,never()).log(notNull());}
@Test public void shouldLogDifferentArgs(){LoggingListener listener=new LoggingListener(true,logger);listener.foundStubCalledWithDifferentArgs(new InvocationBuilder().toInvocation(),new InvocationBuilder().toInvocationMatcher());verify(logger).log(notNull());}
@Test public void shouldVerifyExactNumberOfInvocationsUsingMatcher(){mock.simpleMethod(1);mock.simpleMethod(2);mock.simpleMethod(3);verify(mock,times(3)).simpleMethod(anyInt());}
@Test public void shouldVerifyUsingSameMatcher(){Object one=new String("1243");Object two=new String("1243");Object three=new String("1243");assertNotSame(one,two);assertEquals(one,two);assertEquals(two,three);mock.oneArg(one);mock.oneArg(two);verify(mock).oneArg(same(one));verify(mock,times(2)).oneArg(two);try {verify(mock).oneArg(same(three));fail();}catch(WantedButNotInvoked e){}}
@Test public void shouldVerifyUsingMixedMatchers(){mock.threeArgumentMethod(11,"","01234");try {verify(mock).threeArgumentMethod(and(geq(7),leq(10)),isA(String.class),Matchers.contains("123"));fail();}catch(ArgumentsAreDifferent e){}mock.threeArgumentMethod(8,new Object(),"01234");try {verify(mock).threeArgumentMethod(and(geq(7),leq(10)),isA(String.class),Matchers.contains("123"));fail();}catch(ArgumentsAreDifferent e){}mock.threeArgumentMethod(8,"","no match");try {verify(mock).threeArgumentMethod(and(geq(7),leq(10)),isA(String.class),Matchers.contains("123"));fail();}catch(ArgumentsAreDifferent e){}mock.threeArgumentMethod(8,"","123");verify(mock).threeArgumentMethod(and(geq(7),leq(10)),isA(String.class),Matchers.contains("123"));}
@Test public void shouldFindGenericClass()throws Exception {assertEquals(String.class,m.getGenericType(field("one")));assertEquals(Integer.class,m.getGenericType(field("two")));assertEquals(Double.class,m.getGenericType(field("map")));}
@Test public void shouldGetObjectForNonGeneric()throws Exception {assertEquals(Object.class,m.getGenericType(field("nonGeneric")));}
@Test public void shouldDealWithNestedGenerics()throws Exception {assertEquals(Set.class,m.getGenericType(field("nested")));assertEquals(Set.class,m.getGenericType(field("multiNested")));}
@Test public void shouldVerifyEvenIfArgumentsWereMutated()throws Exception {EmailSender emailSender=mock(EmailSender.class,new ClonesArguments());businessLogic(emailSender);verify(emailSender).sendEmail(1,new Person("Wes"));}
@Test public void shouldReturnDefaultValueWithCloningAnswer()throws Exception {EmailSender emailSender=mock(EmailSender.class,new ClonesArguments());when(emailSender.getAllEmails(new Person("Wes"))).thenAnswer(new ClonesArguments());List<?> emails=emailSender.getAllEmails(new Person("Wes"));assertNotNull(emails);}
@Test public void shouldReadConfigurationClassFromClassPath(){ConfigurationAccess.getConfig().overrideDefaultAnswer(new Answer<Object>(){public Object answer(InvocationOnMock invocation){return "foo";}});IMethods mock=mock(IMethods.class);assertEquals("foo",mock.simpleMethod());}
@Test public void failIfMockIsSharedBetweenThreads()throws Exception {Service service=Mockito.mock(Service.class);ExecutorService threads=Executors.newCachedThreadPool();AtomicInteger counter=new AtomicInteger(2);Mockito.when(service.verySlowMethod()).thenAnswer(new LockingAnswer(counter));threads.execute(new ServiceRunner(service));threads.execute(new ServiceRunner(service));threads.shutdown();if (!threads.awaitTermination(1000,TimeUnit.MILLISECONDS)){Assert.fail();}}
@Test public void successIfEveryThreadHasItsOwnMock(){}
@Test public void shouldFinishStubbingWhenWrongThrowableIsSet()throws Exception {state.stubbingStarted();try {invocationContainerImpl.addAnswer(new ThrowsException(new Exception()));fail();}catch(MockitoException e){state.validateState();}}
@Test public void shouldFinishStubbingOnAddingReturnValue()throws Exception {state.stubbingStarted();invocationContainerImpl.addAnswer(new Returns("test"));state.validateState();}
@Test public void shouldGetResultsForMethods()throws Throwable {invocationContainerImpl.setInvocationForPotentialStubbing(new InvocationMatcher(simpleMethod));invocationContainerImpl.addAnswer(new Returns("simpleMethod"));Invocation differentMethod=new InvocationBuilder().differentMethod().toInvocation();invocationContainerImpl.setInvocationForPotentialStubbing(new InvocationMatcher(differentMethod));invocationContainerImpl.addAnswer(new ThrowsException(new MyException()));assertEquals("simpleMethod",invocationContainerImpl.answerTo(simpleMethod));try {invocationContainerImpl.answerTo(differentMethod);fail();}catch(MyException e){}}
@Test public void shouldAddThrowableForVoidMethod()throws Throwable {invocationContainerImpl.addAnswerForVoidMethod(new ThrowsException(new MyException()));invocationContainerImpl.setMethodForStubbing(new InvocationMatcher(simpleMethod));try {invocationContainerImpl.answerTo(simpleMethod);fail();}catch(MyException e){}}
@Test public void shouldValidateThrowableForVoidMethod()throws Throwable {invocationContainerImpl.addAnswerForVoidMethod(new ThrowsException(new Exception()));try {invocationContainerImpl.setMethodForStubbing(new InvocationMatcher(simpleMethod));fail();}catch(MockitoException e){}}
@Test public void shouldValidateThrowable()throws Throwable {try {invocationContainerImpl.addAnswer(new ThrowsException(null));fail();}catch(MockitoException e){}}
@Test public void shouldKnowWhenStringContainsIgnoringCase()throws Exception {assertContainsIgnoringCase("foo","foo");assertContainsIgnoringCase("fOo","foo");assertContainsIgnoringCase("FoO","foo");assertContainsIgnoringCase("foo","a foo :)");assertContainsIgnoringCase("fOo","a foo :)");assertContainsIgnoringCase("FoO","a foo :)");assertContainsIgnoringCase("","a foo :)");assertContainsIgnoringCase("","");}
@Test(expected=AssertionError.class)public void shouldKnowWhenStringDoesNotContainIgnoringCase()throws Exception {assertContainsIgnoringCase("fooo","foo");}
@Test(expected=AssertionError.class)public void shouldKnowWhenStringDoesNotContainIgnoringCase2()throws Exception {assertContainsIgnoringCase("fOo","f oo");}
@Test public void sameToStringWithString(){assertEquals("same(\"X\")",describe(new Same("X")));}
@Test public void nullToString(){assertEquals("isNull()",describe(Null.NULL));}
@Test public void notNullToString(){assertEquals("notNull()",describe(NotNull.NOT_NULL));}
@Test public void anyToString(){assertEquals("<any>",describe(Any.ANY));}
@Test public void sameToStringWithChar(){assertEquals("same('x')",describe(new Same('x')));}
@Test public void sameToStringWithObject(){Object o=new Object(){@Override public String toString(){return "X";}};assertEquals("same(X)",describe(new Same(o)));}
@Test public void equalsToStringWithString(){assertEquals("\"X\"",describe(new Equals("X")));}
@Test public void equalsToStringWithChar(){assertEquals("'x'",describe(new Equals('x')));}
@Test public void equalsToStringWithObject(){Object o=new Object(){@Override public String toString(){return "X";}};assertEquals("X",describe(new Equals(o)));}
@Test public void orToString(){List<Matcher> matchers=new ArrayList<Matcher>();matchers.add(new Equals(1));matchers.add(new Equals(2));assertEquals("or(1,2)",describe(new Or(matchers)));}
@Test public void notToString(){assertEquals("not(1)",describe(new Not(new Equals(1))));}
@Test public void andToString(){List<Matcher> matchers=new ArrayList<Matcher>();matchers.add(new Equals(1));matchers.add(new Equals(2));assertEquals("and(1,2)",describe(new And(matchers)));}
@Test public void startsWithToString(){assertEquals("startsWith(\"AB\")",describe(new StartsWith("AB")));}
@Test public void endsWithToString(){assertEquals("endsWith(\"AB\")",describe(new EndsWith("AB")));}
@Test public void containsToString(){assertEquals("contains(\"AB\")",describe(new Contains("AB")));}
@Test public void findToString(){assertEquals("find(\"\\\\s+\")",describe(new Find("\\s+")));}
@Test public void matchesToString(){assertEquals("matches(\"\\\\s+\")",describe(new Matches("\\s+")));}
@Test public void shouldMarkInvocationAsVerified(){InvocationMarker marker=new InvocationMarker();Invocation i=new InvocationBuilder().toInvocation();InvocationMatcher im=new InvocationBuilder().toInvocationMatcher();assertFalse(i.isVerified());marker.markVerified(Arrays.asList(i),im);assertTrue(i.isVerified());}
@Test public void shouldCaptureArguments(){InvocationMarker marker=new InvocationMarker();Invocation i=new InvocationBuilder().toInvocation();final ObjectBox box=new ObjectBox();CapturesArgumensFromInvocation c=new CapturesArgumensFromInvocation(){public void captureArgumentsFrom(Invocation i){box.put(i);}};marker.markVerified(Arrays.asList(i),c);assertEquals(i,box.getObject());}
@Test public void shouldMarkInvocationsAsVerifiedInOrder(){InOrderContextImpl context=new InOrderContextImpl();InvocationMarker marker=new InvocationMarker();Invocation i=new InvocationBuilder().toInvocation();InvocationMatcher im=new InvocationBuilder().toInvocationMatcher();assertFalse(context.isVerified(i));assertFalse(i.isVerified());marker.markVerifiedInOrder(Arrays.asList(i),im,context);assertTrue(context.isVerified(i));assertTrue(i.isVerified());}
@Test public void shouldVerifyWithTimeout(){}
@Test public void shouldFailVerificationWithTimeout(){}
@Test public void shouldAllowMixingOtherModesWithTimeout(){}
@Test public void shouldAllowMixingOtherModesWithTimeoutAndFail(){}
@Test public void shouldAllowMixingOnlyWithTimeout(){}
@Test public void shouldAllowMixingOnlyWithTimeoutAndFail(){}
@Ignore @Test public void shouldAllowTimeoutVerificationInOrder()throws Exception {Thread t1=waitAndExerciseMock(20);t1.start();mock.add("foo");InOrder inOrder=inOrder(mock);inOrder.verify(mock).add(anyString());inOrder.verify(mock,never()).clear();inOrder.verify(mock,timeout(40)).clear();}
@Test public void shouldKnowWhenNull()throws Exception {FieldReader reader=new FieldReader(new Foo(),Foo.class.getDeclaredField("isNull"));assertTrue(reader.isNull());}
@Test public void shouldKnowWhenNotNull()throws Exception {FieldReader reader=new FieldReader(new Foo(),Foo.class.getDeclaredField("notNull"));assertFalse(reader.isNull());}
@Test public void just_for_information_fields_are_read_in_declaration_order_see_Service(){Field[]declaredFields=Service.class.getDeclaredFields();assertEquals("mockShouldNotGoInHere",declaredFields[0].getName());assertEquals("mockShouldGoInHere",declaredFields[1].getName());}
@Test public void mock_should_be_injected_once_and_in_the_best_matching_type(){assertSame(REFERENCE,illegalInjectionExample.mockShouldNotGoInHere);assertSame(mockedBean,illegalInjectionExample.mockShouldGoInHere);}
@Test public void should_match_be_consistent_regardless_of_order(){assertSame(REFERENCE,reversedOrderService.mockShouldNotGoInHere);assertSame(mockedBean,reversedOrderService.mockShouldGoInHere);}
@Test public void should_not_inject_the_object(){assertNull(withNullObjectField.keepMeNull);assertSame(mockedBean,withNullObjectField.injectMePlease);}
@Test public void returnFoo1(){ReturnsObject mock=mock(ReturnsObject.class);when(mock.callMe()).thenReturn("foo");assertEquals("foo",mock.callMe());}
@Test public void returnFoo2(){ReturnsString mock=mock(ReturnsString.class);when(mock.callMe()).thenReturn("foo");assertEquals("foo",mock.callMe());}
@Test public void returnFoo3(){ReturnsObject mock=mock(ReturnsString.class);when(mock.callMe()).thenReturn("foo");assertEquals("foo",mock.callMe());}
@Test public void returnFoo4(){ReturnsString mock=mock(ReturnsString.class);mock.callMe();ReturnsObject mock2=mock;verify(mock2).callMe();}
@Test public void test(){IMethods mock=mock(IMethods.class);mock.simpleMethod(1);mock.otherMethod();verify(mock).simpleMethod(1);throw new RuntimeException("boo");}
@Test public void shouldContainWarnings()throws Exception {Result result=new JUnitCore().run(new ContainsWarnings());assertEquals(1,result.getFailures().size());Throwable exception=result.getFailures().get(0).getException();assertTrue(exception instanceof ExceptionIncludingMockitoWarnings);}
@Test public void shouldNotContainWarnings()throws Exception {Result result=new JUnitCore().run(NoWarnings.class);assertEquals(1,result.getFailures().size());assertEquals("boo",result.getFailures().get(0).getException().getMessage());}
@Test(expected=ArgumentsAreDifferent.class)public void shouldPrintInvocationsWhenStubbingNotUsed()throws Exception {performStubbing();businessLogicWithAsking("arg");verify(mockTwo).doSomething("foo");}
@Test public void shouldFailWithUnfinishedVerification(){withFinal=mock(WithFinal.class);verify(withFinal).foo();try {verify(withFinal).foo();fail();}catch(UnfinishedVerificationException e){}}
@Test public void shouldFailWithUnfinishedStubbing(){withFinal=mock(WithFinal.class);try {when(withFinal.foo()).thenReturn(null);fail();}catch(MissingMethodInvocationException e){}}
@Test public void shouldSerializationWork()throws Exception {Foo foo=new Foo();foo=serializeAndBack(foo);assertSame(foo,foo.bar.foo);}
@Test public void shouldAllowToExcludeStubsForVerification()throws Exception {when(mock.simpleMethod()).thenReturn("foo");String stubbed=mock.simpleMethod();mock.objectArgMethod(stubbed);verify(mock).objectArgMethod("foo");try {verifyNoMoreInteractions(mock);fail();}catch(NoInteractionsWanted e){};ignoreStubs(mock);verifyNoMoreInteractions(mock);}
@Test public void shouldExcludeFromVerificationInOrder()throws Exception {when(mock.simpleMethod()).thenReturn("foo");mock.objectArgMethod("1");mock.objectArgMethod("2");mock.simpleMethod();InOrder inOrder=inOrder(ignoreStubs(mock));inOrder.verify(mock).objectArgMethod("1");inOrder.verify(mock).objectArgMethod("2");inOrder.verifyNoMoreInteractions();verifyNoMoreInteractions(mock);}
@Test(expected=NotAMockException.class)public void shouldIgnoringStubsDetectNulls()throws Exception {ignoreStubs(mock,null);}
@Test(expected=NotAMockException.class)public void shouldIgnoringStubsDetectNonMocks()throws Exception {ignoreStubs(mock,new Object());}
@Test public void shouldEvaluateLatestStubbingFirst()throws Exception {stub(mock.objectReturningMethod(isA(Integer.class))).toReturn(100);stub(mock.objectReturningMethod(200)).toReturn(200);assertEquals(200,mock.objectReturningMethod(200));assertEquals(100,mock.objectReturningMethod(666));assertEquals("default behavior should return null",null,mock.objectReturningMethod("blah"));}
@Test public void shouldStubbingBeTreatedAsInteraction()throws Exception {stub(mock.booleanReturningMethod()).toReturn(true);mock.booleanReturningMethod();try {verifyNoMoreInteractions(mock);fail();}catch(NoInteractionsWanted e){}}
@Test public void shouldAllowStubbingToString()throws Exception {IMethods mockTwo=mock(IMethods.class);stub(mockTwo.toString()).toReturn("test");assertContains("Mock for IMethods",mock.toString());assertEquals("test",mockTwo.toString());}
@Test public void shouldStubbingNotBeTreatedAsInteraction(){stub(mock.simpleMethod("one")).toThrow(new RuntimeException());stubVoid(mock).toThrow(new RuntimeException()).on().simpleMethod("two");verifyZeroInteractions(mock);}
@Test public void shouldAllowConsecutiveStubbing()throws Exception {stub(mock.simpleMethod()).toReturn("100").toReturn("200");assertEquals("100",mock.simpleMethod());assertEquals("200",mock.simpleMethod());}
@Test public void shouldAllowVerifyingInThreads()throws Exception {for (int i=0;i < 100;i++){performTest();}}
@Test public void shouldLog()throws Exception {SimpleMockitoLogger logger=new SimpleMockitoLogger();logger.log("foo");assertEquals("foo",logger.getLoggedInfo());}
@Test public void shouldReturnEmptyCollectionsOrNullForNonCollections(){assertTrue(((Collection)values.returnValueFor(Collection.class)).isEmpty());assertTrue(((Set)values.returnValueFor(Set.class)).isEmpty());assertTrue(((SortedSet)values.returnValueFor(SortedSet.class)).isEmpty());assertTrue(((HashSet)values.returnValueFor(HashSet.class)).isEmpty());assertTrue(((TreeSet)values.returnValueFor(TreeSet.class)).isEmpty());assertTrue(((LinkedHashSet)values.returnValueFor(LinkedHashSet.class)).isEmpty());assertTrue(((List)values.returnValueFor(List.class)).isEmpty());assertTrue(((ArrayList)values.returnValueFor(ArrayList.class)).isEmpty());assertTrue(((LinkedList)values.returnValueFor(LinkedList.class)).isEmpty());assertTrue(((Map)values.returnValueFor(Map.class)).isEmpty());assertTrue(((SortedMap)values.returnValueFor(SortedMap.class)).isEmpty());assertTrue(((HashMap)values.returnValueFor(HashMap.class)).isEmpty());assertTrue(((TreeMap)values.returnValueFor(TreeMap.class)).isEmpty());assertTrue(((LinkedHashMap)values.returnValueFor(LinkedHashMap.class)).isEmpty());assertNull(values.returnValueFor(String.class));}
@Test public void shouldReturnPrimitive(){assertEquals(false,values.returnValueFor(Boolean.TYPE));assertEquals((char)0,values.returnValueFor(Character.TYPE));assertEquals(0,values.returnValueFor(Byte.TYPE));assertEquals(0,values.returnValueFor(Short.TYPE));assertEquals(0,values.returnValueFor(Integer.TYPE));assertEquals(0,values.returnValueFor(Long.TYPE));assertEquals(0,values.returnValueFor(Float.TYPE));assertEquals(0,values.returnValueFor(Double.TYPE));}
@Test public void shouldReturnNonZeroForCompareToMethod(){Date d=mock(Date.class);d.compareTo(new Date());Invocation compareTo=this.getLastInvocation();Object result=values.answer(compareTo);assertTrue(result != (Object)0);}
@Test public void shouldVerifyInOrder(){NoMoreInteractions n=new NoMoreInteractions();Invocation i=new InvocationBuilder().toInvocation();assertFalse(context.isVerified(i));try {n.verifyInOrder(new VerificationDataInOrderImpl(context,asList(i),null));fail();}catch(VerificationInOrderFailure e){}}
@Test public void shouldVerifyInOrderAndPass(){NoMoreInteractions n=new NoMoreInteractions();Invocation i=new InvocationBuilder().toInvocation();context.markVerified(i);assertTrue(context.isVerified(i));n.verifyInOrder(new VerificationDataInOrderImpl(context,asList(i),null));}
@Test public void shouldVerifyInOrderMultipleInvoctions(){NoMoreInteractions n=new NoMoreInteractions();Invocation i=new InvocationBuilder().seq(1).toInvocation();Invocation i2=new InvocationBuilder().seq(2).toInvocation();context.markVerified(i2);n.verifyInOrder(new VerificationDataInOrderImpl(context,asList(i,i2),null));}
@Test public void shouldVerifyInOrderMultipleInvoctionsAndThrow(){NoMoreInteractions n=new NoMoreInteractions();Invocation i=new InvocationBuilder().seq(1).toInvocation();Invocation i2=new InvocationBuilder().seq(2).toInvocation();try {n.verifyInOrder(new VerificationDataInOrderImpl(context,asList(i,i2),null));fail();}catch(VerificationInOrderFailure e){}}
@Test public void shouldResetOngoingStubbingSoThatMoreMeaningfulExceptionsAreRaised(){mock(IMethods.class);mock.booleanReturningMethod();reset(mock);try {when(null).thenReturn("anything");fail();}catch(MissingMethodInvocationException e){}}
@Test public void shouldRemoveAllStubbing()throws Exception {when(mock.objectReturningMethod(isA(Integer.class))).thenReturn(100);when(mock.objectReturningMethod(200)).thenReturn(200);reset(mock);assertNull(mock.objectReturningMethod(200));assertEquals("default behavior should return null",null,mock.objectReturningMethod("blah"));}
@Test public void shouldRemoveAllInteractions()throws Exception {mock.simpleMethod(1);reset(mock);verifyZeroInteractions(mock);}
@Test public void shouldRemoveStubbingToString()throws Exception {IMethods mockTwo=mock(IMethods.class);when(mockTwo.toString()).thenReturn("test");reset(mockTwo);assertContains("Mock for IMethods",mockTwo.toString());}
@Test public void shouldStubbingNotBeTreatedAsInteraction(){when(mock.simpleMethod("one")).thenThrow(new RuntimeException());doThrow(new RuntimeException()).when(mock).simpleMethod("two");reset(mock);verifyZeroInteractions(mock);}
@Test public void shouldNotAffectMockName(){IMethods mock=mock(IMethods.class,"mockie");IMethods mockTwo=mock(IMethods.class);reset(mock);assertContains("Mock for IMethods","" + mockTwo);assertEquals("mockie","" + mock);}
@Test public void shouldResetMultipleMocks(){mock.simpleMethod();mockTwo.simpleMethod();reset(mock,mockTwo);verifyNoMoreInteractions(mock,mockTwo);}
@Test public void shouldValidateStateWhenResetting(){verify(mock);try {reset(mockTwo);fail();}catch(UnfinishedVerificationException e){}}
@Test public void shouldMaintainPreviousDefaultAnswer(){mock=mock(IMethods.class,RETURNS_MOCKS);reset(mock);assertNotNull(mock.iMethodsReturningMethod());}
@Test public void dummy()throws Exception {}
@Test public void shouldValidateWithDefaultRunner()throws Exception {runner=new MockitoJUnitRunner(DummyTest.class);runner.run(notifier);assertThat(notifier.addedListeners,contains(clazz(FrameworkUsageValidator.class)));}
@Test public void shouldValidateWithD44Runner()throws Exception {runner=new MockitoJUnit44Runner(DummyTest.class);runner.run(notifier);assertThat(notifier.addedListeners,contains(clazz(FrameworkUsageValidator.class)));}
@Test public void shouldValidateWithVerboseRunner()throws Exception {runner=new ConsoleSpammingMockitoJUnitRunner(DummyTest.class);runner.run(notifier);assertEquals(2,notifier.addedListeners.size());assertThat(notifier.addedListeners,contains(clazz(FrameworkUsageValidator.class)));}
@Test public void shouldPassWhenMatchingInteractionFound()throws Exception {Invocation actual=new InvocationBuilder().toInvocation();finderStub.allMatchingUnverifiedChunksToReturn.add(actual);checker.check(invocations,wanted,new VerificationModeBuilder().inOrder(),context);}
@Test public void shouldReportWantedButNotInvoked()throws Exception {assertTrue(finderStub.allMatchingUnverifiedChunksToReturn.isEmpty());checker.check(invocations,wanted,new VerificationModeBuilder().inOrder(),context);assertEquals(wanted,reporterStub.wanted);}
@Test public void shouldReportArgumentsAreDifferent()throws Exception {assertTrue(finderStub.findInvocations(invocations,wanted).isEmpty());finderStub.similarToReturn=new InvocationBuilder().toInvocation();checker.check(invocations,wanted,new VerificationModeBuilder().inOrder(),context);SmartPrinter printer=new SmartPrinter(wanted,finderStub.similarToReturn,0);assertEquals(printer.getWanted(),reporterStub.wantedString);assertEquals(printer.getActual(),reporterStub.actual);assertEquals(finderStub.similarToReturn.getLocation(),reporterStub.actualLocation);}
@Test public void shouldReportWantedDiffersFromActual()throws Exception {Invocation previous=new InvocationBuilder().toInvocation();finderStub.previousInOrderToReturn=previous;checker.check(invocations,wanted,new VerificationModeBuilder().inOrder(),context);assertEquals(wanted,reporterStub.wanted);assertEquals(previous,reporterStub.previous);}
@Test public void should_enable_and_safely_disable()throws Exception {AccessibilityChanger changer=new AccessibilityChanger();changer.enableAccess(field("whatever"));changer.safelyDisableAccess(field("whatever"));}
@Test(expected=java.lang.AssertionError.class)@Ignore("should be run only when -ea is passed to the VM")public void safelyDisableAccess_should_fail_when_enableAccess_not_called()throws Exception {new AccessibilityChanger().safelyDisableAccess(field("whatever"));}
@Test public void shouldRemoveMockitoInternalsFromStackTraceWhenRealMethodThrows()throws Throwable {FilteredCGLIBProxyRealMethod realMethod=new FilteredCGLIBProxyRealMethod(new RealMethod(){public Object invoke(Object target,Object[]arguments)throws Throwable {return new Foo().throwSomething();}});try {realMethod.invoke(null,null);fail();}catch(Exception e){assertThat(e,hasMethodInStackTraceAt(0,"throwSomething"));assertThat(e,hasMethodInStackTraceAt(1,"invoke"));assertThat(e,hasMethodInStackTraceAt(2,"shouldRemoveMockitoInternalsFromStackTraceWhenRealMethodThrows"));}}
@Test public void shouldDetectUnusedStubbingWhenPrinting()throws Exception {given(mock.giveMeSomeString("different arg")).willReturn("foo");mock.giveMeSomeString("arg");String log=NewMockito.debug().printInvocations(mock,mockTwo);assertContainsIgnoringCase("unused",log);}
@Test public void shouldNotAllowNegativeNumberOfInvocations()throws Exception {try {VerificationModeFactory.times(-50);fail();}catch(MockitoException e){assertEquals("Negative value is not allowed here",e.getMessage());}}
@Test public void shouldAllowThrowsExceptionToBeSerializable()throws Exception {Bar mock=mock(Bar.class,new ThrowsException(new RuntimeException()));serializeAndBack(mock);}
@Test public void shouldAllowMethodDelegation()throws Exception {Bar barMock=mock(Bar.class,withSettings().serializable());Foo fooMock=mock(Foo.class);when(barMock.doSomething()).thenAnswer(new ThrowsException(new RuntimeException()));serializeAndBack(barMock);}
@Test public void shouldAllowMockToBeSerializable()throws Exception {IMethods mock=mock(IMethods.class,withSettings().serializable());serializeAndBack(mock);}
@Test public void shouldAllowMockAndBooleanValueToSerializable()throws Exception {IMethods mock=mock(IMethods.class,withSettings().serializable());when(mock.booleanReturningMethod()).thenReturn(true);ByteArrayOutputStream serialized=serializeMock(mock);IMethods readObject=deserializeMock(serialized,IMethods.class);assertTrue(readObject.booleanReturningMethod());}
@Test public void shouldAllowMockAndStringValueToBeSerializable()throws Exception {IMethods mock=mock(IMethods.class,withSettings().serializable());String value="value";when(mock.stringReturningMethod()).thenReturn(value);ByteArrayOutputStream serialized=serializeMock(mock);IMethods readObject=deserializeMock(serialized,IMethods.class);assertEquals(value,readObject.stringReturningMethod());}
@Test public void shouldAllMockAndSerializableValueToBeSerialized()throws Exception {IMethods mock=mock(IMethods.class,withSettings().serializable());List<?> value=Collections.emptyList();when(mock.objectReturningMethodNoArgs()).thenReturn(value);ByteArrayOutputStream serialized=serializeMock(mock);IMethods readObject=deserializeMock(serialized,IMethods.class);assertEquals(value,readObject.objectReturningMethodNoArgs());}
@Test public void shouldSerializeMethodCallWithParametersThatAreSerializable()throws Exception {IMethods mock=mock(IMethods.class,withSettings().serializable());List<?> value=Collections.emptyList();when(mock.objectArgMethod(value)).thenReturn(value);ByteArrayOutputStream serialized=serializeMock(mock);IMethods readObject=deserializeMock(serialized,IMethods.class);assertEquals(value,readObject.objectArgMethod(value));}
@Test public void shouldSerializeMethodCallsUsingAnyStringMatcher()throws Exception {IMethods mock=mock(IMethods.class,withSettings().serializable());List<?> value=Collections.emptyList();when(mock.objectArgMethod(anyString())).thenReturn(value);ByteArrayOutputStream serialized=serializeMock(mock);IMethods readObject=deserializeMock(serialized,IMethods.class);assertEquals(value,readObject.objectArgMethod(""));}
@Test public void shouldVerifyCalledNTimesForSerializedMock()throws Exception {IMethods mock=mock(IMethods.class,withSettings().serializable());List<?> value=Collections.emptyList();when(mock.objectArgMethod(anyString())).thenReturn(value);mock.objectArgMethod("");ByteArrayOutputStream serialized=serializeMock(mock);IMethods readObject=deserializeMock(serialized,IMethods.class);verify(readObject,times(1)).objectArgMethod("");}
@Test public void shouldVerifyEvenIfSomeMethodsCalledAfterSerialization()throws Exception {IMethods mock=mock(IMethods.class,withSettings().serializable());mock.simpleMethod(1);ByteArrayOutputStream serialized=serializeMock(mock);IMethods readObject=deserializeMock(serialized,IMethods.class);readObject.simpleMethod(1);verify(readObject,times(2)).simpleMethod(1);}
@Test public void shouldSerializationWork()throws Exception {Foo foo=new Foo();foo=serializeAndBack(foo);assertSame(foo,foo.bar.foo);}
@Test public void shouldStubEvenIfSomeMethodsCalledAfterSerialization()throws Exception {IMethods mock=mock(IMethods.class,withSettings().serializable());when(mock.simpleMethod(1)).thenReturn("foo");ByteArrayOutputStream serialized=serializeMock(mock);IMethods readObject=deserializeMock(serialized,IMethods.class);when(readObject.simpleMethod(2)).thenReturn("bar");assertEquals("foo",readObject.simpleMethod(1));assertEquals("bar",readObject.simpleMethod(2));}
@Test public void shouldVerifyCallOrderForSerializedMock()throws Exception {IMethods mock=mock(IMethods.class,withSettings().serializable());IMethods mock2=mock(IMethods.class,withSettings().serializable());mock.arrayReturningMethod();mock2.arrayReturningMethod();ByteArrayOutputStream serialized=serializeMock(mock);ByteArrayOutputStream serialized2=serializeMock(mock2);IMethods readObject=deserializeMock(serialized,IMethods.class);IMethods readObject2=deserializeMock(serialized2,IMethods.class);InOrder inOrder=inOrder(readObject,readObject2);inOrder.verify(readObject).arrayReturningMethod();inOrder.verify(readObject2).arrayReturningMethod();}
@Test public void shouldRememberInteractionsForSerializedMock()throws Exception {IMethods mock=mock(IMethods.class,withSettings().serializable());List<?> value=Collections.emptyList();when(mock.objectArgMethod(anyString())).thenReturn(value);mock.objectArgMethod("happened");ByteArrayOutputStream serialized=serializeMock(mock);IMethods readObject=deserializeMock(serialized,IMethods.class);verify(readObject,never()).objectArgMethod("never happened");}
@Test public void shouldSerializeWithStubbingCallback()throws Exception {IMethods mock=mock(IMethods.class,withSettings().serializable());CustomAnswersMustImplementSerializableForSerializationToWork answer=new CustomAnswersMustImplementSerializableForSerializationToWork();answer.string="return value";when(mock.objectArgMethod(anyString())).thenAnswer(answer);ByteArrayOutputStream serialized=serializeMock(mock);IMethods readObject=deserializeMock(serialized,IMethods.class);assertEquals(answer.string,readObject.objectArgMethod(""));}
@Test public void shouldSerializeWithRealObjectSpy()throws Exception {List<Object> list=new ArrayList<Object>();List<Object> spy=mock(ArrayList.class,withSettings().spiedInstance(list).defaultAnswer(CALLS_REAL_METHODS).serializable());when(spy.size()).thenReturn(100);ByteArrayOutputStream serialized=serializeMock(spy);List<?> readObject=deserializeMock(serialized,List.class);assertEquals(100,readObject.size());}
@Test public void shouldSerializeObjectMock(){}
@Test public void shouldSerializeRealPartialMock(){}
@Test public void shouldSerializeAlreadySerializableClass()throws Exception {AlreadySerializable mock=mock(AlreadySerializable.class,withSettings().serializable());when(mock.toString()).thenReturn("foo");mock=serializeAndBack(mock);assertEquals("foo",mock.toString());}
@Test public void shouldBeSerializeAndHaveExtraInterfaces()throws Exception {IMethods mock=mock(IMethods.class,withSettings().serializable().extraInterfaces(List.class));IMethods mockTwo=mock(IMethods.class,withSettings().extraInterfaces(List.class).serializable());serializeAndBack((List)mock);serializeAndBack((List)mockTwo);}
@Test public void tryToRevealTheProblem(){ToMock toMock=mock(ToMock.class);for (int i=0;i < 100;i++){int j=i % 11;when(toMock.getValue(i)).thenReturn(j);while (true){try {this.executor.execute(getConflictingRunnable(toMock));break;}catch(RejectedExecutionException ex){fail();}}try {Thread.sleep(10 / ((i % 10)+ 1));}catch(InterruptedException e){}}}
@Test public void shouldInitSpiesInBaseClass()throws Exception {SubClass subClass=new SubClass();MockitoAnnotations.initMocks(subClass);assertTrue(isMock(subClass.list));}
@Test public void shouldInitSpiesInHierarchy()throws Exception {assertTrue(isMock(spyInSubclass));assertTrue(isMock(spyInBaseclass));}
@Test public void shouldVerifyInOrder(){inOrder.verify(mockOne).simpleMethod(1);inOrder.verify(mockTwo,times(2)).simpleMethod(2);inOrder.verify(mockThree).simpleMethod(3);inOrder.verify(mockTwo).simpleMethod(2);inOrder.verify(mockOne).simpleMethod(4);verifyNoMoreInteractions(mockOne,mockTwo,mockThree);}
@Test public void shouldVerifyInOrderUsingAtLeastOnce(){inOrder.verify(mockOne,atLeastOnce()).simpleMethod(1);inOrder.verify(mockTwo,times(2)).simpleMethod(2);inOrder.verify(mockThree).simpleMethod(3);inOrder.verify(mockTwo).simpleMethod(2);inOrder.verify(mockOne,atLeastOnce()).simpleMethod(4);verifyNoMoreInteractions(mockOne,mockTwo,mockThree);}
@Test public void shouldVerifyInOrderWhenExpectingSomeInvocationsToBeCalledZeroTimes(){inOrder.verify(mockOne,times(0)).oneArg(false);inOrder.verify(mockOne).simpleMethod(1);inOrder.verify(mockTwo,times(2)).simpleMethod(2);inOrder.verify(mockTwo,times(0)).simpleMethod(22);inOrder.verify(mockThree).simpleMethod(3);inOrder.verify(mockTwo).simpleMethod(2);inOrder.verify(mockOne).simpleMethod(4);inOrder.verify(mockThree,times(0)).oneArg(false);verifyNoMoreInteractions(mockOne,mockTwo,mockThree);}
@Test public void shouldFailWhenFirstMockCalledTwice(){inOrder.verify(mockOne).simpleMethod(1);try {inOrder.verify(mockOne).simpleMethod(1);fail();}catch(VerificationInOrderFailure e){}}
@Test public void shouldFailWhenLastMockCalledTwice(){inOrder.verify(mockOne).simpleMethod(1);inOrder.verify(mockTwo,times(2)).simpleMethod(2);inOrder.verify(mockThree).simpleMethod(3);inOrder.verify(mockTwo).simpleMethod(2);inOrder.verify(mockOne).simpleMethod(4);try {inOrder.verify(mockOne).simpleMethod(4);fail();}catch(VerificationInOrderFailure e){}}
@Test(expected=VerificationInOrderFailure.class)public void shouldFailOnFirstMethodBecauseOneInvocationWanted(){inOrder.verify(mockOne,times(0)).simpleMethod(1);}
@Test(expected=VerificationInOrderFailure.class)public void shouldFailOnFirstMethodBecauseOneInvocationWantedAgain(){inOrder.verify(mockOne,times(2)).simpleMethod(1);}
@Test public void shouldFailOnSecondMethodBecauseFourInvocationsWanted(){inOrder.verify(mockOne,times(1)).simpleMethod(1);try {inOrder.verify(mockTwo,times(4)).simpleMethod(2);fail();}catch(VerificationInOrderFailure e){}}
@Test public void shouldFailOnSecondMethodBecauseTwoInvocationsWantedAgain(){inOrder.verify(mockOne,times(1)).simpleMethod(1);try {inOrder.verify(mockTwo,times(0)).simpleMethod(2);fail();}catch(VerificationInOrderFailure e){}}
@Test public void shouldFailOnLastMethodBecauseOneInvocationWanted(){inOrder.verify(mockOne,atLeastOnce()).simpleMethod(1);inOrder.verify(mockTwo,times(2)).simpleMethod(2);inOrder.verify(mockThree,atLeastOnce()).simpleMethod(3);inOrder.verify(mockTwo,atLeastOnce()).simpleMethod(2);try {inOrder.verify(mockOne,times(0)).simpleMethod(4);fail();}catch(VerificationInOrderFailure e){}}
@Test public void shouldFailOnLastMethodBecauseOneInvocationWantedAgain(){inOrder.verify(mockOne,atLeastOnce()).simpleMethod(1);inOrder.verify(mockTwo,times(2)).simpleMethod(2);inOrder.verify(mockThree,atLeastOnce()).simpleMethod(3);inOrder.verify(mockTwo,atLeastOnce()).simpleMethod(2);try {inOrder.verify(mockOne,times(2)).simpleMethod(4);fail();}catch(VerificationInOrderFailure e){}}
@Test(expected=ArgumentsAreDifferent.class)public void shouldFailOnFirstMethodBecauseDifferentArgsWanted(){inOrder.verify(mockOne).simpleMethod(100);}
@Test(expected=WantedButNotInvoked.class)public void shouldFailOnFirstMethodBecauseDifferentMethodWanted(){inOrder.verify(mockOne).oneArg(true);}
@Test public void shouldFailOnSecondMethodBecauseDifferentArgsWanted(){inOrder.verify(mockOne).simpleMethod(1);try {inOrder.verify(mockTwo,times(2)).simpleMethod(-999);fail();}catch(VerificationInOrderFailure e){}}
@Test public void shouldFailOnSecondMethodBecauseDifferentMethodWanted(){inOrder.verify(mockOne,times(1)).simpleMethod(1);try {inOrder.verify(mockTwo,times(2)).oneArg(true);fail();}catch(VerificationInOrderFailure e){}}
@Test public void shouldFailOnLastMethodBecauseDifferentArgsWanted(){inOrder.verify(mockOne).simpleMethod(1);inOrder.verify(mockTwo,times(2)).simpleMethod(2);inOrder.verify(mockThree).simpleMethod(3);inOrder.verify(mockTwo).simpleMethod(2);try {inOrder.verify(mockOne).simpleMethod(-666);fail();}catch(VerificationInOrderFailure e){}}
@Test public void shouldFailOnLastMethodBecauseDifferentMethodWanted(){inOrder.verify(mockOne).simpleMethod(1);inOrder.verify(mockTwo,times(2)).simpleMethod(2);inOrder.verify(mockThree).simpleMethod(3);inOrder.verify(mockTwo).simpleMethod(2);try {inOrder.verify(mockOne).oneArg(false);fail();}catch(VerificationInOrderFailure e){}}
@Test public void shouldFailWhenLastMethodVerifiedFirst(){inOrder.verify(mockOne).simpleMethod(4);try {inOrder.verify(mockOne).simpleMethod(1);fail();}catch(VerificationInOrderFailure e){}}
@Test public void shouldFailWhenMiddleMethodVerifiedFirst(){inOrder.verify(mockTwo,times(2)).simpleMethod(2);try {inOrder.verify(mockOne).simpleMethod(1);fail();}catch(VerificationInOrderFailure e){}}
@Test public void shouldFailWhenMiddleMethodVerifiedFirstInAtLeastOnceMode(){inOrder.verify(mockTwo,atLeastOnce()).simpleMethod(2);try {inOrder.verify(mockOne).simpleMethod(1);fail();}catch(VerificationInOrderFailure e){}}
@Test public void shouldFailOnVerifyNoMoreInteractions(){inOrder.verify(mockOne).simpleMethod(1);inOrder.verify(mockTwo,times(2)).simpleMethod(2);inOrder.verify(mockThree).simpleMethod(3);inOrder.verify(mockTwo).simpleMethod(2);try {verifyNoMoreInteractions(mockOne,mockTwo,mockThree);fail();}catch(NoInteractionsWanted e){}}
@Test(expected=NoInteractionsWanted.class)public void shouldFailOnVerifyZeroInteractions(){verifyZeroInteractions(mockOne);}
@SuppressWarnings("all")@Test(expected=MockitoException.class)public void shouldScreamWhenNullPassed(){inOrder(null);}
@Test public void shouldPassWhenVerificationPasses(){Timeout t=new Timeout(1,3,mode);doNothing().when(mode).verify(data);t.verify(data);}
@Test public void shouldFailBecauseVerificationFails(){Timeout t=new Timeout(1,2,mode);doThrow(error).doThrow(error).doThrow(error).when(mode).verify(data);try {t.verify(data);fail();}catch(MockitoAssertionError e){}}
@Test public void shouldPassEvenIfFirstVerificationFails(){Timeout t=new Timeout(1,2,mode);doThrow(error).doThrow(error).doNothing().when(mode).verify(data);t.verify(data);}
@Test public void shouldTryToVerifyCorrectNumberOfTimes(){Timeout t=new Timeout(1,4,mode);doThrow(error).when(mode).verify(data);try {t.verify(data);fail();}catch(MockitoAssertionError e){};verify(mode,times(5)).verify(data);}
@Test public void shouldCreateCorrectType(){Timeout t=new Timeout(25,50,mode);assertCorrectMode(t.atLeastOnce(),Timeout.class,50,25,AtLeast.class);assertCorrectMode(t.atLeast(5),Timeout.class,50,25,AtLeast.class);assertCorrectMode(t.times(5),Timeout.class,50,25,Times.class);assertCorrectMode(t.never(),Timeout.class,50,25,Times.class);assertCorrectMode(t.only(),Timeout.class,50,25,Only.class);}
@Test public void shouldInitSpies()throws Exception {doReturn("foo").when(spiedList).get(10);assertEquals("foo",spiedList.get(10));assertTrue(spiedList.isEmpty());}
@Test public void shouldInitSpyIfNestedStaticClass()throws Exception {assertNotNull(staticTypeWithNoArgConstructor);assertNotNull(staticTypeWithoutDefinedConstructor);}
@Test public void shouldFailIfTypeIsAnInterface()throws Exception {class FailingSpy {@Spy private List spyTypeIsInterface;}try {MockitoAnnotations.initMocks(new FailingSpy());fail();}catch(Exception e){Assertions.assertThat(e.getMessage()).contains("an interface");}}
@Test public void shouldReportWhenNoArgConstructor()throws Exception {class FailingSpy {@Spy NoValidConstructor noValidConstructor;}try {MockitoAnnotations.initMocks(new FailingSpy());fail();}catch(Exception e){Assertions.assertThat(e.getMessage()).contains("default constructor");}}
@Test public void shouldReportWhenConstructorThrows()throws Exception {class FailingSpy {@Spy ThrowingConstructor throwingConstructor;}try {MockitoAnnotations.initMocks(new FailingSpy());fail();}catch(Exception e){Assertions.assertThat(e.getMessage()).contains("raised an exception");}}
@Test public void shouldFailIfTypeIsAbstract()throws Exception {class FailingSpy {@Spy private AbstractList spyTypeIsAbstract;}try {MockitoAnnotations.initMocks(new FailingSpy());fail();}catch(Exception e){Assertions.assertThat(e.getMessage()).contains("abstract class");}}
@Test public void shouldFailIfTypeIsInnerClass()throws Exception {class FailingSpy {@Spy private TheInnerClass spyTypeIsInner;class TheInnerClass {}}try {MockitoAnnotations.initMocks(new FailingSpy());fail();}catch(MockitoException e){Assertions.assertThat(e.getMessage()).contains("inner class");}}
@Test(expected=IndexOutOfBoundsException.class)public void shouldResetSpies()throws Exception {spiedList.get(10);}
@Test public void should_return_object_matching_given_types()throws Exception {ConstructorInjection.SimpleArgumentResolver resolver=new ConstructorInjection.SimpleArgumentResolver(newSetOf(new HashSet(),new ByteArrayOutputStream(),new HashMap()));Object[]resolvedInstance=resolver.resolveTypeInstances(Set.class,Map.class,OutputStream.class);assertEquals(3,resolvedInstance.length);assertTrue(resolvedInstance[0]instanceof Set);assertTrue(resolvedInstance[1]instanceof Map);assertTrue(resolvedInstance[2]instanceof OutputStream);}
@Test public void should_return_null_when_match_is_not_possible_on_given_types()throws Exception {ConstructorInjection.SimpleArgumentResolver resolver=new ConstructorInjection.SimpleArgumentResolver(newSetOf(new HashSet(),new ByteArrayOutputStream()));Object[]resolvedInstance=resolver.resolveTypeInstances(Set.class,Map.class,OutputStream.class);assertEquals(3,resolvedInstance.length);assertTrue(resolvedInstance[0]instanceof Set);assertNull(resolvedInstance[1]);assertTrue(resolvedInstance[2]instanceof OutputStream);}
@Test public void should_return_null_when_types_are_primitives()throws Exception {ConstructorInjection.SimpleArgumentResolver resolver=new ConstructorInjection.SimpleArgumentResolver(newSetOf(new HashMap(),new TreeSet()));Object[]resolvedInstance=resolver.resolveTypeInstances(Set.class,Map.class,Boolean.class);assertEquals(3,resolvedInstance.length);assertTrue(resolvedInstance[0]instanceof Set);assertTrue(resolvedInstance[1]instanceof Map);assertNull(resolvedInstance[2]);}
@Test public void shouldMockPackageProtectedClasses(){mock(PackageProtected.class);mock(Foo.class);mock(Bar.class);}
@Test public void shouldConcatenateItemToAnEmptyArray()throws Exception {Class<?>[]items=utils.concat(new Class[0],List.class);Assertions.assertThat(items).containsOnly(List.class);}
@Test public void shouldConcatenateItemToFullArray()throws Exception {Class<?>[]items=utils.concat(new Class[]{Serializable.class,Map.class},List.class);Assertions.assertThat(items).containsOnly(Serializable.class,Map.class,List.class);}
@Test public void shouldAllowVerifyingWhenOtherMockCallIsInTheSameLine(){when(mock.otherMethod()).thenReturn("foo");mockTwo.simpleMethod("foo");verify(mockTwo).simpleMethod(mock.otherMethod());try {verify(mockTwo,never()).simpleMethod(mock.otherMethod());fail();}catch(NeverWantedButInvoked e){}}
@Test public void shouldShareState()throws Exception {ThreadSafeMockingProgress p=new ThreadSafeMockingProgress();p.verificationStarted(new DummyVerificationMode());p=new ThreadSafeMockingProgress();assertNotNull(p.pullVerificationMode());}
@Test public void shouldKnowWhenVerificationHasStarted()throws Exception {verify(mock(List.class));ThreadSafeMockingProgress p=new ThreadSafeMockingProgress();assertNotNull(p.pullVerificationMode());}
@Test public void shouldVerifyAtLeastXTimes()throws Exception {mock.clear();mock.clear();mock.clear();verify(mock,atLeast(2)).clear();}
@Test public void shouldFailVerifiationAtLeastXTimes()throws Exception {mock.add("one");verify(mock,atLeast(1)).add(anyString());try {verify(mock,atLeast(2)).add(anyString());fail();}catch(MockitoAssertionError e){}}
@Test public void shouldAllowAtLeastZeroForTheSakeOfVerifyNoMoreInteractionsSometimes()throws Exception {mock.add("one");mock.clear();verify(mock,atLeast(0)).add("one");verify(mock,atLeast(0)).clear();verifyNoMoreInteractions(mock);}
@Test public void testCompleteProgress()throws Exception {IProgressMonitor progressMonitor=mock(IProgressMonitor.class);progressMonitor.beginTask("foo",12);progressMonitor.worked(10);progressMonitor.done();verify(progressMonitor).beginTask(anyString(),anyInt());verify(progressMonitor,atLeastOnce()).worked(anyInt());}
@Test public void shouldMatchWhenFieldValuesEqual()throws Exception {Child wanted=new Child(1,"foo",2,"bar");verify(mock).run(refEq(wanted));}
@Test(expected=ArgumentsAreDifferent.class)public void shouldNotMatchWhenFieldValuesDiffer()throws Exception {Child wanted=new Child(1,"foo",2,"bar XXX");verify(mock).run(refEq(wanted));}
@Test(expected=ArgumentsAreDifferent.class)public void shouldNotMatchAgain()throws Exception {Child wanted=new Child(1,"foo",999,"bar");verify(mock).run(refEq(wanted));}
@Test(expected=ArgumentsAreDifferent.class)public void shouldNotMatchYetAgain()throws Exception {Child wanted=new Child(1,"XXXXX",2,"bar");verify(mock).run(refEq(wanted));}
@Test(expected=ArgumentsAreDifferent.class)public void shouldNotMatch()throws Exception {Child wanted=new Child(234234,"foo",2,"bar");verify(mock).run(refEq(wanted));}
@Test public void shouldMatchWhenFieldValuesEqualWithOneFieldExcluded()throws Exception {Child wanted=new Child(1,"foo",2,"excluded");verify(mock).run(refEq(wanted,"childFieldTwo"));}
@Test public void shouldMatchWhenFieldValuesEqualWithTwoFieldsExcluded()throws Exception {Child wanted=new Child(234234,"foo",2,"excluded");verify(mock).run(refEq(wanted,"childFieldTwo","parentField"));verify(mock).run(refEq(wanted,"parentField","childFieldTwo"));}
@Test(expected=ArgumentsAreDifferent.class)public void shouldNotMatchWithFieldsExclusion()throws Exception {Child wanted=new Child(234234,"foo",2,"excluded");verify(mock).run(refEq(wanted,"childFieldTwo"));}
@Test public void shouldNotThrowCCE(){mock.simpleMethod(new Object());try {verify(mock).simpleMethod(argThat(isStringWithTextFoo()));fail();}catch(ArgumentsAreDifferent e){}}
@Test public void shouldDetectTooLittleActualInvocations()throws Exception {mock.clear();mock.clear();verify(mock,times(2)).clear();try {verify(mock,times(100)).clear();fail();}catch(TooLittleActualInvocations e){assertContains("Wanted 100 times",e.getMessage());assertContains("was 2",e.getMessage());}}
@Test public void shouldDetectTooManyActualInvocations()throws Exception {mock.clear();mock.clear();verify(mock,times(2)).clear();try {verify(mock,times(1)).clear();fail();}catch(TooManyActualInvocations e){assertContains("Wanted 1 time",e.getMessage());assertContains("was 2 times",e.getMessage());}}
@Test public void shouldDetectActualInvocationsCountIsMoreThanZero()throws Exception {verify(mock,times(0)).clear();try {verify(mock,times(15)).clear();fail();}catch(WantedButNotInvoked e){}}
@Test public void shouldDetectActuallyCalledOnce()throws Exception {mock.clear();try {verify(mock,times(0)).clear();fail();}catch(NeverWantedButInvoked e){assertContains("Never wanted here",e.getMessage());}}
@Test public void shouldPassWhenMethodsActuallyNotCalled()throws Exception {verify(mock,times(0)).clear();verify(mock,times(0)).add("yes,I wasn't called");}
@Test public void shouldNotCountInStubbedInvocations()throws Exception {when(mock.add("test")).thenReturn(false);when(mock.add("test")).thenReturn(true);mock.add("test");mock.add("test");verify(mock,times(2)).add("test");}
@Test public void shouldAllowVerifyingInteractionNeverHappened()throws Exception {mock.add("one");verify(mock,never()).add("two");verify(mock,never()).clear();try {verify(mock,never()).add("one");fail();}catch(NeverWantedButInvoked e){}}
@Test public void shouldAllowVerifyingInteractionNeverHappenedInOrder()throws Exception {mock.add("one");mock.add("two");InOrder inOrder=inOrder(mock);inOrder.verify(mock,never()).add("xxx");inOrder.verify(mock).add("one");inOrder.verify(mock,never()).add("one");try {inOrder.verify(mock,never()).add("two");fail();}catch(VerificationInOrderFailure e){}}
@Test public void shouldHaveBridgeMethod()throws Exception {Super s=new Sub();assertEquals("Dummy says: Hello",s.say("Hello"));assertThat(Sub.class,hasBridgeMethod("say"));assertThat(s,hasBridgeMethod("say"));}
@Test public void shouldVerifyCorrectlyWhenBridgeMethodCalled()throws Exception {Sub s=mock(Sub.class);setMockWithDownCast(s);say("Hello");verify(s).say("Hello");}
@Test public void shouldNotAllowExtraInterfaceThatIsTheSameAsTheMockedType()throws Exception {try {validator.validateExtraInterfaces(IMethods.class,new Class<?>[]{IMethods.class});fail();}catch(MockitoException e){assertContains("You mocked following type: IMethods",e.getMessage());}}
@Test public void shouldNotAllowsInconsistentTypes()throws Exception {try {validator.validateMockedType(List.class,new ArrayList());fail();}catch(MockitoException e){}}
@Test public void shouldAllowOnlyConsistentTypes()throws Exception {validator.validateMockedType(ArrayList.class,new ArrayList());}
@Test public void shouldValidationBeSafeWhenNullsPassed()throws Exception {validator.validateMockedType(null,new ArrayList());validator.validateMockedType(ArrayList.class,null);}
@Test public void tellHandyReturnValuesToReturnValueFor()throws Exception {final Object expected=new Object();ArgumentCaptor<Object> argumentCaptor=ArgumentCaptor.forClass(Object.class);argumentCaptor.handyReturnValues=new HandyReturnValues(){@Override public <T>T returnFor(Class<T> clazz){return (T)expected;}};Object returned=argumentCaptor.capture();assertEquals(expected,returned);}
@Ignore("prototyping new feature that allows to avoid eq()matchers when raw args passed")@Test public void shouldAllowMixingRawArgumentsWithMatchers(){mock.varargs("1","2","3");verify(mock).varargs("1",anyString(),"3");verify(mock).varargs(anyBoolean(),false);}
@Test(expected=TooLittleActualInvocations.class)public void shouldLetPassingNullLastActualStackTrace()throws Exception {new Reporter().tooLittleActualInvocations(new Discrepancy(1,2),new InvocationBuilder().toInvocation(),null);}
@Test(expected=MockitoException.class)public void shouldThrowCorrectExceptionForNullInvocationListener()throws Exception {new Reporter().invocationListenerDoesNotAcceptNullParameters();}
@Test public void shouldFailIfCaptorHasWrongType()throws Exception {try {MockitoAnnotations.initMocks(this);fail();}catch(MockitoException e){assertContains("notACaptorField",e.getMessage());assertContains("wrong type",e.getMessage());}}
@SuppressWarnings("all")@Test public void tryDescriptiveMessagesOnMisuse(){Foo foo=mock(Foo.class);}
@Test(expected=NotAMockException.class)public void shouldScreamWhenWholeMethodPassedToVerify(){verify(mock.booleanReturningMethod());}
@Test(expected=NotAMockException.class)public void shouldScreamWhenWholeMethodPassedToVerifyNoMoreInteractions(){verifyNoMoreInteractions(mock.byteReturningMethod());}
@Test(expected=NotAMockException.class)public void shouldScreamWhenInOrderCreatedWithDodgyMock(){inOrder("not a mock");}
@Test(expected=NullInsteadOfMockException.class)public void shouldScreamWhenInOrderCreatedWithNulls(){inOrder(mock,null);}
@Test(expected=NullInsteadOfMockException.class)public void shouldScreamNullPassedToVerify(){verify(null);}
@Test(expected=NullInsteadOfMockException.class)public void shouldScreamWhenNotMockPassedToVerifyNoMoreInteractions(){verifyNoMoreInteractions(null,"blah");}
@SuppressWarnings("all")@Test(expected=MockitoException.class)public void shouldScreamWhenNullPassedToVerifyNoMoreInteractions(){verifyNoMoreInteractions(null);}
@Test public void shouldBeSerializable()throws Exception {ByteArrayOutputStream serialized=new ByteArrayOutputStream();new ObjectOutputStream(serialized).writeObject(method);}
@Test public void shouldBeAbleToRetrieveMethodExceptionTypes()throws Exception {assertArrayEquals(toStringMethod.getExceptionTypes(),method.getExceptionTypes());}
@Test public void shouldBeAbleToRetrieveMethodName()throws Exception {assertEquals(toStringMethod.getName(),method.getName());}
@Test public void shouldBeAbleToCheckIsArgVargs()throws Exception {assertEquals(toStringMethod.isVarArgs(),method.isVarArgs());}
@Test public void shouldBeAbleToGetParameterTypes()throws Exception {assertArrayEquals(toStringMethod.getParameterTypes(),method.getParameterTypes());}
@Test public void shouldBeAbleToGetReturnType()throws Exception {assertEquals(toStringMethod.getReturnType(),method.getReturnType());}
@Test public void shouldBeEqualForTwoInstances()throws Exception {assertTrue(new SerializableMethod(toStringMethod).equals(method));}
@Test public void shouldNotBeEqualForSameMethodFromTwoDifferentClasses()throws Exception {Method testBaseToStringMethod=String.class.getMethod("toString",args);assertFalse(new SerializableMethod(testBaseToStringMethod).equals(method));}
@Test public void shouldToStringBeNotVerifiable()throws Exception {InvocationMatcher toString=new InvocationBuilder().method("toString").toInvocationMatcher();try {new VerificationDataImpl(null,toString);fail();}catch(MockitoException e){}}
@Test public void shouldVerify()throws Exception {mock.clear();verify(mock).clear();mock.add("test");verify(mock).add("test");verifyNoMoreInteractions(mock);}
@Test(expected=WantedButNotInvoked.class)public void shouldFailVerification()throws Exception {verify(mock).clear();}
@Test public void shouldFailVerificationOnMethodArgument()throws Exception {mock.clear();mock.add("foo");verify(mock).clear();try {verify(mock).add("bar");fail();}catch(AssertionError expected){}}
@Test public void shouldFailOnWrongMethod()throws Exception {mock.clear();mock.clear();mockTwo.add("add");verify(mock,atLeastOnce()).clear();verify(mockTwo,atLeastOnce()).add("add");try {verify(mockTwo,atLeastOnce()).add("foo");fail();}catch(WantedButNotInvoked e){}}
@Test public void shouldDetectRedundantInvocation()throws Exception {mock.clear();mock.add("foo");mock.add("bar");verify(mock).clear();verify(mock).add("foo");try {verifyNoMoreInteractions(mock);fail();}catch(NoInteractionsWanted e){}}
@Test public void shouldDetectWhenInvokedMoreThanOnce()throws Exception {mock.add("foo");mock.clear();mock.clear();verify(mock).add("foo");try {verify(mock).clear();fail();}catch(TooManyActualInvocations e){}}
@Test public void shouldVerifyStubbedMethods()throws Exception {when(mock.add("test")).thenReturn(Boolean.FALSE);mock.add("test");verify(mock).add("test");}
@Test public void shouldDetectWhenOverloadedMethodCalled()throws Exception {IMethods mockThree=mock(IMethods.class);mockThree.varargs((Object[])new Object[]{});try {verify(mockThree).varargs((String[])new String[]{});fail();}catch(WantedButNotInvoked e){}}
@Test public void shouldVerifyAllInvocationsInOrder(){InOrder inOrder=inOrder(mockOne,mockTwo,mockThree);inOrder.verify(mockOne).simpleMethod(1);inOrder.verify(mockTwo,times(2)).simpleMethod(2);inOrder.verify(mockThree).simpleMethod(3);inOrder.verify(mockTwo).simpleMethod(2);inOrder.verify(mockOne).simpleMethod(4);verifyNoMoreInteractions(mockOne,mockTwo,mockThree);}
@Test public void shouldVerifyInOrderMockTwoAndThree(){InOrder inOrder=inOrder(mockTwo,mockThree);inOrder.verify(mockTwo,times(2)).simpleMethod(2);inOrder.verify(mockThree).simpleMethod(3);inOrder.verify(mockTwo).simpleMethod(2);verifyNoMoreInteractions(mockTwo,mockThree);}
@Test public void shouldVerifyInOrderMockOneAndThree(){InOrder inOrder=inOrder(mockOne,mockThree);inOrder.verify(mockOne).simpleMethod(1);inOrder.verify(mockThree).simpleMethod(3);inOrder.verify(mockOne).simpleMethod(4);verifyNoMoreInteractions(mockOne,mockThree);}
@Test public void shouldVerifyMockOneInOrder(){InOrder inOrder=inOrder(mockOne);inOrder.verify(mockOne).simpleMethod(1);inOrder.verify(mockOne).simpleMethod(4);verifyNoMoreInteractions(mockOne);}
@Test public void shouldFailVerificationForMockOne(){InOrder inOrder=inOrder(mockOne);inOrder.verify(mockOne).simpleMethod(1);try {inOrder.verify(mockOne).differentMethod();fail();}catch(VerificationInOrderFailure e){}}
@Test public void shouldFailVerificationForMockOneBecauseOfWrongOrder(){InOrder inOrder=inOrder(mockOne);inOrder.verify(mockOne).simpleMethod(4);try {inOrder.verify(mockOne).simpleMethod(1);fail();}catch(VerificationInOrderFailure e){}}
@Test public void shouldVerifyMockTwoWhenThreeTimesUsed(){InOrder inOrder=inOrder(mockTwo);inOrder.verify(mockTwo,times(3)).simpleMethod(2);verifyNoMoreInteractions(mockTwo);}
@Test public void shouldVerifyMockTwo(){InOrder inOrder=inOrder(mockTwo);inOrder.verify(mockTwo,atLeastOnce()).simpleMethod(2);verifyNoMoreInteractions(mockTwo);}
@Test public void shouldFailVerificationForMockTwo(){InOrder inOrder=inOrder(mockTwo);try {inOrder.verify(mockTwo).simpleMethod(2);fail();}catch(VerificationInOrderFailure e){}}
@Test public void shouldThrowNoMoreInvocationsForMockTwo(){InOrder inOrder=inOrder(mockTwo);try {inOrder.verify(mockTwo,times(2)).simpleMethod(2);fail();}catch(VerificationInOrderFailure e){}}
@Test public void shouldThrowTooLittleInvocationsForMockTwo(){InOrder inOrder=inOrder(mockTwo);try {inOrder.verify(mockTwo,times(4)).simpleMethod(2);fail();}catch(VerificationInOrderFailure e){}}
@Test public void shouldThrowTooManyInvocationsForMockTwo(){InOrder inOrder=inOrder(mockTwo);try {inOrder.verify(mockTwo,times(2)).simpleMethod(2);fail();}catch(VerificationInOrderFailure e){}}
@Test public void shouldAllowThreeTimesOnMockTwo(){InOrder inOrder=inOrder(mockTwo);inOrder.verify(mockTwo,times(3)).simpleMethod(2);verifyNoMoreInteractions(mockTwo);}
@Test public void shouldVerifyMockTwoCompletely(){InOrder inOrder=inOrder(mockTwo,mockThree);inOrder.verify(mockTwo,times(2)).simpleMethod(2);inOrder.verify(mockThree).simpleMethod(3);inOrder.verify(mockTwo).simpleMethod(2);verifyNoMoreInteractions(mockTwo,mockThree);}
@Test public void shouldAllowTwoTimesOnMockTwo(){InOrder inOrder=inOrder(mockTwo,mockThree);inOrder.verify(mockTwo,times(2)).simpleMethod(2);try {verifyNoMoreInteractions(mockTwo);fail();}catch(NoInteractionsWanted e){}}
@Test public void shouldVerifyUsingMatchers()throws Exception {List list=Mockito.mock(List.class);HashMap map=Mockito.mock(HashMap.class);list.add("test");list.add(1,"test two");map.put("test",100);map.put("test two",200);verify(list).add(anyObject());verify(list).add(anyInt(),eq("test two"));verify(map,times(2)).put(anyObject(),anyObject());verify(map).put(eq("test two"),eq(200));verifyNoMoreInteractions(list,map);}
@Test public void shouldVerifyMultipleMocks()throws Exception {List list=mock(List.class);Map map=mock(Map.class);Set set=mock(Set.class);list.add("one");list.add("one");list.add("two");map.put("one",1);map.put("one",1);verify(list,times(2)).add("one");verify(list,times(1)).add("two");verify(list,times(0)).add("three");verify(map,times(2)).put(anyObject(),anyInt());verifyNoMoreInteractions(list,map);verifyZeroInteractions(set);}
@Test public void shouldValidateExplicitly(){verify(mock);try {Mockito.validateMockitoUsage();fail();}catch(UnfinishedVerificationException e){}}
@Test public void shouldDetectUnfinishedStubbing(){when(mock.simpleMethod());try {Mockito.validateMockitoUsage();fail();}catch(UnfinishedStubbingException e){}}
@Test public void shouldDetectMisplacedArgumentMatcher(){anyObject();try {Mockito.validateMockitoUsage();fail();}catch(InvalidUseOfMatchersException e){}}
@Test public void someTest(){}
@Test public void shouldKnowWhenClassHasTests(){assertTrue(new TestMethodsFinder().hasTestMethods(HasTests.class));assertFalse(new TestMethodsFinder().hasTestMethods(DoesNotHaveTests.class));}
@Test public void shouldAllowInlineMockCreation(){when(list.get(0)).thenReturn(mock(Set.class));assertTrue(list.get(0)instanceof Set);}
@Test public void shouldUseCustomAnnotation(){assertEquals("SmartMock should return empty String by default","",smartMock.simpleMethod(1));verify(smartMock).simpleMethod(1);}
@Test public void shouldAllowVerifyingInThreads()throws Exception {for (int i=0;i < 100;i++){performTest();}}
@Test public void shouldDetectWrongNumberOfMatchersWhenStubbing(){Mockito.when(mock.threeArgumentMethod(1,"2","3")).thenReturn(null);try {Mockito.when(mock.threeArgumentMethod(1,eq("2"),"3")).thenReturn(null);fail();}catch(InvalidUseOfMatchersException e){}}
@Test public void shouldDetectStupidUseOfMatchersWhenVerifying(){mock.oneArg(true);eq("that's the stupid way");eq("of using matchers");try {Mockito.verify(mock).oneArg(true);fail();}catch(InvalidUseOfMatchersException e){}}
@Test public void shouldScreamWhenMatchersAreInvalid(){mock.simpleMethod(AdditionalMatchers.not(eq("asd")));try {mock.simpleMethod(AdditionalMatchers.not("jkl"));fail();}catch(InvalidUseOfMatchersException e){assertContains("No matchers found for Not(?).",e.getMessage());}try {mock.simpleMethod(AdditionalMatchers.or(eq("jkl"),"asd"));fail();}catch(InvalidUseOfMatchersException e){assertContains("2 matchers expected,1 recorded.",e.getMessage());}try {mock.threeArgumentMethod(1,"asd",eq("asd"));fail();}catch(InvalidUseOfMatchersException e){assertContains("3 matchers expected,1 recorded.",e.getMessage());}}
@Test public void shouldWork()throws Exception {Object o=new Object();set.add(o);assertTrue(set.contains(o));assertFalse(set.contains(new Object()));}
@Test public void shouldWorkEvenIfEqualsTheSame()throws Exception {assertEquals(new Fake(),new Fake());Fake fake=new Fake();set.add(fake);assertTrue(set.contains(fake));assertFalse(set.contains(new Fake()));}
@Test public void shouldPassIfWantedIsZeroAndMatchingChunkIsEmpty()throws Exception {assertTrue(finderStub.validMatchingChunkToReturn.isEmpty());checker.check(invocations,wanted,0,context);}
@Test public void shouldPassIfChunkMatches()throws Exception {finderStub.validMatchingChunkToReturn.add(wanted.getInvocation());checker.check(invocations,wanted,1,context);}
@Test public void shouldReportTooLittleInvocations()throws Exception {Invocation first=new InvocationBuilder().toInvocation();Invocation second=new InvocationBuilder().toInvocation();finderStub.validMatchingChunkToReturn.addAll(asList(first,second));try {checker.check(invocations,wanted,4,context);fail();}catch(VerificationInOrderFailure e){assertContains("Wanted 4 times",e.getMessage());assertContains("But was 2 times",e.getMessage());}}
@Test public void shouldReportTooManyInvocations()throws Exception {Invocation first=new InvocationBuilder().toInvocation();Invocation second=new InvocationBuilder().toInvocation();finderStub.validMatchingChunkToReturn.addAll(asList(first,second));try {checker.check(invocations,wanted,1,context);fail();}catch(VerificationInOrderFailure e){assertContains("Wanted 1 time",e.getMessage());assertContains("But was 2 times",e.getMessage());}}
@Test public void shouldMarkAsVerifiedInOrder()throws Exception {Invocation invocation=new InvocationBuilder().toInvocation();assertFalse(context.isVerified(invocation));finderStub.validMatchingChunkToReturn.addAll(asList(invocation));checker.check(invocations,wanted,1,context);assertTrue(context.isVerified(invocation));}
@Test public void shouldPrintInvocations(){Invocation verified=new InvocationBuilder().simpleMethod().verified().toInvocation();Invocation unverified=new InvocationBuilder().differentMethod().toInvocation();String out=sp.print((List)asList(verified,unverified));assertContains("1. -> at",out);assertContains("2. [?]-> at",out);}
@Test public void shouldNotPrintInvocationsWhenSingleUnwanted(){Invocation unverified=new InvocationBuilder().differentMethod().toInvocation();String out=sp.print((List)asList(unverified));assertContains("Actually,above is the only interaction with this mock.",out);}
@Test public void shouldCompareToBeConsistentWithEquals(){Date today=mock(Date.class);Date tomorrow=mock(Date.class);Set<Date> set=new TreeSet<Date>();set.add(today);set.add(tomorrow);assertEquals(2,set.size());}
@Test public void shouldAllowStubbingAndVerifyingCompareTo(){Date mock=mock(Date.class);when(mock.compareTo(any(Date.class))).thenReturn(10);mock.compareTo(new Date());assertEquals(10,mock.compareTo(new Date()));verify(mock,atLeastOnce()).compareTo(any(Date.class));}
@Test public void shouldResetNotRemoveDefaultStubbing(){Date mock=mock(Date.class);reset(mock);assertEquals(1,mock.compareTo(new Date()));}
@Test public void shouldStub()throws Exception {given(mock.simpleMethod("foo")).willReturn("bar");assertEquals("bar",mock.simpleMethod("foo"));assertEquals(null,mock.simpleMethod("whatever"));}
@Test public void shouldStubWithThrowable()throws Exception {given(mock.simpleMethod("foo")).willThrow(new RuntimeException());try {assertEquals("foo",mock.simpleMethod("foo"));fail();}catch(RuntimeException e){}}
@Test public void shouldStubWithThrowableClass()throws Exception {given(mock.simpleMethod("foo")).willThrow(RuntimeException.class);try {assertEquals("foo",mock.simpleMethod("foo"));fail();}catch(RuntimeException e){}}
@Test public void shouldStubWithAnswer()throws Exception {given(mock.simpleMethod(anyString())).willAnswer(new Answer<String>(){public String answer(InvocationOnMock invocation)throws Throwable {return (String)invocation.getArguments()[0];}});assertEquals("foo",mock.simpleMethod("foo"));}
@Test public void shouldStubWithWillAnswerAlias()throws Exception {given(mock.simpleMethod(anyString())).will(new Answer<String>(){public String answer(InvocationOnMock invocation)throws Throwable {return (String)invocation.getArguments()[0];}});assertEquals("foo",mock.simpleMethod("foo"));}
@Test public void shouldStubConsecutively()throws Exception {given(mock.simpleMethod(anyString())).willReturn("foo").willReturn("bar");assertEquals("foo",mock.simpleMethod("whatever"));assertEquals("bar",mock.simpleMethod("whatever"));}
@Test public void shouldStubVoid()throws Exception {willThrow(new RuntimeException()).given(mock).voidMethod();try {mock.voidMethod();fail();}catch(RuntimeException e){}}
@Test public void shouldStubVoidWithExceptionClass()throws Exception {willThrow(RuntimeException.class).given(mock).voidMethod();try {mock.voidMethod();fail();}catch(RuntimeException e){}}
@Test public void shouldStubVoidConsecutively()throws Exception {willDoNothing().willThrow(new RuntimeException()).given(mock).voidMethod();mock.voidMethod();try {mock.voidMethod();fail();}catch(RuntimeException e){}}
@Test public void shouldStubVoidConsecutivelyWithExceptionClass()throws Exception {willDoNothing().willThrow(IllegalArgumentException.class).given(mock).voidMethod();mock.voidMethod();try {mock.voidMethod();fail();}catch(IllegalArgumentException e){}}
@Test public void shouldStubUsingDoReturnStyle()throws Exception {willReturn("foo").given(mock).simpleMethod("bar");assertEquals(null,mock.simpleMethod("boooo"));assertEquals("foo",mock.simpleMethod("bar"));}
@Test public void shouldStubUsingDoAnswerStyle()throws Exception {willAnswer(new Answer<String>(){public String answer(InvocationOnMock invocation)throws Throwable {return (String)invocation.getArguments()[0];}}).given(mock).simpleMethod(anyString());assertEquals("foo",mock.simpleMethod("foo"));}
@Test public void shouldStubByDelegatingToRealMethod()throws Exception {Dog dog=mock(Dog.class);willCallRealMethod().given(dog).bark();assertEquals("woof",dog.bark());}
@Test public void shouldStubByDelegatingToRealMethodUsingTypicalStubbingSyntax()throws Exception {Dog dog=mock(Dog.class);given(dog.bark()).willCallRealMethod();assertEquals("woof",dog.bark());}
@Test public void shouldAllStubbedMockReferenceAccess()throws Exception {Set expectedMock=mock(Set.class);Set returnedMock=given(expectedMock.isEmpty()).willReturn(false).getMock();assertEquals(expectedMock,returnedMock);}
@Test public void shouldNotReportArgumentTypesWhenToStringIsTheSame()throws Exception {Boo boo=mock(Boo.class);boo.withLong(100);try {verify(boo).withLong(eq(100));fail();}catch(ArgumentsAreDifferent e){assertContains("withLong((Integer)100);",e.getMessage());assertContains("withLong((Long)100);",e.getMessage());}}
@Test public void shouldShowTheTypeOfOnlyTheArgumentThatDoesntMatch()throws Exception {Boo boo=mock(Boo.class);boo.withLongAndInt(100,200);try {verify(boo).withLongAndInt(eq(100),eq(200));fail();}catch(ArgumentsAreDifferent e){assertContains("withLongAndInt((Integer)100,200)",e.getMessage());assertContains("withLongAndInt((Long)100,200)",e.getMessage());}}
@Test public void shouldShowTheTypeOfTheMismatchingArgumentWhenOutputDescriptionsForInvocationsAreDifferent()throws Exception {Boo boo=mock(Boo.class);boo.withLongAndInt(100,200);try {verify(boo).withLongAndInt(eq(100),anyInt());fail();}catch(ArgumentsAreDifferent e){assertContains("withLongAndInt((Long)100,200)",e.getMessage());assertContains("withLongAndInt((Integer)100,<any>)",e.getMessage());}}
@Test public void shouldNotShowTypesWhenArgumentValueIsDifferent()throws Exception {Boo boo=mock(Boo.class);boo.withLongAndInt(100,200);try {verify(boo).withLongAndInt(eq(100L),eq(230));fail();}catch(ArgumentsAreDifferent e){assertContains("withLongAndInt(100,200)",e.getMessage());assertContains("withLongAndInt(100,230)",e.getMessage());}}
@Test public void shouldNotShowTypesWhenTypesAreTheSameEvenIfToStringGivesTheSameResult()throws Exception {IMethods mock=mock(IMethods.class);mock.simpleMethod(new Foo(10));try {verify(mock).simpleMethod(new Foo(20));fail();}catch(ArgumentsAreDifferent e){assertContains("simpleMethod(foo)",e.getMessage());}}
@Test public void shouldDoStuff()throws Exception {isMock(hasSpy.spy);}
@Test public void shouldAllowMultipleInterfaces(){}
@Test public void shouldScreamWhenNullPassedInsteadOfAnInterface(){try {mock(Foo.class,withSettings().extraInterfaces(IFoo.class,null));fail();}catch(MockitoException e){assertContains("extraInterfaces()does not accept null parameters",e.getMessage());}}
@Test public void shouldScreamWhenNoArgsPassed(){try {mock(Foo.class,withSettings().extraInterfaces());fail();}catch(MockitoException e){assertContains("extraInterfaces()requires at least one interface",e.getMessage());}}
@Test public void shouldScreamWhenNullPassedInsteadOfAnArray(){try {mock(Foo.class,withSettings().extraInterfaces((Class[])null));fail();}catch(MockitoException e){assertContains("extraInterfaces()requires at least one interface",e.getMessage());}}
@Test public void shouldScreamWhenNonInterfacePassed(){try {mock(Foo.class,withSettings().extraInterfaces(Foo.class));fail();}catch(MockitoException e){assertContains("Foo which is not an interface",e.getMessage());}}
@Test public void shouldScreamWhenTheSameInterfacesPassed(){try {mock(IMethods.class,withSettings().extraInterfaces(IMethods.class));fail();}catch(MockitoException e){assertContains("You mocked following type: IMethods",e.getMessage());}}
@Test public void shouldInitMocks()throws Exception {list.clear();map.clear();listTwo.clear();verify(list).clear();verify(map).clear();verify(listTwo).clear();}
@Test public void shouldScreamWhenInitializingMocksForNullClass()throws Exception {try {MockitoAnnotations.initMocks(null);fail();}catch(MockitoException e){assertEquals("testClass cannot be null. For info how to use @Mock annotations see examples in javadoc for MockitoAnnotations class",e.getMessage());}}
@Test public void shouldLookForAnnotatedMocksInSuperClasses()throws Exception {Sub sub=new Sub();MockitoAnnotations.initMocks(sub);assertNotNull(sub.getMock());assertNotNull(sub.getBaseMock());assertNotNull(sub.getSuperBaseMock());}
@Test public void shouldInitMocksWithGivenSettings()throws Exception {assertEquals("i have a name",namedAndReturningMocks.toString());assertNotNull(namedAndReturningMocks.iMethodsReturningMethod());assertEquals("returningDefaults",returningDefaults.toString());assertEquals(0,returningDefaults.intReturningMethod());assertTrue(hasExtraInterfaces instanceof List);assertEquals(0,noExtraConfig.intReturningMethod());}
@Test public void shouldBeEqual(){assertEquals(new Equals(null),new Equals(null));assertEquals(new Equals(new Integer(2)),new Equals(new Integer(2)));assertFalse(new Equals(null).equals(null));assertFalse(new Equals(null).equals("Test"));assertEquals(1,new Equals(null).hashCode());}
@Test public void shouldArraysBeEqual(){assertTrue(new Equals(new int[]{1,2}).matches(new int[]{1,2}));assertFalse(new Equals(new Object[]{"1"}).matches(new Object[]{"1.0"}));}
@Test public void shouldDescribeWithExtraTypeInfo()throws Exception {String descStr=describe(new Equals(100).withExtraTypeInfo());assertEquals("(Integer)100",descStr);}
@Test public void shouldDescribeWithExtraTypeInfoOfLong()throws Exception {String descStr=describe(new Equals(100L).withExtraTypeInfo());assertEquals("(Long)100",descStr);}
@Test public void shouldAppendQuotingForString(){String descStr=describe(new Equals("str"));assertEquals("\"str\"",descStr);}
@Test public void shouldAppendQuotingForChar(){String descStr=describe(new Equals('s'));assertEquals("'s'",descStr);}
@Test public void shouldDescribeUsingToString(){String descStr=describe(new Equals(100));assertEquals("100",descStr);}
@Test public void shouldDescribeNull(){String descStr=describe(new Equals(null));assertEquals("null",descStr);}
@Test public void shouldMatchTypes()throws Exception {ContainsExtraTypeInformation equals=new Equals(10);assertTrue(equals.typeMatches(10));assertFalse(equals.typeMatches(10L));}
@Test public void shouldMatchTypesSafelyWhenActualIsNull()throws Exception {ContainsExtraTypeInformation equals=new Equals(null);assertFalse(equals.typeMatches(10));}
@Test public void shouldMatchTypesSafelyWhenGivenIsNull()throws Exception {ContainsExtraTypeInformation equals=new Equals(10);assertFalse(equals.typeMatches(null));}
@Test public void shouldBeACitizenOfHashes()throws Exception {Invocation invocation=new InvocationBuilder().toInvocation();Invocation invocationTwo=new InvocationBuilder().args("blah").toInvocation();Map map=new HashMap();map.put(new InvocationMatcher(invocation),"one");map.put(new InvocationMatcher(invocationTwo),"two");assertEquals(2,map.size());}
@Test public void shouldNotEqualIfNumberOfArgumentsDiffer()throws Exception {PrintingFriendlyInvocation withOneArg=new InvocationMatcher(new InvocationBuilder().args("test").toInvocation());PrintingFriendlyInvocation withTwoArgs=new InvocationMatcher(new InvocationBuilder().args("test",100).toInvocation());assertFalse(withOneArg.equals(null));assertFalse(withOneArg.equals(withTwoArgs));}
@Test public void shouldToStringWithMatchers()throws Exception {Matcher m=NotNull.NOT_NULL;InvocationMatcher notNull=new InvocationMatcher(new InvocationBuilder().toInvocation(),asList(m));Matcher mTwo=new Equals('x');InvocationMatcher equals=new InvocationMatcher(new InvocationBuilder().toInvocation(),asList(mTwo));assertContains("simpleMethod(notNull())",notNull.toString());assertContains("simpleMethod('x')",equals.toString());}
@Test public void shouldKnowIfIsSimilarTo()throws Exception {Invocation same=new InvocationBuilder().mock(mock).simpleMethod().toInvocation();assertTrue(simpleMethod.hasSimilarMethod(same));Invocation different=new InvocationBuilder().mock(mock).differentMethod().toInvocation();assertFalse(simpleMethod.hasSimilarMethod(different));}
@Test public void shouldNotBeSimilarToVerifiedInvocation()throws Exception {Invocation verified=new InvocationBuilder().simpleMethod().verified().toInvocation();assertFalse(simpleMethod.hasSimilarMethod(verified));}
@Test public void shouldNotBeSimilarIfMocksAreDifferent()throws Exception {Invocation onDifferentMock=new InvocationBuilder().simpleMethod().mock("different mock").toInvocation();assertFalse(simpleMethod.hasSimilarMethod(onDifferentMock));}
@Test public void shouldNotBeSimilarIfIsOverloadedButUsedWithTheSameArg()throws Exception {Method method=IMethods.class.getMethod("simpleMethod",String.class);Method overloadedMethod=IMethods.class.getMethod("simpleMethod",Object.class);String sameArg="test";InvocationMatcher invocation=new InvocationBuilder().method(method).arg(sameArg).toInvocationMatcher();Invocation overloadedInvocation=new InvocationBuilder().method(overloadedMethod).arg(sameArg).toInvocation();assertFalse(invocation.hasSimilarMethod(overloadedInvocation));}
@Test public void shouldBeSimilarIfIsOverloadedButUsedWithDifferentArg()throws Exception {Method method=IMethods.class.getMethod("simpleMethod",String.class);Method overloadedMethod=IMethods.class.getMethod("simpleMethod",Object.class);InvocationMatcher invocation=new InvocationBuilder().mock(mock).method(method).arg("foo").toInvocationMatcher();Invocation overloadedInvocation=new InvocationBuilder().mock(mock).method(overloadedMethod).arg("bar").toInvocation();assertTrue(invocation.hasSimilarMethod(overloadedInvocation));}
@Test public void shouldCaptureArgumentsFromInvocation()throws Exception {Invocation invocation=new InvocationBuilder().args("1",100).toInvocation();CapturingMatcher capturingMatcher=new CapturingMatcher();InvocationMatcher invocationMatcher=new InvocationMatcher(invocation,(List)asList(new Equals("1"),capturingMatcher));invocationMatcher.captureArgumentsFrom(invocation);assertEquals(1,capturingMatcher.getAllValues().size());assertEquals(100,capturingMatcher.getLastValue());}
@Test public void shouldMatchVarargsUsingAnyVarargs()throws Exception {mock.varargs("1","2");Invocation invocation=getLastInvocation();InvocationMatcher invocationMatcher=new InvocationMatcher(invocation,(List)asList(AnyVararg.ANY_VARARG));boolean match=invocationMatcher.matches(invocation);assertTrue(match);}
@Test public void shouldMatchCaptureArgumentsWhenArgsCountDoesNOTMatch()throws Exception {mock.varargs();Invocation invocation=getLastInvocation();InvocationMatcher invocationMatcher=new InvocationMatcher(invocation,(List)asList(new LocalizedMatcher(AnyVararg.ANY_VARARG)));invocationMatcher.captureArgumentsFrom(invocation);}
@Test public void shouldCreateFromInvocations()throws Exception {Invocation i=new InvocationBuilder().toInvocation();List<InvocationMatcher> out=InvocationMatcher.createFrom(asList(i));assertEquals(1,out.size());assertEquals(i,out.get(0).getInvocation());}
@Test public void shouldProduceDecentDescription()throws Exception {assertEquals("<Sentence with strong language>",decamelizeMatcher("SentenceWithStrongLanguage"));assertEquals("<W e i r d o 1>",decamelizeMatcher("WEIRDO1"));assertEquals("<_>",decamelizeMatcher("_"));assertEquals("<Has exactly 3 elements>",decamelizeMatcher("HasExactly3Elements"));assertEquals("<custom argument matcher>",decamelizeMatcher(""));}
@Test public void shouldWorkFineIfNoInvocatins()throws Exception {InOrder inOrder=inOrder(mock);inOrder.verifyNoMoreInteractions();}
@Test public void shouldSayNoInteractionsWanted()throws Exception {mock.simpleMethod();InOrder inOrder=inOrder(mock);try {inOrder.verifyNoMoreInteractions();fail();}catch(VerificationInOrderFailure e){assertContains("No interactions wanted",e.getMessage());}}
@Test public void shouldVerifyNoMoreInteractionsInOrder()throws Exception {mock.simpleMethod();mock.simpleMethod(10);mock.otherMethod();InOrder inOrder=inOrder(mock);inOrder.verify(mock).simpleMethod(10);inOrder.verify(mock).otherMethod();inOrder.verifyNoMoreInteractions();}
@Test public void shouldVerifyNoMoreInteractionsInOrderWithMultipleMocks()throws Exception {mock.simpleMethod();mock2.simpleMethod();mock.otherMethod();InOrder inOrder=inOrder(mock,mock2);inOrder.verify(mock2).simpleMethod();inOrder.verify(mock).otherMethod();inOrder.verifyNoMoreInteractions();}
@Test public void shouldFailToVerifyNoMoreInteractionsInOrder()throws Exception {mock.simpleMethod();mock.simpleMethod(10);mock.otherMethod();InOrder inOrder=inOrder(mock);inOrder.verify(mock).simpleMethod(10);try {inOrder.verifyNoMoreInteractions();fail();}catch(VerificationInOrderFailure e){}}
@Test public void shouldFailToVerifyNoMoreInteractionsInOrderWithMultipleMocks()throws Exception {mock.simpleMethod();mock2.simpleMethod();mock.otherMethod();InOrder inOrder=inOrder(mock,mock2);inOrder.verify(mock2).simpleMethod();try {inOrder.verifyNoMoreInteractions();fail();}catch(VerificationInOrderFailure e){}}
@Test public void shouldValidateState()throws Exception {InOrder inOrder=inOrder(mock);verify(mock);try {inOrder.verifyNoMoreInteractions();fail();}catch(UnfinishedVerificationException e){}}
@Test public void shouldMarkVerifiedInOrder()throws Exception {InOrderImpl impl=new InOrderImpl((List)asList(mock));Invocation i=new InvocationBuilder().toInvocation();assertFalse(impl.isVerified(i));impl.markVerified(i);assertTrue(impl.isVerified(i));}
