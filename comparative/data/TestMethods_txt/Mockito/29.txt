@Test public void check_that_mock_can_be_serialized_in_a_classloader_and_deserialized_in_another()throws Exception {byte[]bytes=create_mock_and_serialize_it_in_class_loader_A();Object the_deserialized_mock=read_stream_and_deserialize_it_in_class_loader_B(bytes);}
@Test public void should_get_handler(){List mock=Mockito.mock(List.class);assertNotNull(mockUtil.getMockHandler(mock));}
@Test public void should_scream_when_enhanced_but_not_a_mock_passed(){Object o=Enhancer.create(ArrayList.class,NoOp.INSTANCE);try {mockUtil.getMockHandler(o);fail();}catch(NotAMockException e){}}
@Test(expected=NotAMockException.class)public void should_scream_when_not_a_mock_passed(){mockUtil.getMockHandler("");}
@Test(expected=MockitoException.class)public void should_scream_when_null_passed(){mockUtil.getMockHandler(null);}
@Test public void should_get_mock_settings(){List mock=Mockito.mock(List.class);assertNotNull(mockUtil.getMockSettings(mock));}
@Test public void should_validate_mock(){assertFalse(mockUtil.isMock("i mock a mock"));assertTrue(mockUtil.isMock(Mockito.mock(List.class)));}
@Test public void should_validate_spy(){assertFalse(mockUtil.isSpy("i mock a mock"));assertFalse(mockUtil.isSpy(Mockito.mock(List.class)));assertFalse(mockUtil.isSpy((Class)null));assertTrue(mockUtil.isSpy(Mockito.spy(new ArrayList())));assertTrue(mockUtil.isSpy(Mockito.spy(ArrayList.class)));assertTrue(mockUtil.isSpy(Mockito.mock(ArrayList.class,withSettings().defaultAnswer(Mockito.CALLS_REAL_METHODS))));}
@Test public void should_redefine_MockName_if_default(){List mock=Mockito.mock(List.class);mockUtil.maybeRedefineMockName(mock,"newName");Assertions.assertThat(mockUtil.getMockName(mock).toString()).isEqualTo("newName");}
@Test public void should_not_redefine_MockName_if_default(){List mock=Mockito.mock(List.class,"original");mockUtil.maybeRedefineMockName(mock,"newName");Assertions.assertThat(mockUtil.getMockName(mock).toString()).isEqualTo("original");}
@Test public void should_konw_if_type_is_mockable()throws Exception {assertFalse(mockUtil.isTypeMockable(FinalClass.class));assertFalse(mockUtil.isTypeMockable(int.class));assertTrue(mockUtil.isTypeMockable(SomeClass.class));assertTrue(mockUtil.isTypeMockable(SomeInterface.class));}
@Test public void shouldStubWithThrowable()throws Exception {IllegalArgumentException expected=new IllegalArgumentException("thrown by mock");when(mock.add("throw")).thenThrow(expected);try {mock.add("throw");fail();}catch(IllegalArgumentException e){assertEquals(expected,e);}}
@Test public void shouldSetThrowableToVoidMethod()throws Exception {IllegalArgumentException expected=new IllegalArgumentException("thrown by mock");stubVoid(mock).toThrow(expected).on().clear();try {mock.clear();fail();}catch(Exception e){assertEquals(expected,e);}}
@Test public void shouldLastStubbingVoidBeImportant()throws Exception {stubVoid(mock).toThrow(new ExceptionOne()).on().clear();stubVoid(mock).toThrow(new ExceptionTwo()).on().clear();try {mock.clear();fail();}catch(ExceptionTwo e){}}
@Test public void shouldFailStubbingThrowableOnTheSameInvocationDueToAcceptableLimitation()throws Exception {when(mock.get(1)).thenThrow(new ExceptionOne());try {when(mock.get(1)).thenThrow(new ExceptionTwo());fail();}catch(ExceptionOne e){}}
@Test public void shouldAllowSettingCheckedException()throws Exception {Reader reader=mock(Reader.class);IOException ioException=new IOException();when(reader.read()).thenThrow(ioException);try {reader.read();fail();}catch(Exception e){assertEquals(ioException,e);}}
@Test public void shouldAllowSettingError()throws Exception {Error error=new Error();when(mock.add("quake")).thenThrow(error);try {mock.add("quake");fail();}catch(Error e){assertEquals(error,e);}}
@Test(expected=IllegalArgumentException.class)public void shouldInstantiateExceptionClassOnInteraction(){when(mock.add(null)).thenThrow(IllegalArgumentException.class);mock.add(null);}
@Test(expected=IllegalArgumentException.class)public void shouldInstantiateExceptionClassWithOngoingStubbingOnInteraction(){Mockito.doThrow(IllegalArgumentException.class).when(mock).add(null);mock.add(null);}
@Test(expected=MockitoException.class)public void shouldNotAllowSettingInvalidCheckedException()throws Exception {when(mock.add("monkey island")).thenThrow(new Exception());}
@Test(expected=MockitoException.class)public void shouldNotAllowSettingNullThrowable()throws Exception {when(mock.add("monkey island")).thenThrow((Throwable)null);}
@Test(expected=MockitoException.class)public void shouldNotAllowSettingNullThrowableArray()throws Exception {when(mock.add("monkey island")).thenThrow((Throwable[])null);}
@Test public void shouldMixThrowablesAndReturnsOnDifferentMocks()throws Exception {when(mock.add("ExceptionOne")).thenThrow(new ExceptionOne());when(mock.getLast()).thenReturn("last");stubVoid(mock).toThrow(new ExceptionTwo()).on().clear();stubVoid(mockTwo).toThrow(new ExceptionThree()).on().clear();when(mockTwo.containsValue("ExceptionFour")).thenThrow(new ExceptionFour());when(mockTwo.get("Are you there?")).thenReturn("Yes!");assertNull(mockTwo.get("foo"));assertTrue(mockTwo.keySet().isEmpty());assertEquals("Yes!",mockTwo.get("Are you there?"));try {mockTwo.clear();fail();}catch(ExceptionThree e){}try {mockTwo.containsValue("ExceptionFour");fail();}catch(ExceptionFour e){}assertNull(mock.getFirst());assertEquals("last",mock.getLast());try {mock.add("ExceptionOne");fail();}catch(ExceptionOne e){}try {mock.clear();fail();}catch(ExceptionTwo e){}}
@Test public void shouldStubbingWithThrowableBeVerifiable(){when(mock.size()).thenThrow(new RuntimeException());stubVoid(mock).toThrow(new RuntimeException()).on().clone();try {mock.size();fail();}catch(RuntimeException e){}try {mock.clone();fail();}catch(RuntimeException e){}verify(mock).size();verify(mock).clone();verifyNoMoreInteractions(mock);}
@Test public void shouldStubbingWithThrowableFailVerification(){when(mock.size()).thenThrow(new RuntimeException());stubVoid(mock).toThrow(new RuntimeException()).on().clone();verifyZeroInteractions(mock);mock.add("test");try {verify(mock).size();fail();}catch(WantedButNotInvoked e){}try {verify(mock).clone();fail();}catch(WantedButNotInvoked e){}try {verifyNoMoreInteractions(mock);fail();}catch(NoInteractionsWanted e){}}
@Test(expected=NaughtyException.class)public void shouldShowDecentMessageWhenExcepionIsNaughty()throws Exception {when(mock.add("")).thenThrow(NaughtyException.class);mock.add("");}
@Test public void shouldReturnConsecutiveValues()throws Exception {when(mock.simpleMethod()).thenReturn("one").thenReturn("two").thenReturn("three");assertEquals("one",mock.simpleMethod());assertEquals("two",mock.simpleMethod());assertEquals("three",mock.simpleMethod());assertEquals("three",mock.simpleMethod());assertEquals("three",mock.simpleMethod());}
@SuppressWarnings("all")@Test public void shouldReturnConsecutiveValuesForTwoNulls()throws Exception {when(mock.simpleMethod()).thenReturn(null,(String[])null);assertNull(mock.simpleMethod());assertNull(mock.simpleMethod());}
@Test public void shouldReturnConsecutiveValuesSetByShortenThenReturnMethod()throws Exception {when(mock.simpleMethod()).thenReturn("one","two","three");assertEquals("one",mock.simpleMethod());assertEquals("two",mock.simpleMethod());assertEquals("three",mock.simpleMethod());assertEquals("three",mock.simpleMethod());assertEquals("three",mock.simpleMethod());}
@Test public void shouldReturnConsecutiveValueAndThrowExceptionssSetByShortenReturnMethods()throws Exception {when(mock.simpleMethod()).thenReturn("zero").thenReturn("one","two").thenThrow(new NullPointerException(),new RuntimeException()).thenReturn("three").thenThrow(new IllegalArgumentException());assertEquals("zero",mock.simpleMethod());assertEquals("one",mock.simpleMethod());assertEquals("two",mock.simpleMethod());try {mock.simpleMethod();fail();}catch(NullPointerException e){}try {mock.simpleMethod();fail();}catch(RuntimeException e){}assertEquals("three",mock.simpleMethod());try {mock.simpleMethod();fail();}catch(IllegalArgumentException e){}}
@Test public void shouldThrowConsecutively()throws Exception {when(mock.simpleMethod()).thenThrow(new RuntimeException()).thenThrow(new IllegalArgumentException()).thenThrow(new NullPointerException());try {mock.simpleMethod();fail();}catch(RuntimeException e){}try {mock.simpleMethod();fail();}catch(IllegalArgumentException e){}try {mock.simpleMethod();fail();}catch(NullPointerException e){}try {mock.simpleMethod();fail();}catch(NullPointerException e){}}
@Test public void shouldThrowConsecutivelySetByShortenThenThrowMethod()throws Exception {when(mock.simpleMethod()).thenThrow(new RuntimeException(),new IllegalArgumentException(),new NullPointerException());try {mock.simpleMethod();fail();}catch(RuntimeException e){}try {mock.simpleMethod();fail();}catch(IllegalArgumentException e){}try {mock.simpleMethod();fail();}catch(NullPointerException e){}try {mock.simpleMethod();fail();}catch(NullPointerException e){}}
@Test public void shouldMixConsecutiveReturnsWithExcepions()throws Exception {when(mock.simpleMethod()).thenThrow(new IllegalArgumentException()).thenReturn("one").thenThrow(new NullPointerException()).thenReturn(null);try {mock.simpleMethod();fail();}catch(IllegalArgumentException e){}assertEquals("one",mock.simpleMethod());try {mock.simpleMethod();fail();}catch(NullPointerException e){}assertEquals(null,mock.simpleMethod());assertEquals(null,mock.simpleMethod());}
@Test(expected=MockitoException.class)public void shouldValidateConsecutiveException()throws Exception {when(mock.simpleMethod()).thenReturn("one").thenThrow(new Exception());}
@Test public void shouldStubVoidMethodAndContinueThrowing()throws Exception {stubVoid(mock).toThrow(new IllegalArgumentException()).toReturn().toThrow(new NullPointerException()).on().voidMethod();try {mock.voidMethod();fail();}catch(IllegalArgumentException e){}mock.voidMethod();try {mock.voidMethod();fail();}catch(NullPointerException e){}try {mock.voidMethod();fail();}catch(NullPointerException e){}}
@Test public void shouldStubVoidMethod()throws Exception {stubVoid(mock).toReturn().toThrow(new NullPointerException()).toReturn().on().voidMethod();mock.voidMethod();try {mock.voidMethod();fail();}catch(NullPointerException e){}mock.voidMethod();mock.voidMethod();}
@Test(expected=MockitoException.class)public void shouldValidateConsecutiveExceptionForVoidMethod()throws Exception {stubVoid(mock).toReturn().toThrow(new Exception()).on().voidMethod();}
@Test public void shouldPointToTooManyInvocationsChunkOnError(){try {verify(mock,times(0)).simpleMethod(1);fail();}catch(NeverWantedButInvoked e){assertContains("first(",e.getMessage());}}
@Test public void shouldNotPointStackTracesToRunnersCode(){try {verify(mock,times(0)).simpleMethod(1);fail();}catch(NeverWantedButInvoked e){assertNotContains(".runners.",e.getMessage());}}
@SuppressWarnings("deprecation")@Test public void shouldStubStringVarargs(){when(mock.withStringVarargsReturningString(1)).thenReturn("1");when(mock.withStringVarargsReturningString(2,"1","2","3")).thenReturn("2");RuntimeException expected=new RuntimeException();stubVoid(mock).toThrow(expected).on().withStringVarargs(3,"1","2","3","4");assertEquals("1",mock.withStringVarargsReturningString(1));assertEquals(null,mock.withStringVarargsReturningString(2));assertEquals("2",mock.withStringVarargsReturningString(2,"1","2","3"));assertEquals(null,mock.withStringVarargsReturningString(2,"1","2"));assertEquals(null,mock.withStringVarargsReturningString(2,"1","2","3","4"));assertEquals(null,mock.withStringVarargsReturningString(2,"1","2","9999"));mock.withStringVarargs(3,"1","2","3","9999");mock.withStringVarargs(9999,"1","2","3","4");try {mock.withStringVarargs(3,"1","2","3","4");fail();}catch(Exception e){assertEquals(expected,e);}}
@Test public void shouldStubBooleanVarargs(){when(mock.withBooleanVarargs(1)).thenReturn(true);when(mock.withBooleanVarargs(1,true,false)).thenReturn(true);assertEquals(true,mock.withBooleanVarargs(1));assertEquals(false,mock.withBooleanVarargs(9999));assertEquals(true,mock.withBooleanVarargs(1,true,false));assertEquals(false,mock.withBooleanVarargs(1,true,false,true));assertEquals(false,mock.withBooleanVarargs(2,true,false));assertEquals(false,mock.withBooleanVarargs(1,true));assertEquals(false,mock.withBooleanVarargs(1,false,false));}
@Test public void shouldVerifyStringVarargs(){mock.withStringVarargs(1);mock.withStringVarargs(2,"1","2","3");mock.withStringVarargs(3,"1","2","3","4");verify(mock).withStringVarargs(1);verify(mock).withStringVarargs(2,"1","2","3");try {verify(mock).withStringVarargs(2,"1","2","79","4");fail();}catch(ArgumentsAreDifferent e){}}
@Test public void shouldVerifyObjectVarargs(){mock.withObjectVarargs(1);mock.withObjectVarargs(2,"1",new ArrayList<Object>(),new Integer(1));mock.withObjectVarargs(3,new Integer(1));verify(mock).withObjectVarargs(1);verify(mock).withObjectVarargs(2,"1",new ArrayList<Object>(),new Integer(1));try {verifyNoMoreInteractions(mock);fail();}catch(NoInteractionsWanted e){}}
@Test public void shouldVerifyBooleanVarargs(){mock.withBooleanVarargs(1);mock.withBooleanVarargs(2,true,false,true);mock.withBooleanVarargs(3,true,true,true);verify(mock).withBooleanVarargs(1);verify(mock).withBooleanVarargs(2,true,false,true);try {verify(mock).withBooleanVarargs(3,true,true,true,true);fail();}catch(ArgumentsAreDifferent e){}}
@Test public void shouldVerifyWithAnyObject(){Foo foo=Mockito.mock(Foo.class);foo.varArgs("");Mockito.verify(foo).varArgs((String[])Mockito.anyObject());Mockito.verify(foo).varArgs((String)Mockito.anyObject());}
@Test public void shouldVerifyWithNullVarArgArray(){Foo foo=Mockito.mock(Foo.class);foo.varArgs((String[])null);Mockito.verify(foo).varArgs((String[])Mockito.anyObject());Mockito.verify(foo).varArgs((String[])null);}
@SuppressWarnings("all")@Test public void shouldStubCorrectlyWhenMixedVarargsUsed(){MixedVarargs mixedVarargs=mock(MixedVarargs.class);when(mixedVarargs.doSomething("hello",(String[])null)).thenReturn("hello");when(mixedVarargs.doSomething("goodbye",(String[])null)).thenReturn("goodbye");String result=mixedVarargs.doSomething("hello",(String[])null);assertEquals("hello",result);verify(mixedVarargs).doSomething("hello",(String[])null);}
@SuppressWarnings("all")@Test public void shouldStubCorrectlyWhenDoubleStringAndMixedVarargsUsed(){MixedVarargs mixedVarargs=mock(MixedVarargs.class);when(mixedVarargs.doSomething("one","two",(String[])null)).thenReturn("hello");when(mixedVarargs.doSomething("1","2",(String[])null)).thenReturn("goodbye");String result=mixedVarargs.doSomething("one","two",(String[])null);assertEquals("hello",result);}
@Test public void shouldMatchEasilyEmptyVararg()throws Exception {when(mock.foo(anyVararg())).thenReturn(-1);assertEquals(-1,mock.foo());}
@Test public void should_finish_stubbing_when_wrong_throwable_is_set()throws Exception {state.stubbingStarted();try {invocationContainerImpl.addAnswer(new ThrowsException(new Exception()));fail();}catch(MockitoException e){state.validateState();}}
@Test public void should_finish_stubbing_on_adding_return_value()throws Exception {state.stubbingStarted();invocationContainerImpl.addAnswer(new Returns("test"));state.validateState();}
@Test public void should_get_results_for_methods()throws Throwable {invocationContainerImpl.setInvocationForPotentialStubbing(new InvocationMatcher(simpleMethod));invocationContainerImpl.addAnswer(new Returns("simpleMethod"));Invocation differentMethod=new InvocationBuilder().differentMethod().toInvocation();invocationContainerImpl.setInvocationForPotentialStubbing(new InvocationMatcher(differentMethod));invocationContainerImpl.addAnswer(new ThrowsException(new MyException()));assertEquals("simpleMethod",invocationContainerImpl.answerTo(simpleMethod));try {invocationContainerImpl.answerTo(differentMethod);fail();}catch(MyException e){}}
@Test public void should_get_results_for_methods_stub_only()throws Throwable {invocationContainerImplStubOnly.setInvocationForPotentialStubbing(new InvocationMatcher(simpleMethod));invocationContainerImplStubOnly.addAnswer(new Returns("simpleMethod"));Invocation differentMethod=new InvocationBuilder().differentMethod().toInvocation();invocationContainerImplStubOnly.setInvocationForPotentialStubbing(new InvocationMatcher(differentMethod));invocationContainerImplStubOnly.addAnswer(new ThrowsException(new MyException()));assertEquals("simpleMethod",invocationContainerImplStubOnly.answerTo(simpleMethod));try {invocationContainerImplStubOnly.answerTo(differentMethod);fail();}catch(MyException e){}}
@Test public void should_add_throwable_for_void_method()throws Throwable {invocationContainerImpl.addAnswerForVoidMethod(new ThrowsException(new MyException()));invocationContainerImpl.setMethodForStubbing(new InvocationMatcher(simpleMethod));try {invocationContainerImpl.answerTo(simpleMethod);fail();}catch(MyException e){}}
@Test public void should_validate_throwable_for_void_method()throws Throwable {invocationContainerImpl.addAnswerForVoidMethod(new ThrowsException(new Exception()));try {invocationContainerImpl.setMethodForStubbing(new InvocationMatcher(simpleMethod));fail();}catch(MockitoException e){}}
@Test public void should_validate_throwable()throws Throwable {try {invocationContainerImpl.addAnswer(new ThrowsException(null));fail();}catch(MockitoException e){}}
@Test public void should_print_to_system_out(){assertThat(new VerboseMockInvocationLogger().printStream).isSameAs(System.out);}
@Test public void should_print_invocation_with_return_value(){listener.reportInvocation(new NotifiedMethodInvocationReport(invocation,"return value"));assertThat(printed()).contains(invocation.toString()).contains(invocation.getLocation().toString()).contains("return value");}
@Test public void should_print_invocation_with_exception(){listener.reportInvocation(new NotifiedMethodInvocationReport(invocation,new ThirdPartyException()));assertThat(printed()).contains(invocation.toString()).contains(invocation.getLocation().toString()).contains(ThirdPartyException.class.getName());}
@Test public void should_print_if_method_has_not_been_stubbed()throws Exception {listener.reportInvocation(new NotifiedMethodInvocationReport(invocation,"whatever"));assertThat(printed()).doesNotContain("stubbed");}
@Test public void should_print_stubbed_info_if_availbable()throws Exception {invocation.markStubbed(new StubInfoImpl(stubbedInvocation));listener.reportInvocation(new NotifiedMethodInvocationReport(invocation,"whatever"));assertThat(printed()).contains("stubbed").contains(stubbedInvocation.getLocation().toString());}
@Test public void should_log_count_of_interactions(){listener.reportInvocation(new NotifiedMethodInvocationReport(invocation,new ThirdPartyException()));assertThat(printed()).contains("#1");listener.reportInvocation(new NotifiedMethodInvocationReport(invocation,new ThirdPartyException()));assertThat(printed()).contains("#2");listener.reportInvocation(new NotifiedMethodInvocationReport(invocation,new ThirdPartyException()));assertThat(printed()).contains("#3");}
void testMe(String simple,List<List<String>> genericList);
@Test public void testNormalUsage(){MockitoAnnotations.initMocks(this);assertNotNull(finalCaptor);assertNotNull(genericsCaptor);assertNotNull(nonGenericCaptorIsAllowed);assertNull(notAMock);String argForFinalCaptor="Hello";ArrayList<List<String>> argForGenericsCaptor=new ArrayList<List<String>>();mockInterface.testMe(argForFinalCaptor,argForGenericsCaptor);Mockito.verify(mockInterface).testMe(finalCaptor.capture(),genericsCaptor.capture());assertEquals(argForFinalCaptor,finalCaptor.getValue());assertEquals(argForGenericsCaptor,genericsCaptor.getValue());}
@Test public void shouldScreamWhenWrongTypeForCaptor(){try {MockitoAnnotations.initMocks(new WrongType());fail();}catch(MockitoException e){}}
@Test public void shouldScreamWhenMoreThanOneMockitoAnnotaton(){try {MockitoAnnotations.initMocks(new ToManyAnnotations());fail();}catch(MockitoException e){assertContains("missingGenericsField",e.getMessage());assertContains("multiple Mockito annotations",e.getMessage());}}
@Test public void shouldScreamWhenInitializingCaptorsForNullClass()throws Exception {try {MockitoAnnotations.initMocks(null);fail();}catch(MockitoException e){}}
@Test public void shouldLookForAnnotatedCaptorsInSuperClasses()throws Exception {Sub sub=new Sub();MockitoAnnotations.initMocks(sub);assertNotNull(sub.getCaptor());assertNotNull(sub.getBaseCaptor());assertNotNull(sub.getSuperBaseCaptor());}
@Test public void shouldMarkActualInvocationsAsVerified(){AtLeastXNumberOfInvocationsChecker c=new AtLeastXNumberOfInvocationsChecker();c.invocationMarker=Mockito.mock(InvocationMarker.class);Invocation invocation=new InvocationBuilder().simpleMethod().toInvocation();Invocation invocationTwo=new InvocationBuilder().differentMethod().toInvocation();c.check(asList(invocation,invocationTwo),new InvocationMatcher(invocation),1);Mockito.verify(c.invocationMarker).markVerified(eq(asList(invocation)),any(CapturesArgumensFromInvocation.class));}
@Test public void shouldCreateMockForDeprecatedMockAnnotation()throws Exception {assertNotNull(deprecatedMock);}
@Test public void shouldInjectDeprecatedMockAnnotation()throws Exception {assertNotNull(anInjectedObject.aFieldAwaitingInjection);}
@SuppressWarnings("unchecked")@Test public void shouldCompile(){when(sorter.convertDate(new Date())).thenReturn("one");when(sorter.convertDate((Date)anyObject())).thenReturn("two");when(sorter.sort(anyList())).thenReturn(null);}
@Test public void should_call_single_listener_when_mock_return_normally()throws Exception {Foo foo=mock(Foo.class,withSettings().invocationListeners(listener1));willReturn("basil").given(foo).giveMeSomeString("herb");foo.giveMeSomeString("herb");assertThatHasBeenNotified(listener1,"basil",getClass().getSimpleName());}
@Test public void should_call_all_listener_when_mock_return_normally()throws Exception {Foo foo=mock(Foo.class,withSettings().invocationListeners(listener1,listener2));given(foo.giveMeSomeString("herb")).willReturn("rosemary");foo.giveMeSomeString("herb");assertThatHasBeenNotified(listener1,"rosemary",getClass().getSimpleName());assertThatHasBeenNotified(listener2,"rosemary",getClass().getSimpleName());}
@Test public void should_call_all_listener_when_mock_throws_exception()throws Exception {InvocationListener listener1=mock(InvocationListener.class,"listener1");InvocationListener listener2=mock(InvocationListener.class,"listener2");Foo foo=mock(Foo.class,withSettings().invocationListeners(listener1,listener2));doThrow(new OvenNotWorking()).when(foo).doSomething("cook");try {foo.doSomething("cook");fail("Exception expected.");}catch(OvenNotWorking actualException){InOrder orderedVerify=inOrder(listener1,listener2);orderedVerify.verify(listener1).reportInvocation(any(MethodInvocationReport.class));orderedVerify.verify(listener2).reportInvocation(any(MethodInvocationReport.class));}}
@Test public void shouldFilterList()throws Exception {List list=asList("one","x","two","x","three");List filtered=ListUtil.filter(list,new Filter(){public boolean isOut(Object object){return object == "x";}});assertThat(filtered,hasExactlyInOrder("one","two","three"));}
@Test public void shouldReturnEmptyIfEmptyListGiven()throws Exception {List list=new LinkedList();List filtered=ListUtil.filter(list,null);assertTrue(filtered.isEmpty());}
@Test public void injectMocksShouldInjectMocksFromTestSuperClasses(){ImplicitTest it=new ImplicitTest();MockitoAnnotations.initMocks(it);assertNotNull(it.daoFromParent);assertNotNull(it.daoFromSub);assertNotNull(it.sut.daoFromParent);assertNotNull(it.sut.daoFromSub);}
@Test public void noNullPointerException(){sut.businessMethod();}
@Test public void shouldKeepUnfilteredStackTrace(){try {throwIt();fail();}catch(MockitoAssertionError e){assertEquals("throwIt",e.getUnfilteredStackTrace()[0].getMethodName());}}
@Test public void shouldInjectUsingPropertySetterIfAvailable(){assertTrue(awaitingInjection.propertySetterUsed);}
@Test public void shouldInjectFieldIfNoSetter(){assertEquals(fieldAccess,awaitingInjection.fieldAccess);}
@Test public void shouldWorkAsStandardMockito()throws Exception {List<Integer> list=asList(1,2,3);when(mock.objectReturningMethodNoArgs()).thenAnswer(new ReturnsElementsOf(list));assertEquals(1,mock.objectReturningMethodNoArgs());assertEquals(2,mock.objectReturningMethodNoArgs());assertEquals(3,mock.objectReturningMethodNoArgs());assertEquals(3,mock.objectReturningMethodNoArgs());assertEquals(3,mock.objectReturningMethodNoArgs());}
@Test public void shouldReturnNullIfNecessary()throws Exception {List<Integer> list=asList(1,null);when(mock.objectReturningMethodNoArgs()).thenAnswer(new ReturnsElementsOf(list));assertEquals(1,mock.objectReturningMethodNoArgs());assertEquals(null,mock.objectReturningMethodNoArgs());assertEquals(null,mock.objectReturningMethodNoArgs());}
@Test public void shouldScreamWhenNullPassed()throws Exception {try {new ReturnsElementsOf(null);fail();}catch(MockitoException e){}}
@Test public void shouldBeSerializable()throws Exception {new ObjectOutputStream(new ByteArrayOutputStream()).writeObject(new MethodInterceptorFilter(null,null));}
@Test public void shouldProvideOwnImplementationOfHashCode()throws Throwable {Object ret=filter.intercept(new MethodsImpl(),MethodsImpl.class.getMethod("hashCode"),new Object[0],null);assertTrue((Integer)ret != 0);Mockito.verify(handler,never()).handle(any(InvocationImpl.class));}
@Test public void shouldProvideOwnImplementationOfEquals()throws Throwable {MethodsImpl proxy=new MethodsImpl();Object ret=filter.intercept(proxy,MethodsImpl.class.getMethod("equals",Object.class),new Object[]{proxy},null);assertTrue((Boolean)ret);Mockito.verify(handler,never()).handle(any(InvocationImpl.class));}
@Test public void shouldCreateSerializableMethodProxyIfIsSerializableMock(){}
@Test public void shouldCreateNONSerializableMethodProxyIfIsNotSerializableMock(){}
@Test public void shouldCreateSerializableMethodIfIsSerializableMock(){}
@Test public void shouldCreateJustDelegatingMethodIfIsNotSerializableMock(){}
@Test public void should_evaluate_latest_stubbing_first()throws Exception {when(mock.objectReturningMethod(isA(Integer.class))).thenReturn(100);when(mock.objectReturningMethod(200)).thenReturn(200);assertEquals(200,mock.objectReturningMethod(200));assertEquals(100,mock.objectReturningMethod(666));assertEquals("default behavior should return null",null,mock.objectReturningMethod("blah"));}
@Test public void should_stubbing_be_treated_as_interaction()throws Exception {when(mock.booleanReturningMethod()).thenReturn(true);mock.booleanReturningMethod();try {verifyNoMoreInteractions(mock);fail();}catch(NoInteractionsWanted e){}}
@Test public void should_allow_stubbing_to_string()throws Exception {IMethods mockTwo=mock(IMethods.class);when(mockTwo.toString()).thenReturn("test");assertContains("Mock for IMethods",mock.toString());assertEquals("test",mockTwo.toString());}
@Test public void should_stubbing_not_be_treated_as_interaction(){when(mock.simpleMethod("one")).thenThrow(new RuntimeException());doThrow(new RuntimeException()).when(mock).simpleMethod("two");verifyZeroInteractions(mock);}
@Test public void unfinished_stubbing_cleans_up_the_state(){reset(mock);try {when("").thenReturn("");fail();}catch(MissingMethodInvocationException e){}verifyZeroInteractions(mock);}
@Test public void should_to_string_mock_name(){IMethods mock=mock(IMethods.class,"mockie");IMethods mockTwo=mock(IMethods.class);assertContains("Mock for IMethods","" + mockTwo);assertEquals("mockie","" + mock);}
@Test public void should_allow_mocking_when_to_string_is_final()throws Exception {mock(Foo.class);}
@Test public void test_stub_only_not_verifiable()throws Exception {IMethods localMock=mock(IMethods.class,withSettings().stubOnly());when(localMock.objectReturningMethod(isA(Integer.class))).thenReturn(100);when(localMock.objectReturningMethod(200)).thenReturn(200);assertEquals(200,localMock.objectReturningMethod(200));assertEquals(100,localMock.objectReturningMethod(666));assertEquals("default behavior should return null",null,localMock.objectReturningMethod("blah"));try {verify(localMock,atLeastOnce()).objectReturningMethod(eq(200));fail();}catch(CannotVerifyStubOnlyMock e){}}
@Test public void shouldKnowWhenArgumentsMatch(){Invocation invocation=new InvocationBuilder().args("1",100).toInvocation();InvocationMatcher invocationMatcher=new InvocationBuilder().args("1",100).toInvocationMatcher();boolean match=comparator.argumentsMatch(invocationMatcher,invocation);assertTrue(match);}
@Test public void shouldKnowWhenArgsDifferent(){Invocation invocation=new InvocationBuilder().args("1",100).toInvocation();InvocationMatcher invocationMatcher=new InvocationBuilder().args("100",100).toInvocationMatcher();boolean match=comparator.argumentsMatch(invocationMatcher,invocation);assertFalse(match);}
@Test public void shouldKnowWhenActualArgsSizeIsDifferent(){Invocation invocation=new InvocationBuilder().args("100",100).toInvocation();InvocationMatcher invocationMatcher=new InvocationBuilder().args("100").toInvocationMatcher();boolean match=comparator.argumentsMatch(invocationMatcher,invocation);assertFalse(match);}
@Test public void shouldKnowWhenMatchersSizeIsDifferent(){Invocation invocation=new InvocationBuilder().args("100").toInvocation();InvocationMatcher invocationMatcher=new InvocationBuilder().args("100",100).toInvocationMatcher();boolean match=comparator.argumentsMatch(invocationMatcher,invocation);assertFalse(match);}
@Test public void shouldKnowWhenVarargsMatch(){mock.varargs("1","2","3");Invocation invocation=getLastInvocation();InvocationMatcher invocationMatcher=new InvocationMatcher(invocation,(List)asList(new Equals("1"),Any.ANY,new InstanceOf(String.class)));boolean match=comparator.argumentsMatch(invocationMatcher,invocation);assertTrue(match);}
@Test public void shouldKnowWhenVarargsDifferent(){mock.varargs("1","2");Invocation invocation=getLastInvocation();InvocationMatcher invocationMatcher=new InvocationMatcher(invocation,(List)asList(new Equals("100"),Any.ANY));boolean match=comparator.argumentsMatch(invocationMatcher,invocation);assertFalse(match);}
@Test public void shouldNotAllowAnyObjectMatchEntireVararg(){mock.varargs("1","2");Invocation invocation=getLastInvocation();InvocationMatcher invocationMatcher=new InvocationMatcher(invocation,(List)asList(Any.ANY));boolean match=comparator.argumentsMatch(invocationMatcher,invocation);assertFalse(match);}
@Test public void shouldAllowAnyVarargMatchEntireVararg(){mock.varargs("1","2");Invocation invocation=getLastInvocation();InvocationMatcher invocationMatcher=new InvocationMatcher(invocation,(List)asList(AnyVararg.ANY_VARARG));boolean match=comparator.argumentsMatch(invocationMatcher,invocation);assertTrue(match);}
@Test public void shouldNotAllowAnyObjectWithMixedVarargs(){mock.mixedVarargs(1,"1","2");Invocation invocation=getLastInvocation();InvocationMatcher invocationMatcher=new InvocationMatcher(invocation,(List)asList(new Equals(1)));boolean match=comparator.argumentsMatch(invocationMatcher,invocation);assertFalse(match);}
@Test public void shouldAllowAnyObjectWithMixedVarargs(){mock.mixedVarargs(1,"1","2");Invocation invocation=getLastInvocation();InvocationMatcher invocationMatcher=new InvocationMatcher(invocation,(List)asList(new Equals(1),AnyVararg.ANY_VARARG));boolean match=comparator.argumentsMatch(invocationMatcher,invocation);assertTrue(match);}
@Test public void shouldNotMatchWhenSomeOtherArgumentDoesNotMatch(){mock.mixedVarargs(1,"1","2");Invocation invocation=getLastInvocation();InvocationMatcher invocationMatcher=new InvocationMatcher(invocation,(List)asList(new Equals(100),AnyVararg.ANY_VARARG));boolean match=comparator.argumentsMatch(invocationMatcher,invocation);assertFalse(match);}
@Test public void shouldAnyObjectVarargDealWithDifferentSizeOfArgs(){mock.mixedVarargs(1,"1","2");Invocation invocation=getLastInvocation();InvocationMatcher invocationMatcher=new InvocationMatcher(invocation,(List)asList(new Equals(1)));boolean match=comparator.argumentsMatch(invocationMatcher,invocation);assertFalse(match);}
@Test public void shouldMatchAnyVarargEvenIfOneOfTheArgsIsNull(){mock.mixedVarargs(null,null,"2");Invocation invocation=getLastInvocation();InvocationMatcher invocationMatcher=new InvocationMatcher(invocation,(List)asList(new Equals(null),AnyVararg.ANY_VARARG));boolean match=comparator.argumentsMatch(invocationMatcher,invocation);assertTrue(match);}
@Test public void shouldMatchAnyVarargEvenIfMatcherIsDecorated(){mock.varargs("1","2");Invocation invocation=getLastInvocation();InvocationMatcher invocationMatcher=new InvocationMatcher(invocation,(List)asList(new LocalizedMatcher(AnyVararg.ANY_VARARG)));boolean match=comparator.argumentsMatch(invocationMatcher,invocation);assertTrue(match);}
@Test public void shouldAllowStubbingMocksConfiguredWithRETURNS_MOCKS(){IMethods mock=mock(IMethods.class,RETURNS_MOCKS);when(mock.objectReturningMethodNoArgs()).thenReturn(null);}
@Test public void shouldAllowStubbingMocksConfiguredWithRETURNS_MOCKSWithDoApi(){IMethods mock=mock(IMethods.class,RETURNS_MOCKS);doReturn(null).when(mock).objectReturningMethodNoArgs();}
@Test public void shouldNotThrowNPEWhenIntegerPassed(){mock.intArgumentMethod(100);verify(mock).intArgumentMethod(isA(Integer.class));}
@Test public void shouldNotThrowNPEWhenIntPassed(){mock.intArgumentMethod(100);verify(mock).intArgumentMethod(isA(Integer.class));}
@Test public void shouldNotThrowNPEWhenIntegerPassedToEq(){mock.intArgumentMethod(100);verify(mock).intArgumentMethod(eq(new Integer(100)));}
@Test public void shouldNotThrowNPEWhenIntegerPassedToSame(){mock.intArgumentMethod(100);verify(mock,never()).intArgumentMethod(same(new Integer(100)));}
@Test(expected=AssertionError.class)public void shouldNotThrowNPEWhenNullPassedToEq(){mock.objectArgMethod("not null");verify(mock).objectArgMethod(eq(null));}
@Test(expected=AssertionError.class)public void shouldNotThrowNPEWhenNullPassedToSame(){mock.objectArgMethod("not null");verify(mock).objectArgMethod(same(null));}
@Test public void no_class_in_resource()throws IOException {assertNull(reader.readPluginClass(impl("")));assertNull(reader.readPluginClass(impl("  ")));assertNull(reader.readPluginClass(impl(" \n ")));assertNull(reader.readPluginClass(impl("#foo")));assertNull(reader.readPluginClass(impl("  # foo  ")));assertNull(reader.readPluginClass(impl("  # # # java.langString # ")));assertNull(reader.readPluginClass(impl("  \n # foo \n # foo \n ")));}
@Test public void reads_class_name()throws IOException {assertEquals("java.lang.String",reader.readPluginClass(impl("java.lang.String")));assertEquals("x",reader.readPluginClass(impl("x")));assertEquals("x y z",reader.readPluginClass(impl(" x y z ")));assertEquals("foo.Foo",reader.readPluginClass(impl(" #my class\n  foo.Foo \n #other class ")));assertEquals("foo.Foo",reader.readPluginClass(impl("foo.Foo  # cool class")));}
@Test public void shouldPrintInvocationsWhenStubbingNotUsed()throws Exception {performStubbing();businessLogicWithAsking("arg");verify(mockTwo).doSomething("foo");}
@Test public void shouldVerifyNormallyWithSpecificTimes(){}
@Test public void shouldVerifyNormallyWithAtLeast(){}
@Test public void shouldFailVerificationWithWrongTimes(){}
@Test public void shouldWaitTheFullTimeIfTheTestCouldPass()throws Exception {Thread t=waitAndExerciseMock(50);t.start();long startTime=System.currentTimeMillis();try {verify(mock,after(100).atLeast(2)).clear();fail();}catch(MockitoAssertionError e){}assertTrue(System.currentTimeMillis()- startTime >= 100);}
@Test public void shouldStopEarlyIfTestIsDefinitelyFailed(){}
@Test public void shouldFailWhenMethodNotCalled(){}
@Test public void shouldFailWhenMethodCalledTooFewTimes(){}
@Test public void shouldFailWhenSingleMethodCallsAreOutOfSequence(){}
@Test public void shouldFailWhenDifferentMethodCallsAreOutOfSequence(){}
@Test public void shouldFailWhenMethodCallsOnDifferentMocksAreOutOfSequence(){}
@Test public void shouldAllowSequentialCallsToCallsForSingleMethod(){mockOne.oneArg(1);mockOne.oneArg(2);mockOne.oneArg(2);mockOne.oneArg(1);InOrder verifier=inOrder(mockOne);verifier.verify(mockOne,calls(1)).oneArg(1);verifier.verify(mockOne,calls(2)).oneArg(2);verifier.verify(mockOne,calls(1)).oneArg(1);verifyNoMoreInteractions(mockOne);verifier.verifyNoMoreInteractions();}
@Test public void shouldAllowSequentialCallsToCallsForDifferentMethods(){mockOne.oneArg(1);mockOne.voidMethod();mockOne.voidMethod();mockOne.oneArg(1);InOrder verifier=inOrder(mockOne);verifier.verify(mockOne,calls(1)).oneArg(1);verifier.verify(mockOne,calls(2)).voidMethod();verifier.verify(mockOne,calls(1)).oneArg(1);verifyNoMoreInteractions(mockOne);verifier.verifyNoMoreInteractions();}
@Test public void shouldAllowSequentialCallsToCallsForMethodsOnDifferentMocks(){mockOne.voidMethod();mockTwo.voidMethod();mockTwo.voidMethod();mockOne.voidMethod();InOrder verifier=inOrder(mockOne,mockTwo);verifier.verify(mockOne,calls(1)).voidMethod();verifier.verify(mockTwo,calls(2)).voidMethod();verifier.verify(mockOne,calls(1)).voidMethod();verifyNoMoreInteractions(mockOne);verifyNoMoreInteractions(mockTwo);verifier.verifyNoMoreInteractions();}
@Test public void shouldAllowFewerCallsForSingleMethod(){mockOne.oneArg(1);mockOne.oneArg(2);mockOne.oneArg(2);mockOne.oneArg(1);mockOne.oneArg(2);InOrder verifier=inOrder(mockOne);verifier.verify(mockOne,calls(1)).oneArg(1);verifier.verify(mockOne,calls(1)).oneArg(2);verifier.verify(mockOne,calls(1)).oneArg(1);verifier.verify(mockOne,calls(1)).oneArg(2);}
@Test public void shouldNotVerifySkippedCallsWhenFewerCallsForSingleMethod(){}
@Test public void shouldNotVerifySkippedCallsInInOrderWhenFewerCallsForSingleMethod(){}
@Test public void shouldAllowFewerCallsForDifferentMethods(){mockOne.oneArg(1);mockOne.voidMethod();mockOne.voidMethod();mockOne.oneArg(1);mockOne.voidMethod();InOrder verifier=inOrder(mockOne);verifier.verify(mockOne,calls(1)).oneArg(1);verifier.verify(mockOne,calls(1)).voidMethod();verifier.verify(mockOne,calls(1)).oneArg(1);verifier.verify(mockOne,calls(1)).voidMethod();}
@Test public void shouldNotVerifySkippedCallsWhenFewerCallsForDifferentMethods(){}
@Test public void shouldNotVerifySkippedCallsInInOrderWhenFewerCallsForDifferentMethods(){}
@Test public void shouldAllowFewerCallsForMethodsOnDifferentMocks(){mockOne.voidMethod();mockTwo.voidMethod();mockTwo.voidMethod();mockOne.voidMethod();mockTwo.voidMethod();InOrder verifier=inOrder(mockOne,mockTwo);verifier.verify(mockOne,calls(1)).voidMethod();verifier.verify(mockTwo,calls(1)).voidMethod();verifier.verify(mockOne,calls(1)).voidMethod();verifier.verify(mockTwo,calls(1)).voidMethod();}
@Test public void shouldNotVerifySkippedCallsWhenFewerCallsForMethodsOnDifferentMocks(){}
@Test public void shouldNotVerifySkippedCallsInInOrderWhenFewerCallsForMethodsOnDifferentMocks(){}
@Test public void shouldVerifyWithCallsAfterUseOfTimes(){mockOne.oneArg(1);mockOne.oneArg(2);mockOne.oneArg(2);mockOne.oneArg(1);InOrder verifier=inOrder(mockOne);verifier.verify(mockOne,times(1)).oneArg(1);verifier.verify(mockOne,calls(2)).oneArg(2);verifier.verify(mockOne,calls(1)).oneArg(1);}
@Test public void shouldVerifyWithCallsAfterUseOfAtLeast(){mockOne.oneArg(1);mockOne.oneArg(2);mockOne.oneArg(2);InOrder verifier=inOrder(mockOne);verifier.verify(mockOne,atLeast(1)).oneArg(1);verifier.verify(mockOne,calls(2)).oneArg(2);}
@Test public void shouldVerifyWithTimesAfterUseOfCalls(){mockOne.oneArg(1);mockOne.oneArg(2);mockOne.oneArg(2);mockOne.oneArg(1);InOrder verifier=inOrder(mockOne);verifier.verify(mockOne,calls(1)).oneArg(1);verifier.verify(mockOne,times(2)).oneArg(2);verifier.verify(mockOne,times(1)).oneArg(1);}
@Test public void shouldVerifyWithAtLeastAfterUseOfCalls(){mockOne.oneArg(1);mockOne.oneArg(2);mockOne.oneArg(2);mockOne.oneArg(1);InOrder verifier=inOrder(mockOne);verifier.verify(mockOne,calls(1)).oneArg(1);verifier.verify(mockOne,atLeast(1)).oneArg(2);verifier.verify(mockOne,atLeast(1)).oneArg(1);}
@Test public void shouldVerifyWithTimesAfterCallsInSameChunk(){mockOne.oneArg(1);mockOne.oneArg(1);mockOne.oneArg(1);InOrder verifier=inOrder(mockOne);verifier.verify(mockOne,calls(1)).oneArg(1);verifier.verify(mockOne,times(2)).oneArg(1);verifier.verifyNoMoreInteractions();}
@Test public void shouldFailToCreateCallsWithZeroArgument(){}
@Test public void shouldFailToCreateCallsWithNegativeArgument(){}
@Test public void shouldFailToCreateCallsForNonInOrderVerification(){}
@Test public void shouldInitMocksUsingRunner(){list.add("test");verify(list).add("test");}
@Test public void shouldInjectMocksUsingRunner(){assertNotNull(list);assertSame(list,listDependent.getList());}
@Test public void shouldFilterTestMethodsCorrectly()throws Exception {MockitoJUnitRunner runner=new MockitoJUnitRunner(this.getClass());runner.filter(methodNameContains("shouldInitMocksUsingRunner"));assertEquals(1,runner.testCount());}
@Test public void shouldKeepUnfilteredStackTrace(){try {throwIt();fail();}catch(MockitoException e){assertEquals("throwIt",e.getUnfilteredStackTrace()[0].getMethodName());}}
@Test public void shouldResetOngoingStubbingOnVerify(){mock.booleanReturningMethod();verify(mock).booleanReturningMethod();assertOngoingStubbingIsReset();}
@Test public void shouldResetOngoingStubbingOnInOrder(){mock.booleanReturningMethod();InOrder inOrder=inOrder(mock);inOrder.verify(mock).booleanReturningMethod();assertOngoingStubbingIsReset();}
@Test public void shouldResetOngoingStubbingOnDoReturn(){mock.booleanReturningMethod();doReturn(false).when(mock).booleanReturningMethod();assertOngoingStubbingIsReset();}
@Test public void use_the_correct_setter_on_the_target()throws Exception {SomeBean someBean=new SomeBean();Field theField=someBean.getClass().getDeclaredField("theField");File valueToInject=new File("path");boolean injected=new BeanPropertySetter(someBean,theField,true).set(valueToInject);assertTrue(injected);assertTrue(someBean.theFieldSetterWasUsed);assertSame(valueToInject,someBean.getTheField());}
@Test public void use_the_setter_on_the_target_when_field_name_begins_by_at_least_2_caps()throws Exception {BeanWithWeirdFields someBean=new BeanWithWeirdFields();Field theField=someBean.getClass().getDeclaredField("UUID");UUID valueToInject=new UUID(0L,0L);boolean injected=new BeanPropertySetter(someBean,theField,true).set(valueToInject);assertTrue(injected);assertTrue(someBean.theFieldSetterWasUSed);assertSame(valueToInject,someBean.UUID);}
@Test public void should_not_fail_if_bean_class_declares_only_the_setter_for_the_property()throws Exception {SomeBeanWithJustASetter someBean=new SomeBeanWithJustASetter();Field theField=someBean.getClass().getDeclaredField("theField");File valueToInject=new File("path");boolean injected=new BeanPropertySetter(someBean,theField,true).set(valueToInject);assertTrue(injected);assertTrue(someBean.theFieldSetterWasUsed);}
@Test public void should_fail_if_matching_setter_cannot_be_found_and_if_report_failure_is_true()throws Exception {SomeBeanWithNoSetterMatchingFieldType bean=new SomeBeanWithNoSetterMatchingFieldType();Field theField=bean.getClass().getDeclaredField("theField");File valueToInject=new File("path");try {new BeanPropertySetter(bean,theField,true).set(valueToInject);fail();}catch(Exception e){Assertions.assertThat(e.getMessage()).contains("setter not found");}}
@Test public void return_false_if_no_setter_was_found()throws Exception {SomeBeanWithJustAGetter bean=new SomeBeanWithJustAGetter();Field theField=bean.getClass().getDeclaredField("theField");File valueToInject=new File("path");boolean injected=new BeanPropertySetter(bean,theField).set(valueToInject);assertFalse(injected);}
@Test public void return_false_if_no_setter_was_found_and_if_reportNoSetterFound_is_false()throws Exception {SomeBeanWithNoSetterMatchingFieldType bean=new SomeBeanWithNoSetterMatchingFieldType();Field theField=bean.getClass().getDeclaredField("theField");File valueToInject=new File("path");boolean injected=new BeanPropertySetter(bean,theField,false).set(valueToInject);assertFalse(injected);}
@Test public void shouldNotFindAnySuspiciousMatchersWhenNumberOfArgumentsDoesntMatch(){List<Matcher> matchers=(List)Arrays.asList(new Equals(1));Integer[]suspicious=tool.getSuspiciouslyNotMatchingArgsIndexes(matchers,new Object[]{10,20});assertEquals(0,suspicious.length);}
@Test public void shouldNotFindAnySuspiciousMatchersWhenArgumentsMatch(){List<Matcher> matchers=(List)Arrays.asList(new Equals(10),new Equals(20));Integer[]suspicious=tool.getSuspiciouslyNotMatchingArgsIndexes(matchers,new Object[]{10,20});assertEquals(0,suspicious.length);}
@Test public void shouldFindSuspiciousMatchers(){Equals matcherInt20=new Equals(20);Long longPretendingAnInt=new Long(20);List<Matcher> matchers=(List)Arrays.asList(new Equals(10),matcherInt20);Integer[]suspicious=tool.getSuspiciouslyNotMatchingArgsIndexes(matchers,new Object[]{10,longPretendingAnInt});assertEquals(1,suspicious.length);assertEquals(new Integer(1),suspicious[0]);}
@Test public void shouldNotFindSuspiciousMatchersWhenTypesAreTheSame(){Equals matcherWithBadDescription=new Equals(20){public void describeTo(Description desc){desc.appendText("10");}};Integer argument=10;Integer[]suspicious=tool.getSuspiciouslyNotMatchingArgsIndexes((List)Arrays.asList(matcherWithBadDescription),new Object[]{argument});assertEquals(0,suspicious.length);}
@Test public void shouldWorkFineWhenGivenArgIsNull(){Integer[]suspicious=tool.getSuspiciouslyNotMatchingArgsIndexes((List)Arrays.asList(new Equals(20)),new Object[]{null});assertEquals(0,suspicious.length);}
@Test public void shouldUseMatchersSafely(){List<Matcher> matchers=(List)Arrays.asList(new BaseMatcher(){public boolean matches(Object item){throw new ClassCastException("nasty matcher");}public void describeTo(Description description){}});Integer[]suspicious=tool.getSuspiciouslyNotMatchingArgsIndexes(matchers,new Object[]{10});assertEquals(0,suspicious.length);}
@Test public void shouldMarkAsVerified(){Invocation invocation=new InvocationBuilder().toInvocation();assertFalse(invocation.isVerified());only.verify(new VerificationDataStub(new InvocationMatcher(invocation),invocation));assertTrue(invocation.isVerified());}
@Test public void shouldNotMarkAsVerifiedWhenAssertionFailed(){Invocation invocation=new InvocationBuilder().toInvocation();assertFalse(invocation.isVerified());try {only.verify(new VerificationDataStub(new InvocationBuilder().toInvocationMatcher(),invocation));fail();}catch(MockitoAssertionError e){}assertFalse(invocation.isVerified());}
@Test public void shouldFilterStackTraceOnVerify(){try {verify(mock).simpleMethod();fail();}catch(WantedButNotInvoked e){assertThat(e,hasFirstMethodInStackTrace("shouldFilterStackTraceOnVerify"));}}
@Test public void shouldFilterStackTraceOnVerifyNoMoreInteractions(){mock.oneArg(true);try {verifyNoMoreInteractions(mock);fail();}catch(NoInteractionsWanted e){assertThat(e,hasFirstMethodInStackTrace("shouldFilterStackTraceOnVerifyNoMoreInteractions"));}}
@Test public void shouldFilterStackTraceOnVerifyZeroInteractions(){mock.oneArg(true);try {verifyZeroInteractions(mock);fail();}catch(NoInteractionsWanted e){assertThat(e,hasFirstMethodInStackTrace("shouldFilterStackTraceOnVerifyZeroInteractions"));}}
@Test public void shouldFilterStacktraceOnMockitoException(){verify(mock);try {verify(mock).oneArg(true);fail();}catch(MockitoException expected){assertThat(expected,hasFirstMethodInStackTrace("shouldFilterStacktraceOnMockitoException"));}}
@Test public void shouldFilterStacktraceWhenVerifyingInOrder(){InOrder inOrder=inOrder(mock);mock.oneArg(true);mock.oneArg(false);inOrder.verify(mock).oneArg(false);try {inOrder.verify(mock).oneArg(true);fail();}catch(VerificationInOrderFailure e){assertThat(e,hasFirstMethodInStackTrace("shouldFilterStacktraceWhenVerifyingInOrder"));}}
@Test public void shouldFilterStacktraceWhenInOrderThrowsMockitoException(){try {inOrder();fail();}catch(MockitoException expected){assertThat(expected,hasFirstMethodInStackTrace("shouldFilterStacktraceWhenInOrderThrowsMockitoException"));}}
@Test public void shouldFilterStacktraceWhenInOrderVerifies(){try {InOrder inOrder=inOrder(mock);inOrder.verify(null);fail();}catch(MockitoException expected){assertThat(expected,hasFirstMethodInStackTrace("shouldFilterStacktraceWhenInOrderVerifies"));}}
@Test public void shouldFilterStackTraceWhenThrowingExceptionFromMockHandler(){try {when(mock.oneArg(true)).thenThrow(new Exception());fail();}catch(MockitoException expected){assertThat(expected,hasFirstMethodInStackTrace("shouldFilterStackTraceWhenThrowingExceptionFromMockHandler"));}}
@Test public void shouldShowProperExceptionStackTrace()throws Exception {when(mock.simpleMethod()).thenThrow(new RuntimeException());try {mock.simpleMethod();fail();}catch(RuntimeException e){assertThat(e,hasFirstMethodInStackTrace("shouldShowProperExceptionStackTrace"));}}
@Test public void shouldInitMocksUsingRunner(){list.add("test");verify(list).add("test");}
@Test public void shouldInjectMocksUsingRunner(){assertSame(list,listDependent.getList());}
@Test public void shouldFilterTestMethodsCorrectly()throws Exception {MockitoJUnit44Runner runner=new MockitoJUnit44Runner(this.getClass());runner.filter(methodNameContains("shouldInitMocksUsingRunner"));assertEquals(1,runner.testCount());}
@Test public void shouldVerifyInOrderAllInvocations(){inOrder.verify(mockOne).simpleMethod(1);inOrder.verify(mockTwo,times(2)).simpleMethod(2);inOrder.verify(mockThree).simpleMethod(3);inOrder.verify(mockTwo).simpleMethod(2);inOrder.verify(mockOne).simpleMethod(4);verifyNoMoreInteractions(mockOne,mockTwo,mockThree);}
@Test public void shouldVerifyInOrderAndBeRelaxed(){inOrder.verify(mockTwo,times(2)).simpleMethod(2);inOrder.verify(mockThree).simpleMethod(3);verifyNoMoreInteractions(mockThree);}
@Test public void shouldAllowFirstChunkBeforeLastInvocation(){inOrder.verify(mockTwo,times(2)).simpleMethod(2);inOrder.verify(mockOne).simpleMethod(4);try {verifyNoMoreInteractions(mockTwo);fail();}catch(NoInteractionsWanted e){}}
@Test public void shouldAllowAllChunksBeforeLastInvocation(){inOrder.verify(mockTwo,times(3)).simpleMethod(2);inOrder.verify(mockOne).simpleMethod(4);verifyNoMoreInteractions(mockTwo);}
@Test public void shouldVerifyDetectFirstChunkOfInvocationThatExistInManyChunks(){inOrder.verify(mockTwo,times(2)).simpleMethod(2);inOrder.verify(mockThree).simpleMethod(3);try {verifyNoMoreInteractions(mockTwo);fail();}catch(NoInteractionsWanted e){}}
@Test public void shouldVerifyDetectAllChunksOfInvocationThatExistInManyChunks(){inOrder.verify(mockTwo,times(3)).simpleMethod(2);inOrder.verify(mockOne).simpleMethod(4);verifyNoMoreInteractions(mockTwo);}
@Test public void shouldVerifyInteractionsFromAllChunksWhenAtLeastOnceMode(){inOrder.verify(mockTwo,atLeastOnce()).simpleMethod(2);verifyNoMoreInteractions(mockTwo);try {inOrder.verify(mockThree).simpleMethod(3);fail();}catch(VerificationInOrderFailure e){}}
@Test public void shouldVerifyInteractionsFromFirstChunk(){inOrder.verify(mockTwo,times(2)).simpleMethod(2);try {verifyNoMoreInteractions(mockTwo);fail();}catch(NoInteractionsWanted e){}}
@Test(expected=VerificationInOrderFailure.class)public void shouldFailVerificationOfNonFirstChunk(){inOrder.verify(mockTwo,times(1)).simpleMethod(2);}
@Test public void shouldPassOnCombinationOfTimesAndAtLeastOnce(){mockTwo.simpleMethod(2);inOrder.verify(mockTwo,times(2)).simpleMethod(2);inOrder.verify(mockTwo,atLeastOnce()).simpleMethod(2);verifyNoMoreInteractions(mockTwo);}
@Test public void shouldPassOnEdgyCombinationOfTimesAndAtLeastOnce(){mockTwo.simpleMethod(2);mockThree.simpleMethod(3);inOrder.verify(mockThree).simpleMethod(3);inOrder.verify(mockTwo,atLeastOnce()).simpleMethod(2);inOrder.verify(mockThree).simpleMethod(3);verifyNoMoreInteractions(mockThree);}
@Test public void shouldVerifyInOrderMockTwoAndThree(){inOrder.verify(mockTwo,times(2)).simpleMethod(2);inOrder.verify(mockThree).simpleMethod(3);inOrder.verify(mockTwo).simpleMethod(2);verifyNoMoreInteractions(mockTwo,mockThree);}
@Test public void shouldVerifyInOrderMockOneAndThree(){inOrder.verify(mockOne).simpleMethod(1);inOrder.verify(mockThree).simpleMethod(3);inOrder.verify(mockOne).simpleMethod(4);verifyNoMoreInteractions(mockOne,mockThree);}
@Test public void shouldVerifyInOrderOnlyTwoInvocations(){inOrder.verify(mockTwo,times(2)).simpleMethod(2);inOrder.verify(mockOne).simpleMethod(4);}
@Test public void shouldVerifyInOrderOnlyMockTwo(){inOrder.verify(mockTwo,times(2)).simpleMethod(2);inOrder.verify(mockTwo).simpleMethod(2);verifyNoMoreInteractions(mockTwo);}
@Test public void shouldVerifyMockTwoCalledTwice(){inOrder.verify(mockTwo,times(2)).simpleMethod(2);}
@Test public void shouldVerifyMockTwoCalledAtLeastOnce(){inOrder.verify(mockTwo,atLeastOnce()).simpleMethod(2);}
@Test(expected=WantedButNotInvoked.class)public void shouldFailOnWrongMethodCalledOnMockTwo(){inOrder.verify(mockTwo,atLeastOnce()).differentMethod();}
@Test public void shouldAllowTimesZeroButOnlyInOrder(){inOrder.verify(mockTwo,atLeastOnce()).simpleMethod(2);inOrder.verify(mockOne,times(0)).simpleMethod(1);try {verify(mockOne,times(0)).simpleMethod(1);fail();}catch(NeverWantedButInvoked e){}}
@Test public void shouldFailTimesZeroInOrder(){inOrder.verify(mockTwo,times(2)).simpleMethod(2);try {inOrder.verify(mockThree,times(0)).simpleMethod(3);fail();}catch(VerificationInOrderFailure e){}}
@Test(expected=VerificationInOrderFailure.class)public void shouldFailWhenMockTwoWantedZeroTimes(){inOrder.verify(mockTwo,times(0)).simpleMethod(2);}
@Test public void shouldVerifyLastInvocation(){inOrder.verify(mockOne).simpleMethod(4);}
@Test public void shouldVerifySecondAndLastInvocation(){inOrder.verify(mockTwo,atLeastOnce()).simpleMethod(2);inOrder.verify(mockOne).simpleMethod(4);}
@Test public void shouldVerifySecondAndLastInvocationWhenAtLeastOnceUsed(){inOrder.verify(mockTwo,atLeastOnce()).simpleMethod(2);inOrder.verify(mockOne).simpleMethod(4);}
@Test public void shouldFailOnLastTwoInvocationsInWrongOrder(){inOrder.verify(mockOne).simpleMethod(4);try {inOrder.verify(mockTwo,atLeastOnce()).simpleMethod(2);fail();}catch(VerificationInOrderFailure e){}}
@Test public void shouldFailOnLastAndFirstInWrongOrder(){inOrder.verify(mockOne).simpleMethod(4);try {inOrder.verify(mockOne).simpleMethod(1);fail();}catch(VerificationInOrderFailure e){}}
@Test public void shouldFailOnWrongMethodAfterLastInvocation(){inOrder.verify(mockOne).simpleMethod(4);try {inOrder.verify(mockOne).simpleMethod(999);fail();}catch(VerificationInOrderFailure e){}}
@Test public void should_return_mock_value_for_interface()throws Exception {Object interfaceMock=values.returnValueFor(FooInterface.class);assertTrue(new MockUtil().isMock(interfaceMock));}
@Test public void should_return_mock_value_for_class()throws Exception {Object classMock=values.returnValueFor(BarClass.class);assertTrue(new MockUtil().isMock(classMock));}
@Test public void should_return_null_for_final_class()throws Exception {assertNull(values.returnValueFor(Baz.class));}
@Test public void should_return_the_usual_default_values_for_primitives()throws Throwable {ReturnsMocks answer=new ReturnsMocks();assertEquals(false,answer.answer(invocationOf(HasPrimitiveMethods.class,"booleanMethod")));assertEquals((char)0,answer.answer(invocationOf(HasPrimitiveMethods.class,"charMethod")));assertEquals((byte)0,answer.answer(invocationOf(HasPrimitiveMethods.class,"byteMethod")));assertEquals((short)0,answer.answer(invocationOf(HasPrimitiveMethods.class,"shortMethod")));assertEquals(0,answer.answer(invocationOf(HasPrimitiveMethods.class,"intMethod")));assertEquals(0L,answer.answer(invocationOf(HasPrimitiveMethods.class,"longMethod")));assertEquals(0f,answer.answer(invocationOf(HasPrimitiveMethods.class,"floatMethod")));assertEquals(0d,answer.answer(invocationOf(HasPrimitiveMethods.class,"doubleMethod")));}
@Test public void should_return_empty_array()throws Throwable {String[]ret=(String[])values.answer(invocationOf(StringMethods.class,"stringArrayMethod"));assertTrue(ret.getClass().isArray());assertTrue(ret.length == 0);}
@Test public void should_return_empty_string()throws Throwable {assertEquals("",values.answer(invocationOf(StringMethods.class,"stringMethod")));}
@Test public void shouldPointStackTraceToPreviousVerified(){inOrder.verify(mock,atLeastOnce()).simpleMethod(anyInt());inOrder.verify(mockTwo).simpleMethod(anyInt());try {inOrder.verify(mock).simpleMethod(999);fail();}catch(VerificationInOrderFailure e){assertContains("fourth(",e.getMessage());}}
@Test public void shouldPointToThirdMethod(){inOrder.verify(mock,atLeastOnce()).simpleMethod(anyInt());try {inOrder.verify(mockTwo).simpleMethod(999);fail();}catch(VerificationInOrderFailure e){assertContains("third(",e.getMessage());}}
@Test public void shouldPointToSecondMethod(){inOrder.verify(mock).simpleMethod(anyInt());inOrder.verify(mockTwo).simpleMethod(anyInt());try {inOrder.verify(mockTwo,times(3)).simpleMethod(999);fail();}catch(VerificationInOrderFailure e){assertContains("second(",e.getMessage());}}
@Test public void shouldPointToFirstMethodBecauseOfTooManyActualInvocations(){try {inOrder.verify(mock,times(0)).simpleMethod(anyInt());fail();}catch(VerificationInOrderFailure e){assertContains("first(",e.getMessage());}}
@Test public void shouldPointToSecondMethodBecauseOfTooManyActualInvocations(){inOrder.verify(mock).simpleMethod(anyInt());try {inOrder.verify(mockTwo,times(0)).simpleMethod(anyInt());fail();}catch(VerificationInOrderFailure e){assertContains("second(",e.getMessage());}}
@Test public void shouldPointToFourthMethodBecauseOfTooLittleActualInvocations(){inOrder.verify(mock).simpleMethod(anyInt());inOrder.verify(mockTwo).simpleMethod(anyInt());inOrder.verify(mock).simpleMethod(anyInt());try {inOrder.verify(mockTwo,times(3)).simpleMethod(anyInt());fail();}catch(VerificationInOrderFailure e){assertContains("fourth(",e.getMessage());}}
@Test public void shouldPrintNiceName(){veryCoolSpy.add(1);try {verify(veryCoolSpy).add(2);fail();}catch(AssertionError e){Assertions.assertThat(e.getMessage()).contains("veryCoolSpy");}}
@Test public void should_print_method_name(){try {verify(mock).simpleMethod();fail();}catch(WantedButNotInvoked e){String actualMessage=e.getMessage();String expectedMessage="\n" + "Wanted but not invoked:" + "\n"+ "iMethods.simpleMethod();"+ "\n"+ "-> at";assertContains(expectedMessage,actualMessage);}}
@Test public void should_print_method_name_and_arguments(){try {verify(mock).threeArgumentMethod(12,new Foo(),"xx");fail();}catch(WantedButNotInvoked e){assertContains("iMethods.threeArgumentMethod(12,foo,\"xx\")",e.getMessage());}}
@Test public void should_print_actual_and_wanted_in_line(){mock.varargs(1,2);try {verify(mock).varargs(1,1000);fail();}catch(ArgumentsAreDifferent e){String wanted="\n" + "Argument(s)are different! Wanted:" + "\n"+ "iMethods.varargs(1,1000);";assertContains(wanted,e.getMessage());String actual="\n" + "Actual invocation has different arguments:" + "\n"+ "iMethods.varargs(1,2);";assertContains(actual,e.getMessage());}}
@Test public void should_print_actual_and_wanted_in_multiple_lines(){mock.varargs("this is very long string","this is another very long string");try {verify(mock).varargs("x","y","z");fail();}catch(ArgumentsAreDifferent e){String wanted="\n" + "Argument(s)are different! Wanted:" + "\n"+ "iMethods.varargs("+ "\n"+ "    \"x\","+ "\n"+ "    \"y\","+ "\n"+ "    \"z\""+ "\n"+ ");";assertContains(wanted,e.getMessage());String actual="\n" + "Actual invocation has different arguments:" + "\n"+ "iMethods.varargs("+ "\n"+ "    \"this is very long string\","+ "\n"+ "    \"this is another very long string\""+ "\n"+ ");";assertContains(actual,e.getMessage());}}
@Test public void should_print_actual_and_wanted_when_actual_method_name_and_wanted_method_name_are_the_same(){mock.simpleMethod();try {verify(mock).simpleMethod(10);fail();}catch(ArgumentsAreDifferent e){assertContains("simpleMethod(10)",e.getMessage());assertContains("simpleMethod()",e.getMessage());}}
@Test public void should_print_actual_and_unverified_wanted_when_the_difference_is_about_arguments(){mock.twoArgumentMethod(1,1);mock.twoArgumentMethod(2,2);verify(mock).twoArgumentMethod(1,1);try {verify(mock).twoArgumentMethod(2,1000);fail();}catch(ArgumentsAreDifferent e){assertContains("(2,1000)",e.getMessage());assertContains("(2,2)",e.getMessage());}}
@Test public void should_print_first_unexpected_invocation(){mock.oneArg(true);mock.oneArg(false);mock.threeArgumentMethod(1,"2","3");verify(mock).oneArg(true);try {verifyNoMoreInteractions(mock);fail();}catch(NoInteractionsWanted e){String expectedMessage="\n" + "No interactions wanted here:" + "\n"+ "-> at";assertContains(expectedMessage,e.getMessage());String expectedCause="\n" + "But found this interaction on mock '" + mock + "':"+ "\n"+ "-> at";assertContains(expectedCause,e.getMessage());}}
@Test public void should_print_first_unexpected_invocation_when_verifying_zero_interactions(){mock.twoArgumentMethod(1,2);mock.threeArgumentMethod(1,"2","3");try {verifyZeroInteractions(mock);fail();}catch(NoInteractionsWanted e){String expected="\n" + "No interactions wanted here:" + "\n"+ "-> at";assertContains(expected,e.getMessage());String expectedCause="\n" + "But found this interaction on mock '" + mock + "':"+ "\n"+ "-> at";assertContains(expectedCause,e.getMessage());}}
@Test public void should_print_method_name_when_verifying_at_least_once()throws Exception {try {verify(mock,atLeastOnce()).twoArgumentMethod(1,2);fail();}catch(WantedButNotInvoked e){assertContains("twoArgumentMethod(1,2)",e.getMessage());}}
@Test public void should_print_method_when_matcher_used()throws Exception {try {verify(mock,atLeastOnce()).twoArgumentMethod(anyInt(),eq(100));fail();}catch(WantedButNotInvoked e){String actualMessage=e.getMessage();String expectedMessage="\n" + "Wanted but not invoked:" + "\n"+ "iMethods.twoArgumentMethod(<any>,100);";assertContains(expectedMessage,actualMessage);}}
@Test public void should_print_method_when_missing_invocation_with_array_matcher(){mock.oneArray(new boolean[]{true,false,false});try {verify(mock).oneArray(aryEq(new boolean[]{false,false,false}));fail();}catch(ArgumentsAreDifferent e){assertContains("[false,false,false]",e.getMessage());assertContains("[true,false,false]",e.getMessage());}}
@Test public void should_print_method_when_missing_invocation_with_vararg_matcher(){mock.varargsString(10,"xxx","yyy","zzz");try {verify(mock).varargsString(10,"111","222","333");fail();}catch(ArgumentsAreDifferent e){assertContains("111",e.getMessage());assertContains("\"xxx\"",e.getMessage());}}
@Test public void should_print_method_when_missing_invocation_with_matcher(){mock.simpleMethod("foo");try {verify(mock).simpleMethod(matches("burrito from Exmouth"));fail();}catch(ArgumentsAreDifferent e){assertContains("matches(\"burrito from Exmouth\")",e.getMessage());assertContains("\"foo\"",e.getMessage());}}
@Test public void should_print_null_arguments()throws Exception {mock.simpleMethod(null,(Integer)null);try {verify(mock).simpleMethod("test");fail();}catch(ArgumentsAreDifferent e){assertContains("simpleMethod(null,null);",e.getMessage());}}
@Test public void should_say_never_wanted_but_invoked()throws Exception {mock.simpleMethod(1);verify(mock,never()).simpleMethod(2);try {verify(mock,never()).simpleMethod(1);fail();}catch(NeverWantedButInvoked e){assertContains("Never wanted here:",e.getMessage());assertContains("But invoked here:",e.getMessage());}}
@Test public void should_show_right_actual_method()throws Exception {mock.simpleMethod(9191);mock.simpleMethod("foo");try {verify(mock).simpleMethod("bar");fail();}catch(ArgumentsAreDifferent e){assertContains("bar",e.getMessage());assertContains("foo",e.getMessage());}}
@Test public void should_print_field_name_when_annotations_used()throws Exception {iHavefunkyName.simpleMethod(10);try {verify(iHavefunkyName).simpleMethod(20);fail();}catch(ArgumentsAreDifferent e){assertContains("iHavefunkyName.simpleMethod(20)",e.getMessage());assertContains("iHavefunkyName.simpleMethod(10)",e.getMessage());}}
@Test public void should_print_interactions_on_mock_when_ordinary_verification_fail()throws Exception {mock.otherMethod();mock.booleanReturningMethod();try {verify(mock).simpleMethod();fail();}catch(WantedButNotInvoked e){}}
@Test public void should_never_break_method_string_when_no_args_in_method()throws Exception {try {verify(veeeeeeeeeeeeeeeeeeeeeeeerylongNameMock).simpleMethod();fail();}catch(WantedButNotInvoked e){assertContains("veeeeeeeeeeeeeeeeeeeeeeeerylongNameMock.simpleMethod()",e.getMessage());}}
@Test public void should_print_method_name_and_arguments_of_other_interactions_with_different_methods()throws Exception {try {mock.arrayMethod(new String[]{"a","b","c"});mock.forByte((byte)25);verify(mock).threeArgumentMethod(12,new Foo(),"xx");fail();}catch(WantedButNotInvoked e){System.out.println(e);assertContains("iMethods.threeArgumentMethod(12,foo,\"xx\")",e.getMessage());assertContains("iMethods.arrayMethod([\"a\",\"b\",\"c\"])",e.getMessage());assertContains("iMethods.forByte(25)",e.getMessage());}}
@Test @Ignore("issue 380 related")public void should_print_method_name_and_arguments_of_other_interactions_of_same_method()throws Exception {try {mock.forByte((byte)25);mock.forByte((byte)12);verify(mock).forByte((byte)42);fail();}catch(WantedButNotInvoked e){System.out.println(e);assertContains("iMethods.forByte(42)",e.getMessage());assertContains("iMethods.forByte(25)",e.getMessage());assertContains("iMethods.forByte(12)",e.getMessage());}}
@Test @Ignore("issue 380 related")public void test1(){AnInterface m=Mockito.mock(AnInterface.class);for (int i=1;i <= 2;i++){m.foo(i);}verify(m).foo(1);verify(m).foo(2);verify(m).foo(3);verify(m).foo(4);}
@Test @Ignore("issue 380 related")public void test2(){AnInterface m=Mockito.mock(AnInterface.class);for (int i=1;i <= 4;i++){m.foo(i);}verify(m).foo(1);verify(m).foo(2);verify(m).foo(5);}
@Test public void shouldStubUsingMatchers(){when(one.simpleMethod(2)).thenReturn("2");when(two.simpleMethod(anyString())).thenReturn("any");when(three.simpleMethod(startsWith("test"))).thenThrow(new RuntimeException());assertEquals(null,one.simpleMethod(1));assertEquals("2",one.simpleMethod(2));assertEquals("any",two.simpleMethod("two"));assertEquals("any",two.simpleMethod("two again"));assertEquals(null,three.simpleMethod("three"));assertEquals(null,three.simpleMethod("three again"));try {three.simpleMethod("test three again");fail();}catch(RuntimeException e){}}
@SuppressWarnings("deprecation")@Test public void shouldVerifyUsingMatchers(){stubVoid(one).toThrow(new RuntimeException()).on().oneArg(true);when(three.varargsObject(5,"first arg","second arg")).thenReturn("stubbed");try {one.oneArg(true);fail();}catch(RuntimeException e){}one.simpleMethod(100);two.simpleMethod("test Mockito");three.varargsObject(10,"first arg","second arg");assertEquals("stubbed",three.varargsObject(5,"first arg","second arg"));verify(one).oneArg(eq(true));verify(one).simpleMethod(anyInt());verify(two).simpleMethod(startsWith("test"));verify(three).varargsObject(5,"first arg","second arg");verify(three).varargsObject(eq(10),eq("first arg"),startsWith("second"));verifyNoMoreInteractions(one,two,three);try {verify(three).varargsObject(eq(10),eq("first arg"),startsWith("third"));fail();}catch(WantedButNotInvoked e){}}
@Test public void fields_should_return_all_declared_fields_in_hierarchy()throws Exception {assertThat(Fields.allDeclaredFieldsOf(new HierarchyOfClasses()).names()).containsOnly("a","b","static_a","static_b");}
@Test public void fields_should_return_declared_fields()throws Exception {assertThat(Fields.declaredFieldsOf(new HierarchyOfClasses()).names()).containsOnly("b","static_b");}
@Test public void can_filter_not_null_fields()throws Exception {assertThat(Fields.declaredFieldsOf(new NullOrNotNullFields()).notNull().names()).containsOnly("c");}
@Test public void can_get_values_of_instance_fields()throws Exception {assertThat(Fields.declaredFieldsOf(new ValuedFields()).assignedValues()).containsOnly("a","b");}
@Test public void can_get_list_of_InstanceField()throws Exception {ValuedFields instance=new ValuedFields();assertThat(Fields.declaredFieldsOf(instance).instanceFields()).containsOnly(new InstanceField(field("a",instance),instance),new InstanceField(field("b",instance),instance));}
@Test public void shouldSetInternalStateOnHierarchy(){DummyClassForTests dummy=new DummyClassForTests();Whitebox.setInternalState(dummy,"somePrivateField","cool!");Object internalState=org.powermock.reflect.Whitebox.getInternalState(dummy,"somePrivateField");assertEquals("cool!",internalState);}
@Test public void shouldGetInternalStateFromHierarchy(){DummyClassForTests dummy=new DummyClassForTests();org.powermock.reflect.Whitebox.setInternalState(dummy,"somePrivateField","boo!");Object internalState=Whitebox.getInternalState(dummy,"somePrivateField");assertEquals("boo!",internalState);}
@Test public void shouldUseCustomBooleanMatcher(){when(mock.oneArg(booleanThat(new IsAnyBoolean()))).thenReturn("foo");assertEquals("foo",mock.oneArg(true));assertEquals("foo",mock.oneArg(false));assertEquals(null,mock.oneArg("x"));}
@Test public void shouldUseCustomCharMatcher(){when(mock.oneArg(charThat(new IsSorZ()))).thenReturn("foo");assertEquals("foo",mock.oneArg('s'));assertEquals("foo",mock.oneArg('z'));assertEquals(null,mock.oneArg('x'));}
@Test public void shouldUseCustomPrimitiveNumberMatchers(){when(mock.oneArg(byteThat(new IsZeroOrOne<Byte>()))).thenReturn("byte");when(mock.oneArg(shortThat(new IsZeroOrOne<Short>()))).thenReturn("short");when(mock.oneArg(intThat(new IsZeroOrOne<Integer>()))).thenReturn("int");when(mock.oneArg(longThat(new IsZeroOrOne<Long>()))).thenReturn("long");when(mock.oneArg(floatThat(new IsZeroOrOne<Float>()))).thenReturn("float");when(mock.oneArg(doubleThat(new IsZeroOrOne<Double>()))).thenReturn("double");assertEquals("byte",mock.oneArg((byte)0));assertEquals("short",mock.oneArg((short)1));assertEquals("int",mock.oneArg(0));assertEquals("long",mock.oneArg(1L));assertEquals("float",mock.oneArg(0F));assertEquals("double",mock.oneArg(1.0));assertEquals(null,mock.oneArg(2));assertEquals(null,mock.oneArg("foo"));}
@Test public void shouldUseCustomObjectMatcher(){when(mock.oneArg(argThat(new ContainsFoo()))).thenReturn("foo");assertEquals("foo",mock.oneArg("foo"));assertEquals(null,mock.oneArg("bar"));}
@Test public void shouldCustomMatcherPrintDescriptionBasedOnName(){mock.simpleMethod("foo");try {verify(mock).simpleMethod(containsTest());fail();}catch(AssertionError e){assertContains("<String that contains xxx>",e.getMessage());}}
@Test public void shouldAnonymousCustomMatcherPrintDefaultDescription(){mock.simpleMethod("foo");try {verify(mock).simpleMethod((String)argThat(new ArgumentMatcher<Object>(){@Override public boolean matches(Object argument){return false;}}));fail();}catch(AssertionError e){assertContains("<custom argument matcher>",e.getMessage());assertContains("foo",e.getMessage());}}
@Test public void shouldAnswer()throws Exception {when(mock.simpleMethod(anyString())).thenAnswer(new Answer<String>(){public String answer(InvocationOnMock invocation)throws Throwable {String arg=(String)invocation.getArguments()[0];return invocation.getMethod().getName()+ "-" + arg;}});assertEquals("simpleMethod-test",mock.simpleMethod("test"));}
@Test public void shouldAnswerWithThenAnswerAlias()throws Exception {RecordCall recordCall=new RecordCall();Set mockedSet=when(mock(Set.class).isEmpty()).then(recordCall).getMock();mockedSet.isEmpty();assertTrue(recordCall.isCalled());}
@Test public void shouldAnswerConsecutively()throws Exception {when(mock.simpleMethod()).thenAnswer(new Answer<String>(){public String answer(InvocationOnMock invocation)throws Throwable {return invocation.getMethod().getName();}}).thenReturn("Hello").thenAnswer(new Answer<String>(){public String answer(InvocationOnMock invocation)throws Throwable {return invocation.getMethod().getName()+ "-1";}});assertEquals("simpleMethod",mock.simpleMethod());assertEquals("Hello",mock.simpleMethod());assertEquals("simpleMethod-1",mock.simpleMethod());assertEquals("simpleMethod-1",mock.simpleMethod());}
@Test public void shoudAnswerVoidMethod()throws Exception {RecordCall recordCall=new RecordCall();stubVoid(mock).toAnswer(recordCall).on().voidMethod();mock.voidMethod();assertTrue(recordCall.isCalled());}
@Test public void shouldAnswerVoidMethodConsecutively()throws Exception {RecordCall call1=new RecordCall();RecordCall call2=new RecordCall();stubVoid(mock).toAnswer(call1).toThrow(new UnsupportedOperationException()).toAnswer(call2).on().voidMethod();mock.voidMethod();assertTrue(call1.isCalled());assertFalse(call2.isCalled());try {mock.voidMethod();fail();}catch(UnsupportedOperationException e){}mock.voidMethod();assertTrue(call2.isCalled());}
@Test public void shouldMakeSureTheInterfaceDoesNotChange()throws Exception {when(mock.simpleMethod(anyString())).thenAnswer(new Answer<String>(){public String answer(InvocationOnMock invocation)throws Throwable {assertTrue(invocation.getArguments().getClass().isArray());assertEquals(Method.class,invocation.getMethod().getClass());return "assertions passed";}});assertEquals("assertions passed",mock.simpleMethod("test"));}
@Test public void shouldAnyXMatchersAcceptNull(){when(mock.oneArg(anyObject())).thenReturn("0");when(mock.oneArg(anyString())).thenReturn("1");when(mock.forList(anyList())).thenReturn("2");when(mock.forMap(anyMap())).thenReturn("3");when(mock.forCollection(anyCollection())).thenReturn("4");when(mock.forSet(anySet())).thenReturn("5");assertEquals("0",mock.oneArg((Object)null));assertEquals("1",mock.oneArg((String)null));assertEquals("2",mock.forList(null));assertEquals("3",mock.forMap(null));assertEquals("4",mock.forCollection(null));assertEquals("5",mock.forSet(null));}
@Test public void shouldAnyPrimiteWraperMatchersAcceptNull(){when(mock.forInteger(anyInt())).thenReturn("0");when(mock.forCharacter(anyChar())).thenReturn("1");when(mock.forShort(anyShort())).thenReturn("2");when(mock.forByte(anyByte())).thenReturn("3");when(mock.forBoolean(anyBoolean())).thenReturn("4");when(mock.forLong(anyLong())).thenReturn("5");when(mock.forFloat(anyFloat())).thenReturn("6");when(mock.forDouble(anyDouble())).thenReturn("7");assertEquals("0",mock.forInteger(null));assertEquals("1",mock.forCharacter(null));assertEquals("2",mock.forShort(null));assertEquals("3",mock.forByte(null));assertEquals("4",mock.forBoolean(null));assertEquals("5",mock.forLong(null));assertEquals("6",mock.forFloat(null));assertEquals("7",mock.forDouble(null));}
@Test public void shouldAllowStubbedMockReferenceAccess()throws Exception {Set expectedMock=mock(Set.class);Set returnedMock=when(expectedMock.isEmpty()).thenReturn(false).getMock();assertEquals(expectedMock,returnedMock);}
@Test public void stubbedMockShouldWorkAsUsual()throws Exception {Set returnedMock=when(mock(Set.class).isEmpty()).thenReturn(false,true).getMock();assertEquals(false,returnedMock.isEmpty());assertEquals(true,returnedMock.isEmpty());}
@Test public void should_fail_fast_when_argument_matchers_are_abused(){misplaced_anyObject_argument_matcher();try {mock(IMethods.class);fail();}catch(InvalidUseOfMatchersException e){assertContains("Misplaced argument matcher",e.getMessage());}}
@Test public void should_report_argument_locations_when_argument_matchers_misused(){try {Observer observer=mock(Observer.class);misplaced_anyInt_argument_matcher();misplaced_anyObject_argument_matcher();misplaced_anyBoolean_argument_matcher();observer.update(null,null);validateMockitoUsage();fail();}catch(InvalidUseOfMatchersException e){assertContains("DetectingMisusedMatchersTest.misplaced_anyInt_argument_matcher",e.getMessage());assertContains("DetectingMisusedMatchersTest.misplaced_anyObject_argument_matcher",e.getMessage());assertContains("DetectingMisusedMatchersTest.misplaced_anyBoolean_argument_matcher",e.getMessage());}}
@Test public void shouldSayUnfinishedVerificationButNotInvalidUseOfMatchers(){verify(withFinal).finalMethod(anyObject());try {verify(withFinal);fail();}catch(UnfinishedVerificationException e){}}
@Test(expected=MockitoException.class)public void shouldNotAllowMockAndSpy()throws Exception {MockitoAnnotations.initMocks(new Object(){@Mock @Spy List mock;});}
@Test(expected=MockitoException.class)public void shouldNotAllowSpyAndInjectMock()throws Exception {MockitoAnnotations.initMocks(new Object(){@InjectMocks @Spy List mock;});}
@Test(expected=MockitoException.class)public void shouldNotAllowMockAndInjectMock()throws Exception {MockitoAnnotations.initMocks(new Object(){@InjectMocks @Mock List mock;});}
@Test(expected=MockitoException.class)public void shouldNotAllowCaptorAndMock()throws Exception {MockitoAnnotations.initMocks(new Object(){@Mock @Captor ArgumentCaptor captor;});}
@Test(expected=MockitoException.class)public void shouldNotAllowCaptorAndSpy()throws Exception {MockitoAnnotations.initMocks(new Object(){@Spy @Captor ArgumentCaptor captor;});}
@Test(expected=MockitoException.class)public void shouldNotAllowCaptorAndInjectMock()throws Exception {MockitoAnnotations.initMocks(new Object(){@InjectMocks @Captor ArgumentCaptor captor;});}
@Test public void shouldPointOutMisplacedMatcher(){misplacedArgumentMatcherHere();try {verify(mock).simpleMethod();fail();}catch(InvalidUseOfMatchersException e){assertContains("-> at ",e.getMessage());assertContains("misplacedArgumentMatcherHere(",e.getMessage());}}
@Test public void shouldPointOutUnfinishedStubbing(){unfinishedStubbingHere();try {verify(mock).simpleMethod();fail();}catch(UnfinishedStubbingException e){assertContains("-> at ",e.getMessage());assertContains("unfinishedStubbingHere(",e.getMessage());}}
@Test public void shouldShowWhereIsUnfinishedVerification()throws Exception {unfinishedVerificationHere();try {mock(IMethods.class);fail();}catch(UnfinishedVerificationException e){assertContains("unfinishedVerificationHere(",e.getMessage());}}
@Test public void closes_streams()throws Exception {IOUtil.closeQuietly(null);IOUtil.closeQuietly(new ByteArrayOutputStream());IOUtil.close(null);IOUtil.close(new ByteArrayOutputStream());}
@Test public void writes_reads_files()throws Exception {File file=tmp.newFile();IOUtil.writeText("foo\n\nbar",file);assertEquals(asList("foo","","bar"),IOUtil.readLines(new FileInputStream(file)));}
@Test public void shouldCallRealMethdsEvenDelegatedToOtherSelfMethod(){String name=spy.getName();assertEquals("Default name",name);}
@Test public void shouldAllowStubbingOfMethodsThatDelegateToOtherMethods(){when(spy.getName()).thenReturn("foo");assertEquals("foo",spy.getName());}
@Test public void shouldAllowStubbingWithThrowablesMethodsThatDelegateToOtherMethods(){doThrow(new RuntimeException("appetite for destruction")).when(spy).getNameButDelegateToMethodThatThrows();try {spy.getNameButDelegateToMethodThatThrows();fail();}catch(Exception e){assertEquals("appetite for destruction",e.getMessage());}}
@Test public void shouldStackTraceGetFilteredOnUserExceptions(){try {spy.getNameButDelegateToMethodThatThrows();fail();}catch(Throwable t){assertThat(t,ExtraMatchers.hasMethodsInStackTrace("throwSomeException","getNameButDelegateToMethodThatThrows","shouldStackTraceGetFilteredOnUserExceptions"));}}
@Test public void shouldVerify(){spy.getName();verify(spy).guessName();}
@Test public void shouldStub(){when(spy.guessName()).thenReturn(new Name("John"));String name=spy.getName();assertEquals("John",name);}
@Test public void shouldDealWithPrivateFieldsOfSubclasses(){assertEquals("100$",spy.howMuchDidYouInherit());}
@Test public void shouldKnowAboutJUnit45()throws Exception {RunnerProvider provider=new RunnerProvider();assertTrue(provider.isJUnit45OrHigherAvailable());}
@Test public void shouldCreateRunnerInstance()throws Throwable {RunnerProvider provider=new RunnerProvider();RunnerImpl runner=provider.newInstance("org.mockito.internal.runners.JUnit45AndHigherRunnerImpl",this.getClass());assertNotNull(runner);}
@Test public void shouldReturnEmptyArray(){String[]ret=(String[])rv.returnValueFor((new String[0]).getClass());assertTrue(ret.getClass().isArray());assertTrue(ret.length == 0);}
@Test public void shouldReturnEmptyString(){assertEquals("",rv.returnValueFor(String.class));}
@Test public void when_same_type_the_order_is_based_on_field_name()throws Exception {assertThat(new PropertyAndSetterInjection.FieldTypeAndNameComparator().compare(field("objectA"),field("objectB"))).isEqualTo(-1);assertThat(new PropertyAndSetterInjection.FieldTypeAndNameComparator().compare(field("objectB"),field("objectA"))).isEqualTo(1);assertThat(new PropertyAndSetterInjection.FieldTypeAndNameComparator().compare(field("objectB"),field("objectB"))).isEqualTo(0);}
@Test public void when_type_is_different_the_supertype_comes_last()throws Exception {assertThat(new PropertyAndSetterInjection.FieldTypeAndNameComparator().compare(field("numberA"),field("objectB"))).isEqualTo(-1);assertThat(new PropertyAndSetterInjection.FieldTypeAndNameComparator().compare(field("objectB"),field("numberA"))).isEqualTo(1);}
@Test public void using_Collections_dot_sort()throws Exception {List<Field> unsortedFields=Arrays.asList(field("objectB"),field("integerB"),field("numberA"),field("numberB"),field("objectA"),field("integerA"));Collections.sort(unsortedFields,new PropertyAndSetterInjection.FieldTypeAndNameComparator());assertThat(unsortedFields).containsSequence(field("integerA"),field("integerB"),field("numberA"),field("numberB"),field("objectA"),field("objectB"));}
@Test public void issue_352_order_was_different_between_JDK6_and_JDK7()throws Exception {List<Field> unsortedFields=Arrays.asList(field("objectB"),field("objectA"));Collections.sort(unsortedFields,new PropertyAndSetterInjection.FieldTypeAndNameComparator());assertThat(unsortedFields).containsSequence(field("objectA"),field("objectB"));}
@Test public void shouldPointStackTraceToPreviousInvocation(){inOrder.verify(mock,times(2)).simpleMethod(anyInt());inOrder.verify(mockTwo,times(2)).simpleMethod(anyInt());try {inOrder.verify(mock).simpleMethod(999);fail();}catch(VerificationInOrderFailure e){assertContains("secondChunk(",e.getMessage());}}
@Test public void shouldPointToThirdInteractionBecauseAtLeastOnceUsed(){inOrder.verify(mock,atLeastOnce()).simpleMethod(anyInt());try {inOrder.verify(mockTwo).simpleMethod(999);fail();}catch(VerificationInOrderFailure e){assertContains("thirdChunk(",e.getMessage());}}
@Test public void shouldPointToThirdChunkWhenTooLittleActualInvocations(){inOrder.verify(mock,times(2)).simpleMethod(anyInt());inOrder.verify(mockTwo,times(2)).simpleMethod(anyInt());inOrder.verify(mock,atLeastOnce()).simpleMethod(anyInt());try {inOrder.verify(mockTwo,times(3)).simpleMethod(999);fail();}catch(VerificationInOrderFailure e){assertContains("thirdChunk(",e.getMessage());}}
@Test public void shouldPointToFourthChunkBecauseTooManyActualInvocations(){inOrder.verify(mock,atLeastOnce()).simpleMethod(anyInt());try {inOrder.verify(mockTwo,times(0)).simpleMethod(anyInt());fail();}catch(VerificationInOrderFailure e){assertContains("fourthChunk(",e.getMessage());}}
@Test public void shouldStubbingNotRegisterRedundantInteractions()throws Exception {when(mock.add("one")).thenReturn(true);when(mock.add("two")).thenReturn(true);mock.add("one");verify(mock).add("one");verifyNoMoreInteractions(mock);}
@Test public void shouldVerifyWhenWantedNumberOfInvocationsUsed()throws Exception {mock.add("one");mock.add("one");mock.add("one");verify(mock,times(3)).add("one");verifyNoMoreInteractions(mock);}
@Test public void shouldVerifyNoInteractionsAsManyTimesAsYouWant()throws Exception {verifyNoMoreInteractions(mock);verifyNoMoreInteractions(mock);verifyZeroInteractions(mock);verifyZeroInteractions(mock);}
@Test public void shouldFailZeroInteractionsVerification()throws Exception {mock.clear();try {verifyZeroInteractions(mock);fail();}catch(NoInteractionsWanted e){}}
@Test public void shouldFailNoMoreInteractionsVerification()throws Exception {mock.clear();try {verifyNoMoreInteractions(mock);fail();}catch(NoInteractionsWanted e){}}
@Test public void shouldPrintAllInvocationsWhenVerifyingNoMoreInvocations()throws Exception {mock.add(1);mock.add(2);mock.clear();verify(mock).add(2);try {verifyNoMoreInteractions(mock);fail();}catch(NoInteractionsWanted e){assertContains("list of all invocations",e.getMessage());}}
@Test public void shouldNotContainAllInvocationsWhenSingleUnwantedFound()throws Exception {mock.add(1);try {verifyNoMoreInteractions(mock);fail();}catch(NoInteractionsWanted e){assertNotContains("list of all invocations",e.getMessage());}}
@Test public void shouldVerifyOneMockButFailOnOther()throws Exception {List list=mock(List.class);Map map=mock(Map.class);list.add("one");list.add("one");map.put("one",1);verify(list,times(2)).add("one");verifyNoMoreInteractions(list);try {verifyZeroInteractions(map);fail();}catch(NoInteractionsWanted e){}}
@SuppressWarnings("all")@Test(expected=MockitoException.class)public void verifyNoMoreInteractionsShouldScreamWhenNullPassed()throws Exception {verifyNoMoreInteractions((Object[])null);}
@Test public void shouldNotThrowNPE()throws Exception {Foo foo=new Foo();Foo spy=spy(foo);spy.len(anyString());spy.size(anyMap());spy.size(anyList());spy.size(anyCollection());spy.size(anySet());}
@Test public void shouldWork()throws Exception {Object o=new Object();set.add(o);assertTrue(set.contains(o));assertFalse(set.contains(new Object()));}
@Test public void shouldWorkEvenIfEqualsTheSame()throws Exception {assertEquals(new Fake(),new Fake());Fake fake=new Fake();set.add(fake);assertTrue(set.contains(fake));assertFalse(set.contains(new Fake()));}
@Test public void should_be_created_with_an_argument_resolver()throws Exception {new ParameterizedConstructorInstantiator(this,field("whateverForNow"),resolver);}
@Test public void should_fail_if_no_parameterized_constructor_found___excluding_inner_and_others_kind_of_types()throws Exception {try {new ParameterizedConstructorInstantiator(this,field("withNoArgConstructor"),resolver).instantiate();fail();}catch(MockitoException me){assertThat(me.getMessage()).contains("no parameterized constructor").contains("withNoArgConstructor").contains("NoArgConstructor");}}
@Test public void should_instantiate_type_if_resolver_provide_matching_types()throws Exception {Observer observer=mock(Observer.class);Map map=mock(Map.class);given(resolver.resolveTypeInstances(Matchers.<Class<?>[]>anyVararg())).willReturn(new Object[]{observer,map});new ParameterizedConstructorInstantiator(this,field("withMultipleConstructor"),resolver).instantiate();assertNotNull(withMultipleConstructor);assertNotNull(withMultipleConstructor.observer);assertNotNull(withMultipleConstructor.map);}
@Test public void should_fail_if_an_argument_instance_type_do_not_match_wanted_type()throws Exception {Observer observer=mock(Observer.class);Set wrongArg=mock(Set.class);given(resolver.resolveTypeInstances(Matchers.<Class<?>[]>anyVararg())).willReturn(new Object[]{observer,wrongArg});try {new ParameterizedConstructorInstantiator(this,field("withMultipleConstructor"),resolver).instantiate();fail();}catch(MockitoException e){assertThat(e.getMessage()).contains("argResolver").contains("incorrect types");}}
@Test public void should_report_failure_if_constructor_throws_exception()throws Exception {given(resolver.resolveTypeInstances(Matchers.<Class<?>[]>anyVararg())).willReturn(new Object[]{null});try {new ParameterizedConstructorInstantiator(this,field("withThrowingConstructor"),resolver).instantiate();fail();}catch(MockitoException e){assertThat(e.getMessage()).contains("constructor").contains("raised an exception");}}
@Test public void should_instantiate_type_with_vararg_constructor()throws Exception {Observer[]vararg=new Observer[]{};given(resolver.resolveTypeInstances(Matchers.<Class<?>[]>anyVararg())).willReturn(new Object[]{"",vararg});new ParameterizedConstructorInstantiator(this,field("withVarargConstructor"),resolver).instantiate();assertNotNull(withVarargConstructor);}
@Test public void shouldSmartNPEPointToUnstubbedCall()throws Exception {IMethods methods=unstubbedMethodInvokedHere(mock);try {methods.simpleMethod();fail();}catch(SmartNullPointerException e){assertContains("unstubbedMethodInvokedHere(",e.getMessage());}}
@Test public void shouldThrowSmartNPEWhenMethodReturnsClass()throws Exception {Foo mock=mock(Foo.class,RETURNS_SMART_NULLS);Foo foo=mock.getSomeClass();try {foo.boo();fail();}catch(SmartNullPointerException e){}}
@Test public void shouldThrowSmartNPEWhenMethodReturnsInterface()throws Exception {Foo mock=mock(Foo.class,RETURNS_SMART_NULLS);Bar bar=mock.getSomeInterface();try {bar.boo();fail();}catch(SmartNullPointerException e){}}
@Test public void shouldReturnOrdinaryEmptyValuesForOrdinaryTypes()throws Exception {IMethods mock=mock(IMethods.class,RETURNS_SMART_NULLS);assertEquals("",mock.stringReturningMethod());assertEquals(0,mock.intReturningMethod());assertEquals(true,mock.listReturningMethod().isEmpty());assertEquals(0,mock.arrayReturningMethod().length);}
@Test public void shouldNotThrowSmartNullPointerOnToString(){Object smartNull=mock.objectReturningMethod();try {verify(mock).simpleMethod(smartNull);fail();}catch(WantedButNotInvoked e){}}
@Test public void shouldNotThrowSmartNullPointerOnObjectMethods(){Object smartNull=mock.objectReturningMethod();smartNull.toString();}
@Test public void shouldShowParameters(){Foo foo=mock(Foo.class,RETURNS_SMART_NULLS);Bar smartNull=foo.getBarWithParams(10,"yes sir");try {smartNull.boo();fail();}catch(Exception e){assertContains("yes sir",e.getMessage());}}
@Test public void shouldShowParametersWhenParamsAreHuge(){Foo foo=mock(Foo.class,RETURNS_SMART_NULLS);String longStr="Lorem Ipsum is simply dummy text of the printing and typesetting industry. Lorem Ipsum has been the industry's standard dummy text ever since the 1500s,when an unknown printer took a galley of type and scrambled it to make a type specimen book. It has survived not only five centuries,but also the leap into electronic typesetting,remaining essentially unchanged. It was popularised in the 1960s with the release of Letraset sheets containing Lorem Ipsum passages,and more recently with desktop publishing software like Aldus PageMaker including versions of Lorem Ipsum.";Bar smartNull=foo.getBarWithParams(10,longStr);try {smartNull.boo();fail();}catch(Exception e){assertContains("Lorem Ipsum",e.getMessage());}}
@Test public void managerCountsArticlesAndSavesThemInTheDatabase(){when(mockCalculator.countArticles("Guardian")).thenReturn(12);when(mockCalculator.countArticlesInPolish(anyString())).thenReturn(5);articleManager.updateArticleCounters("Guardian");verify(mockDatabase).updateNumberOfArticles("Guardian",12);verify(mockDatabase).updateNumberOfPolishArticles("Guardian",5);verify(mockDatabase).updateNumberOfEnglishArticles("Guardian",7);}
@Test public void managerCountsArticlesUsingCalculator(){articleManager.updateArticleCounters("Guardian");verify(mockCalculator).countArticles("Guardian");verify(mockCalculator).countArticlesInPolish("Guardian");}
@Test public void managerSavesArticlesInTheDatabase(){articleManager.updateArticleCounters("Guardian");verify(mockDatabase).updateNumberOfArticles("Guardian",0);verify(mockDatabase).updateNumberOfPolishArticles("Guardian",0);verify(mockDatabase).updateNumberOfEnglishArticles("Guardian",0);}
@Test public void managerUpdatesNumberOfRelatedArticles(){Article articleOne=new Article();Article articleTwo=new Article();Article articleThree=new Article();when(mockCalculator.countNumberOfRelatedArticles(articleOne)).thenReturn(1);when(mockCalculator.countNumberOfRelatedArticles(articleTwo)).thenReturn(12);when(mockCalculator.countNumberOfRelatedArticles(articleThree)).thenReturn(0);when(mockDatabase.getArticlesFor("Guardian")).thenReturn(Arrays.asList(articleOne,articleTwo,articleThree));articleManager.updateRelatedArticlesCounters("Guardian");verify(mockDatabase).save(articleOne);verify(mockDatabase).save(articleTwo);verify(mockDatabase).save(articleThree);}
@Test public void shouldPersistRecalculatedArticle(){Article articleOne=new Article();Article articleTwo=new Article();when(mockCalculator.countNumberOfRelatedArticles(articleOne)).thenReturn(1);when(mockCalculator.countNumberOfRelatedArticles(articleTwo)).thenReturn(12);when(mockDatabase.getArticlesFor("Guardian")).thenReturn(Arrays.asList(articleOne,articleTwo));articleManager.updateRelatedArticlesCounters("Guardian");InOrder inOrder=inOrder(mockDatabase,mockCalculator);inOrder.verify(mockCalculator).countNumberOfRelatedArticles((Article)anyObject());inOrder.verify(mockDatabase,atLeastOnce()).save((Article)anyObject());}
@Test public void when_identical_types_and_the_correct_mock_name_is_greater_than_the_non_matching_name_then_injection_occurs_only_on_the_named_one(){assertThat("stringString_that_matches_field".compareTo("mockStringInteger_was_not_injected")).isGreaterThanOrEqualTo(1);assertSame(stringString_that_matches_field,fooService.stringString_that_matches_field);assertSame(mockStringInteger_was_not_injected,fooService.stringInteger_field);}
@Test public void should_throw_ClassCastException_on_second_call(){}
@Test public void should_not_throw_ClassCastException_when_objenesis_cache_disabled(){}
@Test(expected=MockitoException.class)public void shouldNotAllowSettingNullInterface(){mockSettingsImpl.extraInterfaces(List.class,null);}
@Test(expected=MockitoException.class)public void shouldNotAllowNonInterfaces(){mockSettingsImpl.extraInterfaces(List.class,LinkedList.class);}
@Test(expected=MockitoException.class)public void shouldNotAllowUsingTheSameInterfaceAsExtra(){mockSettingsImpl.extraInterfaces(List.class,LinkedList.class);}
@Test(expected=MockitoException.class)public void shouldNotAllowEmptyExtraInterfaces(){mockSettingsImpl.extraInterfaces();}
@Test(expected=MockitoException.class)public void shouldNotAllowNullArrayOfExtraInterfaces(){mockSettingsImpl.extraInterfaces((Class[])null);}
@Test public void shouldAllowMultipleInterfaces(){mockSettingsImpl.extraInterfaces(List.class,Set.class);assertEquals(2,mockSettingsImpl.getExtraInterfaces().size());assertTrue(mockSettingsImpl.getExtraInterfaces().contains(List.class));assertTrue(mockSettingsImpl.getExtraInterfaces().contains(Set.class));}
@Test public void shouldSetMockToBeSerializable()throws Exception {mockSettingsImpl.serializable();assertTrue(mockSettingsImpl.isSerializable());}
@Test public void shouldKnowIfIsSerializable()throws Exception {assertFalse(mockSettingsImpl.isSerializable());mockSettingsImpl.serializable();assertTrue(mockSettingsImpl.isSerializable());}
@Test public void shouldAddVerboseLoggingListener(){assertFalse(mockSettingsImpl.hasInvocationListeners());mockSettingsImpl.verboseLogging();assertContainsType(mockSettingsImpl.getInvocationListeners(),VerboseMockInvocationLogger.class);}
@Test public void shouldAddVerboseLoggingListenerOnlyOnce(){assertFalse(mockSettingsImpl.hasInvocationListeners());mockSettingsImpl.verboseLogging().verboseLogging();Assertions.assertThat(mockSettingsImpl.getInvocationListeners()).hasSize(1);}
@SuppressWarnings("all")@Test(expected=MockitoException.class)public void shouldNotAllowNullListener(){mockSettingsImpl.invocationListeners((InvocationListener[])null);}
@Test public void shouldAddInvocationListener(){assertFalse(mockSettingsImpl.hasInvocationListeners());mockSettingsImpl.invocationListeners(invocationListener);Assertions.assertThat(mockSettingsImpl.getInvocationListeners()).contains(invocationListener);}
@Test public void canAddDuplicateInvocationListeners_ItsNotOurBusinessThere(){assertFalse(mockSettingsImpl.hasInvocationListeners());mockSettingsImpl.invocationListeners(invocationListener,invocationListener).invocationListeners(invocationListener);Assertions.assertThat(mockSettingsImpl.getInvocationListeners()).containsSequence(invocationListener,invocationListener,invocationListener);}
@Test public void shouldReportErrorWhenAddingNoInvocationListeners()throws Exception {try {mockSettingsImpl.invocationListeners();fail();}catch(Exception e){Assertions.assertThat(e.getMessage()).contains("at least one listener");}}
@Test public void shouldReportErrorWhenAddingANullInvocationListener()throws Exception {try {mockSettingsImpl.invocationListeners(invocationListener,null);fail();}catch(Exception e){Assertions.assertThat(e.getMessage()).contains("does not accept null");}}
@Test public void should_capture_arguments()throws Exception {CapturingMatcher m=new CapturingMatcher();m.captureFrom("foo");m.captureFrom("bar");Assertions.assertThat(m.getAllValues()).containsSequence("foo","bar");}
@Test public void should_know_last_captured_value()throws Exception {CapturingMatcher m=new CapturingMatcher();m.captureFrom("foo");m.captureFrom("bar");assertEquals("bar",m.getLastValue());}
@Test public void should_scream_when_nothing_yet_captured()throws Exception {CapturingMatcher m=new CapturingMatcher();try {m.getLastValue();fail();}catch(MockitoException e){}}
@Ignore("Use it for performance checks")@Test public void testSomething(){List mocks=new LinkedList();for (int i=0;i < 50000;i++){System.out.println("Mock no: " + i);IMethods mock=mock(IMethods.class);mocks.add(mock);when(mock.simpleMethod(1)).thenReturn("one");when(mock.simpleMethod(2)).thenReturn("two");assertEquals("one",mock.simpleMethod(1));assertEquals("two",mock.simpleMethod(2));verify(mock).simpleMethod(1);verify(mock).simpleMethod(2);}}
@Test public void shouldStub()throws Exception {doReturn("foo").when(mock).simpleMethod();doReturn("bar").when(mock).simpleMethod();assertEquals("bar",mock.simpleMethod());}
@Test public void shouldStubWithArgs()throws Exception {doReturn("foo").when(mock).simpleMethod("foo");doReturn("bar").when(mock).simpleMethod(eq("one"),anyInt());assertEquals("foo",mock.simpleMethod("foo"));assertEquals("bar",mock.simpleMethod("one",234));assertEquals(null,mock.simpleMethod("xxx",234));}
@Test public void shouldStubWithThrowable()throws Exception {doThrow(new FooRuntimeException()).when(mock).voidMethod();try {mock.voidMethod();fail();}catch(FooRuntimeException e){}}
@Test public void shouldAllowSettingValidCheckedException()throws Exception {doThrow(new IOException()).when(mock).throwsIOException(0);try {mock.throwsIOException(0);fail();}catch(IOException e){}}
@Test public void shouldDetectInvalidCheckedException()throws Exception {try {doThrow(new FooCheckedException()).when(mock).throwsIOException(0);fail();}catch(Exception e){assertContains("Checked exception is invalid",e.getMessage());}}
@Test public void shouldScreamWhenReturnSetForVoid()throws Exception {try {doReturn("foo").when(mock).voidMethod();fail();}catch(MockitoException e){assertContains("void method",e.getMessage());assertContains("cannot",e.getMessage());}}
@Test public void shouldScreamWhenNotAMockPassed()throws Exception {try {doReturn("foo").when("foo").toString();fail();}catch(Exception e){assertContains("Argument passed to when()is not a mock",e.getMessage());}}
@Test public void shouldScreamWhenNullPassed()throws Exception {try {doReturn("foo").when((Object)null).toString();fail();}catch(Exception e){assertContains("Argument passed to when()is null",e.getMessage());}}
@Test public void shouldAllowChainedStubbing(){doReturn("foo").doThrow(new RuntimeException()).doReturn("bar").when(mock).simpleMethod();assertEquals("foo",mock.simpleMethod());try {mock.simpleMethod();fail();}catch(RuntimeException e){}assertEquals("bar",mock.simpleMethod());assertEquals("bar",mock.simpleMethod());}
@Test public void shouldAllowDoCallRealMethodInChainedStubbing()throws Exception {MethodsImpl methods=mock(MethodsImpl.class);doReturn("A").doCallRealMethod().when(methods).simpleMethod();assertEquals("A",methods.simpleMethod());assertEquals(null,methods.simpleMethod());}
@Test(expected=IllegalArgumentException.class)public void shouldAllowChainedStubbingWithExceptionClass()throws Exception {doReturn("whatever").doThrow(IllegalArgumentException.class).when(mock).simpleMethod();assertEquals("whatever",mock.simpleMethod());mock.simpleMethod();}
@Test public void shouldAllowChainedStubbingOnVoidMethods(){doNothing().doNothing().doThrow(new RuntimeException()).when(mock).voidMethod();mock.voidMethod();mock.voidMethod();try {mock.voidMethod();fail();}catch(RuntimeException e){}try {mock.voidMethod();fail();}catch(RuntimeException e){}}
@Test public void shouldStubWithGenericAnswer(){doAnswer(new Answer<Object>(){public Object answer(InvocationOnMock invocation)throws Throwable {return "foo";}}).when(mock).simpleMethod();assertEquals("foo",mock.simpleMethod());}
@Test public void shouldNotAllowDoNothingOnNonVoids(){try {doNothing().when(mock).simpleMethod();fail();}catch(MockitoException e){assertContains("Only void methods can doNothing()",e.getMessage());}}
@Test public void shouldStubbingBeTreatedAsInteraction()throws Exception {doReturn("foo").when(mock).simpleMethod();mock.simpleMethod();try {verifyNoMoreInteractions(mock);fail();}catch(NoInteractionsWanted e){}}
@Test public void shouldVerifyStubbedCall()throws Exception {doReturn("foo").when(mock).simpleMethod();mock.simpleMethod();mock.simpleMethod();verify(mock,times(2)).simpleMethod();verifyNoMoreInteractions(mock);}
@Test public void shouldAllowStubbingToString()throws Exception {doReturn("test").when(mock).toString();assertEquals("test",mock.toString());}
@Test public void shouldDetectInvalidReturnType()throws Exception {try {doReturn("foo").when(mock).booleanObjectReturningMethod();fail();}catch(Exception e){assertContains("String cannot be returned by booleanObjectReturningMethod()" + "\n" + "booleanObjectReturningMethod()should return Boolean",e.getMessage());}}
@Test public void shouldDetectWhenNullAssignedToBoolean()throws Exception {try {doReturn(null).when(mock).intReturningMethod();fail();}catch(Exception e){assertContains("null cannot be returned by intReturningMethod",e.getMessage());}}
@Test public void shouldAllowStubbingWhenTypesMatchSignature()throws Exception {doReturn("foo").when(mock).objectReturningMethodNoArgs();doReturn("foo").when(mock).simpleMethod();doReturn(1).when(mock).intReturningMethod();doReturn(new Integer(2)).when(mock).intReturningMethod();}
@Test public void should_be_thread_safe()throws Throwable {doShouldBeThreadSafe(container);}
@Test public void should_be_thread_safe_stub_only()throws Throwable {doShouldBeThreadSafe(containerStubOnly);}
@Test public void should_return_invoked_mock()throws Exception {container.setInvocationForPotentialStubbing(new InvocationMatcher(invocation));assertEquals(invocation.getMock(),container.invokedMock());}
@Test public void should_return_invoked_mock_stub_only()throws Exception {containerStubOnly.setInvocationForPotentialStubbing(new InvocationMatcher(invocation));assertEquals(invocation.getMock(),containerStubOnly.invokedMock());}
@Test public void should_tell_if_has_invocation_for_potential_stubbing()throws Exception {container.setInvocationForPotentialStubbing(new InvocationBuilder().toInvocationMatcher());assertTrue(container.hasInvocationForPotentialStubbing());container.addAnswer(new ReturnsEmptyValues());assertFalse(container.hasInvocationForPotentialStubbing());}
@Test public void should_tell_if_has_invocation_for_potential_stubbing_stub_only()throws Exception {containerStubOnly.setInvocationForPotentialStubbing(new InvocationBuilder().toInvocationMatcher());assertTrue(containerStubOnly.hasInvocationForPotentialStubbing());containerStubOnly.addAnswer(new ReturnsEmptyValues());assertFalse(containerStubOnly.hasInvocationForPotentialStubbing());}
@Test public void shouldGetArgumentsLine(){String line=printer.getArgumentsLine((List)Arrays.asList(new Equals(1),new Equals(2)),new PrintSettings());assertEquals("(1,2);",line);}
@Test public void shouldGetArgumentsBlock(){String line=printer.getArgumentsBlock((List)Arrays.asList(new Equals(1),new Equals(2)),new PrintSettings());assertEquals("(\n    1,\n    2\n);",line);}
@Test public void shouldDescribeTypeInfoOnlyMarkedMatchers(){String line=printer.getArgumentsLine((List)Arrays.asList(new Equals(1L),new Equals(2)),PrintSettings.verboseMatchers(1));assertEquals("(1,(Integer)2);",line);}
@Test public void shouldGetVerboseArgumentsInBlock(){String line=printer.getArgumentsBlock((List)Arrays.asList(new Equals(1L),new Equals(2)),PrintSettings.verboseMatchers(0,1));assertEquals("(\n    (Long)1,\n    (Integer)2\n);",line);}
@Test public void shouldGetVerboseArgumentsEvenIfSomeMatchersAreNotVerbose(){String line=printer.getArgumentsLine((List)Arrays.asList(new Equals(1L),NotNull.NOT_NULL),PrintSettings.verboseMatchers(0));assertEquals("((Long)1,notNull());",line);}
@Test public void shouldGetAllInvocationsInOrder()throws Exception {mockOne.simpleMethod(100);mockTwo.simpleMethod(200);mockOne.simpleMethod(300);List<Invocation> invocations=finder.find(asList(mockOne,mockTwo));assertEquals(3,invocations.size());assertArgumentEquals(100,invocations.get(0));assertArgumentEquals(200,invocations.get(1));assertArgumentEquals(300,invocations.get(2));}
@Test public void shouldNotCountDuplicatedInteractions()throws Exception {mockOne.simpleMethod(100);List<Invocation> invocations=finder.find(asList(mockOne,mockOne,mockOne));assertEquals(1,invocations.size());}
@Test public void shouldAllowPassingNullArgument(){Fun mockFun=mock(Fun.class);when(mockFun.doFun((String)anyObject())).thenReturn("value");mockFun.doFun(null);try {verify(mockFun).doFun("hello");fail();}catch(AssertionError r){}}
@Test public void shouldShowActualAndExpectedWhenArgumentsAreDifferent(){callMethodOnMock("foo");try {verifyTheMock(1,"not foo");fail();}catch(ArgumentsAreDifferent e){assertContains("callMethodOnMock(",e.getMessage());assertContains("verifyTheMock(",e.getMessage());}}
@Test public void listener()throws Exception {InvocationListener invocationListener=mock(InvocationListener.class);List mockedList=mock(List.class,withSettings().invocationListeners(invocationListener));reset(mockedList);mockedList.clear();verify(invocationListener).reportInvocation(any(MethodInvocationReport.class));}
@Test public void shouldLogUnusedStubbingWarningWhenTestFails()throws Exception {when(mock.simpleMethod(1)).thenReturn("foo");when(mock.otherMethod()).thenReturn("foo");when(mock.booleanObjectReturningMethod()).thenReturn(false);String ret=mock.simpleMethod(2);assertEquals("foo",ret);}
@Test public void shouldNotLogAnythingWhenNoWarnings()throws Exception {when(mock.simpleMethod()).thenReturn("foo");mock.simpleMethod();verify(mock).simpleMethod();fail();}
@Test public void shouldProvideTheNameForClass()throws Exception {String name=new MockNameImpl(null,SomeClass.class).toString();assertEquals("someClass",name);}
@Test public void shouldProvideTheNameForAnonymousClass()throws Exception {SomeInterface anonymousInstance=new SomeInterface(){};String name=new MockNameImpl(null,anonymousInstance.getClass()).toString();assertEquals("someInterface",name);}
@Test public void shouldProvideTheGivenName()throws Exception {String name=new MockNameImpl("The Hulk",SomeClass.class).toString();assertEquals("The Hulk",name);}
@Test public void shouldMixVerificationInOrderAndOrdinaryVerification(){inOrder.verify(mockOne,atLeastOnce()).simpleMethod(1);inOrder.verify(mockThree).simpleMethod(3);inOrder.verify(mockThree).simpleMethod(4);verify(mockTwo).simpleMethod(2);verifyNoMoreInteractions(mockOne,mockTwo,mockThree);}
@Test public void shouldAllowOrdinarilyVerifyingMockPassedToInOrderObject(){inOrder.verify(mockOne,atLeastOnce()).simpleMethod(1);verify(mockThree).simpleMethod(3);verify(mockThree).simpleMethod(4);verify(mockTwo).simpleMethod(2);verifyNoMoreInteractions(mockOne,mockTwo,mockThree);}
@Test public void shouldAllowRedundantVerifications(){verify(mockOne,atLeastOnce()).simpleMethod(1);verify(mockTwo).simpleMethod(2);verify(mockThree).simpleMethod(3);verify(mockThree).simpleMethod(4);inOrder.verify(mockOne,atLeastOnce()).simpleMethod(1);inOrder.verify(mockThree).simpleMethod(3);inOrder.verify(mockThree).simpleMethod(4);verifyNoMoreInteractions(mockOne,mockTwo,mockThree);}
@Test public void shouldFailOnNoMoreInteractions(){inOrder.verify(mockOne,atLeastOnce()).simpleMethod(1);inOrder.verify(mockThree).simpleMethod(3);inOrder.verify(mockThree).simpleMethod(4);try {verifyNoMoreInteractions(mockOne,mockTwo,mockThree);fail();}catch(NoInteractionsWanted e){}}
@Test public void shouldFailOnNoMoreInteractionsOnMockVerifiedInOrder(){inOrder.verify(mockOne,atLeastOnce()).simpleMethod(1);inOrder.verify(mockThree).simpleMethod(3);verify(mockTwo).simpleMethod(2);try {verifyNoMoreInteractions(mockOne,mockTwo,mockThree);fail();}catch(NoInteractionsWanted e){}}
@Test public void shouldAllowOneMethodVerifiedInOrder(){verify(mockTwo).simpleMethod(2);verify(mockOne,atLeastOnce()).simpleMethod(1);inOrder.verify(mockOne,atLeastOnce()).simpleMethod(1);}
@Test public void shouldFailOnLastInvocationTooEarly(){inOrder.verify(mockThree).simpleMethod(4);verify(mockThree).simpleMethod(4);verify(mockTwo).simpleMethod(2);try {inOrder.verify(mockOne,atLeastOnce()).simpleMethod(1);fail();}catch(VerificationInOrderFailure e){}}
@Test(expected=MockitoException.class)public void shouldScreamWhenUnfamiliarMockPassedToInOrderObject(){inOrder.verify(mockTwo,atLeastOnce()).simpleMethod(1);}
@Test public void shouldUseEqualsToVerifyMethodArguments(){mockOne=mock(IMethods.class);String textOne="test";String textTwo=new String(textOne);assertEquals(textOne,textTwo);assertNotSame(textOne,textTwo);mockOne.simpleMethod(textOne);mockOne.simpleMethod(textTwo);verify(mockOne,times(2)).simpleMethod(textOne);inOrder=inOrder(mockOne);inOrder.verify(mockOne,times(2)).simpleMethod(textOne);}
@Test public void shouldUseEqualsToVerifyMethodVarargs(){mockOne=mock(IMethods.class);String textOne="test";String textTwo=new String(textOne);assertEquals(textOne,textTwo);assertNotSame(textOne,textTwo);mockOne.varargsObject(1,textOne,textOne);mockOne.varargsObject(1,textTwo,textTwo);verify(mockOne,times(2)).varargsObject(1,textOne,textOne);inOrder=inOrder(mockOne);inOrder.verify(mockOne,times(2)).varargsObject(1,textOne,textOne);}
@Test public void shouldDisableTimeoutForAtMost(){try {verify(mock,timeout(30000).atMost(1)).simpleMethod();fail();}catch(FriendlyReminderException e){}}
@Test public void shouldDisableTimeoutForNever(){try {verify(mock,timeout(30000).never()).simpleMethod();fail();}catch(FriendlyReminderException e){}}
@Test public void inOrderTest(){List list=mock(List.class);list.add("a");list.add("x");list.add("b");list.add("y");InOrder inOrder=inOrder(list);InOrder inAnotherOrder=inOrder(list);assertNotSame(inOrder,inAnotherOrder);inOrder.verify(list).add("a");inOrder.verify(list).add("b");inAnotherOrder.verify(list).add("x");inAnotherOrder.verify(list).add("y");}
@Test public void shouldFailFastWhenCallingRealMethodOnInterface()throws Exception {List list=mock(List.class);try {when(list.get(0)).thenCallRealMethod();fail();}catch(MockitoException e){}}
@Test public void shouldFailInRuntimeWhenCallingRealMethodOnInterface()throws Exception {List list=mock(List.class);when(list.get(0)).thenAnswer(new Answer(){public Object answer(InvocationOnMock invocation)throws Throwable {return invocation.callRealMethod();}});try {list.get(0);fail();}catch(MockitoException e){}}
@Test public void shouldVerifyActualNumberOfInvocationsSmallerThanWanted()throws Exception {mock.clear();mock.clear();mock.clear();Mockito.verify(mock,times(3)).clear();try {Mockito.verify(mock,times(100)).clear();fail();}catch(TooLittleActualInvocations e){assertContains("mock.clear();",e.getMessage());assertContains("Wanted 100 times",e.getMessage());assertContains("was 3",e.getMessage());}}
@Test public void shouldVerifyActualNumberOfInvocationsLargerThanWanted()throws Exception {mock.clear();mock.clear();mock.clear();mock.clear();Mockito.verify(mock,times(4)).clear();try {Mockito.verify(mock,times(1)).clear();fail();}catch(TooManyActualInvocations e){assertContains("mock.clear();",e.getMessage());assertContains("Wanted 1 time",e.getMessage());assertContains("was 4",e.getMessage());}}
@Test public void shouldAllowCapturingArguments(){mock.simpleMethod("o");ArgumentCaptor<String> arg=ArgumentCaptor.forClass(String.class);verify(mock,only()).simpleMethod(arg.capture());assertEquals("o",arg.getValue());}
@Test public void discoverDeepMockingOfGenerics(){MyClass1 myMock1=mock(MyClass1.class,RETURNS_DEEP_STUBS);when(myMock1.getNested().getNested().returnSomething()).thenReturn("Hello World.");}
@Test public void should_provide_invocations(){List<String> methodsInvoked=new ArrayList<String>(){{add("add");add("remove");add("clear");}};List<String> mockedList=(List<String>)mock(List.class);mockedList.add("one");mockedList.remove(0);mockedList.clear();MockingDetails mockingDetails=new MockitoCore().mockingDetails(mockedList);Collection<Invocation> invocations=mockingDetails.getInvocations();assertNotNull(invocations);assertEquals(invocations.size(),3);for(Invocation method : invocations){assertTrue(methodsInvoked.contains(method.getMethod().getName()));if (method.getMethod().getName().equals("add")){assertEquals(method.getArguments().length,1);assertEquals(method.getArguments()[0],"one");}}}
@Test public void should_handle_null_input(){}
@Test public void shouldInjectMocksIfThereIsNoUserDefinedEngine()throws Exception {AnnotationEngine defaultEngine=new DefaultMockitoConfiguration().getAnnotationEngine();ConfigurationAccess.getConfig().overrideAnnotationEngine(defaultEngine);SimpleTestCase test=new SimpleTestCase();MockitoAnnotations.initMocks(test);assertNotNull(test.mock);assertNotNull(test.tested.dependency);assertSame(test.mock,test.tested.dependency);}
@Test public void shouldRespectUsersEngine()throws Exception {AnnotationEngine customizedEngine=new DefaultAnnotationEngine(){};ConfigurationAccess.getConfig().overrideAnnotationEngine(customizedEngine);SimpleTestCase test=new SimpleTestCase();MockitoAnnotations.initMocks(test);assertNotNull(test.mock);assertNull(test.tested.dependency);}
@Test(expected=NullPointerException.class)public void should_not_allow_null_on_field(){MockInjection.onField((Field)null,this);}
@Test(expected=NullPointerException.class)public void should_not_allow_null_on_fields(){MockInjection.onFields((Set<Field>)null,this);}
@Test(expected=NullPointerException.class)public void should_not_allow_null_on_instance_owning_the_field()throws Exception {MockInjection.onField(field("withConstructor"),null);}
@Test(expected=NullPointerException.class)public void should_not_allow_null_on_mocks()throws Exception {MockInjection.onField(field("withConstructor"),this).withMocks(null);}
@Test public void can_try_constructor_injection()throws Exception {MockInjection.onField(field("withConstructor"),this).withMocks(oneSetMock()).tryConstructorInjection().apply();assertThat(withConstructor.initializedWithConstructor).isEqualTo(true);}
@Test public void should_not_fail_if_constructor_injection_is_not_possible()throws Exception {MockInjection.onField(field("withoutConstructor"),this).withMocks(otherKindOfMocks()).tryConstructorInjection().apply();assertThat(withoutConstructor).isNull();}
@Test public void can_try_property_or_setter_injection()throws Exception {MockInjection.onField(field("withoutConstructor"),this).withMocks(oneSetMock()).tryPropertyOrFieldInjection().apply();assertThat(withoutConstructor.theSet).isNotNull();}
@Test public void should_not_fail_if_property_or_field_injection_is_not_possible()throws Exception {MockInjection.onField(field("withoutConstructor"),this).withMocks(otherKindOfMocks()).tryPropertyOrFieldInjection().apply();assertThat(withoutConstructor.theSet).isNull();}
@Test public void shouldReplaceException()throws Exception {RuntimeException actualExc=new RuntimeException("foo");Failure failure=new Failure(Description.EMPTY,actualExc);hacker.appendWarnings(failure,"unused stubbing");assertEquals(ExceptionIncludingMockitoWarnings.class,failure.getException().getClass());assertEquals(actualExc,failure.getException().getCause());Assertions.assertThat(actualExc.getStackTrace()).isEqualTo(failure.getException().getStackTrace());}
@Test public void shouldAppendWarning()throws Exception {Failure failure=new Failure(Description.EMPTY,new RuntimeException("foo"));hacker.appendWarnings(failure,"unused stubbing blah");assertContains("unused stubbing blah",failure.getException().getMessage());}
@Test public void shouldNotAppendWhenNoWarnings()throws Exception {RuntimeException ex=new RuntimeException("foo");Failure failure=new Failure(Description.EMPTY,ex);hacker.appendWarnings(failure,"");assertEquals(ex,failure.getException());}
@Test public void shouldNotAppendWhenNullWarnings()throws Exception {RuntimeException ex=new RuntimeException("foo");Failure failure=new Failure(Description.EMPTY,ex);hacker.appendWarnings(failure,null);assertEquals(ex,failure.getException());}
@Test public void shouldPrintTheWarningSoICanSeeIt()throws Exception {Failure failure=new Failure(Description.EMPTY,new RuntimeException("foo"));hacker.appendWarnings(failure,"unused stubbing blah");System.out.println(failure.getException());}
@Test public void shouldShowAllInteractionsOnMockWhenOrdinaryVerificationFail()throws Exception {firstInteraction();secondInteraction();try {verify(mock).simpleMethod();fail();}catch(WantedButNotInvoked e){assertContains("However,there were other interactions with this mock",e.getMessage());assertContains("firstInteraction(",e.getMessage());assertContains("secondInteraction(",e.getMessage());}}
@Test public void shouldNotShowAllInteractionsOnDifferentMock()throws Exception {differentMockInteraction();firstInteraction();try {verify(mock).simpleMethod();fail();}catch(WantedButNotInvoked e){assertContains("firstInteraction(",e.getMessage());assertNotContains("differentMockInteraction(",e.getMessage());}}
@Test public void shouldNotShowAllInteractionsHeaderWhenNoOtherInteractions()throws Exception {try {verify(mock).simpleMethod();fail();}catch(WantedButNotInvoked e){assertContains("there were zero interactions with this mock.",e.getMessage());}}
@Test public void shouldReportTooLittleActual()throws Exception {finderStub.actualToReturn.add(new InvocationBuilder().toInvocation());checker.check(invocations,wanted,100);assertEquals(1,reporterStub.actualCount);assertEquals(100,reporterStub.wantedCount);assertEquals(wanted,reporterStub.wanted);}
@Test public void shouldReportWithLastInvocationStackTrace()throws Exception {Invocation first=new InvocationBuilder().toInvocation();Invocation second=new InvocationBuilder().toInvocation();finderStub.actualToReturn.addAll(asList(first,second));checker.check(invocations,wanted,100);assertSame(second.getLocation(),reporterStub.location);}
@Test public void shouldNotReportWithLastInvocationStackTraceIfNoInvocationsFound()throws Exception {assertTrue(finderStub.actualToReturn.isEmpty());checker.check(invocations,wanted,100);assertNull(reporterStub.location);}
@Test public void shouldReportWithFirstUndesiredInvocationStackTrace()throws Exception {Invocation first=new InvocationBuilder().toInvocation();Invocation second=new InvocationBuilder().toInvocation();Invocation third=new InvocationBuilder().toInvocation();finderStub.actualToReturn.addAll(asList(first,second,third));checker.check(invocations,wanted,2);assertSame(third.getLocation(),reporterStub.location);}
@Test public void shouldReportTooManyActual()throws Exception {finderStub.actualToReturn.add(new InvocationBuilder().toInvocation());finderStub.actualToReturn.add(new InvocationBuilder().toInvocation());checker.check(invocations,wanted,1);assertEquals(2,reporterStub.actualCount);assertEquals(1,reporterStub.wantedCount);assertEquals(wanted,reporterStub.wanted);}
@Test public void shouldReportNeverWantedButInvoked()throws Exception {Invocation invocation=new InvocationBuilder().toInvocation();finderStub.actualToReturn.add(invocation);checker.check(invocations,wanted,0);assertEquals(wanted,reporterStub.wanted);assertEquals(invocation.getLocation(),reporterStub.location);}
@Test public void shouldMarkInvocationsAsVerified()throws Exception {Invocation invocation=new InvocationBuilder().toInvocation();finderStub.actualToReturn.add(invocation);assertFalse(invocation.isVerified());checker.check(invocations,wanted,1);assertTrue(invocation.isVerified());}
@Test public void andOverloaded(){when(mock.oneArg(and(eq(false),eq(false)))).thenReturn("0");when(mock.oneArg(and(eq((byte)1),eq((byte)1)))).thenReturn("1");when(mock.oneArg(and(eq('a'),eq('a')))).thenReturn("2");when(mock.oneArg(and(eq((double)1),eq((double)1)))).thenReturn("3");when(mock.oneArg(and(eq((float)1),eq((float)1)))).thenReturn("4");when(mock.oneArg(and(eq((int)1),eq((int)1)))).thenReturn("5");when(mock.oneArg(and(eq((long)1),eq((long)1)))).thenReturn("6");when(mock.oneArg(and(eq((short)1),eq((short)1)))).thenReturn("7");when(mock.oneArg(and(Matchers.contains("a"),Matchers.contains("d")))).thenReturn("8");when(mock.oneArg(and(isA(Class.class),eq(Object.class)))).thenReturn("9");assertEquals("0",mock.oneArg(false));assertEquals(null,mock.oneArg(true));assertEquals("1",mock.oneArg((byte)1));assertEquals("2",mock.oneArg('a'));assertEquals("3",mock.oneArg((double)1));assertEquals("4",mock.oneArg((float)1));assertEquals("5",mock.oneArg((int)1));assertEquals("6",mock.oneArg((long)1));assertEquals("7",mock.oneArg((short)1));assertEquals("8",mock.oneArg("abcde"));assertEquals(null,mock.oneArg("aaaaa"));assertEquals("9",mock.oneArg(Object.class));}
@Test public void orOverloaded(){when(mock.oneArg(or(eq(false),eq(true)))).thenReturn("0");when(mock.oneArg(or(eq((byte)1),eq((byte)2)))).thenReturn("1");when(mock.oneArg(or(eq((char)1),eq((char)2)))).thenReturn("2");when(mock.oneArg(or(eq((double)1),eq((double)2)))).thenReturn("3");when(mock.oneArg(or(eq((float)1),eq((float)2)))).thenReturn("4");when(mock.oneArg(or(eq((int)1),eq((int)2)))).thenReturn("5");when(mock.oneArg(or(eq((long)1),eq((long)2)))).thenReturn("6");when(mock.oneArg(or(eq((short)1),eq((short)2)))).thenReturn("7");when(mock.oneArg(or(eq("asd"),eq("jkl")))).thenReturn("8");when(mock.oneArg(or(eq(this.getClass()),eq(Object.class)))).thenReturn("9");assertEquals("0",mock.oneArg(true));assertEquals("0",mock.oneArg(false));assertEquals("1",mock.oneArg((byte)2));assertEquals("2",mock.oneArg((char)1));assertEquals("3",mock.oneArg((double)2));assertEquals("4",mock.oneArg((float)1));assertEquals("5",mock.oneArg((int)2));assertEquals("6",mock.oneArg((long)1));assertEquals("7",mock.oneArg((short)1));assertEquals("8",mock.oneArg("jkl"));assertEquals("8",mock.oneArg("asd"));assertEquals(null,mock.oneArg("asdjkl"));assertEquals("9",mock.oneArg(Object.class));assertEquals(null,mock.oneArg(String.class));}
@Test public void notOverloaded(){when(mock.oneArg(not(eq(false)))).thenReturn("0");when(mock.oneArg(not(eq((byte)1)))).thenReturn("1");when(mock.oneArg(not(eq('a')))).thenReturn("2");when(mock.oneArg(not(eq((double)1)))).thenReturn("3");when(mock.oneArg(not(eq((float)1)))).thenReturn("4");when(mock.oneArg(not(eq((int)1)))).thenReturn("5");when(mock.oneArg(not(eq((long)1)))).thenReturn("6");when(mock.oneArg(not(eq((short)1)))).thenReturn("7");when(mock.oneArg(not(Matchers.contains("a")))).thenReturn("8");when(mock.oneArg(not(isA(Class.class)))).thenReturn("9");assertEquals("0",mock.oneArg(true));assertEquals(null,mock.oneArg(false));assertEquals("1",mock.oneArg((byte)2));assertEquals("2",mock.oneArg('b'));assertEquals("3",mock.oneArg((double)2));assertEquals("4",mock.oneArg((float)2));assertEquals("5",mock.oneArg((int)2));assertEquals("6",mock.oneArg((long)2));assertEquals("7",mock.oneArg((short)2));assertEquals("8",mock.oneArg("bcde"));assertEquals("9",mock.oneArg(new Object()));assertEquals(null,mock.oneArg(Class.class));}
@Test public void lessOrEqualOverloaded(){when(mock.oneArg(leq((byte)1))).thenReturn("1");when(mock.oneArg(leq((double)1))).thenReturn("3");when(mock.oneArg(leq((float)1))).thenReturn("4");when(mock.oneArg(leq((int)1))).thenReturn("5");when(mock.oneArg(leq((long)1))).thenReturn("6");when(mock.oneArg(leq((short)1))).thenReturn("7");when(mock.oneArg(leq(new BigDecimal("1")))).thenReturn("8");assertEquals("1",mock.oneArg((byte)1));assertEquals(null,mock.oneArg((byte)2));assertEquals("3",mock.oneArg((double)1));assertEquals("7",mock.oneArg((short)0));assertEquals("4",mock.oneArg((float)-5));assertEquals("5",mock.oneArg((int)-2));assertEquals("6",mock.oneArg((long)-3));assertEquals("8",mock.oneArg(new BigDecimal("0.5")));assertEquals(null,mock.oneArg(new BigDecimal("1.1")));}
@Test public void lessThanOverloaded(){when(mock.oneArg(lt((byte)1))).thenReturn("1");when(mock.oneArg(lt((double)1))).thenReturn("3");when(mock.oneArg(lt((float)1))).thenReturn("4");when(mock.oneArg(lt((int)1))).thenReturn("5");when(mock.oneArg(lt((long)1))).thenReturn("6");when(mock.oneArg(lt((short)1))).thenReturn("7");when(mock.oneArg(lt(new BigDecimal("1")))).thenReturn("8");assertEquals("1",mock.oneArg((byte)0));assertEquals(null,mock.oneArg((byte)1));assertEquals("3",mock.oneArg((double)0));assertEquals("7",mock.oneArg((short)0));assertEquals("4",mock.oneArg((float)-4));assertEquals("5",mock.oneArg((int)-34));assertEquals("6",mock.oneArg((long)-6));assertEquals("8",mock.oneArg(new BigDecimal("0.5")));assertEquals(null,mock.oneArg(new BigDecimal("23")));}
@Test public void greaterOrEqualMatcherOverloaded(){when(mock.oneArg(geq((byte)1))).thenReturn("1");when(mock.oneArg(geq((double)1))).thenReturn("3");when(mock.oneArg(geq((float)1))).thenReturn("4");when(mock.oneArg(geq((int)1))).thenReturn("5");when(mock.oneArg(geq((long)1))).thenReturn("6");when(mock.oneArg(geq((short)1))).thenReturn("7");when(mock.oneArg(geq(new BigDecimal("1")))).thenReturn("8");assertEquals("1",mock.oneArg((byte)2));assertEquals(null,mock.oneArg((byte)0));assertEquals("3",mock.oneArg((double)1));assertEquals("7",mock.oneArg((short)2));assertEquals("4",mock.oneArg((float)3));assertEquals("5",mock.oneArg((int)4));assertEquals("6",mock.oneArg((long)5));assertEquals("8",mock.oneArg(new BigDecimal("1.00")));assertEquals(null,mock.oneArg(new BigDecimal("0.9")));}
@Test public void greaterThanMatcherOverloaded(){when(mock.oneArg(gt((byte)1))).thenReturn("1");when(mock.oneArg(gt((double)1))).thenReturn("3");when(mock.oneArg(gt((float)1))).thenReturn("4");when(mock.oneArg(gt((int)1))).thenReturn("5");when(mock.oneArg(gt((long)1))).thenReturn("6");when(mock.oneArg(gt((short)1))).thenReturn("7");when(mock.oneArg(gt(new BigDecimal("1")))).thenReturn("8");assertEquals("1",mock.oneArg((byte)2));assertEquals(null,mock.oneArg((byte)1));assertEquals("3",mock.oneArg((double)2));assertEquals("7",mock.oneArg((short)2));assertEquals("4",mock.oneArg((float)3));assertEquals("5",mock.oneArg((int)2));assertEquals("6",mock.oneArg((long)5));assertEquals("8",mock.oneArg(new BigDecimal("1.5")));assertEquals(null,mock.oneArg(new BigDecimal("0.9")));}
@Test public void compareToMatcher(){when(mock.oneArg(cmpEq(new BigDecimal("1.5")))).thenReturn("0");assertEquals("0",mock.oneArg(new BigDecimal("1.50")));assertEquals(null,mock.oneArg(new BigDecimal("1.51")));}
@Test public void anyStringMatcher(){when(mock.oneArg(anyString())).thenReturn("1");assertEquals("1",mock.oneArg(""));assertEquals("1",mock.oneArg("any string"));assertEquals(null,mock.oneArg((Object)null));}
@Test public void anyMatcher(){when(mock.oneArg(anyBoolean())).thenReturn("0");when(mock.oneArg(anyByte())).thenReturn("1");when(mock.oneArg(anyChar())).thenReturn("2");when(mock.oneArg(anyDouble())).thenReturn("3");when(mock.oneArg(anyFloat())).thenReturn("4");when(mock.oneArg(anyInt())).thenReturn("5");when(mock.oneArg(anyLong())).thenReturn("6");when(mock.oneArg(anyShort())).thenReturn("7");when(mock.oneArg((String)anyObject())).thenReturn("8");when(mock.oneArg(anyObject())).thenReturn("9");assertEquals("0",mock.oneArg(true));assertEquals("0",mock.oneArg(false));assertEquals("1",mock.oneArg((byte)1));assertEquals("2",mock.oneArg((char)1));assertEquals("3",mock.oneArg((double)1));assertEquals("4",mock.oneArg((float)889));assertEquals("5",mock.oneArg((int)1));assertEquals("6",mock.oneArg((long)1));assertEquals("7",mock.oneArg((short)1));assertEquals("8",mock.oneArg("Test"));assertEquals("9",mock.oneArg(new Object()));assertEquals("9",mock.oneArg(new HashMap()));}
@Test public void shouldArrayEqualsDealWithNullArray()throws Exception {Object[]nullArray=null;when(mock.oneArray(aryEq(nullArray))).thenReturn("null");assertEquals("null",mock.oneArray(nullArray));mock=mock(IMethods.class);try {verify(mock).oneArray(aryEq(nullArray));fail();}catch(WantedButNotInvoked e){assertContains("oneArray(null)",e.getMessage());}}
@Test public void shouldUseSmartEqualsForArrays()throws Exception {mock.arrayMethod(new String[]{"one"});verify(mock).arrayMethod(eq(new String[]{"one"}));verify(mock).arrayMethod(new String[]{"one"});}
@Test public void shouldUseSmartEqualsForPrimitiveArrays()throws Exception {mock.objectArgMethod(new int[]{1,2});verify(mock).objectArgMethod(eq(new int[]{1,2}));verify(mock).objectArgMethod(new int[]{1,2});}
@Test(expected=ArgumentsAreDifferent.class)public void arrayEqualsShouldThrowArgumentsAreDifferentExceptionForNonMatchingArguments(){List list=Mockito.mock(List.class);list.add("test");list.contains(new Object[]{"1"});Mockito.verify(list).contains(new Object[]{"1","2","3"});}
@Test public void arrayEqualsMatcher(){when(mock.oneArray(aryEq(new boolean[]{true,false,false}))).thenReturn("0");when(mock.oneArray(aryEq(new byte[]{1}))).thenReturn("1");when(mock.oneArray(aryEq(new char[]{1}))).thenReturn("2");when(mock.oneArray(aryEq(new double[]{1}))).thenReturn("3");when(mock.oneArray(aryEq(new float[]{1}))).thenReturn("4");when(mock.oneArray(aryEq(new int[]{1}))).thenReturn("5");when(mock.oneArray(aryEq(new long[]{1}))).thenReturn("6");when(mock.oneArray(aryEq(new short[]{1}))).thenReturn("7");when(mock.oneArray(aryEq(new String[]{"Test"}))).thenReturn("8");when(mock.oneArray(aryEq(new Object[]{"Test",new Integer(4)}))).thenReturn("9");assertEquals("0",mock.oneArray(new boolean[]{true,false,false}));assertEquals("1",mock.oneArray(new byte[]{1}));assertEquals("2",mock.oneArray(new char[]{1}));assertEquals("3",mock.oneArray(new double[]{1}));assertEquals("4",mock.oneArray(new float[]{1}));assertEquals("5",mock.oneArray(new int[]{1}));assertEquals("6",mock.oneArray(new long[]{1}));assertEquals("7",mock.oneArray(new short[]{1}));assertEquals("8",mock.oneArray(new String[]{"Test"}));assertEquals("9",mock.oneArray(new Object[]{"Test",new Integer(4)}));assertEquals(null,mock.oneArray(new Object[]{"Test",new Integer(999)}));assertEquals(null,mock.oneArray(new Object[]{"Test",new Integer(4),"x"}));assertEquals(null,mock.oneArray(new boolean[]{true,false}));assertEquals(null,mock.oneArray(new boolean[]{true,true,false}));}
@Test public void greaterOrEqualMatcher(){when(mock.oneArg(geq(7))).thenReturn(">= 7");when(mock.oneArg(lt(7))).thenReturn("< 7");assertEquals(">= 7",mock.oneArg(7));assertEquals(">= 7",mock.oneArg(8));assertEquals(">= 7",mock.oneArg(9));assertEquals("< 7",mock.oneArg(6));assertEquals("< 7",mock.oneArg(6));}
@Test public void greaterThanMatcher(){when(mock.oneArg(gt(7))).thenReturn("> 7");when(mock.oneArg(leq(7))).thenReturn("<= 7");assertEquals("> 7",mock.oneArg(8));assertEquals("> 7",mock.oneArg(9));assertEquals("> 7",mock.oneArg(10));assertEquals("<= 7",mock.oneArg(7));assertEquals("<= 7",mock.oneArg(6));}
@Test public void lessOrEqualMatcher(){when(mock.oneArg(leq(7))).thenReturn("<= 7");when(mock.oneArg(gt(7))).thenReturn("> 7");assertEquals("<= 7",mock.oneArg(7));assertEquals("<= 7",mock.oneArg(6));assertEquals("<= 7",mock.oneArg(5));assertEquals("> 7",mock.oneArg(8));assertEquals("> 7",mock.oneArg(9));}
@Test public void lessThanMatcher(){when(mock.oneArg(lt(7))).thenReturn("< 7");when(mock.oneArg(geq(7))).thenReturn(">= 7");assertEquals("< 7",mock.oneArg(5));assertEquals("< 7",mock.oneArg(6));assertEquals("< 7",mock.oneArg(4));assertEquals(">= 7",mock.oneArg(7));assertEquals(">= 7",mock.oneArg(8));}
@Test public void orMatcher(){when(mock.oneArg(anyInt())).thenReturn("other");when(mock.oneArg(or(eq(7),eq(9)))).thenReturn("7 or 9");assertEquals("other",mock.oneArg(10));assertEquals("7 or 9",mock.oneArg(7));assertEquals("7 or 9",mock.oneArg(9));}
@Test public void nullMatcher(){when(mock.threeArgumentMethod(eq(1),isNull(),eq(""))).thenReturn("1");when(mock.threeArgumentMethod(eq(1),not(isNull()),eq(""))).thenReturn("2");assertEquals("1",mock.threeArgumentMethod(1,null,""));assertEquals("2",mock.threeArgumentMethod(1,new Object(),""));}
@Test public void notNullMatcher(){when(mock.threeArgumentMethod(eq(1),notNull(),eq(""))).thenReturn("1");when(mock.threeArgumentMethod(eq(1),not(isNotNull()),eq(""))).thenReturn("2");assertEquals("1",mock.threeArgumentMethod(1,new Object(),""));assertEquals("2",mock.threeArgumentMethod(1,null,""));}
@Test public void findMatcher(){when(mock.oneArg(find("([a-z]+)\\d"))).thenReturn("1");assertEquals("1",mock.oneArg("ab12"));assertEquals(null,mock.oneArg("12345"));assertEquals(null,mock.oneArg((Object)null));}
@Test public void matchesMatcher(){when(mock.oneArg(matches("[a-z]+\\d\\d"))).thenReturn("1");when(mock.oneArg(matches("\\d\\d\\d"))).thenReturn("2");assertEquals("1",mock.oneArg("a12"));assertEquals("2",mock.oneArg("131"));assertEquals(null,mock.oneArg("blah"));}
@Test public void containsMatcher(){when(mock.oneArg(Matchers.contains("ell"))).thenReturn("1");when(mock.oneArg(Matchers.contains("ld"))).thenReturn("2");assertEquals("1",mock.oneArg("hello"));assertEquals("2",mock.oneArg("world"));assertEquals(null,mock.oneArg("xlx"));}
@Test public void startsWithMatcher(){when(mock.oneArg(startsWith("ab"))).thenReturn("1");when(mock.oneArg(startsWith("bc"))).thenReturn("2");assertEquals("1",mock.oneArg("ab quake"));assertEquals("2",mock.oneArg("bc quake"));assertEquals(null,mock.oneArg("ba quake"));}
@Test public void endsWithMatcher(){when(mock.oneArg(Matchers.endsWith("ab"))).thenReturn("1");when(mock.oneArg(Matchers.endsWith("bc"))).thenReturn("2");assertEquals("1",mock.oneArg("xab"));assertEquals("2",mock.oneArg("xbc"));assertEquals(null,mock.oneArg("ac"));}
@Test public void deltaMatcher(){when(mock.oneArg(eq(1.0D,0.1D))).thenReturn("1");when(mock.oneArg(eq(2.0D,0.1D))).thenReturn("2");when(mock.oneArg(eq(1.0F,0.1F))).thenReturn("3");when(mock.oneArg(eq(2.0F,0.1F))).thenReturn("4");when(mock.oneArg(eq(2.0F,0.1F))).thenReturn("4");assertEquals("1",mock.oneArg(1.0));assertEquals("1",mock.oneArg(0.91));assertEquals("1",mock.oneArg(1.09));assertEquals("2",mock.oneArg(2.0));assertEquals("3",mock.oneArg(1.0F));assertEquals("3",mock.oneArg(0.91F));assertEquals("3",mock.oneArg(1.09F));assertEquals("4",mock.oneArg(2.1F));assertEquals(null,mock.oneArg(2.2F));}
@Test public void deltaMatcherPrintsItself(){try {verify(mock).oneArg(eq(1.0D,0.1D));fail();}catch(WantedButNotInvoked e){assertContains("eq(1.0,0.1)",e.getMessage());}}
@Test public void sameMatcher(){Object one=new String("1243");Object two=new String("1243");Object three=new String("1243");assertNotSame(one,two);assertEquals(one,two);assertEquals(two,three);when(mock.oneArg(same(one))).thenReturn("1");when(mock.oneArg(same(two))).thenReturn("2");assertEquals("1",mock.oneArg(one));assertEquals("2",mock.oneArg(two));assertEquals(null,mock.oneArg(three));}
@Test public void eqMatcherAndNulls(){mock.simpleMethod((Object)null);verify(mock).simpleMethod((Object)eq(null));}
@Test public void sameMatcherAndNulls(){mock.simpleMethod((Object)null);verify(mock).simpleMethod(same(null));}
@Test public void shouldNotAllowNegativeNumberOfMinimumInvocations()throws Exception {try {VerificationModeFactory.atLeast(-50);fail();}catch(MockitoException e){assertEquals("Negative value is not allowed here",e.getMessage());}}
@Test public void shouldAllowZeroInvocations()throws Exception {VerificationModeFactory.atLeast(0);}
@Test public void shouldVerify(){spy.add("one");spy.add("two");assertEquals("one",spy.get(0));assertEquals("two",spy.get(1));verify(spy).add("one");verify(spy).add("two");}
@Test public void shouldBeAbleToMockObjectBecauseWhyNot(){spy(new Object());}
@Test public void shouldStub(){spy.add("one");when(spy.get(0)).thenReturn("1").thenReturn("1 again");assertEquals("1",spy.get(0));assertEquals("1 again",spy.get(0));assertEquals("one",spy.iterator().next());assertEquals(1,spy.size());}
@Test public void shouldAllowOverridingStubs(){when(spy.contains(anyObject())).thenReturn(true);when(spy.contains("foo")).thenReturn(false);assertTrue(spy.contains("bar"));assertFalse(spy.contains("foo"));}
@SuppressWarnings("deprecation")@Test public void shouldStubVoid(){stubVoid(spy).toReturn().toThrow(new RuntimeException()).on().clear();spy.add("one");spy.clear();try {spy.clear();fail();}catch(RuntimeException e){}assertEquals(1,spy.size());}
@Test public void shouldStubWithDoReturnAndVerify(){doReturn("foo").doReturn("bar").when(spy).get(0);assertEquals("foo",spy.get(0));assertEquals("bar",spy.get(0));verify(spy,times(2)).get(0);verifyNoMoreInteractions(spy);}
@Test public void shouldVerifyInOrder(){spy.add("one");spy.add("two");InOrder inOrder=inOrder(spy);inOrder.verify(spy).add("one");inOrder.verify(spy).add("two");verifyNoMoreInteractions(spy);}
@Test public void shouldVerifyInOrderAndFail(){spy.add("one");spy.add("two");InOrder inOrder=inOrder(spy);inOrder.verify(spy).add("two");try {inOrder.verify(spy).add("one");fail();}catch(VerificationInOrderFailure f){}}
@Test public void shouldVerifyNumberOfTimes(){spy.add("one");spy.add("one");verify(spy,times(2)).add("one");verifyNoMoreInteractions(spy);}
@Test public void shouldVerifyNumberOfTimesAndFail(){spy.add("one");spy.add("one");try {verify(spy,times(3)).add("one");fail();}catch(TooLittleActualInvocations e){}}
@Test public void shouldVerifyNoMoreInteractionsAndFail(){spy.add("one");spy.add("two");verify(spy).add("one");try {verifyNoMoreInteractions(spy);fail();}catch(NoInteractionsWanted e){}}
@Test public void shouldToString(){spy.add("foo");assertEquals("[foo]",spy.toString());}
@Test public void shouldAllowSpyingAnonymousClasses(){Foo spy=spy(new Foo(){public String print(){return "foo";}});assertEquals("foo",spy.print());}
@Test public void shouldSayNiceMessageWhenSpyingOnPrivateClass()throws Exception {List real=Arrays.asList("first","second");try {spy(real);fail();}catch(MockitoException e){assertContains("Most likely it is a private class that is not visible by Mockito",e.getMessage());}}
@Test public void shouldInjectIntoTestCase()throws Throwable {jUnitRule.apply(new DummyStatement(),injectTestCase).evaluate();assertNotNull("@Mock mock object created",injectTestCase.getInjected());assertNotNull("@InjectMocks object created",injectTestCase.getInjectInto());assertNotNull("Mock injected into the object",injectTestCase.getInjectInto().getInjected());}
@Test public void shouldRethrowException()throws Throwable {try {jUnitRule.apply(new ExceptionStatement(),injectTestCase).evaluate();fail("Should throw exception");}catch(RuntimeException e){assertEquals("Correct message","Statement exception",e.getMessage());}}
@Test public void shouldDetectUnfinishedStubbing()throws Throwable {try {jUnitRule.apply(new UnfinishedStubbingStatement(),injectTestCase).evaluate();fail("Should detect invalid Mockito usage");}catch(UnfinishedStubbingException e){}}
@Test public void dummy()throws Exception {}
@Test public void shouldRunInMultipleThreads(){}
@Test public void testname()throws Exception {}
@Test public void testReflectionEquals(){TestObject o1=new TestObject(4);TestObject o2=new TestObject(5);assertTrue(EqualsBuilder.reflectionEquals(o1,o1));assertTrue(!EqualsBuilder.reflectionEquals(o1,o2));o2.setA(4);assertTrue(EqualsBuilder.reflectionEquals(o1,o2));assertTrue(!EqualsBuilder.reflectionEquals(o1,this));assertTrue(!EqualsBuilder.reflectionEquals(o1,null));assertTrue(!EqualsBuilder.reflectionEquals(null,o2));assertTrue(EqualsBuilder.reflectionEquals((Object)null,(Object)null));}
@Test public void testReflectionHierarchyEquals(){testReflectionHierarchyEquals(false);testReflectionHierarchyEquals(true);assertTrue(EqualsBuilder.reflectionEquals(new TestTTLeafObject(1,2,3,4),new TestTTLeafObject(1,2,3,4),true));assertTrue(EqualsBuilder.reflectionEquals(new TestTTLeafObject(1,2,3,4),new TestTTLeafObject(1,2,3,4),false));assertTrue(!EqualsBuilder.reflectionEquals(new TestTTLeafObject(1,0,0,4),new TestTTLeafObject(1,2,3,4),true));assertTrue(!EqualsBuilder.reflectionEquals(new TestTTLeafObject(1,2,3,4),new TestTTLeafObject(1,2,3,0),true));assertTrue(!EqualsBuilder.reflectionEquals(new TestTTLeafObject(0,2,3,4),new TestTTLeafObject(1,2,3,4),true));}
@Test public void testSuper(){TestObject o1=new TestObject(4);TestObject o2=new TestObject(5);assertEquals(true,new EqualsBuilder().appendSuper(true).append(o1,o1).isEquals());assertEquals(false,new EqualsBuilder().appendSuper(false).append(o1,o1).isEquals());assertEquals(false,new EqualsBuilder().appendSuper(true).append(o1,o2).isEquals());assertEquals(false,new EqualsBuilder().appendSuper(false).append(o1,o2).isEquals());}
@Test public void testObject(){TestObject o1=new TestObject(4);TestObject o2=new TestObject(5);assertTrue(new EqualsBuilder().append(o1,o1).isEquals());assertTrue(!new EqualsBuilder().append(o1,o2).isEquals());o2.setA(4);assertTrue(new EqualsBuilder().append(o1,o2).isEquals());assertTrue(!new EqualsBuilder().append(o1,this).isEquals());assertTrue(!new EqualsBuilder().append(o1,null).isEquals());assertTrue(!new EqualsBuilder().append(null,o2).isEquals());assertTrue(new EqualsBuilder().append((Object)null,(Object)null).isEquals());}
@Test public void testLong(){long o1=1L;long o2=2L;assertTrue(new EqualsBuilder().append(o1,o1).isEquals());assertTrue(!new EqualsBuilder().append(o1,o2).isEquals());}
@Test public void testInt(){int o1=1;int o2=2;assertTrue(new EqualsBuilder().append(o1,o1).isEquals());assertTrue(!new EqualsBuilder().append(o1,o2).isEquals());}
@Test public void testShort(){short o1=1;short o2=2;assertTrue(new EqualsBuilder().append(o1,o1).isEquals());assertTrue(!new EqualsBuilder().append(o1,o2).isEquals());}
@Test public void testChar(){char o1=1;char o2=2;assertTrue(new EqualsBuilder().append(o1,o1).isEquals());assertTrue(!new EqualsBuilder().append(o1,o2).isEquals());}
@Test public void testByte(){byte o1=1;byte o2=2;assertTrue(new EqualsBuilder().append(o1,o1).isEquals());assertTrue(!new EqualsBuilder().append(o1,o2).isEquals());}
@Test public void testDouble(){double o1=1;double o2=2;assertTrue(new EqualsBuilder().append(o1,o1).isEquals());assertTrue(!new EqualsBuilder().append(o1,o2).isEquals());assertTrue(!new EqualsBuilder().append(o1,Double.NaN).isEquals());assertTrue(new EqualsBuilder().append(Double.NaN,Double.NaN).isEquals());assertTrue(new EqualsBuilder().append(Double.POSITIVE_INFINITY,Double.POSITIVE_INFINITY).isEquals());}
@Test public void testFloat(){float o1=1;float o2=2;assertTrue(new EqualsBuilder().append(o1,o1).isEquals());assertTrue(!new EqualsBuilder().append(o1,o2).isEquals());assertTrue(!new EqualsBuilder().append(o1,Float.NaN).isEquals());assertTrue(new EqualsBuilder().append(Float.NaN,Float.NaN).isEquals());assertTrue(new EqualsBuilder().append(Float.POSITIVE_INFINITY,Float.POSITIVE_INFINITY).isEquals());}
@Test public void testBigDecimal(){BigDecimal o1=new BigDecimal("2.0");BigDecimal o2=new BigDecimal("2.00");assertTrue(new EqualsBuilder().append(o1,o1).isEquals());assertTrue(new EqualsBuilder().append(o1,o2).isEquals());}
@Test public void testAccessors(){EqualsBuilder equalsBuilder=new EqualsBuilder();assertTrue(equalsBuilder.isEquals());equalsBuilder.setEquals(true);assertTrue(equalsBuilder.isEquals());equalsBuilder.setEquals(false);assertFalse(equalsBuilder.isEquals());}
@Test public void testBoolean(){boolean o1=true;boolean o2=false;assertTrue(new EqualsBuilder().append(o1,o1).isEquals());assertTrue(!new EqualsBuilder().append(o1,o2).isEquals());}
@Test public void testObjectArray(){TestObject[]obj1=new TestObject[3];obj1[0]=new TestObject(4);obj1[1]=new TestObject(5);obj1[2]=null;TestObject[]obj2=new TestObject[3];obj2[0]=new TestObject(4);obj2[1]=new TestObject(5);obj2[2]=null;assertTrue(new EqualsBuilder().append(obj1,obj1).isEquals());assertTrue(new EqualsBuilder().append(obj2,obj2).isEquals());assertTrue(new EqualsBuilder().append(obj1,obj2).isEquals());obj1[1].setA(6);assertTrue(!new EqualsBuilder().append(obj1,obj2).isEquals());obj1[1].setA(5);assertTrue(new EqualsBuilder().append(obj1,obj2).isEquals());obj1[2]=obj1[1];assertTrue(!new EqualsBuilder().append(obj1,obj2).isEquals());obj1[2]=null;assertTrue(new EqualsBuilder().append(obj1,obj2).isEquals());obj2=null;assertTrue(!new EqualsBuilder().append(obj1,obj2).isEquals());obj1=null;assertTrue(new EqualsBuilder().append(obj1,obj2).isEquals());}
@Test public void testLongArray(){long[]obj1=new long[2];obj1[0]=5L;obj1[1]=6L;long[]obj2=new long[2];obj2[0]=5L;obj2[1]=6L;assertTrue(new EqualsBuilder().append(obj1,obj1).isEquals());assertTrue(new EqualsBuilder().append(obj1,obj2).isEquals());obj1[1]=7;assertTrue(!new EqualsBuilder().append(obj1,obj2).isEquals());obj2=null;assertTrue(!new EqualsBuilder().append(obj1,obj2).isEquals());obj1=null;assertTrue(new EqualsBuilder().append(obj1,obj2).isEquals());}
@Test public void testIntArray(){int[]obj1=new int[2];obj1[0]=5;obj1[1]=6;int[]obj2=new int[2];obj2[0]=5;obj2[1]=6;assertTrue(new EqualsBuilder().append(obj1,obj1).isEquals());assertTrue(new EqualsBuilder().append(obj1,obj2).isEquals());obj1[1]=7;assertTrue(!new EqualsBuilder().append(obj1,obj2).isEquals());obj2=null;assertTrue(!new EqualsBuilder().append(obj1,obj2).isEquals());obj1=null;assertTrue(new EqualsBuilder().append(obj1,obj2).isEquals());}
@Test public void testShortArray(){short[]obj1=new short[2];obj1[0]=5;obj1[1]=6;short[]obj2=new short[2];obj2[0]=5;obj2[1]=6;assertTrue(new EqualsBuilder().append(obj1,obj1).isEquals());assertTrue(new EqualsBuilder().append(obj1,obj2).isEquals());obj1[1]=7;assertTrue(!new EqualsBuilder().append(obj1,obj2).isEquals());obj2=null;assertTrue(!new EqualsBuilder().append(obj1,obj2).isEquals());obj1=null;assertTrue(new EqualsBuilder().append(obj1,obj2).isEquals());}
@Test public void testCharArray(){char[]obj1=new char[2];obj1[0]=5;obj1[1]=6;char[]obj2=new char[2];obj2[0]=5;obj2[1]=6;assertTrue(new EqualsBuilder().append(obj1,obj1).isEquals());assertTrue(new EqualsBuilder().append(obj1,obj2).isEquals());obj1[1]=7;assertTrue(!new EqualsBuilder().append(obj1,obj2).isEquals());obj2=null;assertTrue(!new EqualsBuilder().append(obj1,obj2).isEquals());obj1=null;assertTrue(new EqualsBuilder().append(obj1,obj2).isEquals());}
@Test public void testByteArray(){byte[]obj1=new byte[2];obj1[0]=5;obj1[1]=6;byte[]obj2=new byte[2];obj2[0]=5;obj2[1]=6;assertTrue(new EqualsBuilder().append(obj1,obj1).isEquals());assertTrue(new EqualsBuilder().append(obj1,obj2).isEquals());obj1[1]=7;assertTrue(!new EqualsBuilder().append(obj1,obj2).isEquals());obj2=null;assertTrue(!new EqualsBuilder().append(obj1,obj2).isEquals());obj1=null;assertTrue(new EqualsBuilder().append(obj1,obj2).isEquals());}
@Test public void testDoubleArray(){double[]obj1=new double[2];obj1[0]=5;obj1[1]=6;double[]obj2=new double[2];obj2[0]=5;obj2[1]=6;assertTrue(new EqualsBuilder().append(obj1,obj1).isEquals());assertTrue(new EqualsBuilder().append(obj1,obj2).isEquals());obj1[1]=7;assertTrue(!new EqualsBuilder().append(obj1,obj2).isEquals());obj2=null;assertTrue(!new EqualsBuilder().append(obj1,obj2).isEquals());obj1=null;assertTrue(new EqualsBuilder().append(obj1,obj2).isEquals());}
@Test public void testFloatArray(){float[]obj1=new float[2];obj1[0]=5;obj1[1]=6;float[]obj2=new float[2];obj2[0]=5;obj2[1]=6;assertTrue(new EqualsBuilder().append(obj1,obj1).isEquals());assertTrue(new EqualsBuilder().append(obj1,obj2).isEquals());obj1[1]=7;assertTrue(!new EqualsBuilder().append(obj1,obj2).isEquals());obj2=null;assertTrue(!new EqualsBuilder().append(obj1,obj2).isEquals());obj1=null;assertTrue(new EqualsBuilder().append(obj1,obj2).isEquals());}
@Test public void testBooleanArray(){boolean[]obj1=new boolean[2];obj1[0]=true;obj1[1]=false;boolean[]obj2=new boolean[2];obj2[0]=true;obj2[1]=false;assertTrue(new EqualsBuilder().append(obj1,obj1).isEquals());assertTrue(new EqualsBuilder().append(obj1,obj2).isEquals());obj1[1]=true;assertTrue(!new EqualsBuilder().append(obj1,obj2).isEquals());obj2=null;assertTrue(!new EqualsBuilder().append(obj1,obj2).isEquals());obj1=null;assertTrue(new EqualsBuilder().append(obj1,obj2).isEquals());}
@Test public void testMultiLongArray(){long[][]array1=new long[2][2];long[][]array2=new long[2][2];for (int i=0;i < array1.length;++i){for (int j=0;j < array1[0].length;j++){array1[i][j]=(i + 1)* (j + 1);array2[i][j]=(i + 1)* (j + 1);}}assertTrue(new EqualsBuilder().append(array1,array1).isEquals());assertTrue(new EqualsBuilder().append(array1,array2).isEquals());array1[1][1]=0;assertTrue(!new EqualsBuilder().append(array1,array2).isEquals());}
@Test public void testMultiIntArray(){int[][]array1=new int[2][2];int[][]array2=new int[2][2];for (int i=0;i < array1.length;++i){for (int j=0;j < array1[0].length;j++){array1[i][j]=(i + 1)* (j + 1);array2[i][j]=(i + 1)* (j + 1);}}assertTrue(new EqualsBuilder().append(array1,array1).isEquals());assertTrue(new EqualsBuilder().append(array1,array2).isEquals());array1[1][1]=0;assertTrue(!new EqualsBuilder().append(array1,array2).isEquals());}
@Test public void testMultiShortArray(){short[][]array1=new short[2][2];short[][]array2=new short[2][2];for (short i=0;i < array1.length;++i){for (short j=0;j < array1[0].length;j++){array1[i][j]=i;array2[i][j]=i;}}assertTrue(new EqualsBuilder().append(array1,array1).isEquals());assertTrue(new EqualsBuilder().append(array1,array2).isEquals());array1[1][1]=0;assertTrue(!new EqualsBuilder().append(array1,array2).isEquals());}
@Test public void testMultiCharArray(){char[][]array1=new char[2][2];char[][]array2=new char[2][2];for (char i=0;i < array1.length;++i){for (char j=0;j < array1[0].length;j++){array1[i][j]=i;array2[i][j]=i;}}assertTrue(new EqualsBuilder().append(array1,array1).isEquals());assertTrue(new EqualsBuilder().append(array1,array2).isEquals());array1[1][1]=0;assertTrue(!new EqualsBuilder().append(array1,array2).isEquals());}
@Test public void testMultiByteArray(){byte[][]array1=new byte[2][2];byte[][]array2=new byte[2][2];for (byte i=0;i < array1.length;++i){for (byte j=0;j < array1[0].length;j++){array1[i][j]=i;array2[i][j]=i;}}assertTrue(new EqualsBuilder().append(array1,array1).isEquals());assertTrue(new EqualsBuilder().append(array1,array2).isEquals());array1[1][1]=0;assertTrue(!new EqualsBuilder().append(array1,array2).isEquals());}
@Test public void testMultiFloatArray(){float[][]array1=new float[2][2];float[][]array2=new float[2][2];for (int i=0;i < array1.length;++i){for (int j=0;j < array1[0].length;j++){array1[i][j]=(i + 1)* (j + 1);array2[i][j]=(i + 1)* (j + 1);}}assertTrue(new EqualsBuilder().append(array1,array1).isEquals());assertTrue(new EqualsBuilder().append(array1,array2).isEquals());array1[1][1]=0;assertTrue(!new EqualsBuilder().append(array1,array2).isEquals());}
@Test public void testMultiDoubleArray(){double[][]array1=new double[2][2];double[][]array2=new double[2][2];for (int i=0;i < array1.length;++i){for (int j=0;j < array1[0].length;j++){array1[i][j]=(i + 1)* (j + 1);array2[i][j]=(i + 1)* (j + 1);}}assertTrue(new EqualsBuilder().append(array1,array1).isEquals());assertTrue(new EqualsBuilder().append(array1,array2).isEquals());array1[1][1]=0;assertTrue(!new EqualsBuilder().append(array1,array2).isEquals());}
@Test public void testMultiBooleanArray(){boolean[][]array1=new boolean[2][2];boolean[][]array2=new boolean[2][2];for (int i=0;i < array1.length;++i){for (int j=0;j < array1[0].length;j++){array1[i][j]=(i == 1)|| (j == 1);array2[i][j]=(i == 1)|| (j == 1);}}assertTrue(new EqualsBuilder().append(array1,array1).isEquals());assertTrue(new EqualsBuilder().append(array1,array2).isEquals());array1[1][1]=false;assertTrue(!new EqualsBuilder().append(array1,array2).isEquals());boolean[]array3=new boolean[]{true,true};assertFalse(new EqualsBuilder().append(array1,array3).isEquals());assertFalse(new EqualsBuilder().append(array3,array1).isEquals());assertFalse(new EqualsBuilder().append(array2,array3).isEquals());assertFalse(new EqualsBuilder().append(array3,array2).isEquals());}
@Test public void testRaggedArray(){long[][]array1=new long[2][];long[][]array2=new long[2][];for (int i=0;i < array1.length;++i){array1[i]=new long[2];array2[i]=new long[2];for (int j=0;j < array1[i].length;++j){array1[i][j]=(i + 1)* (j + 1);array2[i][j]=(i + 1)* (j + 1);}}assertTrue(new EqualsBuilder().append(array1,array1).isEquals());assertTrue(new EqualsBuilder().append(array1,array2).isEquals());array1[1][1]=0;assertTrue(!new EqualsBuilder().append(array1,array2).isEquals());}
@Test public void testMixedArray(){Object[]array1=new Object[2];Object[]array2=new Object[2];for (int i=0;i < array1.length;++i){array1[i]=new long[2];array2[i]=new long[2];for (int j=0;j < 2;++j){((long[])array1[i])[j]=(i + 1)* (j + 1);((long[])array2[i])[j]=(i + 1)* (j + 1);}}assertTrue(new EqualsBuilder().append(array1,array1).isEquals());assertTrue(new EqualsBuilder().append(array1,array2).isEquals());((long[])array1[1])[1]=0;assertTrue(!new EqualsBuilder().append(array1,array2).isEquals());}
@Test public void testObjectArrayHiddenByObject(){TestObject[]array1=new TestObject[2];array1[0]=new TestObject(4);array1[1]=new TestObject(5);TestObject[]array2=new TestObject[2];array2[0]=new TestObject(4);array2[1]=new TestObject(5);Object obj1=array1;Object obj2=array2;assertTrue(new EqualsBuilder().append(obj1,obj1).isEquals());assertTrue(new EqualsBuilder().append(obj1,array1).isEquals());assertTrue(new EqualsBuilder().append(obj1,obj2).isEquals());assertTrue(new EqualsBuilder().append(obj1,array2).isEquals());array1[1].setA(6);assertTrue(!new EqualsBuilder().append(obj1,obj2).isEquals());}
@Test public void testLongArrayHiddenByObject(){long[]array1=new long[2];array1[0]=5L;array1[1]=6L;long[]array2=new long[2];array2[0]=5L;array2[1]=6L;Object obj1=array1;Object obj2=array2;assertTrue(new EqualsBuilder().append(obj1,obj1).isEquals());assertTrue(new EqualsBuilder().append(obj1,array1).isEquals());assertTrue(new EqualsBuilder().append(obj1,obj2).isEquals());assertTrue(new EqualsBuilder().append(obj1,array2).isEquals());array1[1]=7;assertTrue(!new EqualsBuilder().append(obj1,obj2).isEquals());}
@Test public void testIntArrayHiddenByObject(){int[]array1=new int[2];array1[0]=5;array1[1]=6;int[]array2=new int[2];array2[0]=5;array2[1]=6;Object obj1=array1;Object obj2=array2;assertTrue(new EqualsBuilder().append(obj1,obj1).isEquals());assertTrue(new EqualsBuilder().append(obj1,array1).isEquals());assertTrue(new EqualsBuilder().append(obj1,obj2).isEquals());assertTrue(new EqualsBuilder().append(obj1,array2).isEquals());array1[1]=7;assertTrue(!new EqualsBuilder().append(obj1,obj2).isEquals());}
@Test public void testShortArrayHiddenByObject(){short[]array1=new short[2];array1[0]=5;array1[1]=6;short[]array2=new short[2];array2[0]=5;array2[1]=6;Object obj1=array1;Object obj2=array2;assertTrue(new EqualsBuilder().append(obj1,obj1).isEquals());assertTrue(new EqualsBuilder().append(obj1,array1).isEquals());assertTrue(new EqualsBuilder().append(obj1,obj2).isEquals());assertTrue(new EqualsBuilder().append(obj1,array2).isEquals());array1[1]=7;assertTrue(!new EqualsBuilder().append(obj1,obj2).isEquals());}
@Test public void testCharArrayHiddenByObject(){char[]array1=new char[2];array1[0]=5;array1[1]=6;char[]array2=new char[2];array2[0]=5;array2[1]=6;Object obj1=array1;Object obj2=array2;assertTrue(new EqualsBuilder().append(obj1,obj1).isEquals());assertTrue(new EqualsBuilder().append(obj1,array1).isEquals());assertTrue(new EqualsBuilder().append(obj1,obj2).isEquals());assertTrue(new EqualsBuilder().append(obj1,array2).isEquals());array1[1]=7;assertTrue(!new EqualsBuilder().append(obj1,obj2).isEquals());}
@Test public void testByteArrayHiddenByObject(){byte[]array1=new byte[2];array1[0]=5;array1[1]=6;byte[]array2=new byte[2];array2[0]=5;array2[1]=6;Object obj1=array1;Object obj2=array2;assertTrue(new EqualsBuilder().append(obj1,obj1).isEquals());assertTrue(new EqualsBuilder().append(obj1,array1).isEquals());assertTrue(new EqualsBuilder().append(obj1,obj2).isEquals());assertTrue(new EqualsBuilder().append(obj1,array2).isEquals());array1[1]=7;assertTrue(!new EqualsBuilder().append(obj1,obj2).isEquals());}
@Test public void testDoubleArrayHiddenByObject(){double[]array1=new double[2];array1[0]=5;array1[1]=6;double[]array2=new double[2];array2[0]=5;array2[1]=6;Object obj1=array1;Object obj2=array2;assertTrue(new EqualsBuilder().append(obj1,obj1).isEquals());assertTrue(new EqualsBuilder().append(obj1,array1).isEquals());assertTrue(new EqualsBuilder().append(obj1,obj2).isEquals());assertTrue(new EqualsBuilder().append(obj1,array2).isEquals());array1[1]=7;assertTrue(!new EqualsBuilder().append(obj1,obj2).isEquals());}
@Test public void testFloatArrayHiddenByObject(){float[]array1=new float[2];array1[0]=5;array1[1]=6;float[]array2=new float[2];array2[0]=5;array2[1]=6;Object obj1=array1;Object obj2=array2;assertTrue(new EqualsBuilder().append(obj1,obj1).isEquals());assertTrue(new EqualsBuilder().append(obj1,array1).isEquals());assertTrue(new EqualsBuilder().append(obj1,obj2).isEquals());assertTrue(new EqualsBuilder().append(obj1,array2).isEquals());array1[1]=7;assertTrue(!new EqualsBuilder().append(obj1,obj2).isEquals());}
@Test public void testBooleanArrayHiddenByObject(){boolean[]array1=new boolean[2];array1[0]=true;array1[1]=false;boolean[]array2=new boolean[2];array2[0]=true;array2[1]=false;Object obj1=array1;Object obj2=array2;assertTrue(new EqualsBuilder().append(obj1,obj1).isEquals());assertTrue(new EqualsBuilder().append(obj1,array1).isEquals());assertTrue(new EqualsBuilder().append(obj1,obj2).isEquals());assertTrue(new EqualsBuilder().append(obj1,array2).isEquals());array1[1]=true;assertTrue(!new EqualsBuilder().append(obj1,obj2).isEquals());}
/** * Tests two instances of classes that can be equal and that are not "related". The two classes are not subclasses of each other and do not share a parent aside from Object. See http://issues.apache.org/bugzilla/show_bug.cgi?id=33069*/@Test public void testUnrelatedClasses(){Object[]x=new Object[]{new TestACanEqualB(1)};Object[]y=new Object[]{new TestBCanEqualA(1)};assertTrue(Arrays.equals(x,x));assertTrue(Arrays.equals(y,y));assertTrue(Arrays.equals(x,y));assertTrue(Arrays.equals(y,x));assertTrue(x[0].equals(x[0]));assertTrue(y[0].equals(y[0]));assertTrue(x[0].equals(y[0]));assertTrue(y[0].equals(x[0]));assertTrue(new EqualsBuilder().append(x,x).isEquals());assertTrue(new EqualsBuilder().append(y,y).isEquals());assertTrue(new EqualsBuilder().append(x,y).isEquals());assertTrue(new EqualsBuilder().append(y,x).isEquals());}
/** * Test from http://issues.apache.org/bugzilla/show_bug.cgi?id=33067*/@Test public void testNpeForNullElement(){Object[]x1=new Object[]{new Integer(1),null,new Integer(3)};Object[]x2=new Object[]{new Integer(1),new Integer(2),new Integer(3)};new EqualsBuilder().append(x1,x2);}
@Test public void testReflectionEqualsExcludeFields()throws Exception {TestObjectWithMultipleFields x1=new TestObjectWithMultipleFields(1,2,3);TestObjectWithMultipleFields x2=new TestObjectWithMultipleFields(1,3,4);assertTrue(!EqualsBuilder.reflectionEquals(x1,x2));assertTrue(!EqualsBuilder.reflectionEquals(x1,x2,(String[])null));assertTrue(!EqualsBuilder.reflectionEquals(x1,x2,new String[]{}));assertTrue(!EqualsBuilder.reflectionEquals(x1,x2,new String[]{"xxx"}));assertTrue(!EqualsBuilder.reflectionEquals(x1,x2,new String[]{"two"}));assertTrue(!EqualsBuilder.reflectionEquals(x1,x2,new String[]{"three"}));assertTrue(EqualsBuilder.reflectionEquals(x1,x2,new String[]{"two","three"}));assertTrue(EqualsBuilder.reflectionEquals(x1,x2,new String[]{"one","two","three"}));assertTrue(EqualsBuilder.reflectionEquals(x1,x2,new String[]{"one","two","three","xxx"}));}
@Test public void testInjectMocks()throws Exception {assertNotNull("Mock created",injected);assertNotNull("Object created",injectInto);assertEquals("A injected into B",injected,injectInto.getInjected());}
@Test public void typeVariable_of_self_type(){GenericMetadataSupport genericMetadata=inferFrom(GenericsSelfReference.class).resolveGenericReturnType(firstNamedMethod("self",GenericsSelfReference.class));assertThat(genericMetadata.rawType()).isEqualTo(GenericsSelfReference.class);}
@Test public void can_get_raw_type_from_Class()throws Exception {assertThat(inferFrom(ListOfAnyNumbers.class).rawType()).isEqualTo(ListOfAnyNumbers.class);assertThat(inferFrom(ListOfNumbers.class).rawType()).isEqualTo(ListOfNumbers.class);assertThat(inferFrom(GenericsNest.class).rawType()).isEqualTo(GenericsNest.class);assertThat(inferFrom(StringList.class).rawType()).isEqualTo(StringList.class);}
@Test public void can_get_raw_type_from_ParameterizedType()throws Exception {assertThat(inferFrom(ListOfAnyNumbers.class.getGenericInterfaces()[0]).rawType()).isEqualTo(List.class);assertThat(inferFrom(ListOfNumbers.class.getGenericInterfaces()[0]).rawType()).isEqualTo(List.class);assertThat(inferFrom(GenericsNest.class.getGenericInterfaces()[0]).rawType()).isEqualTo(Map.class);assertThat(inferFrom(StringList.class.getGenericSuperclass()).rawType()).isEqualTo(ArrayList.class);}
@Test public void can_get_type_variables_from_Class()throws Exception {assertThat(inferFrom(GenericsNest.class).actualTypeArguments().keySet()).hasSize(1).onProperty("name").contains("K");assertThat(inferFrom(ListOfNumbers.class).actualTypeArguments().keySet()).isEmpty();assertThat(inferFrom(ListOfAnyNumbers.class).actualTypeArguments().keySet()).hasSize(1).onProperty("name").contains("N");assertThat(inferFrom(Map.class).actualTypeArguments().keySet()).hasSize(2).onProperty("name").contains("K","V");assertThat(inferFrom(Serializable.class).actualTypeArguments().keySet()).isEmpty();assertThat(inferFrom(StringList.class).actualTypeArguments().keySet()).isEmpty();}
@Test public void can_get_type_variables_from_ParameterizedType()throws Exception {assertThat(inferFrom(GenericsNest.class.getGenericInterfaces()[0]).actualTypeArguments().keySet()).hasSize(2).onProperty("name").contains("K","V");assertThat(inferFrom(ListOfAnyNumbers.class.getGenericInterfaces()[0]).actualTypeArguments().keySet()).hasSize(1).onProperty("name").contains("E");assertThat(inferFrom(Integer.class.getGenericInterfaces()[0]).actualTypeArguments().keySet()).hasSize(1).onProperty("name").contains("T");assertThat(inferFrom(StringBuilder.class.getGenericInterfaces()[0]).actualTypeArguments().keySet()).isEmpty();assertThat(inferFrom(StringList.class).actualTypeArguments().keySet()).isEmpty();}
@Test public void typeVariable_return_type_of____iterator____resolved_to_Iterator_and_type_argument_to_String()throws Exception {GenericMetadataSupport genericMetadata=inferFrom(StringList.class).resolveGenericReturnType(firstNamedMethod("iterator",StringList.class));assertThat(genericMetadata.rawType()).isEqualTo(Iterator.class);assertThat(genericMetadata.actualTypeArguments().values()).contains(String.class);}
@Test public void typeVariable_return_type_of____get____resolved_to_Set_and_type_argument_to_Number()throws Exception {GenericMetadataSupport genericMetadata=inferFrom(GenericsNest.class).resolveGenericReturnType(firstNamedMethod("get",GenericsNest.class));assertThat(genericMetadata.rawType()).isEqualTo(Set.class);assertThat(genericMetadata.actualTypeArguments().values()).contains(Number.class);}
@Test public void bounded_typeVariable_return_type_of____returningK____resolved_to_Comparable_and_with_BoundedType()throws Exception {GenericMetadataSupport genericMetadata=inferFrom(GenericsNest.class).resolveGenericReturnType(firstNamedMethod("returningK",GenericsNest.class));assertThat(genericMetadata.rawType()).isEqualTo(Comparable.class);GenericMetadataSupport extraInterface_0=inferFrom(genericMetadata.extraInterfaces().get(0));assertThat(extraInterface_0.rawType()).isEqualTo(Cloneable.class);}
@Test public void fixed_ParamType_return_type_of____remove____resolved_to_Set_and_type_argument_to_Number()throws Exception {GenericMetadataSupport genericMetadata=inferFrom(GenericsNest.class).resolveGenericReturnType(firstNamedMethod("remove",GenericsNest.class));assertThat(genericMetadata.rawType()).isEqualTo(Set.class);assertThat(genericMetadata.actualTypeArguments().values()).contains(Number.class);}
@Test public void paramType_return_type_of____values____resolved_to_Collection_and_type_argument_to_Parameterized_Set()throws Exception {GenericMetadataSupport genericMetadata=inferFrom(GenericsNest.class).resolveGenericReturnType(firstNamedMethod("values",GenericsNest.class));assertThat(genericMetadata.rawType()).isEqualTo(Collection.class);GenericMetadataSupport fromTypeVariableE=inferFrom(typeVariableValue(genericMetadata.actualTypeArguments(),"E"));assertThat(fromTypeVariableE.rawType()).isEqualTo(Set.class);assertThat(fromTypeVariableE.actualTypeArguments().values()).contains(Number.class);}
@Test public void paramType_with_type_parameters_return_type_of____paramType_with_type_params____resolved_to_Collection_and_type_argument_to_Parameterized_Set()throws Exception {GenericMetadataSupport genericMetadata=inferFrom(GenericsNest.class).resolveGenericReturnType(firstNamedMethod("paramType_with_type_params",GenericsNest.class));assertThat(genericMetadata.rawType()).isEqualTo(List.class);Type firstBoundOfE=((GenericMetadataSupport.TypeVarBoundedType)typeVariableValue(genericMetadata.actualTypeArguments(),"E")).firstBound();assertThat(inferFrom(firstBoundOfE).rawType()).isEqualTo(Comparable.class);}
@Test public void typeVariable_with_type_parameters_return_type_of____typeVar_with_type_params____resolved_K_hence_to_Comparable_and_with_BoundedType()throws Exception {GenericMetadataSupport genericMetadata=inferFrom(GenericsNest.class).resolveGenericReturnType(firstNamedMethod("typeVar_with_type_params",GenericsNest.class));assertThat(genericMetadata.rawType()).isEqualTo(Comparable.class);GenericMetadataSupport extraInterface_0=inferFrom(genericMetadata.extraInterfaces().get(0));assertThat(extraInterface_0.rawType()).isEqualTo(Cloneable.class);}
@Test public void class_return_type_of____append____resolved_to_StringBuilder_and_type_arguments()throws Exception {GenericMetadataSupport genericMetadata=inferFrom(StringBuilder.class).resolveGenericReturnType(firstNamedMethod("append",StringBuilder.class));assertThat(genericMetadata.rawType()).isEqualTo(StringBuilder.class);assertThat(genericMetadata.actualTypeArguments()).isEmpty();}
@Test public void paramType_with_wildcard_return_type_of____returning_wildcard_with_class_lower_bound____resolved_to_List_and_type_argument_to_Integer()throws Exception {GenericMetadataSupport genericMetadata=inferFrom(GenericsNest.class).resolveGenericReturnType(firstNamedMethod("returning_wildcard_with_class_lower_bound",GenericsNest.class));assertThat(genericMetadata.rawType()).isEqualTo(List.class);GenericMetadataSupport.BoundedType boundedType=(GenericMetadataSupport.BoundedType)typeVariableValue(genericMetadata.actualTypeArguments(),"E");assertThat(boundedType.firstBound()).isEqualTo(Integer.class);assertThat(boundedType.interfaceBounds()).isEmpty();}
@Test public void paramType_with_wildcard_return_type_of____returning_wildcard_with_typeVar_lower_bound____resolved_to_List_and_type_argument_to_Integer()throws Exception {GenericMetadataSupport genericMetadata=inferFrom(GenericsNest.class).resolveGenericReturnType(firstNamedMethod("returning_wildcard_with_typeVar_lower_bound",GenericsNest.class));assertThat(genericMetadata.rawType()).isEqualTo(List.class);GenericMetadataSupport.BoundedType boundedType=(GenericMetadataSupport.BoundedType)typeVariableValue(genericMetadata.actualTypeArguments(),"E");assertThat(inferFrom(boundedType.firstBound()).rawType()).isEqualTo(Comparable.class);assertThat(boundedType.interfaceBounds()).contains(Cloneable.class);}
@Test public void paramType_with_wildcard_return_type_of____returning_wildcard_with_typeVar_upper_bound____resolved_to_List_and_type_argument_to_Integer()throws Exception {GenericMetadataSupport genericMetadata=inferFrom(GenericsNest.class).resolveGenericReturnType(firstNamedMethod("returning_wildcard_with_typeVar_upper_bound",GenericsNest.class));assertThat(genericMetadata.rawType()).isEqualTo(List.class);GenericMetadataSupport.BoundedType boundedType=(GenericMetadataSupport.BoundedType)typeVariableValue(genericMetadata.actualTypeArguments(),"E");assertThat(inferFrom(boundedType.firstBound()).rawType()).isEqualTo(Comparable.class);assertThat(boundedType.interfaceBounds()).contains(Cloneable.class);}
@Test public void dont_raise_NullPointerException()throws Exception {MockitoAnnotations.initMocks(this);}
@Test public void should_do_the_trick_of_instantiating()throws Exception {given(resolver.resolveTypeInstances(Matchers.<Class<?>[]>anyVararg())).willReturn(new Object[]{observer});boolean result=underTest.process(field("whatever"),this,newSetOf(observer));assertTrue(result);assertNotNull(whatever);}
@Test public void should_serialize_and_deserialize_mock_created_with_deep_stubs()throws Exception {SampleClass sampleClass=mock(SampleClass.class,withSettings().defaultAnswer(RETURNS_DEEP_STUBS).serializable());when(sampleClass.getSample().isFalse()).thenReturn(true);when(sampleClass.getSample().number()).thenReturn(999);SampleClass deserializedSample=serializeAndBack(sampleClass);assertThat(deserializedSample.getSample().isFalse()).isEqualTo(true);assertThat(deserializedSample.getSample().number()).isEqualTo(999);}
@Test public void should_serialize_and_deserialize_parameterized_class_mocked_with_deep_stubs()throws Exception {ListContainer deep_stubbed=mock(ListContainer.class,withSettings().defaultAnswer(RETURNS_DEEP_STUBS).serializable());when(deep_stubbed.iterator().next().add("yes")).thenReturn(true);ListContainer deserialized_deep_stub=serializeAndBack(deep_stubbed);assertThat(deserialized_deep_stub.iterator().next().add("not stubbed but mock already previously resolved")).isEqualTo(false);assertThat(deserialized_deep_stub.iterator().next().add("yes")).isEqualTo(true);}
@Test(expected=ClassCastException.class)public void should_discard_generics_metadata_when_serialized_then_disabling_deep_stubs_with_generics()throws Exception {ListContainer deep_stubbed=mock(ListContainer.class,withSettings().defaultAnswer(RETURNS_DEEP_STUBS).serializable());when(deep_stubbed.iterator().hasNext()).thenReturn(true);ListContainer deserialized_deep_stub=serializeAndBack(deep_stubbed);when(deserialized_deep_stub.iterator().next().get(42)).thenReturn("no");}
@Test public void empty_resources(){assertNull(finder.findPluginClass((Iterable)asList()));}
@Test public void no_valid_impl()throws Exception {File f=tmp.newFile();IOUtil.writeText("  \n  ",f);assertNull(finder.findPluginClass((Iterable)asList(f.toURI().toURL())));}
@Test public void single_implementation()throws Exception {File f=tmp.newFile();when(switcher.isEnabled("foo.Foo")).thenReturn(true);IOUtil.writeText("  foo.Foo  ",f);assertEquals("foo.Foo",finder.findPluginClass((Iterable)asList(f.toURI().toURL())));}
@Test public void single_implementation_disabled()throws Exception {File f=tmp.newFile();when(switcher.isEnabled("foo.Foo")).thenReturn(false);IOUtil.writeText("  foo.Foo  ",f);assertEquals(null,finder.findPluginClass((Iterable)asList(f.toURI().toURL())));}
@Test public void multiple_implementations_only_one_enabled()throws Exception {File f1=tmp.newFile();File f2=tmp.newFile();when(switcher.isEnabled("Bar")).thenReturn(true);IOUtil.writeText("Foo",f1);IOUtil.writeText("Bar",f2);assertEquals("Bar",finder.findPluginClass((Iterable)asList(f1.toURI().toURL(),f2.toURI().toURL())));}
@Test public void multiple_implementations_only_one_useful()throws Exception {File f1=tmp.newFile();File f2=tmp.newFile();when(switcher.isEnabled(anyString())).thenReturn(true);IOUtil.writeText("   ",f1);IOUtil.writeText("X",f2);assertEquals("X",finder.findPluginClass((Iterable)asList(f1.toURI().toURL(),f2.toURI().toURL())));}
@Test public void multiple_empty_implementations()throws Exception {File f1=tmp.newFile();File f2=tmp.newFile();when(switcher.isEnabled(anyString())).thenReturn(true);IOUtil.writeText("   ",f1);IOUtil.writeText("\n",f2);assertEquals(null,finder.findPluginClass((Iterable)asList(f1.toURI().toURL(),f2.toURI().toURL())));}
@Test public void problems_loading_impl()throws Exception {when(switcher.isEnabled(anyString())).thenThrow(new RuntimeException("Boo!"));try {finder.findPluginClass((Iterable)asList(new File("xxx").toURI().toURL()));fail();}catch(Exception e){assertContains("xxx",e.getMessage());e.getCause().getMessage().equals("Boo!");}}
@Test public void myTest()throws Exception {SocketFactory sf=mock(SocketFactory.class,RETURNS_DEEP_STUBS);when(sf.createSocket(anyString(),eq(80))).thenReturn(null);sf.createSocket("what",80);}
@Test public void simpleCase()throws Exception {OutputStream out=new ByteArrayOutputStream();Socket socket=mock(Socket.class);when(socket.getOutputStream()).thenReturn(out);assertSame(out,socket.getOutputStream());}
/** * Test that deep stubbing works for one intermediate level*/@Test public void oneLevelDeep()throws Exception {OutputStream out=new ByteArrayOutputStream();SocketFactory socketFactory=mock(SocketFactory.class,RETURNS_DEEP_STUBS);when(socketFactory.createSocket().getOutputStream()).thenReturn(out);assertSame(out,socketFactory.createSocket().getOutputStream());}
/** * Test that stubbing of two mocks stubs don't interfere*/@Test public void interactions()throws Exception {OutputStream out1=new ByteArrayOutputStream();OutputStream out2=new ByteArrayOutputStream();SocketFactory sf1=mock(SocketFactory.class,RETURNS_DEEP_STUBS);when(sf1.createSocket().getOutputStream()).thenReturn(out1);SocketFactory sf2=mock(SocketFactory.class,RETURNS_DEEP_STUBS);when(sf2.createSocket().getOutputStream()).thenReturn(out2);assertSame(out1,sf1.createSocket().getOutputStream());assertSame(out2,sf2.createSocket().getOutputStream());}
/** * Test that stubbing of methods of different arguments don't interfere*/@Test public void withArguments()throws Exception {OutputStream out1=new ByteArrayOutputStream();OutputStream out2=new ByteArrayOutputStream();OutputStream out3=new ByteArrayOutputStream();SocketFactory sf=mock(SocketFactory.class,RETURNS_DEEP_STUBS);when(sf.createSocket().getOutputStream()).thenReturn(out1);when(sf.createSocket("google.com",80).getOutputStream()).thenReturn(out2);when(sf.createSocket("stackoverflow.com",80).getOutputStream()).thenReturn(out3);assertSame(out1,sf.createSocket().getOutputStream());assertSame(out2,sf.createSocket("google.com",80).getOutputStream());assertSame(out3,sf.createSocket("stackoverflow.com",80).getOutputStream());}
/** * Test that deep stubbing work with argument patterns*/@Test public void withAnyPatternArguments()throws Exception {OutputStream out=new ByteArrayOutputStream();SocketFactory sf=mock(SocketFactory.class,RETURNS_DEEP_STUBS);when(sf.createSocket(anyString(),anyInt()).getOutputStream()).thenReturn(out);assertSame(out,sf.createSocket("google.com",80).getOutputStream());assertSame(out,sf.createSocket("stackoverflow.com",8080).getOutputStream());}
/** * Test that deep stubbing work with argument patterns*/@Test public void withComplexPatternArguments()throws Exception {OutputStream out1=new ByteArrayOutputStream();OutputStream out2=new ByteArrayOutputStream();SocketFactory sf=mock(SocketFactory.class,RETURNS_DEEP_STUBS);when(sf.createSocket(anyString(),eq(80)).getOutputStream()).thenReturn(out1);when(sf.createSocket(anyString(),eq(8080)).getOutputStream()).thenReturn(out2);assertSame(out2,sf.createSocket("stackoverflow.com",8080).getOutputStream());assertSame(out1,sf.createSocket("google.com",80).getOutputStream());assertSame(out2,sf.createSocket("google.com",8080).getOutputStream());assertSame(out1,sf.createSocket("stackoverflow.com",80).getOutputStream());}
/** * Test that deep stubbing work with primitive expected values*/@Test public void withSimplePrimitive()throws Exception {int a=32;SocketFactory sf=mock(SocketFactory.class,RETURNS_DEEP_STUBS);when(sf.createSocket().getPort()).thenReturn(a);assertEquals(a,sf.createSocket().getPort());}
/** * Test that deep stubbing work with primitive expected values with pattern method arguments*/@Test public void withPatternPrimitive()throws Exception {int a=12,b=23,c=34;SocketFactory sf=mock(SocketFactory.class,RETURNS_DEEP_STUBS);when(sf.createSocket(eq("stackoverflow.com"),eq(80)).getPort()).thenReturn(a);when(sf.createSocket(eq("google.com"),anyInt()).getPort()).thenReturn(b);when(sf.createSocket(eq("stackoverflow.com"),eq(8080)).getPort()).thenReturn(c);assertEquals(b,sf.createSocket("google.com",80).getPort());assertEquals(c,sf.createSocket("stackoverflow.com",8080).getPort());assertEquals(a,sf.createSocket("stackoverflow.com",80).getPort());}
@Test public void shouldStubbingBasicallyWorkFine()throws Exception {given(person.getAddress().getStreet().getName()).willReturn("Norymberska");String street=person.getAddress().getStreet().getName();assertEquals("Norymberska",street);}
@Test public void shouldVerificationBasicallyWorkFine()throws Exception {person.getAddress().getStreet().getName();verify(person.getAddress().getStreet()).getName();}
@Test public void verification_work_with_argument_Matchers_in_nested_calls()throws Exception {person.getAddress("111 Mock Lane").getStreet();person.getAddress("111 Mock Lane").getStreet(Locale.ITALIAN).getName();verify(person.getAddress(anyString())).getStreet();verify(person.getAddress(anyString()).getStreet(Locale.CHINESE),never()).getName();verify(person.getAddress(anyString()).getStreet(eq(Locale.ITALIAN))).getName();}
@Test public void deep_stub_return_same_mock_instance_if_invocation_matchers_matches()throws Exception {when(person.getAddress(anyString()).getStreet().getName()).thenReturn("deep");person.getAddress("the docks").getStreet().getName();assertSame(person.getAddress("the docks").getStreet(),person.getAddress(anyString()).getStreet());assertSame(person.getAddress(anyString()).getStreet(),person.getAddress(anyString()).getStreet());assertSame(person.getAddress("the docks").getStreet(),person.getAddress("the docks").getStreet());assertSame(person.getAddress(anyString()).getStreet(),person.getAddress("the docks").getStreet());assertSame(person.getAddress("111 Mock Lane").getStreet(),person.getAddress("the docks").getStreet());}
@Test public void times_never_atLeast_atMost_verificationModes_should_work()throws Exception {when(person.getAddress(anyString()).getStreet().getName()).thenReturn("deep");person.getAddress("the docks").getStreet().getName();person.getAddress("the docks").getStreet().getName();person.getAddress("the docks").getStreet().getName();person.getAddress("the docks").getStreet(Locale.ITALIAN).getName();verify(person.getAddress("the docks").getStreet(),times(3)).getName();verify(person.getAddress("the docks").getStreet(Locale.CHINESE),never()).getName();verify(person.getAddress("the docks").getStreet(Locale.ITALIAN),atMost(1)).getName();}
@Test public void inOrder_only_work_on_the_very_last_mock_but_it_works()throws Exception {when(person.getAddress(anyString()).getStreet().getName()).thenReturn("deep");when(person.getAddress(anyString()).getStreet(Locale.ITALIAN).getName()).thenReturn("deep");when(person.getAddress(anyString()).getStreet(Locale.CHINESE).getName()).thenReturn("deep");person.getAddress("the docks").getStreet().getName();person.getAddress("the docks").getStreet().getLongName();person.getAddress("the docks").getStreet(Locale.ITALIAN).getName();person.getAddress("the docks").getStreet(Locale.CHINESE).getName();InOrder inOrder=inOrder(person.getAddress("the docks").getStreet(),person.getAddress("the docks").getStreet(Locale.CHINESE),person.getAddress("the docks").getStreet(Locale.ITALIAN));inOrder.verify(person.getAddress("the docks").getStreet(),times(1)).getName();inOrder.verify(person.getAddress("the docks").getStreet()).getLongName();inOrder.verify(person.getAddress("the docks").getStreet(Locale.ITALIAN),atLeast(1)).getName();inOrder.verify(person.getAddress("the docks").getStreet(Locale.CHINESE)).getName();}
@Test public void verificationMode_only_work_on_the_last_returned_mock()throws Exception {when(person.getAddress("the docks").getStreet().getName()).thenReturn("deep");person.getAddress("the docks").getStreet().getName();verify(person.getAddress("the docks").getStreet()).getName();try {verify(person.getAddress("the docks"),times(1)).getStreet();fail();}catch(TooManyActualInvocations e){Assertions.assertThat(e.getMessage()).contains("Wanted 1 time").contains("But was 3 times");}}
@Test public void shouldFailGracefullyWhenClassIsFinal()throws Exception {FinalClass value=new FinalClass();given(person.getFinalClass()).willReturn(value);assertEquals(value,person.getFinalClass());}
@SuppressWarnings("deprecation")@Test public void should_allow_assertions_on_captured_argument(){emailer.email(12);ArgumentCaptor<Person> argument=new ArgumentCaptor<Person>();verify(emailService).sendEmailTo(argument.capture());assertEquals(12,argument.getValue().getAge());}
@Test public void should_allow_assertions_on_all_captured_arguments(){emailer.email(11,12);ArgumentCaptor<Person> argument=ArgumentCaptor.forClass(Person.class);verify(emailService,atLeastOnce()).sendEmailTo(argument.capture());List<Person> allValues=argument.getAllValues();assertEquals(11,allValues.get(0).getAge());assertEquals(12,allValues.get(1).getAge());}
@Test public void should_allow_assertions_on_last_argument(){emailer.email(11,12,13);ArgumentCaptor<Person> argument=ArgumentCaptor.forClass(Person.class);verify(emailService,atLeastOnce()).sendEmailTo(argument.capture());assertEquals(13,argument.getValue().getAge());}
@Test public void should_print_captor_matcher(){ArgumentCaptor<Person> person=ArgumentCaptor.forClass(Person.class);try {verify(emailService).sendEmailTo(person.capture());fail();}catch(WantedButNotInvoked e){assertContains("<Capturing argument>",e.getMessage());}}
@Test public void should_allow_assertions_on_captured_null(){emailService.sendEmailTo(null);ArgumentCaptor<Person> argument=ArgumentCaptor.forClass(Person.class);verify(emailService).sendEmailTo(argument.capture());assertEquals(null,argument.getValue());}
@Test public void should_allow_capturing_for_stubbing(){ArgumentCaptor<Person> argument=ArgumentCaptor.forClass(Person.class);when(emailService.sendEmailTo(argument.capture())).thenReturn(false);emailService.sendEmailTo(new Person(10));assertEquals(10,argument.getValue().getAge());}
@Test public void should_capture_when_stubbing_only_when_entire_invocation_matches(){ArgumentCaptor<String> argument=ArgumentCaptor.forClass(String.class);when(mock.simpleMethod(argument.capture(),eq(2))).thenReturn("blah");mock.simpleMethod("foo",200);mock.simpleMethod("bar",2);Assertions.assertThat(argument.getAllValues()).containsOnly("bar");}
@Test public void should_say_something_smart_when_misused(){ArgumentCaptor<Person> argument=ArgumentCaptor.forClass(Person.class);try {argument.getValue();fail();}catch(MockitoException e){}}
@Test public void should_capture_when_full_arg_list_matches()throws Exception {mock.simpleMethod("foo",1);mock.simpleMethod("bar",2);ArgumentCaptor<String> captor=ArgumentCaptor.forClass(String.class);verify(mock).simpleMethod(captor.capture(),eq(1));assertEquals(1,captor.getAllValues().size());assertEquals("foo",captor.getValue());}
@Test public void should_capture_int_by_creating_captor_with_primitive_wrapper(){IMethods mock=mock(IMethods.class);ArgumentCaptor<Integer> argument=ArgumentCaptor.forClass(Integer.class);mock.intArgumentMethod(10);verify(mock).intArgumentMethod(argument.capture());assertEquals(10,(int)argument.getValue());}
@Test public void should_capture_int_by_creating_captor_with_primitive()throws Exception {IMethods mock=mock(IMethods.class);ArgumentCaptor<Integer> argument=ArgumentCaptor.forClass(int.class);mock.intArgumentMethod(10);verify(mock).intArgumentMethod(argument.capture());assertEquals(10,(int)argument.getValue());}
@Test public void should_capture_byte_vararg_by_creating_captor_with_primitive()throws Exception {IMethods mock=mock(IMethods.class);ArgumentCaptor<Byte> argumentCaptor=ArgumentCaptor.forClass(byte.class);mock.varargsbyte((byte)1,(byte)2);verify(mock).varargsbyte(argumentCaptor.capture());assertEquals((byte)2,(byte)argumentCaptor.getValue());Assertions.assertThat(argumentCaptor.getAllValues()).containsExactly((byte)1,(byte)2);}
@Test public void should_capture_byte_vararg_by_creating_captor_with_primitive_wrapper()throws Exception {IMethods mock=mock(IMethods.class);ArgumentCaptor<Byte> argumentCaptor=ArgumentCaptor.forClass(Byte.class);mock.varargsbyte((byte)1,(byte)2);verify(mock).varargsbyte(argumentCaptor.capture());assertEquals((byte)2,(byte)argumentCaptor.getValue());Assertions.assertThat(argumentCaptor.getAllValues()).containsExactly((byte)1,(byte)2);}
@Test public void should_capture_vararg()throws Exception {IMethods mock=mock(IMethods.class);ArgumentCaptor<String> argumentCaptor=ArgumentCaptor.forClass(String.class);mock.mixedVarargs(42,"a","b","c");verify(mock).mixedVarargs(any(),argumentCaptor.capture());Assertions.assertThat(argumentCaptor.getAllValues()).containsExactly("a","b","c");}
@Test public void should_capture_all_vararg()throws Exception {IMethods mock=mock(IMethods.class);ArgumentCaptor<String> argumentCaptor=ArgumentCaptor.forClass(String.class);mock.mixedVarargs(42,"a","b","c");mock.mixedVarargs(42,"again ?!");verify(mock,times(2)).mixedVarargs(any(),argumentCaptor.capture());List<String> allVarargsValues=argumentCaptor.getAllValues();Assertions.assertThat(allVarargsValues).containsExactly("a","b","c","again ?!");}
@Test public void should_capture_one_arg_even_when_using_vararg_captor_on_nonvararg_method()throws Exception {IMethods mock=mock(IMethods.class);ArgumentCaptor<String> argumentCaptor=ArgumentCaptor.forClass(String.class);mock.simpleMethod("a",2);verify(mock).simpleMethod(argumentCaptor.capture(),eq(2));Assertions.assertThat(argumentCaptor.getAllValues()).containsExactly("a");}
@Test public void captures_correclty_when_captor_used_multiple_times()throws Exception {IMethods mock=mock(IMethods.class);ArgumentCaptor<String> argumentCaptor=ArgumentCaptor.forClass(String.class);mock.mixedVarargs(42,"a","b","c");verify(mock).mixedVarargs(any(),argumentCaptor.capture(),argumentCaptor.capture(),argumentCaptor.capture());Assertions.assertThat(argumentCaptor.getAllValues()).containsExactly("a","b","c");}
@Test public void should_not_raise_a_mockito_exception_about_serialization_when_accessing_deep_stub(){NotSerializableShouldBeMocked the_deep_stub=mock(ToBeDeepStubbed.class,RETURNS_DEEP_STUBS).getSomething();assertThat(the_deep_stub).isNotNull();}
@Test public void hints_that_parent_not_public_during_stubbing()throws Exception {ClassForMocking clazzMock=mock(ClassForMocking.class);try {when(clazzMock.isValid()).thenReturn(true);fail();}catch(MissingMethodInvocationException e){Assertions.assertThat(e.getMessage()).contains(MockitoLimitations.NON_PUBLIC_PARENT);}}
@Test public void hints_that_parent_not_public_during_stubbing_start()throws Exception {ClassForMocking clazzMock=mock(ClassForMocking.class);mock(List.class).clear();try {when(clazzMock.isValid()).thenReturn(true);fail();}catch(CannotStubVoidMethodWithReturnValue e){Assertions.assertThat(e.getMessage()).contains(MockitoLimitations.NON_PUBLIC_PARENT);}}
@Test public void hints_that_parent_not_public_during_verify()throws Exception {ClassForMocking clazzMock=mock(ClassForMocking.class);verify(clazzMock).isValid();try {verify(clazzMock);fail();}catch(UnfinishedVerificationException e){Assertions.assertThat(e.getMessage()).contains(MockitoLimitations.NON_PUBLIC_PARENT);}}
@Test public void hints_that_parent_not_public_when_misplaced_matchers_detected()throws Exception {ClassForMocking clazzMock=mock(ClassForMocking.class);try {when(clazzMock.arg(anyObject())).thenReturn(0);fail();}catch(InvalidUseOfMatchersException e){Assertions.assertThat(e.getMessage()).contains(MockitoLimitations.NON_PUBLIC_PARENT);}}
@Test public void shouldSetMockitoNamingPolicy()throws Exception {MethodProxy methodProxy=MethodProxy.create(String.class,Integer.class,"","","");new CGLIBHacker().setMockitoNamingPolicy(methodProxy);Object createInfo=Whitebox.getInternalState(methodProxy,"createInfo");NamingPolicy namingPolicy=(NamingPolicy)Whitebox.getInternalState(createInfo,"namingPolicy");assertEquals(MockitoNamingPolicy.INSTANCE,namingPolicy);}
@Test public void shouldSetMockitoNamingPolicyEvenIfMethodProxyIsProxied()throws Exception {MethodProxy proxiedMethodProxy=spy(MethodProxy.create(String.class,Integer.class,"","",""));new CGLIBHacker().setMockitoNamingPolicy(proxiedMethodProxy);Object createInfo=Whitebox.getInternalState(proxiedMethodProxy,"createInfo");NamingPolicy namingPolicy=(NamingPolicy)Whitebox.getInternalState(createInfo,"namingPolicy");assertEquals(MockitoNamingPolicy.INSTANCE,namingPolicy);}
@Test public void handle_result_must_not_be_null_for_primitives()throws Throwable {MockCreationSettings settings=(MockCreationSettings)new MockSettingsImpl().defaultAnswer(new Returns(null));InternalMockHandler handler=new MockHandlerFactory().create(settings);mock.intReturningMethod();Invocation invocation=super.getLastInvocation();Object result=handler.handle(invocation);assertNotNull(result);assertEquals(0,result);}
@Test public void valid_handle_result_is_permitted()throws Throwable {MockCreationSettings settings=(MockCreationSettings)new MockSettingsImpl().defaultAnswer(new Returns(123));InternalMockHandler handler=new MockHandlerFactory().create(settings);mock.intReturningMethod();Invocation invocation=super.getLastInvocation();Object result=handler.handle(invocation);assertEquals(123,result);}
@Test public void shouldRemoveStubbableFromProgressAfterStubbing(){List mock=Mockito.mock(List.class);Mockito.when(mock.add("test")).thenReturn(true);assertNull(new ThreadSafeMockingProgress().pullOngoingStubbing());}
@Test(expected=NotAMockException.class)public void shouldValidateMockWhenVerifying(){Mockito.verify("notMock");}
@Test(expected=NotAMockException.class)public void shouldValidateMockWhenVerifyingWithExpectedNumberOfInvocations(){Mockito.verify("notMock",times(19));}
@Test(expected=NotAMockException.class)public void shouldValidateMockWhenVerifyingNoMoreInteractions(){Mockito.verifyNoMoreInteractions("notMock");}
@Test(expected=NotAMockException.class)public void shouldValidateMockWhenVerifyingZeroInteractions(){Mockito.verifyZeroInteractions("notMock");}
@SuppressWarnings("deprecation")@Test(expected=NotAMockException.class)public void shouldValidateMockWhenStubbingVoid(){Mockito.stubVoid("notMock");}
@Test(expected=NotAMockException.class)public void shouldValidateMockWhenCreatingInOrderObject(){Mockito.inOrder("notMock");}
@Test public void shouldStartingMockSettingsContainDefaultBehavior(){MockSettingsImpl settings=(MockSettingsImpl)Mockito.withSettings();assertEquals(Mockito.RETURNS_DEFAULTS,settings.getDefaultAnswer());}
@Test public void shouldReturnAllKindsOfPrimitives()throws Exception {assertEquals((byte)0,mock.byteReturningMethod());assertEquals((short)0,mock.shortReturningMethod());assertEquals(0,mock.intReturningMethod());assertEquals(0L,mock.longReturningMethod());assertEquals(0.0F,mock.floatReturningMethod(),0.0F);assertEquals(0.0D,mock.doubleReturningMethod(),0.0D);assertEquals((char)0,mock.charReturningMethod());assertEquals(false,mock.booleanReturningMethod());assertEquals(null,mock.objectReturningMethod());}
@Test public void shouldReturnTheSameValuesForWrapperClasses()throws Exception {assertEquals(new Byte((byte)0),mock.byteObjectReturningMethod());assertEquals(new Short((short)0),mock.shortObjectReturningMethod());assertEquals(new Integer(0),mock.integerReturningMethod());assertEquals(new Long(0L),mock.longObjectReturningMethod());assertEquals(new Float(0.0F),mock.floatObjectReturningMethod(),0.0F);assertEquals(new Double(0.0D),mock.doubleObjectReturningMethod(),0.0D);assertEquals(new Character((char)0),mock.charObjectReturningMethod());assertEquals(new Boolean(false),mock.booleanObjectReturningMethod());}
@Test public void shouldReturnEmptyCollections(){CollectionsServer mock=Mockito.mock(CollectionsServer.class);assertTrue(mock.list().isEmpty());assertTrue(mock.linkedList().isEmpty());assertTrue(mock.map().isEmpty());assertTrue(mock.hashSet().isEmpty());}
@Test public void shouldReturnMutableEmptyCollection(){CollectionsServer mock=Mockito.mock(CollectionsServer.class);List list=mock.list();list.add("test");assertTrue(mock.list().isEmpty());}
@Test public void shouldCreateCorrectCreationInfo()throws Exception {MethodProxy proxy=MethodProxy.create(String.class,Integer.class,"","","");SerializableMockitoMethodProxy serializableMockitoMethodProxy=new SerializableMockitoMethodProxy(proxy);serializableMockitoMethodProxy.methodProxy=null;Object methodProxy=Whitebox.invokeMethod(serializableMockitoMethodProxy,"getMethodProxy",new Object[0]);Object info=Whitebox.getInternalState(methodProxy,"createInfo");assertEquals(String.class,Whitebox.getInternalState(info,"c1"));assertEquals(Integer.class,Whitebox.getInternalState(info,"c2"));}
@Test public void shouldCreateCorrectSignatures()throws Exception {MethodProxy proxy=MethodProxy.create(String.class,Integer.class,"a","b","c");SerializableMockitoMethodProxy serializableMockitoMethodProxy=new SerializableMockitoMethodProxy(proxy);serializableMockitoMethodProxy.methodProxy=null;MethodProxy methodProxy=(MethodProxy)Whitebox.invokeMethod(serializableMockitoMethodProxy,"getMethodProxy",new Object[0]);assertEquals("a",methodProxy.getSignature().getDescriptor());assertEquals("b",methodProxy.getSignature().getName());assertEquals("c",methodProxy.getSuperName());}
@Test public void shouldShallowCopyBasicFinalField()throws Exception {assertEquals(100,from.finalField);assertNotEquals(100,to.finalField);tool.copyToMock(from,to);assertEquals(100,to.finalField);}
@Test public void shouldShallowCopyTransientPrivateFields()throws Exception {from.privateTransientField=1000;assertNotEquals(1000,to.privateTransientField);tool.copyToMock(from,to);assertEquals(1000,to.privateTransientField);}
@Test public void shouldShallowCopyLinkedListIntoMock()throws Exception {LinkedList fromList=new LinkedList();LinkedList toList=mock(LinkedList.class);tool.copyToMock(fromList,toList);}
@Test public void shouldShallowCopyFieldValuesIntoMock()throws Exception {from.defaultField="foo";from.instancePublicField=new SomeOtherObject();from.privateField=1;from.privateTransientField=2;from.protectedField=3;assertNotEquals(from.defaultField,to.defaultField);assertNotEquals(from.instancePublicField,to.instancePublicField);assertNotEquals(from.privateField,to.privateField);assertNotEquals(from.privateTransientField,to.privateTransientField);assertNotEquals(from.protectedField,to.protectedField);tool.copyToMock(from,to);assertEquals(from.defaultField,to.defaultField);assertEquals(from.instancePublicField,to.instancePublicField);assertEquals(from.privateField,to.privateField);assertEquals(from.privateTransientField,to.privateTransientField);assertEquals(from.protectedField,to.protectedField);}
@Test public void shouldCopyValuesOfInheritedFields()throws Exception {((InheritMe)from).privateInherited="foo";((InheritMe)from).protectedInherited="bar";assertNotEquals(((InheritMe)from).privateInherited,((InheritMe)to).privateInherited);assertNotEquals(((InheritMe)from).privateInherited,((InheritMe)to).privateInherited);tool.copyToMock(from,to);assertEquals(((InheritMe)from).privateInherited,((InheritMe)to).privateInherited);assertEquals(((InheritMe)from).privateInherited,((InheritMe)to).privateInherited);}
@Test public void shouldEnableAndThenDisableAccessibility()throws Exception {Field privateField=SomeObject.class.getDeclaredField("privateField");assertFalse(privateField.isAccessible());tool.copyToMock(from,to);privateField=SomeObject.class.getDeclaredField("privateField");assertFalse(privateField.isAccessible());}
@Test public void shouldContinueEvenIfThereAreProblemsCopyingSingleFieldValue()throws Exception {tool.fieldCopier=mock(FieldCopier.class);doNothing().doThrow(new IllegalAccessException()).doNothing().when(tool.fieldCopier).copyValue(anyObject(),anyObject(),any(Field.class));tool.copyToMock(from,to);verify(tool.fieldCopier,atLeast(3)).copyValue(any(),any(),any(Field.class));}
@Test public void shouldBeAbleToCopyFromRealObjectToRealObject()throws Exception {from.defaultField="defaultField";from.instancePublicField=new SomeOtherObject();from.privateField=1;from.privateTransientField=2;from.protectedField="protectedField";from.protectedInherited="protectedInherited";to=new SomeObject(0);tool.copyToRealObject(from,to);assertEquals(from.defaultField,to.defaultField);assertEquals(from.instancePublicField,to.instancePublicField);assertEquals(from.privateField,to.privateField);assertEquals(from.privateTransientField,to.privateTransientField);assertEquals(from.protectedField,to.protectedField);assertEquals(from.protectedInherited,to.protectedInherited);}
@Test public void shouldUseFinderCorrectly(){WarningsPrinterImpl printer=new WarningsPrinterImpl(false,finder);printer.print(logger);ArgumentCaptor<LoggingListener> arg=ArgumentCaptor.forClass(LoggingListener.class);verify(finder).find(arg.capture());assertEquals(logger,arg.getValue().getLogger());assertEquals(false,arg.getValue().isWarnAboutUnstubbed());}
@Test public void shouldPassCorrectWarningFlag(){WarningsPrinterImpl printer=new WarningsPrinterImpl(true,finder);printer.print(logger);ArgumentCaptor<LoggingListener> arg=ArgumentCaptor.forClass(LoggingListener.class);verify(finder).find(arg.capture());assertEquals(true,arg.getValue().isWarnAboutUnstubbed());}
@Test public void shouldPrintToString(){WarningsPrinterImpl printer=spy(new WarningsPrinterImpl(true,finder));String out=printer.print();verify(printer).print((MockitoLogger)notNull());assertNotNull(out);}
@Test public void shouldCreateRunnerForJUnit44(){}
@Test public void shouldCreateRunnerForJUnit45(){}
@Test public void shouldThrowMeaningfulMockitoExceptionIfNoValidJUnitFound()throws Exception {RunnerProvider provider=new RunnerProvider(){public boolean isJUnit45OrHigherAvailable(){return false;}public RunnerImpl newInstance(String runnerClassName,Class<?> constructorParam)throws Exception {throw new InitializationError("Where is JUnit,dude?");}};RunnerFactory factory=new RunnerFactory(provider);try {factory.create(RunnerFactoryTest.class);fail();}catch(MockitoException e){assertContains("upgrade your JUnit version",e.getMessage());}}
@Test public void shouldSaySomethingMeaningfulWhenNoTestMethods()throws Exception {RunnerFactory factory=new RunnerFactory(new RunnerProvider());try {factory.create(NoTestMethods.class);fail();}catch(MockitoException e){assertContains("No tests",e.getMessage());}}
@Test public void shouldForwardInvocationTargetException()throws Exception {RunnerFactory factory=new RunnerFactory(new RunnerProvider(){@Override public RunnerImpl newInstance(String runnerClassName,Class<?> constructorParam)throws Exception {throw new InvocationTargetException(new RuntimeException());}});try {factory.create(this.getClass());fail();}catch(InvocationTargetException e){}}
@Test public void shouldAutoboxSafely(){fun.doFun(1.0);verify(fun).doFun(captor.capture());assertEquals((Double)1.0,captor.getValue());}
@Test public void shouldAutoboxAllPrimitives(){verify(fun,never()).moreFun(intCaptor.capture());}
@Test public void shouldProvideMockyImplementationOfToString(){DummyClass dummyClass=Mockito.mock(DummyClass.class);assertEquals("Mock for DummyClass,hashCode: " + dummyClass.hashCode(),dummyClass.toString());DummyInterface dummyInterface=Mockito.mock(DummyInterface.class);assertEquals("Mock for DummyInterface,hashCode: " + dummyInterface.hashCode(),dummyInterface.toString());}
@Test public void shouldReplaceObjectMethods(){}
@Test public void shouldReplaceObjectMethodsWhenOverridden(){}
@Test public void shouldStartVerificationAndPullVerificationMode()throws Exception {assertNull(mockingProgress.pullVerificationMode());VerificationMode mode=VerificationModeFactory.times(19);mockingProgress.verificationStarted(mode);assertSame(mode,mockingProgress.pullVerificationMode());assertNull(mockingProgress.pullVerificationMode());}
@Test public void shouldCheckIfVerificationWasFinished()throws Exception {mockingProgress.verificationStarted(VerificationModeFactory.atLeastOnce());try {mockingProgress.verificationStarted(VerificationModeFactory.atLeastOnce());fail();}catch(MockitoException e){}}
@Test public void shouldNotifyListenerWhenMockingStarted()throws Exception {MockingStartedListener listener=mock(MockingStartedListener.class);mockingProgress.setListener(listener);mockingProgress.mockingStarted("foo",List.class);verify(listener).mockingStarted(eq("foo"),eq(List.class));}
@Test public void shouldNotifyListenerSafely()throws Exception {mockingProgress.setListener(null);mockingProgress.mockingStarted(null,null);}
@Test public void makeSureStateIsValidatedInTheVeryFirstTestThanksToTheRunner(){verify(mock);}
@Test public void shouldSayWantedButNotInvoked(){verify(mock).otherMethod();}
@Test public void shouldPointOutInteractionsOnMockWhenOrdinaryVerificationFails(){mock.otherMethod();mock.booleanObjectReturningMethod();verify(mock).simpleMethod();}
@Test public void shouldShowActualAndExpected(){mock.simpleMethod("blah");verify(mock).simpleMethod();}
@Test public void shouldSayTooLittleInvocations(){mock.simpleMethod();verify(mock,times(2)).simpleMethod();}
@Test public void shouldSayTooManyInvocations(){mock.simpleMethod();mock.simpleMethod();verify(mock,times(1)).simpleMethod();}
@Test public void shouldSayWantedButNotInvokedInOrder(){mock.simpleMethod();mock.otherMethod();InOrder inOrder=inOrder(mock);inOrder.verify(mock).otherMethod();inOrder.verify(mock).simpleMethod();}
@Test public void shouldSayTooLittleInvocationsInOrder(){mock.simpleMethod();mock.otherMethod();mock.otherMethod();InOrder inOrder=inOrder(mock);inOrder.verify(mock).simpleMethod();inOrder.verify(mock,times(3)).otherMethod();}
@Test public void shouldSayTooManyInvocationsInOrder(){mock.otherMethod();mock.otherMethod();InOrder inOrder=inOrder(mock);inOrder.verify(mock,times(1)).otherMethod();}
@Test public void shouldSayNeverWantedButInvokedHere(){mock.otherMethod();verify(mock,never()).otherMethod();}
@Test public void shouldSayTooLittleInvocationsInAtLeastModeInOrder(){mock.simpleMethod();InOrder inOrder=inOrder(mock);inOrder.verify(mock,atLeast(2)).simpleMethod();}
@Test public void shouldSayTooLittleInvocationsInAtLeastMode(){mock.simpleMethod();verify(mock,atLeast(2)).simpleMethod();}
@Test public void shouldSayNoMoreInteractions(){mock.simpleMethod();verifyNoMoreInteractions(mock);}
@Test public void shouldSayUnstubbedMethodWasInvokedHere(){mock=mock(IMethods.class,RETURNS_SMART_NULLS);IMethods m=mock.iMethodsReturningMethod();m.simpleMethod();}
@Test public void shouldPointOutUnfinishedStubbing(){when(mock.simpleMethod());verify(mock).simpleMethod();}
@Test public void shouldMentionFinalAndObjectMethodsWhenMissingMockCall(){when("".equals(null)).thenReturn(false);}
@Test public void shouldMentionFinalAndObjectMethodsWhenVerifying(){verify(mock).equals(null);verify(mock).simpleMethod();}
@Test public void shouldMentionFinalAndObjectMethodsWhenMisplacedArgumentMatcher(){when(mock.equals(anyObject())).thenReturn(false);}
@Test public void shouldShowExampleOfCorrectArgumentCapturing(){ArgumentCaptor<String> argument=ArgumentCaptor.forClass(String.class);argument.capture();argument.getValue();}
@Test public void shouldScreamWhenNullPassedInsteadOfAnInterface(){mock(IMethods.class,withSettings().extraInterfaces(List.class,null));}
@Test public void shouldScreamWhenNonInterfacePassed(){mock(IMethods.class,withSettings().extraInterfaces(LinkedList.class));}
@Test public void shouldScreamWhenExtraIsTheSame(){mock(IMethods.class,withSettings().extraInterfaces(IMethods.class));}
@Test public void shouldScreamWhenExtraInterfacesEmpty(){mock(IMethods.class,withSettings().extraInterfaces());}
@Test public void shouldScreamWhenExtraInterfacesIsANullArray(){mock(IMethods.class,withSettings().extraInterfaces((Class[])null));}
@Test public void shouldMentionSpiesWhenVoidMethodIsToldToReturnValue(){List list=mock(List.class);doReturn("foo").when(list).clear();}
@Test public void should_return_on_success(){impl.verify(null);verify(delegate).verify(null);}
@Test public void should_throw_mockito_assertion_error(){}
@Test public void should_deal_with_junit_assertion_error(){}
@Test public void should_not_wrap_other_exceptions(){}
@Test public void shouldDetectUnfinishedStubbing(){when(mock.simpleMethod());detectsAndCleansUp(new OnMethodCallOnMock(),UnfinishedStubbingException.class);when(mock.simpleMethod());detectsAndCleansUp(new OnStub(),UnfinishedStubbingException.class);when(mock.simpleMethod());detectsAndCleansUp(new OnStubVoid(),UnfinishedStubbingException.class);when(mock.simpleMethod());detectsAndCleansUp(new OnVerify(),UnfinishedStubbingException.class);when(mock.simpleMethod());detectsAndCleansUp(new OnVerifyInOrder(),UnfinishedStubbingException.class);when(mock.simpleMethod());detectsAndCleansUp(new OnVerifyZeroInteractions(),UnfinishedStubbingException.class);when(mock.simpleMethod());detectsAndCleansUp(new OnVerifyNoMoreInteractions(),UnfinishedStubbingException.class);when(mock.simpleMethod());detectsAndCleansUp(new OnDoAnswer(),UnfinishedStubbingException.class);}
@Test public void shouldDetectUnfinishedStubbingVoid(){stubVoid(mock);detectsAndCleansUp(new OnMethodCallOnMock(),UnfinishedStubbingException.class);stubVoid(mock);detectsAndCleansUp(new OnStub(),UnfinishedStubbingException.class);stubVoid(mock);detectsAndCleansUp(new OnStubVoid(),UnfinishedStubbingException.class);stubVoid(mock);detectsAndCleansUp(new OnVerify(),UnfinishedStubbingException.class);stubVoid(mock);detectsAndCleansUp(new OnVerifyInOrder(),UnfinishedStubbingException.class);stubVoid(mock);detectsAndCleansUp(new OnVerifyZeroInteractions(),UnfinishedStubbingException.class);stubVoid(mock);detectsAndCleansUp(new OnVerifyNoMoreInteractions(),UnfinishedStubbingException.class);stubVoid(mock);detectsAndCleansUp(new OnDoAnswer(),UnfinishedStubbingException.class);}
@Test public void shouldDetectUnfinishedDoAnswerStubbing(){doAnswer(null);detectsAndCleansUp(new OnMethodCallOnMock(),UnfinishedStubbingException.class);doAnswer(null);detectsAndCleansUp(new OnStub(),UnfinishedStubbingException.class);doAnswer(null);detectsAndCleansUp(new OnStubVoid(),UnfinishedStubbingException.class);doAnswer(null);detectsAndCleansUp(new OnVerify(),UnfinishedStubbingException.class);doAnswer(null);detectsAndCleansUp(new OnVerifyInOrder(),UnfinishedStubbingException.class);doAnswer(null);detectsAndCleansUp(new OnVerifyZeroInteractions(),UnfinishedStubbingException.class);doAnswer(null);detectsAndCleansUp(new OnVerifyNoMoreInteractions(),UnfinishedStubbingException.class);doAnswer(null);detectsAndCleansUp(new OnDoAnswer(),UnfinishedStubbingException.class);}
@Test public void shouldDetectUnfinishedVerification(){verify(mock);detectsAndCleansUp(new OnStub(),UnfinishedVerificationException.class);verify(mock);detectsAndCleansUp(new OnStubVoid(),UnfinishedVerificationException.class);verify(mock);detectsAndCleansUp(new OnVerify(),UnfinishedVerificationException.class);verify(mock);detectsAndCleansUp(new OnVerifyInOrder(),UnfinishedVerificationException.class);verify(mock);detectsAndCleansUp(new OnVerifyZeroInteractions(),UnfinishedVerificationException.class);verify(mock);detectsAndCleansUp(new OnVerifyNoMoreInteractions(),UnfinishedVerificationException.class);verify(mock);detectsAndCleansUp(new OnDoAnswer(),UnfinishedVerificationException.class);}
@Test public void shouldDetectMisplacedArgumentMatcher(){anyObject();detectsAndCleansUp(new OnStubVoid(),InvalidUseOfMatchersException.class);anyObject();detectsAndCleansUp(new OnVerify(),InvalidUseOfMatchersException.class);anyObject();detectsAndCleansUp(new OnVerifyInOrder(),InvalidUseOfMatchersException.class);anyObject();detectsAndCleansUp(new OnVerifyZeroInteractions(),InvalidUseOfMatchersException.class);anyObject();detectsAndCleansUp(new OnVerifyNoMoreInteractions(),InvalidUseOfMatchersException.class);anyObject();detectsAndCleansUp(new OnDoAnswer(),InvalidUseOfMatchersException.class);}
@Test public void shouldCorrectStateAfterDetectingUnfinishedStubbing(){stubVoid(mock).toThrow(new RuntimeException());try {stubVoid(mock).toThrow(new RuntimeException()).on().oneArg(true);fail();}catch(UnfinishedStubbingException e){}stubVoid(mock).toThrow(new RuntimeException()).on().oneArg(true);try {mock.oneArg(true);fail();}catch(RuntimeException e){}}
@Test public void shouldCorrectStateAfterDetectingUnfinishedVerification(){mock.simpleMethod();verify(mock);try {verify(mock).simpleMethod();fail();}catch(UnfinishedVerificationException e){}verify(mock).simpleMethod();}
@Test public void shouldNotFailWhenNotInitialized(){assertNotNull(articleManager);}
@Test(expected=IllegalArgumentException.class)public void innerMockShouldRaiseAnExceptionThatChangesOuterMockBehavior(){when(calculator.countArticles("new")).thenThrow(new IllegalArgumentException());articleManager.updateArticleCounters("new");}
@Test public void mockJustWorks(){articleManager.updateArticleCounters("new");}
@Test public void constructor_is_called_for_each_test_in_test_class()throws Exception {JUnitCore jUnitCore=new JUnitCore();jUnitCore.addListener(new TextListener(System.out));jUnitCore.run(junit_test_with_3_tests_methods.class);assertThat(junit_test_with_3_tests_methods.constructor_instantiation).isEqualTo(3);}
@Test public void objects_created_with_constructor_initialization_can_be_spied()throws Exception {assertFalse(mockUtil.isMock(articleManager));assertTrue(mockUtil.isMock(spiedArticleManager));}
@Test public void should_report_failure_only_when_object_initialization_throws_exception()throws Exception {try {MockitoAnnotations.initMocks(new ATest());fail();}catch(MockitoException e){assertThat(e.getMessage()).contains("failingConstructor").contains("constructor").contains("threw an exception");assertThat(e.getCause()).isInstanceOf(IllegalStateException.class);}}
@Test public void test_1(){}
@Test public void test_2(){}
@Test public void test_3(){}
@Test public void parent_field_is_not_null(){assertNotNull(((AbstractSystem)system).someService);}
@Test public void child_field_is_not_null(){assertNotNull(system.someService);}
@Test public void should_know_spy(){assertTrue(mockingDetails(annotatedSpy).isMock());assertTrue(mockingDetails(spy(new TestClass())).isMock());assertTrue(mockingDetails(spy(TestClass.class)).isMock());assertTrue(mockingDetails(mock(TestClass.class,withSettings().defaultAnswer(Mockito.CALLS_REAL_METHODS))).isMock());assertTrue(mockingDetails(annotatedSpy).isSpy());assertTrue(mockingDetails(spy(new TestClass())).isSpy());assertTrue(mockingDetails(spy(TestClass.class)).isSpy());assertTrue(mockingDetails(mock(TestClass.class,withSettings().defaultAnswer(Mockito.CALLS_REAL_METHODS))).isSpy());}
@Test public void should_know_mock(){assertTrue(mockingDetails(annotatedMock).isMock());assertTrue(mockingDetails(mock(TestClass.class)).isMock());assertFalse(mockingDetails(annotatedMock).isSpy());assertFalse(mockingDetails(mock(TestClass.class)).isSpy());}
@Test public void should_handle_non_mocks(){assertFalse(mockingDetails("non mock").isSpy());assertFalse(mockingDetails("non mock").isMock());assertFalse(mockingDetails(null).isSpy());assertFalse(mockingDetails(null).isMock());}
@Test public void should_return_true_if_task_is_in_acceptable_time_bounds(){}
@Test public void should_return_false_if_task_is_outside_the_acceptable_time_bounds(){}
@Test public void shouldKnowValidThrowables()throws Exception {Invocation invocation=new InvocationBuilder().method("canThrowException").toInvocation();MethodInfo info=new MethodInfo(invocation);assertFalse(info.isValidException(new Exception()));assertTrue(info.isValidException(new CharacterCodingException()));}
@Test public void second_stubbing_throws_IndexOutOfBoundsException()throws Exception {Map<String,String> map=mock(Map.class);OngoingStubbing<String> mapOngoingStubbing=when(map.get(anyString()));mapOngoingStubbing.thenReturn("first stubbing");try {mapOngoingStubbing.thenReturn("second stubbing");fail();}catch(MockitoException e){assertThat(e.getMessage()).contains("Incorrect use of API detected here").contains(this.getClass().getSimpleName());}}
@Test public void shouldDelegateToGetDescription()throws Exception {final Description expectedDescription=Description.createSuiteDescription(this.getClass());runner=new ConsoleSpammingMockitoJUnitRunner(loggerStub,new RunnerImplStub(){public Description getDescription(){return expectedDescription;}});Description description=runner.getDescription();assertEquals(expectedDescription,description);}
@Test public void shouldPrintVerificationInOrderErrorAndShowBothWantedAndPrevious(){inOrder.verify(one).simpleMethod(1);inOrder.verify(two,atLeastOnce()).simpleMethod(2);try {inOrder.verify(one,atLeastOnce()).simpleMethod(11);fail();}catch(VerificationInOrderFailure e){String expected="\n" + "Verification in order failure" + "\n"+ "Wanted but not invoked:"+ "\n"+ "iMethods.simpleMethod(11);"+ "\n"+ "-> at ";assertContains(expected,e.getMessage());String expectedCause="\n" + "Wanted anywhere AFTER following interaction:" + "\n"+ "iMethods.simpleMethod(2);"+ "\n"+ "-> at ";assertContains(expectedCause,e.getMessage());}}
@Test public void shouldPrintVerificationInOrderErrorAndShowWantedOnly(){try {inOrder.verify(one).differentMethod();fail();}catch(WantedButNotInvoked e){String expected="\n" + "Wanted but not invoked:" + "\n"+ "iMethods.differentMethod();"+ "\n"+ "-> at";assertContains(expected,e.getMessage());}}
@Test public void shouldPrintVerificationInOrderErrorAndShowWantedAndActual(){try {inOrder.verify(one).simpleMethod(999);fail();}catch(org.mockito.exceptions.verification.junit.ArgumentsAreDifferent e){assertContains("has different arguments",e.getMessage());}}
@Test public void shouldNotSayArgumentsAreDifferent(){inOrder.verify(three).simpleMethod(3);try {inOrder.verify(one).simpleMethod(999);fail();}catch(VerificationInOrderFailure e){assertContains("Wanted but not invoked",e.getMessage());}}
@Test public void shouldPrintMethodThatWasNotInvoked(){inOrder.verify(one).simpleMethod(1);inOrder.verify(one).simpleMethod(11);inOrder.verify(two,times(2)).simpleMethod(2);inOrder.verify(three).simpleMethod(3);try {inOrder.verify(three).simpleMethod(999);fail();}catch(VerificationInOrderFailure e){String actualMessage=e.getMessage();String expectedMessage="\n" + "Verification in order failure" + "\n"+ "Wanted but not invoked:"+ "\n"+ "iMethods.simpleMethod(999);";assertContains(expectedMessage,actualMessage);}}
@Test public void shouldPrintTooManyInvocations(){inOrder.verify(one).simpleMethod(1);inOrder.verify(one).simpleMethod(11);try {inOrder.verify(two,times(1)).simpleMethod(2);fail();}catch(VerificationInOrderFailure e){String actualMessage=e.getMessage();String expectedMessage="\n" + "Verification in order failure:" + "\n"+ "iMethods.simpleMethod(2);"+ "\n"+ "Wanted 1 time:"+ "\n"+ "-> at";assertContains(expectedMessage,actualMessage);String expectedCause="\n" + "But was 2 times. Undesired invocation:" + "\n"+ "-> at";assertContains(expectedCause,e.getMessage());}}
@Test public void shouldPrintTooLittleInvocations(){two.simpleMethod(2);inOrder.verify(one,atLeastOnce()).simpleMethod(anyInt());inOrder.verify(two,times(2)).simpleMethod(2);inOrder.verify(three,atLeastOnce()).simpleMethod(3);try {inOrder.verify(two,times(2)).simpleMethod(2);fail();}catch(VerificationInOrderFailure e){String actualMessage=e.getMessage();String expectedMessage="\n" + "Verification in order failure:" + "\n"+ "iMethods.simpleMethod(2);"+ "\n"+ "Wanted 2 times:"+ "\n"+ "-> at";assertContains(expectedMessage,actualMessage);String expectedCause="\n" + "But was 1 time:" + "\n"+ "-> at";assertContains(expectedCause,e.getMessage());}}
@Test public void shouldNotThrowNPE(){when(mock.simpleMethod()).thenThrow(mock2);try {mock.simpleMethod();fail();}catch(DummyException e){}}
@Test public void shouldAskFinderForActualInvocations(){finderStub.actualToReturn.add(new InvocationBuilder().toInvocation());checker.check(invocations,wanted);assertSame(invocations,finderStub.invocations);}
@Test public void shouldPassBecauseActualInvocationFound(){finderStub.actualToReturn.add(new InvocationBuilder().toInvocation());checker.check(invocations,wanted);}
@Test public void shouldAskAnalyzerForSimilarInvocation(){checker.check(invocations,wanted);assertSame(invocations,finderStub.invocations);}
@Test public void shouldReportWantedButNotInvoked(){assertTrue(finderStub.actualToReturn.isEmpty());finderStub.similarToReturn=null;checker.check(invocations,wanted);assertEquals(wanted,reporterStub.wanted);assertNull(reporterStub.actualLocation);}
@Test public void shouldReportWantedInvocationDiffersFromActual(){assertTrue(finderStub.actualToReturn.isEmpty());Invocation actualInvocation=new InvocationBuilder().toInvocation();finderStub.similarToReturn=actualInvocation;checker.check(invocations,wanted);assertNotNull(reporterStub.wanted);assertNotNull(reporterStub.actual);assertSame(actualInvocation.getLocation(),reporterStub.actualLocation);}
@Test(expected=MockitoException.class)public void shouldRequireArgumentsWhenVerifyingNoMoreInteractions(){verifyNoMoreInteractions();}
@Test(expected=MockitoException.class)public void shouldRequireArgumentsWhenVerifyingZeroInteractions(){verifyZeroInteractions();}
@Test(expected=MockitoException.class)public void shouldNotCreateInOrderObjectWithoutMocks(){inOrder();}
@Test(expected=MockitoException.class)public void shouldNotAllowVerifyingInOrderUnfamilarMocks(){InOrder inOrder=inOrder(mock);inOrder.verify(mockTwo).simpleMethod();}
@Test(expected=MissingMethodInvocationException.class)public void shouldReportMissingMethodInvocationWhenStubbing(){when(mock.simpleMethod()).thenReturn("this stubbing is required to make sure Stubbable is pulled");when("".toString()).thenReturn("x");}
@Test(expected=MockitoException.class)public void shouldNotAllowSettingInvalidCheckedException()throws Exception {when(mock.simpleMethod()).thenThrow(new Exception());}
@Test(expected=MockitoException.class)public void shouldNotAllowSettingNullThrowable()throws Exception {when(mock.simpleMethod()).thenThrow(new Throwable[]{null});}
@SuppressWarnings("all")@Test(expected=MockitoException.class)public void shouldNotAllowSettingNullThrowableVararg()throws Exception {when(mock.simpleMethod()).thenThrow((Throwable)null);}
@Test(expected=MockitoException.class)public void shouldNotAllowSettingNullConsecutiveThrowable()throws Exception {when(mock.simpleMethod()).thenThrow(new RuntimeException(),null);}
@Test(expected=MockitoException.class)public void shouldNotAllowMockingFinalClasses()throws Exception {mock(FinalClass.class);}
@Test(expected=MockitoException.class)public void shouldNotAllowMockingPrimitves()throws Exception {mock(Integer.TYPE);}
@Test public void shouldNotMockObjectMethodsOnInterface()throws Exception {ObjectLikeInterface inter=mock(ObjectLikeInterface.class);inter.equals(null);inter.toString();inter.hashCode();verifyZeroInteractions(inter);}
@Test public void shouldMatchTypesWhenActualMatcherHasCorrectType()throws Exception {ContainsExtraTypeInformation equals10=new Equals(10);LocalizedMatcher m=new LocalizedMatcher((Matcher)equals10);assertTrue(m.typeMatches(10));assertFalse(m.typeMatches(10L));}
@Test public void shouldNotMatchTypesWhenActualMatcherDoesNotHaveCorrectType()throws Exception {LocalizedMatcher m=new LocalizedMatcher(Any.ANY);assertFalse(m.typeMatches(10));}
@Test public void shouldDescribeWithTypeInfoWhenActualMatcherHasCorrectType()throws Exception {ContainsExtraTypeInformation equals10=new Equals(10);LocalizedMatcher m=new LocalizedMatcher((Matcher)equals10);assertEquals("(Integer)10",describe(m.withExtraTypeInfo()));}
@Test public void shouldNotDescribeWithTypeInfoWhenActualMatcherDoesNotHaveCorrectType()throws Exception {LocalizedMatcher m=new LocalizedMatcher(Any.ANY);assertSame(m,m.withExtraTypeInfo());}
@Test public void shouldDelegateToCapturingMatcher()throws Exception {CapturingMatcher capturingMatcher=new CapturingMatcher();LocalizedMatcher m=new LocalizedMatcher(capturingMatcher);m.captureFrom("boo");assertEquals("boo",capturingMatcher.getLastValue());}
@Test public void shouldVerifySingleMockInOrderAndNotInOrder(){mockOne=mock(IMethods.class);inOrder=inOrder(mockOne);mockOne.simpleMethod(1);mockOne.simpleMethod(2);verify(mockOne).simpleMethod(2);verify(mockOne).simpleMethod(1);inOrder.verify(mockOne).simpleMethod(2);try {inOrder.verify(mockOne).simpleMethod(1);fail();}catch(VerificationInOrderFailure e){}}
@Test public void shouldMessagesPointToProperMethod(){mockTwo.differentMethod();mockOne.simpleMethod();try {inOrder.verify(mockOne,atLeastOnce()).differentMethod();fail();}catch(WantedButNotInvoked e){assertContains("differentMethod()",e.getMessage());}}
@Test public void shouldVerifyInOrderWhenTwoChunksAreEqual(){mockOne.simpleMethod();mockOne.simpleMethod();mockTwo.differentMethod();mockOne.simpleMethod();mockOne.simpleMethod();inOrder.verify(mockOne,times(2)).simpleMethod();inOrder.verify(mockTwo).differentMethod();inOrder.verify(mockOne,times(2)).simpleMethod();try {inOrder.verify(mockOne,atLeastOnce()).simpleMethod();fail();}catch(VerificationInOrderFailure e){}}
@Test public void shouldVerifyInOrderUsingMatcher(){mockOne.simpleMethod(1);mockOne.simpleMethod(2);mockTwo.differentMethod();mockOne.simpleMethod(3);mockOne.simpleMethod(4);verify(mockOne,times(4)).simpleMethod(anyInt());inOrder.verify(mockOne,times(2)).simpleMethod(anyInt());inOrder.verify(mockTwo).differentMethod();inOrder.verify(mockOne,times(2)).simpleMethod(anyInt());try {inOrder.verify(mockOne,times(3)).simpleMethod(anyInt());fail();}catch(VerificationInOrderFailure e){}}
@Test public void shouldVerifyInOrderWhenMultipleThreadsInteractWithMock()throws Exception {final Foo testInf=mock(Foo.class);Thread threadOne=new Thread(new Runnable(){public void run(){testInf.methodOne();}});threadOne.start();threadOne.join();Thread threadTwo=new Thread(new Runnable(){public void run(){testInf.methodTwo();}});threadTwo.start();threadTwo.join();InOrder inOrder=inOrder(testInf);inOrder.verify(testInf).methodOne();inOrder.verify(testInf).methodTwo();}
@Test public void shouldScreamWhenVerifyToString(){try {verify(mock).toString();fail();}catch(MockitoException e){assertContains("cannot verify",e.getMessage());}}
@Test public void shouldBeSilentWhenVerifyHashCode(){verify(mock).hashCode();}
@Test public void shouldBeSilentWhenVerifyEquals(){verify(mock).equals(null);}
@Test public void shouldBeSilentWhenVerifyEqualsInOrder(){InOrder inOrder=inOrder(mock);inOrder.verify(mock).equals(null);}
@Test public void shouldStubbingWork(){Mockito.when(iterable.iterator()).thenReturn(myIterator);Assert.assertNotNull(((Iterable)iterable).iterator());Assert.assertNotNull(iterable.iterator());}
@Test public void shouldVerificationWorks(){iterable.iterator();verify(iterable).iterator();verify((Iterable)iterable).iterator();}
@Test public void shouldWorkExactlyAsJavaProxyWould(){final List<Method> methods=new LinkedList<Method>();InvocationHandler handler=new InvocationHandler(){public Object invoke(Object proxy,Method method,Object[]args)throws Throwable {methods.add(method);return null;}};iterable=(MyIterable)Proxy.newProxyInstance(this.getClass().getClassLoader(),new Class[]{MyIterable.class},handler);iterable.iterator();((Iterable)iterable).iterator();assertEquals(2,methods.size());assertEquals(methods.get(0),methods.get(1));}
@Test public void shouldAcceptHamcrestMatcher(){when(mock.simpleMethod(argThat(new ContainsX()))).thenReturn("X");assertNull(mock.simpleMethod("blah"));assertEquals("X",mock.simpleMethod("blah X blah"));}
@Test public void shouldVerifyUsingHamcrestMatcher(){mock.simpleMethod("blah");try {verify(mock).simpleMethod(argThat(new ContainsX()));fail();}catch(ArgumentsAreDifferent e){assertContains("contains 'X'",e.getMessage());}}
@Test public void shouldIncludeInitialLog(){int importType=0;Date currentDate=new GregorianCalendar(2009,10,12).getTime();ImportLogBean initialLog=new ImportLogBean(currentDate,importType);initialLog.setStatus(1);given(importLogDao.anyImportRunningOrRunnedToday(importType,currentDate)).willReturn(false);willAnswer(byCheckingLogEquals(initialLog)).given(importLogDao).include(any(ImportLogBean.class));importManager.startImportProcess(importType,currentDate);verify(importLogDao).include(any(ImportLogBean.class));}
@Test public void shouldAlterFinalLog(){int importType=0;Date currentDate=new GregorianCalendar(2009,10,12).getTime();ImportLogBean finalLog=new ImportLogBean(currentDate,importType);finalLog.setStatus(9);given(importLogDao.anyImportRunningOrRunnedToday(importType,currentDate)).willReturn(false);willAnswer(byCheckingLogEquals(finalLog)).given(importLogDao).alter(any(ImportLogBean.class));importManager.startImportProcess(importType,currentDate);verify(importLogDao).alter(any(ImportLogBean.class));}
@Test public void shouldAllowAnyList(){when(mock.forList(anyList())).thenReturn("x");assertEquals("x",mock.forList(null));assertEquals("x",mock.forList(Arrays.asList("x","y")));verify(mock,times(2)).forList(anyList());}
@Test public void shouldAllowAnyCollection(){when(mock.forCollection(anyCollection())).thenReturn("x");assertEquals("x",mock.forCollection(null));assertEquals("x",mock.forCollection(Arrays.asList("x","y")));verify(mock,times(2)).forCollection(anyCollection());}
@Test public void shouldAllowAnyMap(){when(mock.forMap(anyMap())).thenReturn("x");assertEquals("x",mock.forMap(null));assertEquals("x",mock.forMap(new HashMap<String,String>()));verify(mock,times(2)).forMap(anyMap());}
@Test public void shouldAllowAnySet(){when(mock.forSet(anySet())).thenReturn("x");assertEquals("x",mock.forSet(null));assertEquals("x",mock.forSet(new HashSet<String>()));verify(mock,times(2)).forSet(anySet());}
@Test public void shouldUseCaptorInOrdinaryWay(){createPerson("Wes","Williams");ArgumentCaptor<Person> captor=ArgumentCaptor.forClass(Person.class);verify(peopleRepository).save(captor.capture());assertEquals("Wes",captor.getValue().getName());assertEquals("Williams",captor.getValue().getSurname());}
@Test public void shouldUseAnnotatedCaptor(){createPerson("Wes","Williams");verify(peopleRepository).save(captor.capture());assertEquals("Wes",captor.getValue().getName());assertEquals("Williams",captor.getValue().getSurname());}
@Test public void shouldUseGenericlessAnnotatedCaptor(){createPerson("Wes","Williams");verify(peopleRepository).save((Person)genericLessCaptor.capture());assertEquals("Wes",((Person)genericLessCaptor.getValue()).getName());assertEquals("Williams",((Person)genericLessCaptor.getValue()).getSurname());}
@Test public void shouldCaptureGenericList(){List<String> list=new LinkedList<String>();mock.listArgMethod(list);verify(mock).listArgMethod(genericListCaptor.capture());assertSame(list,genericListCaptor.getValue());}
@Test public void testLessThan(){test(new LessThan<String>("b"),true,false,false,"lt");}
@Test public void testGreaterThan(){test(new GreaterThan<String>("b"),false,true,false,"gt");}
@Test public void testLessOrEqual(){test(new LessOrEqual<String>("b"),true,false,true,"leq");}
@Test public void testGreaterOrEqual(){test(new GreaterOrEqual<String>("b"),false,true,true,"geq");}
@Test public void testCompareEqual(){test(new CompareEqual<String>("b"),false,false,true,"cmpEq");CompareEqual<BigDecimal> cmpEq=new CompareEqual<BigDecimal>(new BigDecimal("5.00"));assertTrue(cmpEq.matches(new BigDecimal("5")));}
@Test public void should_not_return_null_for_primitives_wrappers()throws Exception {assertNotNull(h.returnFor(Boolean.class));assertNotNull(h.returnFor(Character.class));assertNotNull(h.returnFor(Byte.class));assertNotNull(h.returnFor(Short.class));assertNotNull(h.returnFor(Integer.class));assertNotNull(h.returnFor(Long.class));assertNotNull(h.returnFor(Float.class));assertNotNull(h.returnFor(Double.class));}
@Test public void should_not_return_null_for_primitives()throws Exception {assertNotNull(h.returnFor(boolean.class));assertNotNull(h.returnFor(char.class));assertNotNull(h.returnFor(byte.class));assertNotNull(h.returnFor(short.class));assertNotNull(h.returnFor(int.class));assertNotNull(h.returnFor(long.class));assertNotNull(h.returnFor(float.class));assertNotNull(h.returnFor(double.class));}
@Test public void should_default_values_for_primitive(){assertThat(h.returnFor(boolean.class)).isFalse();assertThat(h.returnFor(char.class)).isEqualTo('\u0000');assertThat(h.returnFor(byte.class)).isEqualTo((byte)0);assertThat(h.returnFor(short.class)).isEqualTo((short)0);assertThat(h.returnFor(int.class)).isEqualTo(0);assertThat(h.returnFor(long.class)).isEqualTo(0L);assertThat(h.returnFor(float.class)).isEqualTo(0.0F);assertThat(h.returnFor(double.class)).isEqualTo(0.0D);}
@Test public void should_return_null_for_everything_else()throws Exception {assertNull(h.returnFor(Object.class));assertNull(h.returnFor(String.class));assertNull(h.returnFor(null));}
@Test public void should_return_handy_value_for_instances()throws Exception {assertNull(h.returnFor(new Object()));assertNull(h.returnFor((Object)null));assertNotNull(h.returnFor(10.0));assertNotNull(h.returnFor(Boolean.FALSE));}
@Test public void spyInAction(){}
@Test public void partialMockInAction(){}
@Ignore("stubbing from multiple threads is not supported")@Test public void shouldStubFineConcurrently()throws Exception {for (int i=0;i < 100;i++){performTest();}}
@Test public void shouldVerifyAtMostXTimes()throws Exception {mock.clear();mock.clear();verify(mock,atMost(2)).clear();verify(mock,atMost(3)).clear();try {verify(mock,atMost(1)).clear();fail();}catch(MockitoAssertionError e){}}
@Test public void shouldWorkWithArgumentMatchers()throws Exception {mock.add("one");verify(mock,atMost(5)).add(anyString());try {verify(mock,atMost(0)).add(anyString());fail();}catch(MockitoAssertionError e){}}
@Test public void shouldNotAllowNegativeNumber()throws Exception {try {verify(mock,atMost(-1)).clear();fail();}catch(MockitoException e){assertEquals("Negative value is not allowed here",e.getMessage());}}
@Test public void shouldPrintDecentMessage()throws Exception {mock.clear();mock.clear();try {verify(mock,atMost(1)).clear();fail();}catch(MockitoAssertionError e){assertEquals("\nWanted at most 1 time but was 2",e.getMessage());}}
@Test public void shouldNotAllowInOrderMode()throws Exception {mock.clear();InOrder inOrder=inOrder(mock);try {inOrder.verify(mock,atMost(1)).clear();fail();}catch(MockitoException e){assertEquals("AtMost is not implemented to work with InOrder",e.getMessage());}}
@Test public void shouldMarkInteractionsAsVerified()throws Exception {mock.clear();mock.clear();verify(mock,atMost(3)).clear();verifyNoMoreInteractions(mock);}
@Test public void shouldDetectUnverifiedInMarkInteractionsAsVerified()throws Exception {mock.clear();mock.clear();undesiredInteraction();verify(mock,atMost(3)).clear();try {verifyNoMoreInteractions(mock);fail();}catch(NoInteractionsWanted e){assertContains("undesiredInteraction(",e.getMessage());}}
@Test public void shouldGetPluralizedNumber(){new Pluralizer();assertEquals("0 times",Pluralizer.pluralize(0));assertEquals("1 time",Pluralizer.pluralize(1));assertEquals("2 times",Pluralizer.pluralize(2));assertEquals("20 times",Pluralizer.pluralize(20));}
@Test public void testInjectMocks()throws Exception {assertNotNull("Mock created",injected);assertNotNull("Object created",injectInto);assertEquals("A injected into B",injected,injectInto.getInjected());}
@Test public void shouldFindActualInvocations()throws Exception {List<Invocation> actual=finder.findInvocations(invocations,new InvocationMatcher(simpleMethodInvocation));assertThat(actual,hasExactlyInOrder(simpleMethodInvocation,simpleMethodInvocationTwo));actual=finder.findInvocations(invocations,new InvocationMatcher(differentMethodInvocation));assertThat(actual,hasExactlyInOrder(differentMethodInvocation));}
@Test public void shouldFindFirstUnverifiedInvocation()throws Exception {assertSame(simpleMethodInvocation,finder.findFirstUnverified(invocations));simpleMethodInvocationTwo.markVerified();simpleMethodInvocation.markVerified();assertSame(differentMethodInvocation,finder.findFirstUnverified(invocations));differentMethodInvocation.markVerified();assertNull(finder.findFirstUnverified(invocations));}
@Test public void shouldFindFirstUnverifiedInOrder()throws Exception {InOrderContextImpl context=new InOrderContextImpl();assertSame(simpleMethodInvocation,finder.findFirstUnverifiedInOrder(context,invocations));context.markVerified(simpleMethodInvocationTwo);context.markVerified(simpleMethodInvocation);assertSame(differentMethodInvocation,finder.findFirstUnverifiedInOrder(context,invocations));context.markVerified(differentMethodInvocation);assertNull(finder.findFirstUnverifiedInOrder(context,invocations));}
@Test public void shouldFindFirstUnverifiedInOrderAndRespectSequenceNumber()throws Exception {InOrderContextImpl context=new InOrderContextImpl();assertSame(simpleMethodInvocation,finder.findFirstUnverifiedInOrder(context,invocations));context.markVerified(simpleMethodInvocationTwo);context.markVerified(differentMethodInvocation);assertSame(null,finder.findFirstUnverifiedInOrder(context,invocations));}
@Test public void shouldFindFirstUnverifiedInvocationOnMock()throws Exception {assertSame(simpleMethodInvocation,finder.findFirstUnverified(invocations,simpleMethodInvocation.getMock()));assertNull(finder.findFirstUnverified(invocations,"different mock"));}
@Test public void shouldFindFirstSimilarInvocationByName()throws Exception {Invocation overloadedSimpleMethod=new InvocationBuilder().mock(mock).simpleMethod().arg("test").toInvocation();Invocation found=finder.findSimilarInvocation(invocations,new InvocationMatcher(overloadedSimpleMethod));assertSame(found,simpleMethodInvocation);}
@Test public void shouldFindInvocationWithTheSameMethod()throws Exception {Invocation overloadedDifferentMethod=new InvocationBuilder().differentMethod().arg("test").toInvocation();invocations.add(overloadedDifferentMethod);Invocation found=finder.findSimilarInvocation(invocations,new InvocationMatcher(overloadedDifferentMethod));assertSame(found,overloadedDifferentMethod);}
@Test public void shouldGetLastStackTrace()throws Exception {Location last=finder.getLastLocation(invocations);assertSame(differentMethodInvocation.getLocation(),last);assertNull(finder.getLastLocation(Collections.<Invocation>emptyList()));}
@Test public void shouldFindAllMatchingUnverifiedChunks()throws Exception {List<Invocation> allMatching=finder.findAllMatchingUnverifiedChunks(invocations,new InvocationMatcher(simpleMethodInvocation),context);assertThat(allMatching,hasExactlyInOrder(simpleMethodInvocation,simpleMethodInvocationTwo));context.markVerified(simpleMethodInvocation);allMatching=finder.findAllMatchingUnverifiedChunks(invocations,new InvocationMatcher(simpleMethodInvocation),context);assertThat(allMatching,hasExactlyInOrder(simpleMethodInvocationTwo));context.markVerified(simpleMethodInvocationTwo);allMatching=finder.findAllMatchingUnverifiedChunks(invocations,new InvocationMatcher(simpleMethodInvocation),context);assertTrue(allMatching.isEmpty());}
@Test public void shouldFindMatchingChunk()throws Exception {List<Invocation> chunk=finder.findMatchingChunk(invocations,new InvocationMatcher(simpleMethodInvocation),2,context);assertThat(chunk,hasExactlyInOrder(simpleMethodInvocation,simpleMethodInvocationTwo));}
@Test public void shouldReturnAllChunksWhenModeIsAtLeastOnce()throws Exception {Invocation simpleMethodInvocationThree=new InvocationBuilder().mock(mock).toInvocation();invocations.add(simpleMethodInvocationThree);List<Invocation> chunk=finder.findMatchingChunk(invocations,new InvocationMatcher(simpleMethodInvocation),1,context);assertThat(chunk,hasExactlyInOrder(simpleMethodInvocation,simpleMethodInvocationTwo,simpleMethodInvocationThree));}
@Test public void shouldReturnAllChunksWhenWantedCountDoesntMatch()throws Exception {Invocation simpleMethodInvocationThree=new InvocationBuilder().mock(mock).toInvocation();invocations.add(simpleMethodInvocationThree);List<Invocation> chunk=finder.findMatchingChunk(invocations,new InvocationMatcher(simpleMethodInvocation),1,context);assertThat(chunk,hasExactlyInOrder(simpleMethodInvocation,simpleMethodInvocationTwo,simpleMethodInvocationThree));}
@Test public void shouldFindPreviousInOrder()throws Exception {Invocation previous=finder.findPreviousVerifiedInOrder(invocations,context);assertNull(previous);context.markVerified(simpleMethodInvocation);context.markVerified(simpleMethodInvocationTwo);previous=finder.findPreviousVerifiedInOrder(invocations,context);assertSame(simpleMethodInvocationTwo,previous);}
@Test public void shouldSuccessfullyVerifyConcurrentInvocationsWithTimeout()throws Exception {int potentialOverhead=1000;int expectedMaxTestLength=TIMES * INTERVAL_MILLIS + potentialOverhead;reset(target);startInvocations();verify(target,timeout(expectedMaxTestLength).times(TIMES * nThreads)).targetMethod("arg");verifyNoMoreInteractions(target);}
@Test public void should_validate_null_throwable()throws Throwable {try {validator.validate(new ThrowsException(null),new InvocationBuilder().toInvocation());fail();}catch(MockitoException e){}}
@Test public void should_pass_proper_checked_exception()throws Throwable {validator.validate(new ThrowsException(new CharacterCodingException()),invocation);}
@Test(expected=MockitoException.class)public void should_fail_invalid_checked_exception()throws Throwable {validator.validate(new ThrowsException(new IOException()),invocation);}
@Test public void should_pass_RuntimeExceptions()throws Throwable {validator.validate(new ThrowsException(new Error()),invocation);validator.validate(new ThrowsException(new RuntimeException()),invocation);}
@Test(expected=MockitoException.class)public void should_fail_when_return_Value_is_set_for_void_method()throws Throwable {validator.validate(new Returns("one"),new InvocationBuilder().method("voidMethod").toInvocation());}
@Test(expected=MockitoException.class)public void should_fail_when_non_void_method_does_nothing()throws Throwable {validator.validate(new DoesNothing(),new InvocationBuilder().simpleMethod().toInvocation());}
@Test public void should_allow_void_return_for_void_method()throws Throwable {validator.validate(new DoesNothing(),new InvocationBuilder().method("voidMethod").toInvocation());}
@Test public void should_allow_correct_type_of_return_value()throws Throwable {validator.validate(new Returns("one"),new InvocationBuilder().simpleMethod().toInvocation());validator.validate(new Returns(false),new InvocationBuilder().method("booleanReturningMethod").toInvocation());validator.validate(new Returns(Boolean.TRUE),new InvocationBuilder().method("booleanObjectReturningMethod").toInvocation());validator.validate(new Returns(1),new InvocationBuilder().method("integerReturningMethod").toInvocation());validator.validate(new Returns(1L),new InvocationBuilder().method("longReturningMethod").toInvocation());validator.validate(new Returns(1L),new InvocationBuilder().method("longObjectReturningMethod").toInvocation());validator.validate(new Returns(null),new InvocationBuilder().method("objectReturningMethodNoArgs").toInvocation());validator.validate(new Returns(1),new InvocationBuilder().method("objectReturningMethodNoArgs").toInvocation());}
@Test(expected=MockitoException.class)public void should_fail_on_return_type_mismatch()throws Throwable {validator.validate(new Returns("String"),new InvocationBuilder().method("booleanReturningMethod").toInvocation());}
@Test(expected=MockitoException.class)public void should_fail_on_wrong_primitive()throws Throwable {validator.validate(new Returns(1),new InvocationBuilder().method("doubleReturningMethod").toInvocation());}
@Test(expected=MockitoException.class)public void should_fail_on_null_with_primitive()throws Throwable {validator.validate(new Returns(null),new InvocationBuilder().method("booleanReturningMethod").toInvocation());}
@Test public void should_fail_when_calling_real_method_on_interface()throws Throwable {Invocation invocationOnInterface=new InvocationBuilder().method("simpleMethod").toInvocation();try {validator.validate(new CallsRealMethods(),invocationOnInterface);fail();}catch(MockitoException e){}}
@Test public void should_be_OK_when_calling_real_method_on_concrete_class()throws Throwable {ArrayList mock=mock(ArrayList.class);mock.clear();Invocation invocationOnClass=new MockitoCore().getLastInvocation();validator.validate(new CallsRealMethods(),invocationOnClass);}
@Test public void should_allow_possible_argument_types()throws Exception {validator.validate(new ReturnsArgumentAt(0),new InvocationBuilder().method("intArgumentReturningInt").argTypes(int.class).arg(1000).toInvocation());validator.validate(new ReturnsArgumentAt(0),new InvocationBuilder().method("toString").argTypes(String.class).arg("whatever").toInvocation());validator.validate(new ReturnsArgumentAt(2),new InvocationBuilder().method("varargsObject").argTypes(int.class,Object[].class).args(1000,"Object","Object").toInvocation());validator.validate(new ReturnsArgumentAt(1),new InvocationBuilder().method("threeArgumentMethod").argTypes(int.class,Object.class,String.class).args(1000,"Object","String").toInvocation());}
@Test public void should_fail_if_index_is_not_in_range_for_one_arg_invocation()throws Throwable {try {validator.validate(new ReturnsArgumentAt(30),new InvocationBuilder().method("oneArg").arg("A").toInvocation());fail();}catch(MockitoException e){assertThat(e.getMessage()).containsIgnoringCase("invalid argument index").containsIgnoringCase("iMethods.oneArg").containsIgnoringCase("[0]String").containsIgnoringCase("position").contains("30");}}
@Test public void should_fail_if_index_is_not_in_range_for_example_with_no_arg_invocation()throws Throwable {try {validator.validate(new ReturnsArgumentAt(ReturnsArgumentAt.LAST_ARGUMENT),new InvocationBuilder().simpleMethod().toInvocation());fail();}catch(MockitoException e){assertThat(e.getMessage()).containsIgnoringCase("invalid argument index").containsIgnoringCase("iMethods.simpleMethod").containsIgnoringCase("no arguments").containsIgnoringCase("last parameter wanted");}}
@Test public void should_fail_if_argument_type_of_signature_is_incompatible_with_return_type()throws Throwable {try {validator.validate(new ReturnsArgumentAt(2),new InvocationBuilder().method("varargsReturningString").argTypes(Object[].class).args("anyString",new Object(),"anyString").toInvocation());fail();}catch(WrongTypeOfReturnValue e){assertThat(e.getMessage()).containsIgnoringCase("argument of type").containsIgnoringCase("Object").containsIgnoringCase("varargsReturningString").containsIgnoringCase("should return").containsIgnoringCase("String").containsIgnoringCase("possible argument indexes");}}
@Test public void shouldNotThrowNPE(){Foo f=mock(Foo.class);f.bar(1);verify(f).bar(any(Long.class));}
@Test public void shouldCreateMockWhenConstructorIsPrivate(){assertNotNull(Mockito.mock(HasPrivateConstructor.class));}
@Test public void shouldCombineMockNameAndSmartNulls(){IMethods mock=mock(IMethods.class,withSettings().defaultAnswer(RETURNS_SMART_NULLS).name("great mockie"));IMethods smartNull=mock.iMethodsReturningMethod();String name=mock.toString();assertContains("great mockie",name);try {smartNull.simpleMethod();fail();}catch(SmartNullPointerException e){}}
@Test public void shouldCombineMockNameAndExtraInterfaces(){}
@Test public void shouldSpecifyMockNameViaSettings(){IMethods mock=mock(IMethods.class,withSettings().name("great mockie"));String name=mock.toString();assertContains("great mockie",name);}
@Test public void shouldScreamWhenSpyCreatedWithWrongType(){List list=new LinkedList();try {mock(List.class,withSettings().spiedInstance(list));fail();}catch(MockitoException e){}}
@Test public void shouldAllowCreatingSpiesWithCorrectType(){List list=new LinkedList();mock(LinkedList.class,withSettings().spiedInstance(list));}
@Test public void shouldAllowInlineMockCreation()throws Exception {when(mock(Set.class).isEmpty()).thenReturn(false);}
@Test public void should_notify_all_listeners_when_calling_delegate_handler()throws Throwable {given(mockHandler.handle(invocation)).willReturn("returned value");notifier.handle(invocation);verify(listener1).reportInvocation(new NotifiedMethodInvocationReport(invocation,"returned value"));verify(listener2).reportInvocation(new NotifiedMethodInvocationReport(invocation,"returned value"));}
@Test public void should_notify_all_listeners_when_called_delegate_handler_returns_ex()throws Throwable {Exception computedException=new Exception("computed");given(mockHandler.handle(invocation)).willReturn(computedException);notifier.handle(invocation);verify(listener1).reportInvocation(new NotifiedMethodInvocationReport(invocation,(Object)computedException));verify(listener2).reportInvocation(new NotifiedMethodInvocationReport(invocation,(Object)computedException));}
@Test(expected=ParseException.class)public void should_notify_all_listeners_when_called_delegate_handler_throws_exception_and_rethrow_it()throws Throwable {ParseException parseException=new ParseException("",0);given(mockHandler.handle(invocation)).willThrow(parseException);try {notifier.handle(invocation);fail();}finally {verify(listener1).reportInvocation(new NotifiedMethodInvocationReport(invocation,parseException));verify(listener2).reportInvocation(new NotifiedMethodInvocationReport(invocation,parseException));}}
@Test public void should_report_listener_exception()throws Throwable {willThrow(new NullPointerException()).given(customListener).reportInvocation(any(MethodInvocationReport.class));try {notifier.handle(invocation);fail();}catch(MockitoException me){assertThat(me.getMessage()).contains("invocation listener").contains("CustomListener").contains("threw an exception").contains("NullPointerException");}}
@Test public void should_delegate_all_MockHandlerInterface_to_the_parameterized_MockHandler()throws Exception {notifier.getInvocationContainer();notifier.getMockSettings();notifier.voidMethodStubbable(mock(IMethods.class));notifier.setAnswersForStubbing(new ArrayList<Answer>());verify(mockHandler).getInvocationContainer();verify(mockHandler).getMockSettings();verify(mockHandler).voidMethodStubbable(any());verify(mockHandler).setAnswersForStubbing(anyList());}
@Test public void ensure_the_test_runner_breaks()throws Exception {JUnitCore runner=new JUnitCore();runner.addListener(new TextListener(System.out));Result result=runner.run(TestClassWithoutTestMethod.class);assertEquals(1,result.getFailureCount());assertFalse(result.wasSuccessful());}
@Test public void should_allow_throws_exception_to_be_serializable()throws Exception {when(barMock.doSomething()).thenAnswer(new ThrowsException(new RuntimeException()));serializeAndBack(barMock);}
@Test public void should_allow_mock_to_be_serializable()throws Exception {serializeAndBack(imethodsMock);}
@Test public void should_allow_mock_and_boolean_value_to_serializable()throws Exception {when(imethodsMock.booleanReturningMethod()).thenReturn(true);ByteArrayOutputStream serialized=serializeMock(imethodsMock);IMethods readObject=deserializeMock(serialized,IMethods.class);assertTrue(readObject.booleanReturningMethod());}
@Test public void should_allow_mock_and_string_value_to_be_serializable()throws Exception {String value="value";when(imethodsMock.stringReturningMethod()).thenReturn(value);ByteArrayOutputStream serialized=serializeMock(imethodsMock);IMethods readObject=deserializeMock(serialized,IMethods.class);assertEquals(value,readObject.stringReturningMethod());}
@Test public void should_all_mock_and_serializable_value_to_be_serialized()throws Exception {List<?> value=Collections.emptyList();when(imethodsMock.objectReturningMethodNoArgs()).thenReturn(value);ByteArrayOutputStream serialized=serializeMock(imethodsMock);IMethods readObject=deserializeMock(serialized,IMethods.class);assertEquals(value,readObject.objectReturningMethodNoArgs());}
@Test public void should_serialize_method_call_with_parameters_that_are_serializable()throws Exception {List<?> value=Collections.emptyList();when(imethodsMock.objectArgMethod(value)).thenReturn(value);ByteArrayOutputStream serialized=serializeMock(imethodsMock);IMethods readObject=deserializeMock(serialized,IMethods.class);assertEquals(value,readObject.objectArgMethod(value));}
@Test public void should_serialize_method_calls_using_any_string_matcher()throws Exception {List<?> value=Collections.emptyList();when(imethodsMock.objectArgMethod(anyString())).thenReturn(value);ByteArrayOutputStream serialized=serializeMock(imethodsMock);IMethods readObject=deserializeMock(serialized,IMethods.class);assertEquals(value,readObject.objectArgMethod(""));}
@Test public void should_verify_called_n_times_for_serialized_mock()throws Exception {List<?> value=Collections.emptyList();when(imethodsMock.objectArgMethod(anyString())).thenReturn(value);imethodsMock.objectArgMethod("");ByteArrayOutputStream serialized=serializeMock(imethodsMock);IMethods readObject=deserializeMock(serialized,IMethods.class);verify(readObject,times(1)).objectArgMethod("");}
@Test public void should_verify_even_if_some_methods_called_after_serialization()throws Exception {imethodsMock.simpleMethod(1);ByteArrayOutputStream serialized=serializeMock(imethodsMock);IMethods readObject=deserializeMock(serialized,IMethods.class);readObject.simpleMethod(1);verify(readObject,times(2)).simpleMethod(1);}
@Test public void should_serialization_work(){}
@Test public void should_stub_even_if_some_methods_called_after_serialization()throws Exception {when(imethodsMock.simpleMethod(1)).thenReturn("foo");ByteArrayOutputStream serialized=serializeMock(imethodsMock);IMethods readObject=deserializeMock(serialized,IMethods.class);when(readObject.simpleMethod(2)).thenReturn("bar");assertEquals("foo",readObject.simpleMethod(1));assertEquals("bar",readObject.simpleMethod(2));}
@Test public void should_verify_call_order_for_serialized_mock()throws Exception {imethodsMock.arrayReturningMethod();imethodsMock2.arrayReturningMethod();ByteArrayOutputStream serialized=serializeMock(imethodsMock);ByteArrayOutputStream serialized2=serializeMock(imethodsMock2);IMethods readObject=deserializeMock(serialized,IMethods.class);IMethods readObject2=deserializeMock(serialized2,IMethods.class);InOrder inOrder=inOrder(readObject,readObject2);inOrder.verify(readObject).arrayReturningMethod();inOrder.verify(readObject2).arrayReturningMethod();}
@Test public void should_remember_interactions_for_serialized_mock()throws Exception {List<?> value=Collections.emptyList();when(imethodsMock.objectArgMethod(anyString())).thenReturn(value);imethodsMock.objectArgMethod("happened");ByteArrayOutputStream serialized=serializeMock(imethodsMock);IMethods readObject=deserializeMock(serialized,IMethods.class);verify(readObject,never()).objectArgMethod("never happened");}
@Test public void should_serialize_with_stubbing_callback()throws Exception {CustomAnswersMustImplementSerializableForSerializationToWork answer=new CustomAnswersMustImplementSerializableForSerializationToWork();answer.string="return value";when(imethodsMock.objectArgMethod(anyString())).thenAnswer(answer);ByteArrayOutputStream serialized=serializeMock(imethodsMock);IMethods readObject=deserializeMock(serialized,IMethods.class);assertEquals(answer.string,readObject.objectArgMethod(""));}
@Test public void should_serialize_with_real_object_spy()throws Exception {List<Object> list=new ArrayList<Object>();List<Object> spy=mock(ArrayList.class,withSettings().spiedInstance(list).defaultAnswer(CALLS_REAL_METHODS).serializable());when(spy.size()).thenReturn(100);ByteArrayOutputStream serialized=serializeMock(spy);List<?> readObject=deserializeMock(serialized,List.class);assertEquals(100,readObject.size());}
@Test public void should_serialize_object_mock(){}
@Test public void should_serialize_real_partial_mock(){}
@Test public void should_serialize_already_serializable_class()throws Exception {when(alreadySerializableMock.toString()).thenReturn("foo");alreadySerializableMock=serializeAndBack(alreadySerializableMock);assertEquals("foo",alreadySerializableMock.toString());}
@Test public void should_be_serialize_and_have_extra_interfaces()throws Exception {Assertions.assertThat((Object)serializeAndBack((List)imethodsWithExtraInterfacesMock)).isInstanceOf(List.class).isInstanceOf(IMethods.class);}
@Test public void should_fail_when_serializable_used_with_type_that_dont_implements_Serializable_and_dont_declare_a_no_arg_constructor()throws Exception {try {FailTestClass testClass=new FailTestClass();MockitoAnnotations.initMocks(testClass);serializeAndBack(testClass.notSerializableAndNoDefaultConstructor);fail("should have thrown an exception to say the object is not serializable");}catch(MockitoException e){Assertions.assertThat(e.getMessage()).contains(NotSerializableAndNoDefaultConstructor.class.getSimpleName()).contains("serializable()").contains("implement Serializable").contains("no-arg constructor");}}
@Test public void should_be_able_to_serialize_type_that_implements_Serializable_but_but_dont_declare_a_no_arg_constructor()throws Exception {TestClassThatHoldValidField testClass=new TestClassThatHoldValidField();MockitoAnnotations.initMocks(testClass);serializeAndBack(testClass.serializableAndNoDefaultConstructor);}
@Test public void equals_should_return_false_when_not_equal()throws Exception {DelegatingMethod notEqual=new DelegatingMethod(otherMethod);assertFalse(delegatingMethod.equals(notEqual));}
@Test public void equals_should_return_true_when_equal()throws Exception {DelegatingMethod equal=new DelegatingMethod(someMethod);assertTrue(delegatingMethod.equals(equal));}
@Test public void equals_should_return_true_when_self()throws Exception {assertTrue(delegatingMethod.equals(delegatingMethod));}
@Test public void equals_should_return_false_when_not_equal_to_method()throws Exception {assertFalse(delegatingMethod.equals(otherMethod));}
@Test public void equals_should_return_true_when_equal_to_method()throws Exception {assertTrue(delegatingMethod.equals(someMethod));}
@Test public void testEqualsWithDelta_NullExpected()throws Exception {Matcher<Number> matcher=equalsWithDelta(null);assertThat(matcher.matches(1.0)).isFalse();}
@Test public void testEqualsWithDelta_NullActual()throws Exception {Matcher<Number> matcher=equalsWithDelta(1.0);assertThat(matcher.matches(null)).isFalse();}
@Test public void testEqualsWithDelta_NullActualAndExpected()throws Exception {Matcher<Number> matcher=equalsWithDelta(null);assertThat(matcher.matches(null)).isTrue();}
@Test public void testEqualsWithDelta_WhenActualAndExpectedAreTheSameObject()throws Exception {Double expected=1.0;Double actual=expected;Matcher<Number> matcher=equalsWithDelta(expected);assertThat(matcher.matches(actual)).isTrue();}
@Test public void shouldCreateMockFromInterface()throws Exception {SomeInterface proxy=imposterizer.imposterise(new MethodInterceptorStub(),SomeInterface.class);Class superClass=proxy.getClass().getSuperclass();assertEquals(Object.class,superClass);}
@Test public void shouldCreateMockFromClass()throws Exception {ClassWithoutConstructor proxy=imposterizer.imposterise(new MethodInterceptorStub(),ClassWithoutConstructor.class);Class superClass=proxy.getClass().getSuperclass();assertEquals(ClassWithoutConstructor.class,superClass);}
@Test public void shouldCreateMockFromClassEvenWhenConstructorIsDodgy()throws Exception {try {new ClassWithDodgyConstructor();fail();}catch(Exception e){}ClassWithDodgyConstructor mock=imposterizer.imposterise(new MethodInterceptorStub(),ClassWithDodgyConstructor.class);assertNotNull(mock);}
@Test public void shouldMocksHaveDifferentInterceptors()throws Exception {SomeClass mockOne=imposterizer.imposterise(new MethodInterceptorStub(),SomeClass.class);SomeClass mockTwo=imposterizer.imposterise(new MethodInterceptorStub(),SomeClass.class);Factory cglibFactoryOne=(Factory)mockOne;Factory cglibFactoryTwo=(Factory)mockTwo;assertNotSame(cglibFactoryOne.getCallback(0),cglibFactoryTwo.getCallback(0));}
@Test public void shouldUseAnicilliaryTypes(){}
@Test public void shouldCreateClassByConstructor(){imposterizer=new ClassImposterizer(new ConstructorInstantiator(null));OtherClass mock=imposterizer.imposterise(new MethodInterceptorStub(),OtherClass.class);assertNotNull(mock);}
@Test public void shouldInjectWithInvalidReference()throws Exception {assertNotNull("Mock created",injected);assertNotNull("Test object created",injectInto);}
@Test public void testInjectMocks()throws Exception {assertNotNull("Mock created",injected);assertNotNull("Object created",injectInto);assertEquals("A injected into B",injected,injectInto.getInjected());}
@Test public void can_create_mock_with_constructor(){Message mock=mock(Message.class,withSettings().useConstructor().defaultAnswer(CALLS_REAL_METHODS));assertEquals("hey!",mock.getMessage());}
@Test public void can_mock_abstract_classes(){AbstractMessage mock=mock(AbstractMessage.class,withSettings().useConstructor().defaultAnswer(CALLS_REAL_METHODS));assertEquals("hey!",mock.getMessage());}
@Test public void can_spy_abstract_classes(){AbstractMessage mock=spy(AbstractMessage.class);assertEquals("hey!",mock.getMessage());}
@Test public void can_mock_inner_classes(){InnerClass mock=mock(InnerClass.class,withSettings().useConstructor().outerInstance(this).defaultAnswer(CALLS_REAL_METHODS));assertEquals("hey!",mock.getMessage());}
@Test public void exception_message_when_constructor_not_found(){try {spy(HasConstructor.class);fail();}catch(MockitoException e){assertEquals("Unable to create mock instance of type 'HasConstructor'",e.getMessage());assertContains("0-arg constructor",e.getCause().getMessage());}}
@Test public void mocking_inner_classes_with_wrong_outer_instance(){try {mock(InnerClass.class,withSettings().useConstructor().outerInstance("foo").defaultAnswer(CALLS_REAL_METHODS));fail();}catch(MockitoException e){assertEquals("Unable to create mock instance of type 'InnerClass'",e.getMessage());assertContains("Please ensure that the outer instance has correct type and that the target class has 0-arg constructor.",e.getCause().getMessage());}}
@Test public void mocking_interfaces_with_constructor(){mock(IMethods.class,withSettings().useConstructor());spy(IMethods.class);}
@Test public void prevents_across_jvm_serialization_with_constructor(){try {mock(AbstractMessage.class,withSettings().useConstructor().serializable(SerializableMode.ACROSS_CLASSLOADERS));fail();}catch(MockitoException e){assertEquals("Mocks instantiated with constructor cannot be combined with " + SerializableMode.ACROSS_CLASSLOADERS + " serialization mode.",e.getMessage());}}
@Test public void abstractMethodReturnsDefault(){AbstractThing thing=spy(AbstractThing.class);assertEquals("abstract null",thing.fullName());}
@Test public void abstractMethodStubbed(){AbstractThing thing=spy(AbstractThing.class);when(thing.name()).thenReturn("me");assertEquals("abstract me",thing.fullName());}
@Test public void testCallsRealInterfaceMethod(){List<String> list=mock(List.class,withSettings().defaultAnswer(CALLS_REAL_METHODS));assertNull(list.get(1));}
@Test public void shouldVerifyMethodWasInvokedExclusively(){mock.clear();verify(mock,only()).clear();}
@Test public void shouldVerifyMethodWasInvokedExclusivelyWithMatchersUsage(){mock.get(0);verify(mock,only()).get(anyInt());}
@Test public void shouldFailIfMethodWasNotInvoked(){mock.clear();try {verify(mock,only()).get(0);fail();}catch(WantedButNotInvoked e){}}
@Test public void shouldFailIfMethodWasInvokedMoreThanOnce(){mock.clear();mock.clear();try {verify(mock,only()).clear();fail();}catch(NoInteractionsWanted e){}}
@Test public void shouldFailIfMethodWasInvokedButWithDifferentArguments(){mock.get(0);mock.get(2);try {verify(mock,only()).get(999);fail();}catch(WantedButNotInvoked e){}}
@Test public void shouldFailIfExtraMethodWithDifferentArgsFound(){mock.get(0);mock.get(2);try {verify(mock,only()).get(2);fail();}catch(NoInteractionsWanted e){}}
@Test public void shouldVerifyMethodWasInvokedExclusivelyWhenTwoMocksInUse(){mock.clear();mock2.get(0);verify(mock,only()).clear();verify(mock2,only()).get(0);}
@Test public void should_return_the_usual_default_values_for_primitives()throws Throwable {Answer<Object> answer=new ReturnsSmartNulls();assertEquals(false,answer.answer(invocationOf(HasPrimitiveMethods.class,"booleanMethod")));assertEquals((char)0,answer.answer(invocationOf(HasPrimitiveMethods.class,"charMethod")));assertEquals((byte)0,answer.answer(invocationOf(HasPrimitiveMethods.class,"byteMethod")));assertEquals((short)0,answer.answer(invocationOf(HasPrimitiveMethods.class,"shortMethod")));assertEquals(0,answer.answer(invocationOf(HasPrimitiveMethods.class,"intMethod")));assertEquals(0L,answer.answer(invocationOf(HasPrimitiveMethods.class,"longMethod")));assertEquals(0f,answer.answer(invocationOf(HasPrimitiveMethods.class,"floatMethod")));assertEquals(0d,answer.answer(invocationOf(HasPrimitiveMethods.class,"doubleMethod")));}
@Test public void should_return_an_object_that_fails_on_any_method_invocation_for_non_primitives()throws Throwable {Answer<Object> answer=new ReturnsSmartNulls();Foo smartNull=(Foo)answer.answer(invocationOf(Foo.class,"get"));try {smartNull.get();fail();}catch(SmartNullPointerException expected){}}
@Test public void should_return_an_object_that_allows_object_methods()throws Throwable {Answer<Object> answer=new ReturnsSmartNulls();Foo smartNull=(Foo)answer.answer(invocationOf(Foo.class,"get"));assertContains("SmartNull returned by",smartNull + "");assertContains("foo.get()",smartNull + "");}
@Test public void should_print_the_parameters_when_calling_a_method_with_args()throws Throwable {Answer<Object> answer=new ReturnsSmartNulls();Foo smartNull=(Foo)answer.answer(invocationOf(Foo.class,"withArgs","oompa","lumpa"));assertContains("foo.withArgs",smartNull + "");assertContains("oompa",smartNull + "");assertContains("lumpa",smartNull + "");}
@Test public void should_print_the_parameters_on_SmartNullPointerException_message()throws Throwable {Answer<Object> answer=new ReturnsSmartNulls();Foo smartNull=(Foo)answer.answer(invocationOf(Foo.class,"withArgs","oompa","lumpa"));try {smartNull.get();fail();}catch(SmartNullPointerException e){assertContains("oompa",e.getMessage());assertContains("lumpa",e.getMessage());}}
@Test public void shouldKnowIfObjectsAreEqual()throws Exception {int[]arr=new int[]{1,2};assertTrue(areEqual(arr,arr));assertTrue(areEqual(new int[]{1,2},new int[]{1,2}));assertTrue(areEqual(new Double[]{1.0},new Double[]{1.0}));assertTrue(areEqual(new String[0],new String[0]));assertTrue(areEqual(new Object[10],new Object[10]));assertTrue(areEqual(new int[]{1},new Integer[]{1}));assertTrue(areEqual(new Object[]{"1"},new String[]{"1"}));Object badequals=new BadEquals();assertTrue(areEqual(badequals,badequals));assertFalse(areEqual(new Object[9],new Object[10]));assertFalse(areEqual(new int[]{1,2},new int[]{1}));assertFalse(areEqual(new int[]{1},new double[]{1.0}));}
@Test public void shouldAllowCallingInternalMethod(){when(mock.getValue()).thenReturn("foo");when(mock.callInternalMethod()).thenCallRealMethod();assertEquals("foo",mock.callInternalMethod());}
@Test public void shouldReturnRealValue(){when(mock.getValue()).thenCallRealMethod();Assert.assertEquals("HARD_CODED_RETURN_VALUE",mock.getValue());}
@Test public void shouldExecuteRealMethod(){doCallRealMethod().when(mock).setValue(anyString());mock.setValue("REAL_VALUE");Assert.assertEquals("REAL_VALUE",mock.value);}
@Test public void shouldCallRealMethodByDefault(){TestedObject mock=mock(TestedObject.class,CALLS_REAL_METHODS);Assert.assertEquals("HARD_CODED_RETURN_VALUE",mock.getValue());}
@Test public void shouldNotCallRealMethodWhenStubbedLater(){TestedObject mock=mock(TestedObject.class);when(mock.getValue()).thenCallRealMethod();when(mock.getValue()).thenReturn("FAKE_VALUE");Assert.assertEquals("FAKE_VALUE",mock.getValue());}
@Test public void shouldKnowToStringMethod()throws Exception {assertFalse(guru.isToString(Object.class.getMethod("equals",Object.class)));assertFalse(guru.isToString(IMethods.class.getMethod("toString",String.class)));assertTrue(guru.isToString(IMethods.class.getMethod("toString")));}
@Test public void shouldKnowEqualsMethod()throws Exception {assertFalse(guru.isEqualsMethod(IMethods.class.getMethod("equals",String.class)));assertFalse(guru.isEqualsMethod(IMethods.class.getMethod("equals")));assertFalse(guru.isEqualsMethod(Object.class.getMethod("toString")));assertTrue(guru.isEqualsMethod(Object.class.getMethod("equals",Object.class)));}
@Test public void shouldKnowHashCodeMethod()throws Exception {assertFalse(guru.isHashCodeMethod(IMethods.class.getMethod("toString")));assertFalse(guru.isHashCodeMethod(IMethods.class.getMethod("hashCode",String.class)));assertTrue(guru.isHashCodeMethod(Object.class.getDeclaredMethod("hashCode")));}
@Test public void shouldKnowCompareToMethod()throws Exception {assertFalse(guru.isCompareToMethod(Date.class.getMethod("toString")));assertFalse(guru.isCompareToMethod(HasCompare.class.getMethod("foo",HasCompare.class)));assertFalse(guru.isCompareToMethod(HasCompare.class.getMethod("compareTo",HasCompare.class,String.class)));assertFalse(guru.isCompareToMethod(HasCompare.class.getMethod("compareTo",String.class)));assertFalse(guru.isCompareToMethod(HasCompareToButDoesNotImplementComparable.class.getDeclaredMethod("compareTo",HasCompareToButDoesNotImplementComparable.class)));assertTrue(guru.isCompareToMethod(HasCompare.class.getMethod("compareTo",HasCompare.class)));}
@Test public void nestedWhenTest(){Strategy mfoo=mock(Strategy.class);Sampler mpoo=mock(Sampler.class);Producer out=spy(new Producer(mfoo));try {when(out.produce()).thenReturn(mpoo);fail();}catch(WrongTypeOfReturnValue e){assertThat(e.getMessage()).contains("spy").contains("syntax").contains("doReturn|Throw");}}
@Test public void shouldAllowVerifyingInThreads()throws Exception {for (int i=0;i < 50;i++){performTest();}}
@Test public void basicCheck(){Mockito.when((someSubInterface).factory()).thenReturn(extendedFactory);SomeInterface si=someSubInterface;assertTrue(si.factory()!= null);}
@Test public void checkWithExtraCast(){Mockito.when(((SomeInterface)someSubInterface).factory()).thenReturn(extendedFactory);SomeInterface si=someSubInterface;assertTrue(si.factory()!= null);}
@Test public void shouldMatchAnyVararg(){mock.run("a","b");verify(mock).run(anyString(),anyString());verify(mock).run((String)anyObject(),(String)anyObject());verify(mock).run((String[])anyVararg());verify(mock,never()).run();verify(mock,never()).run(anyString(),eq("f"));}
@Test public void shouldNotAllowUsingAnyObjectForVarArgs(){mock.run("a","b");try {verify(mock).run((String[])anyObject());fail();}catch(AssertionError e){}}
@Test public void shouldStubUsingAnyVarargs(){when(mock.run((String[])anyVararg())).thenReturn("foo");assertEquals("foo",mock.run("a","b"));}
@Test public void shouldKeepSameInstanceIfFieldInitialized(){assertSame(baseUnderTestingInstance,initializedBase);}
@Test public void shouldInitializeAnnotatedFieldIfNull(){assertNotNull(notInitializedBase);}
@Test public void shouldIInjectMocksInSpy(){assertNotNull(initializedSpy.getAList());assertTrue(mockUtil.isMock(initializedSpy));}
@Test public void shouldInitializeSpyIfNullAndInjectMocks(){assertNotNull(notInitializedSpy);assertNotNull(notInitializedSpy.getAList());assertTrue(mockUtil.isMock(notInitializedSpy));}
@Test public void shouldInjectMocksIfAnnotated(){MockitoAnnotations.initMocks(this);assertSame(list,superUnderTest.getAList());}
@Test public void shouldNotInjectIfNotAnnotated(){MockitoAnnotations.initMocks(this);assertNull(superUnderTestWithoutInjection.getAList());}
@Test public void shouldInjectMocksForClassHierarchyIfAnnotated(){MockitoAnnotations.initMocks(this);assertSame(list,baseUnderTest.getAList());assertSame(map,baseUnderTest.getAMap());}
@Test public void shouldInjectMocksByName(){MockitoAnnotations.initMocks(this);assertSame(histogram1,subUnderTest.getHistogram1());assertSame(histogram2,subUnderTest.getHistogram2());}
@Test public void shouldInjectSpies(){MockitoAnnotations.initMocks(this);assertSame(searchTree,otherBaseUnderTest.getSearchTree());}
@Test public void shouldInstantiateInjectMockFieldIfPossible()throws Exception {assertNotNull(notInitializedBase);}
@Test public void shouldKeepInstanceOnInjectMockFieldIfPresent()throws Exception {assertSame(baseUnderTestingInstance,initializedBase);}
@Test public void shouldReportNicely()throws Exception {Object failing=new Object(){@InjectMocks ThrowingConstructor failingConstructor;};try {MockitoAnnotations.initMocks(failing);fail();}catch(MockitoException e){Assertions.assertThat(e.getMessage()).contains("failingConstructor").contains("constructor").contains("threw an exception");Assertions.assertThat(e.getCause()).isInstanceOf(RuntimeException.class);}}
@Test public void shouldVerifyCorrectlyWithAnyVarargs(){table.newRow("qux","foo","bar","baz");table.newRow("abc","def");verify(table,times(2)).newRow(anyString(),(String[])anyVararg());}
@Test public void shouldVerifyCorrectlyNumberOfInvocationsUsingAnyVarargAndEqualArgument(){table.newRow("x","foo","bar","baz");table.newRow("x","def");verify(table,times(2)).newRow(eq("x"),(String[])anyVararg());}
@Test public void shouldVerifyCorrectlyNumberOfInvocationsWithVarargs(){table.newRow("qux","foo","bar","baz");table.newRow("abc","def");verify(table).newRow(anyString(),eq("foo"),anyString(),anyString());verify(table).newRow(anyString(),anyString());}
@Test public void shouldHelpOutWithUnnecessaryCasting(){when(mock.objectArgMethod(any(String.class))).thenReturn("string");assertEquals("string",mock.objectArgMethod("foo"));}
@Test public void shouldAnyBeActualAliasToAnyObject(){mock.simpleMethod((Object)null);verify(mock).simpleMethod(anyObject());verify(mock).simpleMethod(any(Object.class));}
@Test public void shouldHelpOutWithUnnecessaryCastingOfLists(){when(mock.listArgMethod(anyListOf(String.class))).thenReturn("list");assertEquals("list",mock.listArgMethod(new LinkedList<String>()));assertEquals("list",mock.listArgMethod(Collections.<String>emptyList()));}
@Test public void shouldHelpOutWithUnnecessaryCastingOfSets(){when(mock.setArgMethod(anySetOf(String.class))).thenReturn("set");assertEquals("set",mock.setArgMethod(new HashSet<String>()));assertEquals("set",mock.setArgMethod(Collections.<String>emptySet()));}
@Test public void shouldHelpOutWithUnnecessaryCastingOfMaps(){when(mock.forMap(anyMapOf(String.class,String.class))).thenReturn("map");assertEquals("map",mock.forMap(new HashMap<String,String>()));assertEquals("map",mock.forMap(Collections.<String,String>emptyMap()));}
@Test public void shouldHelpOutWithUnnecessaryCastingOfCollections(){when(mock.collectionArgMethod(anyCollectionOf(String.class))).thenReturn("col");assertEquals("col",mock.collectionArgMethod(new ArrayList<String>()));assertEquals("col",mock.collectionArgMethod(Collections.<String>emptyList()));}
@Test public void shouldHelpOutWithUnnecessaryCastingOfNullityChecks(){when(mock.objectArgMethod(isNull(LinkedList.class))).thenReturn("string");when(mock.objectArgMethod(notNull(LinkedList.class))).thenReturn("string");when(mock.objectArgMethod(isNotNull(LinkedList.class))).thenReturn("string");assertEquals("string",mock.objectArgMethod(null));assertEquals("string",mock.objectArgMethod("foo"));assertEquals("string",mock.objectArgMethod("foo"));}
@Test public void should_keep_same_instance_if_field_initialized()throws Exception {final StaticClass backupInstance=alreadyInstantiated;FieldInitializer fieldInitializer=new FieldInitializer(this,field("alreadyInstantiated"));FieldInitializationReport report=fieldInitializer.initialize();assertSame(backupInstance,report.fieldInstance());assertFalse(report.fieldWasInitialized());assertFalse(report.fieldWasInitializedUsingContructorArgs());}
@Test public void should_instantiate_field_when_type_has_no_constructor()throws Exception {FieldInitializer fieldInitializer=new FieldInitializer(this,field("noConstructor"));FieldInitializationReport report=fieldInitializer.initialize();assertNotNull(report.fieldInstance());assertTrue(report.fieldWasInitialized());assertFalse(report.fieldWasInitializedUsingContructorArgs());}
@Test public void should_instantiate_field_with_default_constructor()throws Exception {FieldInitializer fieldInitializer=new FieldInitializer(this,field("defaultConstructor"));FieldInitializationReport report=fieldInitializer.initialize();assertNotNull(report.fieldInstance());assertTrue(report.fieldWasInitialized());assertFalse(report.fieldWasInitializedUsingContructorArgs());}
@Test public void should_instantiate_field_with_private_default_constructor()throws Exception {FieldInitializer fieldInitializer=new FieldInitializer(this,field("privateDefaultConstructor"));FieldInitializationReport report=fieldInitializer.initialize();assertNotNull(report.fieldInstance());assertTrue(report.fieldWasInitialized());assertFalse(report.fieldWasInitializedUsingContructorArgs());}
@Test(expected=MockitoException.class)public void should_fail_to_instantiate_field_if_no_default_constructor()throws Exception {FieldInitializer fieldInitializer=new FieldInitializer(this,field("noDefaultConstructor"));fieldInitializer.initialize();}
@Test public void should_fail_to_instantiate_field_if_default_constructor_throws_exception()throws Exception {FieldInitializer fieldInitializer=new FieldInitializer(this,field("throwingExDefaultConstructor"));try {fieldInitializer.initialize();fail();}catch(MockitoException e){InvocationTargetException ite=(InvocationTargetException)e.getCause();assertTrue(ite.getTargetException()instanceof NullPointerException);assertEquals("business logic failed",ite.getTargetException().getMessage());}}
@Test(expected=MockitoException.class)public void should_fail_for_abstract_field()throws Exception {new FieldInitializer(this,field("abstractType"));}
@Test public void should_not_fail_if_abstract_field_is_instantiated()throws Exception {new FieldInitializer(this,field("instantiatedAbstractType"));}
@Test(expected=MockitoException.class)public void should_fail_for_interface_field()throws Exception {new FieldInitializer(this,field("interfaceType"));}
@Test public void should_not_fail_if_interface_field_is_instantiated()throws Exception {new FieldInitializer(this,field("instantiatedInterfaceType"));}
@Test(expected=MockitoException.class)public void should_fail_for_local_type_field()throws Exception {class LocalType {}class TheTestWithLocalType {@InjectMocks LocalType field;}TheTestWithLocalType testWithLocalType=new TheTestWithLocalType();new FieldInitializer(testWithLocalType,testWithLocalType.getClass().getDeclaredField("field"));}
@Test public void should_not_fail_if_local_type_field_is_instantiated()throws Exception {class LocalType {}class TheTestWithLocalType {@InjectMocks LocalType field=new LocalType();}TheTestWithLocalType testWithLocalType=new TheTestWithLocalType();new FieldInitializer(testWithLocalType,testWithLocalType.getClass().getDeclaredField("field"));}
@Test(expected=MockitoException.class)public void should_fail_for_inner_class_field()throws Exception {new FieldInitializer(this,field("innerClassType"));}
@Test public void should_not_fail_if_inner_class_field_is_instantiated()throws Exception {new FieldInitializer(this,field("instantiatedInnerClassType"));}
@Test public void can_instantiate_class_with_parameterized_constructor()throws Exception {ConstructorArgumentResolver resolver=given(mock(ConstructorArgumentResolver.class).resolveTypeInstances(any(Class[].class))).willReturn(new Object[]{null}).getMock();new FieldInitializer(this,field("noDefaultConstructor"),resolver).initialize();assertNotNull(noDefaultConstructor);}
@Test public void dont_fail_with_CONSTANTS()throws Exception {}
@Test public void dont_inject_in_final(){assertNotSame(unrelatedSet,exampleService.aSet);}
@Test public void shouldPrintUnusedStub(){Invocation unusedStub=new InvocationBuilder().simpleMethod().toInvocation();WarningsFinder finder=new WarningsFinder(asList(unusedStub),Arrays.<InvocationMatcher>asList());finder.find(listener);verify(listener,only()).foundUnusedStub(unusedStub);}
@Test public void shouldPrintUnstubbedInvocation(){InvocationMatcher unstubbedInvocation=new InvocationBuilder().differentMethod().toInvocationMatcher();WarningsFinder finder=new WarningsFinder(Arrays.<Invocation>asList(),Arrays.<InvocationMatcher>asList(unstubbedInvocation));finder.find(listener);verify(listener,only()).foundUnstubbed(unstubbedInvocation);}
@Test public void shouldPrintStubWasUsedWithDifferentArgs(){Invocation stub=new InvocationBuilder().arg("foo").mock(mock).toInvocation();InvocationMatcher wrongArg=new InvocationBuilder().arg("bar").mock(mock).toInvocationMatcher();WarningsFinder finder=new WarningsFinder(Arrays.<Invocation>asList(stub),Arrays.<InvocationMatcher>asList(wrongArg));finder.find(listener);verify(listener,only()).foundStubCalledWithDifferentArgs(stub,wrongArg);}
@Test public void shouldUseArgumentTypeWhenOverloadingPuzzleDetected()throws Exception {Sub sub=mock(Sub.class);setMockWithDowncast(sub);say("Hello");try {verify(sub).say("Hello");fail();}catch(WantedButNotInvoked e){}}
@Test public void shouldPrintBothInMultilinesWhenFirstIsMulti(){SmartPrinter printer=new SmartPrinter(multi,shortie.getInvocation());assertContains("\n",printer.getWanted().toString());assertContains("\n",printer.getActual().toString());}
@Test public void shouldPrintBothInMultilinesWhenSecondIsMulti(){SmartPrinter printer=new SmartPrinter(shortie,multi.getInvocation());assertContains("\n",printer.getWanted().toString());assertContains("\n",printer.getActual().toString());}
@Test public void shouldPrintBothInMultilinesWhenBothAreMulti(){SmartPrinter printer=new SmartPrinter(multi,multi.getInvocation());assertContains("\n",printer.getWanted().toString());assertContains("\n",printer.getActual().toString());}
@Test public void shouldPrintBothInSingleLineWhenBothAreShort(){SmartPrinter printer=new SmartPrinter(shortie,shortie.getInvocation());assertNotContains("\n",printer.getWanted().toString());assertNotContains("\n",printer.getActual().toString());}
@Test public void shouldNotThrowAnyException()throws Exception {Foo foo=mock(Foo.class);when(foo.blah(anyString(),anyString())).thenCallRealMethod();assertEquals(1,foo.blah("foo","bar"));}
@Test public void shouldNotPrintInvocationOnMockWithoutSetting(){Foo foo=mock(Foo.class,withSettings().verboseLogging());foo.giveMeSomeString("Klipsch");unrelatedMock.unrelatedMethod("Apple");Assertions.assertThat(printed()).doesNotContain(mockName(unrelatedMock)).doesNotContain("unrelatedMethod").doesNotContain("Apple");}
@Test public void shouldPrintUnstubbedInvocationOnMockToStdOut(){Foo foo=mock(Foo.class,withSettings().verboseLogging());foo.doSomething("Klipsch");Assertions.assertThat(printed()).contains(getClass().getName()).contains(mockName(foo)).contains("doSomething").contains("Klipsch");}
@Test public void shouldPrintStubbedInvocationOnMockToStdOut(){Foo foo=mock(Foo.class,withSettings().verboseLogging());given(foo.giveMeSomeString("Klipsch")).willReturn("earbuds");foo.giveMeSomeString("Klipsch");Assertions.assertThat(printed()).contains(getClass().getName()).contains(mockName(foo)).contains("giveMeSomeString").contains("Klipsch").contains("earbuds");}
@Test public void shouldPrintThrowingInvocationOnMockToStdOut(){Foo foo=mock(Foo.class,withSettings().verboseLogging());doThrow(new ThirdPartyException()).when(foo).doSomething("Klipsch");try {foo.doSomething("Klipsch");fail("Exception excepted.");}catch(ThirdPartyException e){Assertions.assertThat(printed()).contains(getClass().getName()).contains(mockName(foo)).contains("doSomething").contains("Klipsch").contains(ThirdPartyException.class.getName());}}
@Test public void shouldPrintRealInvocationOnSpyToStdOut(){FooImpl fooSpy=mock(FooImpl.class,withSettings().spiedInstance(new FooImpl()).verboseLogging());doCallRealMethod().when(fooSpy).doSomething("Klipsch");fooSpy.doSomething("Klipsch");Assertions.assertThat(printed()).contains(getClass().getName()).contains(mockName(fooSpy)).contains("doSomething").contains("Klipsch");}
@Test public void usage(){Foo foo=mock(Foo.class,withSettings().verboseLogging());given(foo.giveMeSomeString("Apple")).willReturn("earbuds");foo.giveMeSomeString("Shure");foo.giveMeSomeString("Apple");foo.doSomething("Klipsch");}
@Test public void shouldLogUnusedStub(){LoggingListener listener=new LoggingListener(false,logger);listener.foundUnusedStub(new InvocationBuilder().toInvocation());verify(logger).log(notNull());}
@Test public void shouldLogUnstubbed(){LoggingListener listener=new LoggingListener(true,logger);listener.foundUnstubbed(new InvocationBuilder().toInvocationMatcher());verify(logger).log(notNull());}
@Test public void shouldNotLogUnstubbed(){LoggingListener listener=new LoggingListener(false,logger);listener.foundUnstubbed(new InvocationBuilder().toInvocationMatcher());verify(logger,never()).log(notNull());}
@Test public void shouldLogDifferentArgs(){LoggingListener listener=new LoggingListener(true,logger);listener.foundStubCalledWithDifferentArgs(new InvocationBuilder().toInvocation(),new InvocationBuilder().toInvocationMatcher());verify(logger).log(notNull());}
@Test public void shouldVerifyExactNumberOfInvocationsUsingMatcher(){mock.simpleMethod(1);mock.simpleMethod(2);mock.simpleMethod(3);verify(mock,times(3)).simpleMethod(anyInt());}
@Test public void shouldVerifyUsingSameMatcher(){Object one=new String("1243");Object two=new String("1243");Object three=new String("1243");assertNotSame(one,two);assertEquals(one,two);assertEquals(two,three);mock.oneArg(one);mock.oneArg(two);verify(mock).oneArg(same(one));verify(mock,times(2)).oneArg(two);try {verify(mock).oneArg(same(three));fail();}catch(WantedButNotInvoked e){}}
@Test public void shouldVerifyUsingMixedMatchers(){mock.threeArgumentMethod(11,"","01234");try {verify(mock).threeArgumentMethod(and(geq(7),leq(10)),isA(String.class),Matchers.contains("123"));fail();}catch(ArgumentsAreDifferent e){}mock.threeArgumentMethod(8,new Object(),"01234");try {verify(mock).threeArgumentMethod(and(geq(7),leq(10)),isA(String.class),Matchers.contains("123"));fail();}catch(ArgumentsAreDifferent e){}mock.threeArgumentMethod(8,"","no match");try {verify(mock).threeArgumentMethod(and(geq(7),leq(10)),isA(String.class),Matchers.contains("123"));fail();}catch(ArgumentsAreDifferent e){}mock.threeArgumentMethod(8,"","123");verify(mock).threeArgumentMethod(and(geq(7),leq(10)),isA(String.class),Matchers.contains("123"));}
@Test public void should_find_generic_class()throws Exception {assertEquals(String.class,m.getGenericType(field("one")));assertEquals(Integer.class,m.getGenericType(field("two")));assertEquals(Double.class,m.getGenericType(field("map")));}
@Test public void should_get_object_for_non_generic()throws Exception {assertEquals(Object.class,m.getGenericType(field("nonGeneric")));}
@Test public void should_deal_with_nested_generics()throws Exception {assertEquals(Set.class,m.getGenericType(field("nested")));assertEquals(Set.class,m.getGenericType(field("multiNested")));}
@Test public void when_not_stubbed_delegate_should_be_called(){List<String> delegatedList=new ArrayList<String>();delegatedList.add("un");List<String> mock=mock(List.class,delegatesTo(delegatedList));mock.add("two");assertEquals(2,mock.size());}
@Test public void when_stubbed_the_delegate_should_not_be_called(){List<String> delegatedList=new ArrayList<String>();delegatedList.add("un");List<String> mock=mock(List.class,delegatesTo(delegatedList));doReturn(10).when(mock).size();mock.add("two");assertEquals(10,mock.size());assertEquals(2,delegatedList.size());}
@Test public void delegate_should_not_be_called_when_stubbed2(){List<String> delegatedList=new ArrayList<String>();delegatedList.add("un");List<String> mockedList=mock(List.class,delegatesTo(delegatedList));doReturn(false).when(mockedList).add(Mockito.anyString());mockedList.add("two");assertEquals(1,mockedList.size());assertEquals(1,delegatedList.size());}
@Test public void null_wrapper_dont_throw_exception_from_org_mockito_package()throws Exception {IMethods methods=mock(IMethods.class,delegatesTo(new MethodsImpl()));try {byte b=methods.byteObjectReturningMethod();fail();}catch(Exception e){assertThat(e.toString()).doesNotContain("org.mockito");}}
@Test public void instance_of_different_class_can_be_called(){List<String> mock=mock(List.class,delegatesTo(new FakeList<String>()));mock.set(1,"1");assertThat(mock.get(1).equals("1"));}
@Test public void method_with_subtype_return_can_be_called(){List<String> mock=mock(List.class,delegatesTo(new FakeList<String>()));List<String> subList=mock.subList(0,0);assertThat(subList.isEmpty());}
@Test public void calling_missing_method_should_throw_exception(){List<String> mock=mock(List.class,delegatesTo(new FakeList<String>()));try {mock.isEmpty();fail();}catch(MockitoException e){assertThat(e.toString()).contains("Methods called on mock must exist");}}
@Test public void calling_method_with_wrong_primitive_return_should_throw_exception(){List<String> mock=mock(List.class,delegatesTo(new FakeListWithWrongMethods<String>()));try {mock.size();fail();}catch(MockitoException e){assertThat(e.toString()).contains("Methods called on delegated instance must have compatible return type");}}
@Test public void calling_method_with_wrong_reference_return_should_throw_exception(){List<String> mock=mock(List.class,delegatesTo(new FakeListWithWrongMethods<String>()));try {mock.subList(0,0);fail();}catch(MockitoException e){assertThat(e.toString()).contains("Methods called on delegated instance must have compatible return type");}}
@Test public void exception_should_be_propagated_from_delegate()throws Exception {final RuntimeException failure=new RuntimeException("angry-method");IMethods methods=mock(IMethods.class,delegatesTo(new MethodsImpl(){@Override public String simpleMethod(){throw failure;}}));try {methods.simpleMethod();fail();}catch(RuntimeException e){assertThat(e).isEqualTo(failure);}}
@Test public void shouldVerifyEvenIfArgumentsWereMutated()throws Exception {EmailSender emailSender=mock(EmailSender.class,new ClonesArguments());businessLogic(emailSender);verify(emailSender).sendEmail(1,new Person("Wes"));}
@Test public void shouldReturnDefaultValueWithCloningAnswer()throws Exception {EmailSender emailSender=mock(EmailSender.class,new ClonesArguments());when(emailSender.getAllEmails(new Person("Wes"))).thenAnswer(new ClonesArguments());List<?> emails=emailSender.getAllEmails(new Person("Wes"));assertNotNull(emails);}
@Test public void failIfMockIsSharedBetweenThreads()throws Exception {Service service=Mockito.mock(Service.class);ExecutorService threads=Executors.newCachedThreadPool();AtomicInteger counter=new AtomicInteger(2);Mockito.when(service.verySlowMethod()).thenAnswer(new LockingAnswer(counter));threads.execute(new ServiceRunner(service));threads.execute(new ServiceRunner(service));threads.shutdown();if (!threads.awaitTermination(1000,TimeUnit.MILLISECONDS)){Assert.fail();}}
@Test public void successIfEveryThreadHasItsOwnMock(){}
@Test public void shouldKnowWhenStringContainsIgnoringCase()throws Exception {assertContainsIgnoringCase("foo","foo");assertContainsIgnoringCase("fOo","foo");assertContainsIgnoringCase("FoO","foo");assertContainsIgnoringCase("foo","a foo :)");assertContainsIgnoringCase("fOo","a foo :)");assertContainsIgnoringCase("FoO","a foo :)");assertContainsIgnoringCase("","a foo :)");assertContainsIgnoringCase("","");}
@Test(expected=AssertionError.class)public void shouldKnowWhenStringDoesNotContainIgnoringCase()throws Exception {assertContainsIgnoringCase("fooo","foo");}
@Test(expected=AssertionError.class)public void shouldKnowWhenStringDoesNotContainIgnoringCase2()throws Exception {assertContainsIgnoringCase("fOo","f oo");}
@Test public void sameToStringWithString(){assertEquals("same(\"X\")",describe(new Same("X")));}
@Test public void nullToString(){assertEquals("isNull()",describe(Null.NULL));}
@Test public void notNullToString(){assertEquals("notNull()",describe(NotNull.NOT_NULL));}
@Test public void anyToString(){assertEquals("<any>",describe(Any.ANY));}
@Test public void sameToStringWithChar(){assertEquals("same('x')",describe(new Same('x')));}
@Test public void sameToStringWithObject(){Object o=new Object(){@Override public String toString(){return "X";}};assertEquals("same(X)",describe(new Same(o)));}
@Test public void equalsToStringWithString(){assertEquals("\"X\"",describe(new Equals("X")));}
@Test public void equalsToStringWithChar(){assertEquals("'x'",describe(new Equals('x')));}
@Test public void equalsToStringWithObject(){Object o=new Object(){@Override public String toString(){return "X";}};assertEquals("X",describe(new Equals(o)));}
@Test public void orToString(){List<Matcher> matchers=new ArrayList<Matcher>();matchers.add(new Equals(1));matchers.add(new Equals(2));assertEquals("or(1,2)",describe(new Or(matchers)));}
@Test public void notToString(){assertEquals("not(1)",describe(new Not(new Equals(1))));}
@Test public void andToString(){List<Matcher> matchers=new ArrayList<Matcher>();matchers.add(new Equals(1));matchers.add(new Equals(2));assertEquals("and(1,2)",describe(new And(matchers)));}
@Test public void startsWithToString(){assertEquals("startsWith(\"AB\")",describe(new StartsWith("AB")));}
@Test public void endsWithToString(){assertEquals("endsWith(\"AB\")",describe(new EndsWith("AB")));}
@Test public void containsToString(){assertEquals("contains(\"AB\")",describe(new Contains("AB")));}
@Test public void findToString(){assertEquals("find(\"\\\\s+\")",describe(new Find("\\s+")));}
@Test public void matchesToString(){assertEquals("matches(\"\\\\s+\")",describe(new Matches("\\s+")));}
@Test public void shouldMarkInvocationAsVerified(){InvocationMarker marker=new InvocationMarker();Invocation i=new InvocationBuilder().toInvocation();InvocationMatcher im=new InvocationBuilder().toInvocationMatcher();assertFalse(i.isVerified());marker.markVerified(Arrays.asList(i),im);assertTrue(i.isVerified());}
@Test public void shouldCaptureArguments(){InvocationMarker marker=new InvocationMarker();Invocation i=new InvocationBuilder().toInvocation();final ObjectBox box=new ObjectBox();CapturesArgumensFromInvocation c=new CapturesArgumensFromInvocation(){public void captureArgumentsFrom(Invocation i){box.put(i);}};marker.markVerified(Arrays.asList(i),c);assertEquals(i,box.getObject());}
@Test public void shouldMarkInvocationsAsVerifiedInOrder(){InOrderContextImpl context=new InOrderContextImpl();InvocationMarker marker=new InvocationMarker();Invocation i=new InvocationBuilder().toInvocation();InvocationMatcher im=new InvocationBuilder().toInvocationMatcher();assertFalse(context.isVerified(i));assertFalse(i.isVerified());marker.markVerifiedInOrder(Arrays.asList(i),im,context);assertTrue(context.isVerified(i));assertTrue(i.isVerified());}
@Test public void shouldFilterOutCglibGarbage(){StackTraceElement[]t=new TraceBuilder().classes("MockitoExampleTest","List$$EnhancerByMockitoWithCGLIB$$2c406024").toTraceArray();StackTraceElement[]filtered=filter.filter(t,false);assertThat(filtered,hasOnlyThoseClasses("MockitoExampleTest"));}
@Test public void shouldFilterOutMockitoPackage(){StackTraceElement[]t=new TraceBuilder().classes("org.test.MockitoSampleTest","org.mockito.Mockito").toTraceArray();StackTraceElement[]filtered=filter.filter(t,false);assertThat(filtered,hasOnlyThoseClasses("org.test.MockitoSampleTest"));}
@Test public void shouldFilterOutTracesMiddleBadTraces(){StackTraceElement[]t=new TraceBuilder().classes("org.test.MockitoSampleTest","org.test.TestSupport","org.mockito.Mockito","org.test.TestSupport","org.mockito.Mockito").toTraceArray();StackTraceElement[]filtered=filter.filter(t,false);assertThat(filtered,hasOnlyThoseClasses("org.test.TestSupport","org.test.MockitoSampleTest"));}
@Test public void shouldKeepRunners(){StackTraceElement[]t=new TraceBuilder().classes("org.mockito.runners.Runner","junit.stuff","org.test.MockitoSampleTest","org.mockito.Mockito").toTraceArray();StackTraceElement[]filtered=filter.filter(t,false);assertThat(filtered,hasOnlyThoseClasses("org.test.MockitoSampleTest","junit.stuff","org.mockito.runners.Runner"));}
@Test public void shouldKeepInternalRunners(){StackTraceElement[]t=new TraceBuilder().classes("org.mockito.internal.runners.Runner","org.test.MockitoSampleTest").toTraceArray();StackTraceElement[]filtered=filter.filter(t,false);assertThat(filtered,hasOnlyThoseClasses("org.test.MockitoSampleTest","org.mockito.internal.runners.Runner"));}
@Test public void shouldStartFilteringAndKeepTop(){StackTraceElement[]t=new TraceBuilder().classes("org.test.Good","org.mockito.internal.Bad","org.test.MockitoSampleTest").toTraceArray();StackTraceElement[]filtered=filter.filter(t,true);assertThat(filtered,hasOnlyThoseClasses("org.test.MockitoSampleTest","org.test.Good"));}
@Test public void shouldKeepGoodTraceFromTheTopBecauseRealImplementationsOfSpiesSometimesThrowExceptions(){StackTraceElement[]t=new TraceBuilder().classes("org.good.Trace","org.yet.another.good.Trace","org.mockito.internal.to.be.Filtered","org.test.MockitoSampleTest").toTraceArray();StackTraceElement[]filtered=filter.filter(t,true);assertThat(filtered,hasOnlyThoseClasses("org.test.MockitoSampleTest","org.yet.another.good.Trace","org.good.Trace"));}
@Test public void shouldReturnEmptyArrayWhenInputIsEmpty()throws Exception {StackTraceElement[]filtered=filter.filter(new StackTraceElement[0],false);assertEquals(0,filtered.length);}
@Test public void shouldVerifyWithTimeout(){}
@Test public void shouldFailVerificationWithTimeout(){}
@Test public void shouldAllowMixingOtherModesWithTimeout(){}
@Test public void shouldAllowMixingOtherModesWithTimeoutAndFail(){}
@Test public void shouldAllowMixingOnlyWithTimeout(){}
@Test public void shouldAllowMixingOnlyWithTimeoutAndFail(){}
/** * This test is JUnit-specific because the code behaves different if JUnit is used.*/@Test public void canIgnoreInvocationsWithJunit(){Thread t1=new Thread(){@Override public void run(){mock.add("0");mock.add("1");VerificationWithTimeoutTest.this.sleep(100);mock.add("2");}};t1.start();verify(mock,timeout(200)).add("1");verify(mock,timeout(200)).add("2");}
@Ignore @Test public void shouldAllowTimeoutVerificationInOrder()throws Exception {Thread t1=waitAndExerciseMock(20);t1.start();mock.add("foo");InOrder inOrder=inOrder(mock);inOrder.verify(mock).add(anyString());inOrder.verify(mock,never()).clear();inOrder.verify(mock,timeout(40)).clear();}
@Test public void shouldKnowWhenNull()throws Exception {FieldReader reader=new FieldReader(new Foo(),Foo.class.getDeclaredField("isNull"));assertTrue(reader.isNull());}
@Test public void shouldKnowWhenNotNull()throws Exception {FieldReader reader=new FieldReader(new Foo(),Foo.class.getDeclaredField("notNull"));assertFalse(reader.isNull());}
@Test public void single_mock_being_serialized_in_different_classloaders_by_multiple_threads()throws ExecutionException,InterruptedException {int iterations=2;int threadingFactor=200;final ExecutorService executorService=Executors.newFixedThreadPool(threadingFactor);final IMethods iMethods_that_store_invocations=mock(IMethods.class,withSettings().serializable());for (int i=0;i <= iterations;i++){List<Future> futures=new ArrayList<Future>(threadingFactor);final CyclicBarrier barrier_that_will_wait_until_threads_are_ready=new CyclicBarrier(threadingFactor);for (int j=0;j < threadingFactor;j++){futures.add(executorService.submit(new Callable<Object>(){public Object call()throws Exception {barrier_that_will_wait_until_threads_are_ready.await();randomCallOn(iMethods_that_store_invocations);return SimpleSerializationUtil.serializeMock(iMethods_that_store_invocations).toByteArray();}}));executorService.submit(new Callable<Object>(){public Object call()throws Exception {barrier_that_will_wait_until_threads_are_ready.await();return iMethods_that_store_invocations.longObjectReturningMethod();}});}for(Future future : futures){future.get();}}}
@Test public void just_for_information_fields_are_read_in_declaration_order_see_Service(){Field[]declaredFields=Service.class.getDeclaredFields();assertEquals("mockShouldNotGoInHere",declaredFields[0].getName());assertEquals("mockShouldGoInHere",declaredFields[1].getName());}
@Test public void mock_should_be_injected_once_and_in_the_best_matching_type(){assertSame(REFERENCE,illegalInjectionExample.mockShouldNotGoInHere);assertSame(mockedBean,illegalInjectionExample.mockShouldGoInHere);}
@Test public void should_match_be_consistent_regardless_of_order(){assertSame(REFERENCE,reversedOrderService.mockShouldNotGoInHere);assertSame(mockedBean,reversedOrderService.mockShouldGoInHere);}
@Test public void should_inject_the_mock_only_once_and_in_the_correct_type(){assertNull(withNullObjectField.keepMeNull);assertSame(mockedBean,withNullObjectField.injectMePlease);}
@Test public void returnFoo1(){ReturnsObject mock=mock(ReturnsObject.class);when(mock.callMe()).thenReturn("foo");assertEquals("foo",mock.callMe());}
@Test public void returnFoo2(){ReturnsString mock=mock(ReturnsString.class);when(mock.callMe()).thenReturn("foo");assertEquals("foo",mock.callMe());}
@Test public void returnFoo3(){ReturnsObject mock=mock(ReturnsString.class);when(mock.callMe()).thenReturn("foo");assertEquals("foo",mock.callMe());}
@Test public void returnFoo4(){ReturnsString mock=mock(ReturnsString.class);mock.callMe();ReturnsObject mock2=mock;verify(mock2).callMe();}
@Test @Ignore public void test(){IMethods mock=mock(IMethods.class);mock.simpleMethod(1);mock.otherMethod();verify(mock).simpleMethod(1);throw new RuntimeException("boo");}
public void testIgnored(){}
@Test @Ignore public void shouldContainWarnings()throws Exception {Result result=new JUnitCore().run(new ContainsWarnings());assertEquals(1,result.getFailures().size());Throwable exception=result.getFailures().get(0).getException();assertTrue(exception instanceof ExceptionIncludingMockitoWarnings);}
@Test @Ignore public void shouldNotContainWarnings()throws Exception {Result result=new JUnitCore().run(NoWarnings.class);assertEquals(1,result.getFailures().size());assertEquals("boo",result.getFailures().get(0).getException().getMessage());}
@Test public void shouldKnowIfIsEqualTo(){Invocation equal=new InvocationBuilder().args(" ").mock("mock").toInvocation();Invocation nonEqual=new InvocationBuilder().args("X").mock("mock").toInvocation();Invocation withNewStringInstance=new InvocationBuilder().args(new String(" ")).mock("mock").toInvocation();assertFalse(invocation.equals(null));assertFalse(invocation.equals(""));assertTrue(invocation.equals(equal));assertFalse(invocation.equals(nonEqual));assertTrue(invocation.equals(withNewStringInstance));}
@Test public void shouldEqualToNotConsiderSequenceNumber(){Invocation equal=new InvocationBuilder().args(" ").mock("mock").seq(2).toInvocation();assertTrue(invocation.equals(equal));assertTrue(invocation.getSequenceNumber()!= equal.getSequenceNumber());}
@Test public void shouldBeACitizenOfHashes(){Map map=new HashMap();map.put(invocation,"one");assertEquals("one",map.get(invocation));}
@Test public void shouldPrintMethodName(){invocation=new InvocationBuilder().toInvocation();assertEquals("iMethods.simpleMethod();",invocation.toString());}
@Test public void shouldPrintMethodArgs(){invocation=new InvocationBuilder().args("foo").toInvocation();assertThat(invocation.toString(),endsWith("simpleMethod(\"foo\");"));}
@Test public void shouldPrintMethodIntegerArgAndString(){invocation=new InvocationBuilder().args("foo",1).toInvocation();assertThat(invocation.toString(),endsWith("simpleMethod(\"foo\",1);"));}
@Test public void shouldPrintNull(){invocation=new InvocationBuilder().args((String)null).toInvocation();assertThat(invocation.toString(),endsWith("simpleMethod(null);"));}
@Test public void shouldPrintArray(){invocation=new InvocationBuilder().method("oneArray").args(new int[]{1,2,3}).toInvocation();assertThat(invocation.toString(),endsWith("oneArray([1,2,3]);"));}
@Test public void shouldPrintNullIfArrayIsNull()throws Exception {Method m=IMethods.class.getMethod("oneArray",Object[].class);invocation=new InvocationBuilder().method(m).args((Object)null).toInvocation();assertThat(invocation.toString(),endsWith("oneArray(null);"));}
@Test public void shouldPrintArgumentsInMultilinesWhenGetsTooBig(){invocation=new InvocationBuilder().args("veeeeery long string that makes it ugly in one line",1).toInvocation();assertThat(invocation.toString(),endsWith("simpleMethod(" + "\n" + "    \"veeeeery long string that makes it ugly in one line\","+ "\n"+ "    1"+ "\n"+ ");"));}
@Test public void shouldTransformArgumentsToMatchers()throws Exception {Invocation i=new InvocationBuilder().args("foo",new String[]{"bar"}).toInvocation();List matchers=ArgumentsProcessor.argumentsToMatchers(i.getArguments());assertEquals(2,matchers.size());assertEquals(Equals.class,matchers.get(0).getClass());assertEquals(ArrayEquals.class,matchers.get(1).getClass());}
@Test public void shouldBeAbleToCallRealMethod()throws Throwable {Invocation invocation=invocationOf(Foo.class,"bark",new RealMethod(){public Object invoke(Object target,Object[]arguments)throws Throwable {return new Foo().bark();}});assertEquals("woof",invocation.callRealMethod());}
@Test public void shouldScreamWhenCallingRealMethodOnInterface()throws Throwable {Invocation invocationOnInterface=new InvocationBuilder().toInvocation();try {invocationOnInterface.callRealMethod();fail();}catch(MockitoException e){}}
@Test public void shouldReturnCastedArgumentAt(){int argument=42;Invocation invocationOnInterface=new InvocationBuilder().method("twoArgumentMethod").argTypes(int.class,int.class).args(1,argument).toInvocation();int secondArgument=invocationOnInterface.getArgumentAt(1,int.class);assertTrue(secondArgument == argument);}
@Test(expected=ArgumentsAreDifferent.class)public void shouldPrintInvocationsWhenStubbingNotUsed()throws Exception {performStubbing();businessLogicWithAsking("arg");verify(mockTwo).doSomething("foo");}
@Test public void shouldFailWithUnfinishedVerification(){withFinal=mock(WithFinal.class);verify(withFinal).foo();try {verify(withFinal).foo();fail();}catch(UnfinishedVerificationException e){}}
@Test public void shouldFailWithUnfinishedStubbing(){withFinal=mock(WithFinal.class);try {when(withFinal.foo()).thenReturn(null);fail();}catch(MissingMethodInvocationException e){}}
@Test public void shouldSerializationWork()throws Exception {Foo foo=new Foo();foo=serializeAndBack(foo);assertSame(foo,foo.bar.foo);}
@Test public void shouldAllowToExcludeStubsForVerification()throws Exception {when(mock.simpleMethod()).thenReturn("foo");String stubbed=mock.simpleMethod();mock.objectArgMethod(stubbed);verify(mock).objectArgMethod("foo");try {verifyNoMoreInteractions(mock);fail();}catch(NoInteractionsWanted e){};ignoreStubs(mock);verifyNoMoreInteractions(mock);}
@Test public void shouldExcludeFromVerificationInOrder()throws Exception {when(mock.simpleMethod()).thenReturn("foo");mock.objectArgMethod("1");mock.objectArgMethod("2");mock.simpleMethod();InOrder inOrder=inOrder(ignoreStubs(mock));inOrder.verify(mock).objectArgMethod("1");inOrder.verify(mock).objectArgMethod("2");inOrder.verifyNoMoreInteractions();verifyNoMoreInteractions(mock);}
@Test(expected=NotAMockException.class)public void shouldIgnoringStubsDetectNulls()throws Exception {ignoreStubs(mock,null);}
@Test(expected=NotAMockException.class)public void shouldIgnoringStubsDetectNonMocks()throws Exception {ignoreStubs(mock,new Object());}
@Test public void shouldEvaluateLatestStubbingFirst()throws Exception {stub(mock.objectReturningMethod(isA(Integer.class))).toReturn(100);stub(mock.objectReturningMethod(200)).toReturn(200);assertEquals(200,mock.objectReturningMethod(200));assertEquals(100,mock.objectReturningMethod(666));assertEquals("default behavior should return null",null,mock.objectReturningMethod("blah"));}
@Test public void shouldStubbingBeTreatedAsInteraction()throws Exception {stub(mock.booleanReturningMethod()).toReturn(true);mock.booleanReturningMethod();try {verifyNoMoreInteractions(mock);fail();}catch(NoInteractionsWanted e){}}
@Test public void shouldAllowStubbingToString()throws Exception {IMethods mockTwo=mock(IMethods.class);stub(mockTwo.toString()).toReturn("test");assertContains("Mock for IMethods",mock.toString());assertEquals("test",mockTwo.toString());}
@Test public void shouldStubbingNotBeTreatedAsInteraction(){stub(mock.simpleMethod("one")).toThrow(new RuntimeException());stubVoid(mock).toThrow(new RuntimeException()).on().simpleMethod("two");verifyZeroInteractions(mock);}
@Test public void shouldAllowConsecutiveStubbing()throws Exception {stub(mock.simpleMethod()).toReturn("100").toReturn("200");assertEquals("100",mock.simpleMethod());assertEquals("200",mock.simpleMethod());}
@Test public void shouldAllowVerifyingInThreads()throws Exception {for (int i=0;i < 100;i++){performTest();}}
@Test public void shouldLog()throws Exception {SimpleMockitoLogger logger=new SimpleMockitoLogger();logger.log("foo");assertEquals("foo",logger.getLoggedInfo());}
@Test public void should_return_empty_collections_or_null_for_non_collections(){assertTrue(((Collection)values.returnValueFor(Collection.class)).isEmpty());assertTrue(((Set)values.returnValueFor(Set.class)).isEmpty());assertTrue(((SortedSet)values.returnValueFor(SortedSet.class)).isEmpty());assertTrue(((HashSet)values.returnValueFor(HashSet.class)).isEmpty());assertTrue(((TreeSet)values.returnValueFor(TreeSet.class)).isEmpty());assertTrue(((LinkedHashSet)values.returnValueFor(LinkedHashSet.class)).isEmpty());assertTrue(((List)values.returnValueFor(List.class)).isEmpty());assertTrue(((ArrayList)values.returnValueFor(ArrayList.class)).isEmpty());assertTrue(((LinkedList)values.returnValueFor(LinkedList.class)).isEmpty());assertTrue(((Map)values.returnValueFor(Map.class)).isEmpty());assertTrue(((SortedMap)values.returnValueFor(SortedMap.class)).isEmpty());assertTrue(((HashMap)values.returnValueFor(HashMap.class)).isEmpty());assertTrue(((TreeMap)values.returnValueFor(TreeMap.class)).isEmpty());assertTrue(((LinkedHashMap)values.returnValueFor(LinkedHashMap.class)).isEmpty());assertNull(values.returnValueFor(String.class));}
@Test public void should_return_primitive(){assertEquals(false,values.returnValueFor(Boolean.TYPE));assertEquals((char)0,values.returnValueFor(Character.TYPE));assertEquals((byte)0,values.returnValueFor(Byte.TYPE));assertEquals((short)0,values.returnValueFor(Short.TYPE));assertEquals(0,values.returnValueFor(Integer.TYPE));assertEquals(0L,values.returnValueFor(Long.TYPE));assertEquals(0F,values.returnValueFor(Float.TYPE));assertEquals(0D,values.returnValueFor(Double.TYPE));}
@Test public void should_return_non_zero_for_compareTo_method(){Date d=mock(Date.class);d.compareTo(new Date());Invocation compareTo=this.getLastInvocation();Object result=values.answer(compareTo);assertTrue(result != (Object)0);}
@Test public void should_return_zero_if_mock_is_compared_to_itself(){Date d=mock(Date.class);d.compareTo(d);Invocation compareTo=this.getLastInvocation();Object result=values.answer(compareTo);assertEquals(0,result);}
@Test public void shouldVerifyInOrder(){NoMoreInteractions n=new NoMoreInteractions();Invocation i=new InvocationBuilder().toInvocation();assertFalse(context.isVerified(i));try {n.verifyInOrder(new VerificationDataInOrderImpl(context,asList(i),null));fail();}catch(VerificationInOrderFailure e){}}
@Test public void shouldVerifyInOrderAndPass(){NoMoreInteractions n=new NoMoreInteractions();Invocation i=new InvocationBuilder().toInvocation();context.markVerified(i);assertTrue(context.isVerified(i));n.verifyInOrder(new VerificationDataInOrderImpl(context,asList(i),null));}
@Test public void shouldVerifyInOrderMultipleInvoctions(){NoMoreInteractions n=new NoMoreInteractions();Invocation i=new InvocationBuilder().seq(1).toInvocation();Invocation i2=new InvocationBuilder().seq(2).toInvocation();context.markVerified(i2);n.verifyInOrder(new VerificationDataInOrderImpl(context,asList(i,i2),null));}
@Test public void shouldVerifyInOrderMultipleInvoctionsAndThrow(){NoMoreInteractions n=new NoMoreInteractions();Invocation i=new InvocationBuilder().seq(1).toInvocation();Invocation i2=new InvocationBuilder().seq(2).toInvocation();try {n.verifyInOrder(new VerificationDataInOrderImpl(context,asList(i,i2),null));fail();}catch(VerificationInOrderFailure e){}}
@Test public void noMoreInteractionsExceptionMessageShouldDescribeMock(){NoMoreInteractions n=new NoMoreInteractions();String mock="a mock";InvocationMatcher i=new InvocationBuilder().mock(mock).toInvocationMatcher();InvocationContainerImpl invocations=new InvocationContainerImpl(new ThreadSafeMockingProgress(),new MockSettingsImpl());invocations.setInvocationForPotentialStubbing(i);try {n.verify(new VerificationDataImpl(invocations,null));fail();}catch(NoInteractionsWanted e){Assertions.assertThat(e.toString()).contains(mock.toString());}}
@Test public void noMoreInteractionsInOrderExceptionMessageShouldDescribeMock(){NoMoreInteractions n=new NoMoreInteractions();String mock="a mock";Invocation i=new InvocationBuilder().mock(mock).toInvocation();try {n.verifyInOrder(new VerificationDataInOrderImpl(context,asList(i),null));fail();}catch(VerificationInOrderFailure e){Assertions.assertThat(e.toString()).contains(mock.toString());}}
@Test public void shouldResetOngoingStubbingSoThatMoreMeaningfulExceptionsAreRaised(){mock(IMethods.class);mock.booleanReturningMethod();reset(mock);try {when(null).thenReturn("anything");fail();}catch(MissingMethodInvocationException e){}}
@Test(expected=NotAMockException.class)public void resettingNonMockIsSafe(){reset("");}
@Test(expected=NotAMockException.class)public void resettingNullIsSafe(){reset(new Object[]{null});}
@Test public void shouldRemoveAllStubbing()throws Exception {when(mock.objectReturningMethod(isA(Integer.class))).thenReturn(100);when(mock.objectReturningMethod(200)).thenReturn(200);reset(mock);assertNull(mock.objectReturningMethod(200));assertEquals("default behavior should return null",null,mock.objectReturningMethod("blah"));}
@Test public void shouldRemoveAllInteractions()throws Exception {mock.simpleMethod(1);reset(mock);verifyZeroInteractions(mock);}
@Test public void shouldRemoveStubbingToString()throws Exception {IMethods mockTwo=mock(IMethods.class);when(mockTwo.toString()).thenReturn("test");reset(mockTwo);assertContains("Mock for IMethods",mockTwo.toString());}
@Test public void shouldStubbingNotBeTreatedAsInteraction(){when(mock.simpleMethod("one")).thenThrow(new RuntimeException());doThrow(new RuntimeException()).when(mock).simpleMethod("two");reset(mock);verifyZeroInteractions(mock);}
@Test public void shouldNotAffectMockName(){IMethods mock=mock(IMethods.class,"mockie");IMethods mockTwo=mock(IMethods.class);reset(mock);assertContains("Mock for IMethods","" + mockTwo);assertEquals("mockie","" + mock);}
@Test public void shouldResetMultipleMocks(){mock.simpleMethod();mockTwo.simpleMethod();reset(mock,mockTwo);verifyNoMoreInteractions(mock,mockTwo);}
@Test public void shouldValidateStateWhenResetting(){verify(mock);try {reset(mockTwo);fail();}catch(UnfinishedVerificationException e){}}
@Test public void shouldMaintainPreviousDefaultAnswer(){mock=mock(IMethods.class,RETURNS_MOCKS);reset(mock);assertNotNull(mock.iMethodsReturningMethod());}
@Test public void dummy()throws Exception {}
@Test public void shouldValidateWithDefaultRunner()throws Exception {runner=new MockitoJUnitRunner(DummyTest.class);runner.run(notifier);assertThat(notifier.addedListeners,contains(clazz(FrameworkUsageValidator.class)));}
@Test public void shouldValidateWithD44Runner()throws Exception {runner=new MockitoJUnit44Runner(DummyTest.class);runner.run(notifier);assertThat(notifier.addedListeners,contains(clazz(FrameworkUsageValidator.class)));}
@Test public void shouldValidateWithVerboseRunner()throws Exception {runner=new ConsoleSpammingMockitoJUnitRunner(DummyTest.class);runner.run(notifier);assertEquals(2,notifier.addedListeners.size());assertThat(notifier.addedListeners,contains(clazz(FrameworkUsageValidator.class)));}
@Test public void shouldPassWhenMatchingInteractionFound()throws Exception {Invocation actual=new InvocationBuilder().toInvocation();finderStub.allMatchingUnverifiedChunksToReturn.add(actual);checker.check(invocations,wanted,new VerificationModeBuilder().inOrder(),context);}
@Test public void shouldReportWantedButNotInvoked()throws Exception {assertTrue(finderStub.allMatchingUnverifiedChunksToReturn.isEmpty());checker.check(invocations,wanted,new VerificationModeBuilder().inOrder(),context);assertEquals(wanted,reporterStub.wanted);}
@Test public void shouldReportArgumentsAreDifferent()throws Exception {assertTrue(finderStub.findInvocations(invocations,wanted).isEmpty());finderStub.similarToReturn=new InvocationBuilder().toInvocation();checker.check(invocations,wanted,new VerificationModeBuilder().inOrder(),context);SmartPrinter printer=new SmartPrinter(wanted,finderStub.similarToReturn,0);assertEquals(printer.getWanted(),reporterStub.wantedString);assertEquals(printer.getActual(),reporterStub.actual);assertEquals(finderStub.similarToReturn.getLocation(),reporterStub.actualLocation);}
@Test public void shouldReportWantedDiffersFromActual()throws Exception {Invocation previous=new InvocationBuilder().toInvocation();finderStub.previousInOrderToReturn=previous;checker.check(invocations,wanted,new VerificationModeBuilder().inOrder(),context);assertEquals(wanted,reporterStub.wanted);assertEquals(previous,reporterStub.previous);}
@Test public void should_enable_and_safely_disable()throws Exception {AccessibilityChanger changer=new AccessibilityChanger();changer.enableAccess(field("whatever"));changer.safelyDisableAccess(field("whatever"));}
@Test(expected=java.lang.AssertionError.class)@Ignore("should be run only when -ea is passed to the VM")public void safelyDisableAccess_should_fail_when_enableAccess_not_called()throws Exception {new AccessibilityChanger().safelyDisableAccess(field("whatever"));}
@Test public void shouldDetectUnusedStubbingWhenPrinting()throws Exception {given(mock.giveMeSomeString("different arg")).willReturn("foo");mock.giveMeSomeString("arg");String log=NewMockito.debug().printInvocations(mock,mockTwo);assertContainsIgnoringCase("unused",log);}
@Test public void shouldNotAllowNegativeNumberOfInvocations()throws Exception {try {VerificationModeFactory.times(-50);fail();}catch(MockitoException e){assertEquals("Negative value is not allowed here",e.getMessage());}}
@Test public void should_allow_throws_exception_to_be_serializable()throws Exception {Bar mock=mock(Bar.class,new ThrowsException(new RuntimeException()));serializeAndBack(mock);}
@Test public void should_allow_method_delegation()throws Exception {Bar barMock=mock(Bar.class,withSettings().serializable());Foo fooMock=mock(Foo.class);when(barMock.doSomething()).thenAnswer(new ThrowsException(new RuntimeException()));serializeAndBack(barMock);}
@Test public void should_allow_mock_to_be_serializable()throws Exception {IMethods mock=mock(IMethods.class,withSettings().serializable());serializeAndBack(mock);}
@Test public void should_allow_mock_and_boolean_value_to_serializable()throws Exception {IMethods mock=mock(IMethods.class,withSettings().serializable());when(mock.booleanReturningMethod()).thenReturn(true);ByteArrayOutputStream serialized=serializeMock(mock);IMethods readObject=deserializeMock(serialized,IMethods.class);assertTrue(readObject.booleanReturningMethod());}
@Test public void should_allow_mock_and_string_value_to_be_serializable()throws Exception {IMethods mock=mock(IMethods.class,withSettings().serializable());String value="value";when(mock.stringReturningMethod()).thenReturn(value);ByteArrayOutputStream serialized=serializeMock(mock);IMethods readObject=deserializeMock(serialized,IMethods.class);assertEquals(value,readObject.stringReturningMethod());}
@Test public void should_all_mock_and_serializable_value_to_be_serialized()throws Exception {IMethods mock=mock(IMethods.class,withSettings().serializable());List<?> value=Collections.emptyList();when(mock.objectReturningMethodNoArgs()).thenReturn(value);ByteArrayOutputStream serialized=serializeMock(mock);IMethods readObject=deserializeMock(serialized,IMethods.class);assertEquals(value,readObject.objectReturningMethodNoArgs());}
@Test public void should_serialize_method_call_with_parameters_that_are_serializable()throws Exception {IMethods mock=mock(IMethods.class,withSettings().serializable());List<?> value=Collections.emptyList();when(mock.objectArgMethod(value)).thenReturn(value);ByteArrayOutputStream serialized=serializeMock(mock);IMethods readObject=deserializeMock(serialized,IMethods.class);assertEquals(value,readObject.objectArgMethod(value));}
@Test public void should_serialize_method_calls_using_any_string_matcher()throws Exception {IMethods mock=mock(IMethods.class,withSettings().serializable());List<?> value=Collections.emptyList();when(mock.objectArgMethod(anyString())).thenReturn(value);ByteArrayOutputStream serialized=serializeMock(mock);IMethods readObject=deserializeMock(serialized,IMethods.class);assertEquals(value,readObject.objectArgMethod(""));}
@Test public void should_verify_called_n_times_for_serialized_mock()throws Exception {IMethods mock=mock(IMethods.class,withSettings().serializable());List<?> value=Collections.emptyList();when(mock.objectArgMethod(anyString())).thenReturn(value);mock.objectArgMethod("");ByteArrayOutputStream serialized=serializeMock(mock);IMethods readObject=deserializeMock(serialized,IMethods.class);verify(readObject,times(1)).objectArgMethod("");}
@Test public void should_verify_even_if_some_methods_called_after_serialization()throws Exception {IMethods mock=mock(IMethods.class,withSettings().serializable());mock.simpleMethod(1);ByteArrayOutputStream serialized=serializeMock(mock);IMethods readObject=deserializeMock(serialized,IMethods.class);readObject.simpleMethod(1);verify(readObject,times(2)).simpleMethod(1);}
@Test public void should_serialization_work()throws Exception {Foo foo=new Foo();foo=serializeAndBack(foo);assertSame(foo,foo.bar.foo);}
@Test public void should_stub_even_if_some_methods_called_after_serialization()throws Exception {IMethods mock=mock(IMethods.class,withSettings().serializable());when(mock.simpleMethod(1)).thenReturn("foo");ByteArrayOutputStream serialized=serializeMock(mock);IMethods readObject=deserializeMock(serialized,IMethods.class);when(readObject.simpleMethod(2)).thenReturn("bar");assertEquals("foo",readObject.simpleMethod(1));assertEquals("bar",readObject.simpleMethod(2));}
@Test public void should_verify_call_order_for_serialized_mock()throws Exception {IMethods mock=mock(IMethods.class,withSettings().serializable());IMethods mock2=mock(IMethods.class,withSettings().serializable());mock.arrayReturningMethod();mock2.arrayReturningMethod();ByteArrayOutputStream serialized=serializeMock(mock);ByteArrayOutputStream serialized2=serializeMock(mock2);IMethods readObject=deserializeMock(serialized,IMethods.class);IMethods readObject2=deserializeMock(serialized2,IMethods.class);InOrder inOrder=inOrder(readObject,readObject2);inOrder.verify(readObject).arrayReturningMethod();inOrder.verify(readObject2).arrayReturningMethod();}
@Test public void should_remember_interactions_for_serialized_mock()throws Exception {IMethods mock=mock(IMethods.class,withSettings().serializable());List<?> value=Collections.emptyList();when(mock.objectArgMethod(anyString())).thenReturn(value);mock.objectArgMethod("happened");ByteArrayOutputStream serialized=serializeMock(mock);IMethods readObject=deserializeMock(serialized,IMethods.class);verify(readObject,never()).objectArgMethod("never happened");}
@Test public void should_serialize_with_stubbing_callback()throws Exception {IMethods mock=mock(IMethods.class,withSettings().serializable());CustomAnswersMustImplementSerializableForSerializationToWork answer=new CustomAnswersMustImplementSerializableForSerializationToWork();answer.string="return value";when(mock.objectArgMethod(anyString())).thenAnswer(answer);ByteArrayOutputStream serialized=serializeMock(mock);IMethods readObject=deserializeMock(serialized,IMethods.class);assertEquals(answer.string,readObject.objectArgMethod(""));}
@Test public void should_serialize_with_real_object_spy()throws Exception {List<Object> list=new ArrayList<Object>();List<Object> spy=mock(ArrayList.class,withSettings().spiedInstance(list).defaultAnswer(CALLS_REAL_METHODS).serializable());when(spy.size()).thenReturn(100);ByteArrayOutputStream serialized=serializeMock(spy);List<?> readObject=deserializeMock(serialized,List.class);assertEquals(100,readObject.size());}
@Test public void should_serialize_object_mock(){}
@Test public void should_serialize_real_partial_mock(){}
@Test public void should_serialize_already_serializable_class()throws Exception {AlreadySerializable mock=mock(AlreadySerializable.class,withSettings().serializable());when(mock.toString()).thenReturn("foo");mock=serializeAndBack(mock);assertEquals("foo",mock.toString());}
@Test public void should_be_serialize_and_have_extra_interfaces()throws Exception {IMethods mock=mock(IMethods.class,withSettings().serializable().extraInterfaces(List.class));IMethods mockTwo=mock(IMethods.class,withSettings().extraInterfaces(List.class).serializable());Assertions.assertThat((Object)serializeAndBack((List)mock)).isInstanceOf(List.class).isInstanceOf(IMethods.class);Assertions.assertThat((Object)serializeAndBack((List)mockTwo)).isInstanceOf(List.class).isInstanceOf(IMethods.class);}
@Test public void should_fail_when_serializable_used_with_type_that_dont_implements_Serializable_and_dont_declare_a_no_arg_constructor()throws Exception {try {serializeAndBack(mock(NotSerializableAndNoDefaultConstructor.class,withSettings().serializable()));fail("should have thrown an exception to say the object is not serializable");}catch(MockitoException e){Assertions.assertThat(e.getMessage()).contains(NotSerializableAndNoDefaultConstructor.class.getSimpleName()).contains("serializable()").contains("implement Serializable").contains("no-arg constructor");}}
@Test public void should_be_able_to_serialize_type_that_implements_Serializable_but_but_dont_declare_a_no_arg_constructor()throws Exception {serializeAndBack(mock(SerializableAndNoDefaultConstructor.class));}
@Test public void private_constructor_currently_not_supported_at_the_moment_at_deserialization_time()throws Exception {AClassWithPrivateNoArgConstructor mockWithPrivateConstructor=Mockito.mock(AClassWithPrivateNoArgConstructor.class,Mockito.withSettings().serializable());try {SimpleSerializationUtil.serializeAndBack(mockWithPrivateConstructor);fail("should have thrown an ObjectStreamException or a subclass of it");}catch(ObjectStreamException e){Assertions.assertThat(e.toString()).contains("no valid constructor");}}
@Test @Ignore("Bug to fix !!! see issue 399")public void BUG_ISSUE_399_try_some_mocks_with_current_answers()throws Exception {IMethods iMethods=mock(IMethods.class,withSettings().serializable().defaultAnswer(RETURNS_DEEP_STUBS));when(iMethods.iMethodsReturningMethod().linkedListReturningMethod().contains(anyString())).thenReturn(false);serializeAndBack(iMethods);}
@Test public void tryToRevealTheProblem(){ToMock toMock=mock(ToMock.class);for (int i=0;i < 100;i++){int j=i % 11;when(toMock.getValue(i)).thenReturn(j);while (true){try {this.executor.execute(getConflictingRunnable(toMock));break;}catch(RejectedExecutionException ex){fail();}}try {Thread.sleep(10 / ((i % 10)+ 1));}catch(InterruptedException e){}}}
@Test public void shouldInitSpiesInBaseClass()throws Exception {SubClass subClass=new SubClass();MockitoAnnotations.initMocks(subClass);assertTrue(isMock(subClass.list));}
@Test public void shouldInitSpiesInHierarchy()throws Exception {assertTrue(isMock(spyInSubclass));assertTrue(isMock(spyInBaseclass));}
@Test public void creates_instances(){assertEquals(new ConstructorInstantiator(null).newInstance(SomeClass.class).getClass(),SomeClass.class);}
@Test public void creates_instances_of_inner_classes(){assertEquals(new ConstructorInstantiator(this).newInstance(SomeInnerClass.class).getClass(),SomeInnerClass.class);assertEquals(new ConstructorInstantiator(new ChildOfThis()).newInstance(SomeInnerClass.class).getClass(),SomeInnerClass.class);}
@Test public void explains_when_constructor_cannot_be_found(){try {new ConstructorInstantiator(null).newInstance(SomeClass2.class);fail();}catch(InstantationException e){assertEquals("Unable to create instance of 'SomeClass2'.\n" + "Please ensure it has 0-arg constructor which invokes cleanly.",e.getMessage());}}
@Test public void mockJustWorks(){issue421.checkIfMockIsInjected();}
@Test public void shouldVerifyInOrder(){inOrder.verify(mockOne).simpleMethod(1);inOrder.verify(mockTwo,times(2)).simpleMethod(2);inOrder.verify(mockThree).simpleMethod(3);inOrder.verify(mockTwo).simpleMethod(2);inOrder.verify(mockOne).simpleMethod(4);verifyNoMoreInteractions(mockOne,mockTwo,mockThree);}
@Test public void shouldVerifyInOrderUsingAtLeastOnce(){inOrder.verify(mockOne,atLeastOnce()).simpleMethod(1);inOrder.verify(mockTwo,times(2)).simpleMethod(2);inOrder.verify(mockThree).simpleMethod(3);inOrder.verify(mockTwo).simpleMethod(2);inOrder.verify(mockOne,atLeastOnce()).simpleMethod(4);verifyNoMoreInteractions(mockOne,mockTwo,mockThree);}
@Test public void shouldVerifyInOrderWhenExpectingSomeInvocationsToBeCalledZeroTimes(){inOrder.verify(mockOne,times(0)).oneArg(false);inOrder.verify(mockOne).simpleMethod(1);inOrder.verify(mockTwo,times(2)).simpleMethod(2);inOrder.verify(mockTwo,times(0)).simpleMethod(22);inOrder.verify(mockThree).simpleMethod(3);inOrder.verify(mockTwo).simpleMethod(2);inOrder.verify(mockOne).simpleMethod(4);inOrder.verify(mockThree,times(0)).oneArg(false);verifyNoMoreInteractions(mockOne,mockTwo,mockThree);}
@Test public void shouldFailWhenFirstMockCalledTwice(){inOrder.verify(mockOne).simpleMethod(1);try {inOrder.verify(mockOne).simpleMethod(1);fail();}catch(VerificationInOrderFailure e){}}
@Test public void shouldFailWhenLastMockCalledTwice(){inOrder.verify(mockOne).simpleMethod(1);inOrder.verify(mockTwo,times(2)).simpleMethod(2);inOrder.verify(mockThree).simpleMethod(3);inOrder.verify(mockTwo).simpleMethod(2);inOrder.verify(mockOne).simpleMethod(4);try {inOrder.verify(mockOne).simpleMethod(4);fail();}catch(VerificationInOrderFailure e){}}
@Test(expected=VerificationInOrderFailure.class)public void shouldFailOnFirstMethodBecauseOneInvocationWanted(){inOrder.verify(mockOne,times(0)).simpleMethod(1);}
@Test(expected=VerificationInOrderFailure.class)public void shouldFailOnFirstMethodBecauseOneInvocationWantedAgain(){inOrder.verify(mockOne,times(2)).simpleMethod(1);}
@Test public void shouldFailOnSecondMethodBecauseFourInvocationsWanted(){inOrder.verify(mockOne,times(1)).simpleMethod(1);try {inOrder.verify(mockTwo,times(4)).simpleMethod(2);fail();}catch(VerificationInOrderFailure e){}}
@Test public void shouldFailOnSecondMethodBecauseTwoInvocationsWantedAgain(){inOrder.verify(mockOne,times(1)).simpleMethod(1);try {inOrder.verify(mockTwo,times(0)).simpleMethod(2);fail();}catch(VerificationInOrderFailure e){}}
@Test public void shouldFailOnLastMethodBecauseOneInvocationWanted(){inOrder.verify(mockOne,atLeastOnce()).simpleMethod(1);inOrder.verify(mockTwo,times(2)).simpleMethod(2);inOrder.verify(mockThree,atLeastOnce()).simpleMethod(3);inOrder.verify(mockTwo,atLeastOnce()).simpleMethod(2);try {inOrder.verify(mockOne,times(0)).simpleMethod(4);fail();}catch(VerificationInOrderFailure e){}}
@Test public void shouldFailOnLastMethodBecauseOneInvocationWantedAgain(){inOrder.verify(mockOne,atLeastOnce()).simpleMethod(1);inOrder.verify(mockTwo,times(2)).simpleMethod(2);inOrder.verify(mockThree,atLeastOnce()).simpleMethod(3);inOrder.verify(mockTwo,atLeastOnce()).simpleMethod(2);try {inOrder.verify(mockOne,times(2)).simpleMethod(4);fail();}catch(VerificationInOrderFailure e){}}
@Test(expected=ArgumentsAreDifferent.class)public void shouldFailOnFirstMethodBecauseDifferentArgsWanted(){inOrder.verify(mockOne).simpleMethod(100);}
@Test(expected=WantedButNotInvoked.class)public void shouldFailOnFirstMethodBecauseDifferentMethodWanted(){inOrder.verify(mockOne).oneArg(true);}
@Test public void shouldFailOnSecondMethodBecauseDifferentArgsWanted(){inOrder.verify(mockOne).simpleMethod(1);try {inOrder.verify(mockTwo,times(2)).simpleMethod(-999);fail();}catch(VerificationInOrderFailure e){}}
@Test public void shouldFailOnSecondMethodBecauseDifferentMethodWanted(){inOrder.verify(mockOne,times(1)).simpleMethod(1);try {inOrder.verify(mockTwo,times(2)).oneArg(true);fail();}catch(VerificationInOrderFailure e){}}
@Test public void shouldFailOnLastMethodBecauseDifferentArgsWanted(){inOrder.verify(mockOne).simpleMethod(1);inOrder.verify(mockTwo,times(2)).simpleMethod(2);inOrder.verify(mockThree).simpleMethod(3);inOrder.verify(mockTwo).simpleMethod(2);try {inOrder.verify(mockOne).simpleMethod(-666);fail();}catch(VerificationInOrderFailure e){}}
@Test public void shouldFailOnLastMethodBecauseDifferentMethodWanted(){inOrder.verify(mockOne).simpleMethod(1);inOrder.verify(mockTwo,times(2)).simpleMethod(2);inOrder.verify(mockThree).simpleMethod(3);inOrder.verify(mockTwo).simpleMethod(2);try {inOrder.verify(mockOne).oneArg(false);fail();}catch(VerificationInOrderFailure e){}}
@Test public void shouldFailWhenLastMethodVerifiedFirst(){inOrder.verify(mockOne).simpleMethod(4);try {inOrder.verify(mockOne).simpleMethod(1);fail();}catch(VerificationInOrderFailure e){}}
@Test public void shouldFailWhenMiddleMethodVerifiedFirst(){inOrder.verify(mockTwo,times(2)).simpleMethod(2);try {inOrder.verify(mockOne).simpleMethod(1);fail();}catch(VerificationInOrderFailure e){}}
@Test public void shouldFailWhenMiddleMethodVerifiedFirstInAtLeastOnceMode(){inOrder.verify(mockTwo,atLeastOnce()).simpleMethod(2);try {inOrder.verify(mockOne).simpleMethod(1);fail();}catch(VerificationInOrderFailure e){}}
@Test public void shouldFailOnVerifyNoMoreInteractions(){inOrder.verify(mockOne).simpleMethod(1);inOrder.verify(mockTwo,times(2)).simpleMethod(2);inOrder.verify(mockThree).simpleMethod(3);inOrder.verify(mockTwo).simpleMethod(2);try {verifyNoMoreInteractions(mockOne,mockTwo,mockThree);fail();}catch(NoInteractionsWanted e){}}
@Test(expected=NoInteractionsWanted.class)public void shouldFailOnVerifyZeroInteractions(){verifyZeroInteractions(mockOne);}
@SuppressWarnings("all")@Test(expected=MockitoException.class)public void shouldScreamWhenNullPassed(){inOrder((Object[])null);}
@Test public void should_pass_when_verification_passes(){Timeout t=new Timeout(1,3,mode,timer);when(timer.isCounting()).thenReturn(true);doNothing().when(mode).verify(data);t.verify(data);InOrder inOrder=inOrder(timer);inOrder.verify(timer).start();inOrder.verify(timer).isCounting();}
@Test public void should_fail_because_verification_fails(){Timeout t=new Timeout(1,2,mode,timer);when(timer.isCounting()).thenReturn(true,true,true,false);doThrow(error).doThrow(error).doThrow(error).when(mode).verify(data);try {t.verify(data);fail();}catch(MockitoAssertionError e){}verify(timer,times(4)).isCounting();}
@Test public void should_pass_even_if_first_verification_fails(){Timeout t=new Timeout(1,5,mode,timer);when(timer.isCounting()).thenReturn(true,true,true,false);doThrow(error).doThrow(error).doNothing().when(mode).verify(data);t.verify(data);verify(timer,times(3)).isCounting();}
@Test public void should_try_to_verify_correct_number_of_times(){}
@Test public void should_create_correctly_configured_timeout(){Timeout t=new Timeout(25,50,mode,timer);assertTimeoutCorrectlyConfigured(t.atLeastOnce(),Timeout.class,50,25,AtLeast.class);assertTimeoutCorrectlyConfigured(t.atLeast(5),Timeout.class,50,25,AtLeast.class);assertTimeoutCorrectlyConfigured(t.times(5),Timeout.class,50,25,Times.class);assertTimeoutCorrectlyConfigured(t.only(),Timeout.class,50,25,Only.class);}
@Test public void shouldNotFilterWhenConfigurationSaysNo(){ConfigurationAccess.getConfig().overrideCleansStackTrace(false);Throwable t=new TraceBuilder().classes("org.test.MockitoSampleTest","org.mockito.Mockito").toThrowable();filter.filter(t);assertThat(t,hasOnlyThoseClassesInStackTrace("org.mockito.Mockito","org.test.MockitoSampleTest"));}
@Test public void shouldFilterWhenConfigurationSaysYes(){ConfigurationAccess.getConfig().overrideCleansStackTrace(true);Throwable t=new TraceBuilder().classes("org.test.MockitoSampleTest","org.mockito.Mockito").toThrowable();filter.filter(t);assertThat(t,hasOnlyThoseClassesInStackTrace("org.test.MockitoSampleTest"));}
@Test public void should_init_spy_by_instance()throws Exception {doReturn("foo").when(spiedList).get(10);assertEquals("foo",spiedList.get(10));assertTrue(spiedList.isEmpty());}
@Test public void should_init_spy_and_automatically_create_instance()throws Exception {when(staticTypeWithNoArgConstructor.toString()).thenReturn("x");when(staticTypeWithoutDefinedConstructor.toString()).thenReturn("y");assertEquals("x",staticTypeWithNoArgConstructor.toString());assertEquals("y",staticTypeWithoutDefinedConstructor.toString());}
@Test public void should_prevent_spying_on_interfaces()throws Exception {class WithSpy {@Spy List<String> list;}WithSpy withSpy=new WithSpy();try {MockitoAnnotations.initMocks(withSpy);fail();}catch(MockitoException e){Assertions.assertThat(e.getMessage()).contains("is an interface and it cannot be spied on");}}
@Test public void should_allow_spying_on_interfaces_when_instance_is_concrete()throws Exception {class WithSpy {@Spy List<String> list=new LinkedList<String>();}WithSpy withSpy=new WithSpy();MockitoAnnotations.initMocks(withSpy);verify(withSpy.list,never()).clear();}
@Test public void should_report_when_no_arg_less_constructor()throws Exception {class FailingSpy {@Spy NoValidConstructor noValidConstructor;}try {MockitoAnnotations.initMocks(new FailingSpy());fail();}catch(MockitoException e){Assertions.assertThat(e.getMessage()).contains("0-arg constructor");}}
@Test public void should_report_when_constructor_is_explosive()throws Exception {class FailingSpy {@Spy ThrowingConstructor throwingConstructor;}try {MockitoAnnotations.initMocks(new FailingSpy());fail();}catch(MockitoException e){Assertions.assertThat(e.getMessage()).contains("Unable to create mock instance");}}
@Test public void should_spy_abstract_class()throws Exception {class SpyAbstractClass {@Spy AbstractList<String> list;List<String> asSingletonList(String s){when(list.size()).thenReturn(1);when(list.get(0)).thenReturn(s);return list;}}SpyAbstractClass withSpy=new SpyAbstractClass();MockitoAnnotations.initMocks(withSpy);assertEquals(Arrays.asList("a"),withSpy.asSingletonList("a"));}
@Test public void should_spy_inner_class()throws Exception {class WithMockAndSpy {@Spy private InnerStrength strength;@Mock private List<String> list;abstract class InnerStrength {private final String name;InnerStrength(){assertNotNull(list);this.name="inner";}abstract String strength();String fullStrength(){return name + " " + strength();}}}WithMockAndSpy outer=new WithMockAndSpy();MockitoAnnotations.initMocks(outer);when(outer.strength.strength()).thenReturn("strength");assertEquals("inner strength",outer.strength.fullStrength());}
@Test(expected=IndexOutOfBoundsException.class)public void should_reset_spy()throws Exception {spiedList.get(10);}
@Test public void should_report_when_encosing_instance_is_needed()throws Exception {class Outer {class Inner {}}class WithSpy {@Spy private Outer.Inner inner;}try {MockitoAnnotations.initMocks(new WithSpy());fail();}catch(MockitoException e){assertContains("@Spy annotation can only initialize inner classes",e.getMessage());}}
@Test public void should_capture_simple_arguments()throws Exception {VarargCapturingMatcher m=new VarargCapturingMatcher();m.captureFrom("foo");m.captureFrom("bar");assertThat(m.getAllVarargs()).containsSequence(asList("foo"),asList("bar"));}
@Test public void should_know_last_captured_vararg()throws Exception {VarargCapturingMatcher m=new VarargCapturingMatcher();m.captureFrom(new Object[]{"foo","bar"});m.captureFrom(new Object[]{"fool","bard"});assertThat(m.getLastVarargs()).containsSequence("fool","bard");}
@Test public void can_capture_primitive_varargs()throws Exception {VarargCapturingMatcher m=new VarargCapturingMatcher();m.captureFrom(new int[]{1,2,3});assertThat(m.getLastVarargs()).containsSequence(1,2,3);}
@Test public void should_scream_when_nothing_yet_captured()throws Exception {VarargCapturingMatcher m=new VarargCapturingMatcher();try {m.getLastVarargs();fail();}catch(MockitoException e){}}
@Test public void generic_deep_mock_frenzy__look_at_these_chained_calls()throws Exception {GenericsNest<?> mock=mock(GenericsNest.class,RETURNS_DEEP_STUBS);Set<? extends Map.Entry<? extends Cloneable,Set<Number>>> entries=mock.entrySet();Iterator<? extends Map.Entry<? extends Cloneable,Set<Number>>> entriesIterator=mock.entrySet().iterator();Map.Entry<? extends Cloneable,Set<Number>> nextEntry=mock.entrySet().iterator().next();Cloneable cloneableKey=mock.entrySet().iterator().next().getKey();Comparable<?> comparableKey=mock.entrySet().iterator().next().getKey();Set<Number> value=mock.entrySet().iterator().next().getValue();Iterator<Number> numbersIterator=mock.entrySet().iterator().next().getValue().iterator();Number number=mock.entrySet().iterator().next().getValue().iterator().next();}
@Test public void can_create_mock_from_multiple_type_variable_bounds_when_return_type_of_parameterized_method_is_a_parameterizedtype_that_is_referencing_a_typevar_on_class()throws Exception {GenericsNest<?> mock=mock(GenericsNest.class,RETURNS_DEEP_STUBS);Cloneable cloneable_bound_that_is_declared_on_typevar_K_in_the_class_which_is_referenced_by_typevar_O_declared_on_the_method=mock.paramTypeWithTypeParams().get(0);Comparable<?> comparable_bound_that_is_declared_on_typevar_K_in_the_class_which_is_referenced_by_typevar_O_declared_on_the_method=mock.paramTypeWithTypeParams().get(0);}
@Test public void can_create_mock_from_multiple_type_variable_bounds_when_method_return_type_is_referencing_a_typevar_on_class()throws Exception {GenericsNest<?> mock=mock(GenericsNest.class,RETURNS_DEEP_STUBS);Cloneable cloneable_bound_of_typevar_K=mock.returningK();Comparable<?> comparable_bound_of_typevar_K=mock.returningK();}
@Test public void can_create_mock_from_multiple_type_variable_bounds_when_return_type_of_parameterized_method_is_a_typevar_that_is_referencing_a_typevar_on_class()throws Exception {GenericsNest<?> mock=mock(GenericsNest.class,RETURNS_DEEP_STUBS);Cloneable cloneable_bound_of_typevar_K_referenced_by_typevar_O=(Cloneable)mock.typeVarWithTypeParams();Comparable<?> comparable_bound_of_typevar_K_referenced_by_typevar_O=(Comparable)mock.typeVarWithTypeParams();}
@Test public void can_create_mock_from_return_types_declared_with_a_bounded_wildcard()throws Exception {GenericsNest<?> mock=mock(GenericsNest.class,RETURNS_DEEP_STUBS);List<? super Integer> objects=mock.returningWildcard();Number type_that_is_the_upper_bound_of_the_wildcard=(Number)mock.returningWildcard().get(45);type_that_is_the_upper_bound_of_the_wildcard.floatValue();}
@Test public void can_still_work_with_raw_type_in_the_return_type()throws Exception {GenericsNest<?> mock=mock(GenericsNest.class,RETURNS_DEEP_STUBS);Number the_raw_type_that_should_be_returned=mock.returnsNormalType();the_raw_type_that_should_be_returned.floatValue();}
@Test public void will_return_default_value_on_non_mockable_nested_generic()throws Exception {GenericsNest<?> genericsNest=mock(GenericsNest.class,RETURNS_DEEP_STUBS);ListOfInteger listOfInteger=mock(ListOfInteger.class,RETURNS_DEEP_STUBS);assertThat(genericsNest.returningNonMockableNestedGeneric().keySet().iterator().next()).isNull();assertThat(listOfInteger.get(25)).isEqualTo(0);}
@Test(expected=ClassCastException.class)public void as_expected_fail_with_a_CCE_on_callsite_when_erasure_takes_place_for_example___StringBuilder_is_subject_to_erasure()throws Exception {GenericsNest<?> mock=mock(GenericsNest.class,RETURNS_DEEP_STUBS);StringBuilder stringBuilder_assignment_that_should_throw_a_CCE=mock.twoTypeParams(new StringBuilder()).append(2).append(3);}
@Test public void using_stub_only_wont_thrown_an_OutOfMemoryError(){Object obj=mock(Object.class,withSettings().stubOnly());when(obj.toString()).thenReturn("asdf");for (int i=0;i < 1000000;i++){obj.toString();}}
@Test @Ignore("ignored because it will detonate our test suite with an OOM for real")public void without_stub_only_mocks_will_store_invocations_leading_to_an_OutOfMemoryError(){Object obj=mock(Object.class,withSettings());when(obj.toString()).thenReturn("asdf");for (int i=0;i < 1000000;i++){obj.toString();}}
@Test public void should_be_able_to_return_the_first_parameter()throws Throwable {assertThat(new ReturnsArgumentAt(0).answer(invocationWith("A","B"))).isEqualTo("A");}
@Test public void should_be_able_to_return_the_second_parameter()throws Throwable {assertThat(new ReturnsArgumentAt(1).answer(invocationWith("A","B","C"))).isEqualTo("B");}
@Test public void should_be_able_to_return_the_last_parameter()throws Throwable {assertThat(new ReturnsArgumentAt(-1).answer(invocationWith("A"))).isEqualTo("A");assertThat(new ReturnsArgumentAt(-1).answer(invocationWith("A","B"))).isEqualTo("B");}
@Test public void should_be_able_to_return_the_specified_parameter()throws Throwable {assertThat(new ReturnsArgumentAt(0).answer(invocationWith("A","B","C"))).isEqualTo("A");assertThat(new ReturnsArgumentAt(1).answer(invocationWith("A","B","C"))).isEqualTo("B");assertThat(new ReturnsArgumentAt(2).answer(invocationWith("A","B","C"))).isEqualTo("C");}
@Test public void should_raise_an_exception_if_index_is_not_in_allowed_range_at_creation_time()throws Throwable {try {new ReturnsArgumentAt(-30);fail();}catch(Exception e){assertThat(e.getMessage()).containsIgnoringCase("argument index").containsIgnoringCase("positive number").contains("1").containsIgnoringCase("last argument");}}
@Test public void should_return_object_matching_given_types()throws Exception {ConstructorInjection.SimpleArgumentResolver resolver=new ConstructorInjection.SimpleArgumentResolver(newSetOf(new HashSet(),new ByteArrayOutputStream(),new HashMap()));Object[]resolvedInstance=resolver.resolveTypeInstances(Set.class,Map.class,OutputStream.class);assertEquals(3,resolvedInstance.length);assertTrue(resolvedInstance[0]instanceof Set);assertTrue(resolvedInstance[1]instanceof Map);assertTrue(resolvedInstance[2]instanceof OutputStream);}
@Test public void should_return_null_when_match_is_not_possible_on_given_types()throws Exception {ConstructorInjection.SimpleArgumentResolver resolver=new ConstructorInjection.SimpleArgumentResolver(newSetOf(new HashSet(),new ByteArrayOutputStream()));Object[]resolvedInstance=resolver.resolveTypeInstances(Set.class,Map.class,OutputStream.class);assertEquals(3,resolvedInstance.length);assertTrue(resolvedInstance[0]instanceof Set);assertNull(resolvedInstance[1]);assertTrue(resolvedInstance[2]instanceof OutputStream);}
@Test public void should_return_null_when_types_are_primitives()throws Exception {ConstructorInjection.SimpleArgumentResolver resolver=new ConstructorInjection.SimpleArgumentResolver(newSetOf(new HashMap(),new TreeSet()));Object[]resolvedInstance=resolver.resolveTypeInstances(Set.class,Map.class,Boolean.class);assertEquals(3,resolvedInstance.length);assertTrue(resolvedInstance[0]instanceof Set);assertTrue(resolvedInstance[1]instanceof Map);assertNull(resolvedInstance[2]);}
@Test public void shouldMockPackageProtectedClasses(){mock(PackageProtected.class);mock(Foo.class);mock(Bar.class);}
@Test public void shouldAllowVerifyingWhenOtherMockCallIsInTheSameLine(){when(mock.otherMethod()).thenReturn("foo");mockTwo.simpleMethod("foo");verify(mockTwo).simpleMethod(mock.otherMethod());try {verify(mockTwo,never()).simpleMethod(mock.otherMethod());fail();}catch(NeverWantedButInvoked e){}}
@Test public void shouldShareState()throws Exception {ThreadSafeMockingProgress p=new ThreadSafeMockingProgress();p.verificationStarted(new DummyVerificationMode());p=new ThreadSafeMockingProgress();assertNotNull(p.pullVerificationMode());}
@Test public void shouldKnowWhenVerificationHasStarted()throws Exception {verify(mock(List.class));ThreadSafeMockingProgress p=new ThreadSafeMockingProgress();assertNotNull(p.pullVerificationMode());}
@Test public void shouldLocationNotContainGetStackTraceMethod(){assertContains("shouldLocationNotContainGetStackTraceMethod",new LocationImpl().toString());}
@Test public void shouldBeSafeInCaseForSomeReasonFilteredStackTraceIsEmpty(){StackTraceFilter filterReturningEmptyArray=new StackTraceFilter(){@Override public StackTraceElement[]filter(StackTraceElement[]target,boolean keepTop){return new StackTraceElement[0];}};String loc=new LocationImpl(filterReturningEmptyArray).toString();assertEquals("-> at <<unknown line>>",loc);}
@Test public void shouldVerifyAtLeastXTimes()throws Exception {mock.clear();mock.clear();mock.clear();verify(mock,atLeast(2)).clear();}
@Test public void shouldFailVerifiationAtLeastXTimes()throws Exception {mock.add("one");verify(mock,atLeast(1)).add(anyString());try {verify(mock,atLeast(2)).add(anyString());fail();}catch(MockitoAssertionError e){}}
@Test public void shouldAllowAtLeastZeroForTheSakeOfVerifyNoMoreInteractionsSometimes()throws Exception {mock.add("one");mock.clear();verify(mock,atLeast(0)).add("one");verify(mock,atLeast(0)).clear();verifyNoMoreInteractions(mock);}
@Test public void testCompleteProgress()throws Exception {IProgressMonitor progressMonitor=mock(IProgressMonitor.class);progressMonitor.beginTask("foo",12);progressMonitor.worked(10);progressMonitor.done();verify(progressMonitor).beginTask(anyString(),anyInt());verify(progressMonitor,atLeastOnce()).worked(anyInt());}
@Test public void shouldMatchWhenFieldValuesEqual()throws Exception {Child wanted=new Child(1,"foo",2,"bar");verify(mock).run(refEq(wanted));}
@Test(expected=ArgumentsAreDifferent.class)public void shouldNotMatchWhenFieldValuesDiffer()throws Exception {Child wanted=new Child(1,"foo",2,"bar XXX");verify(mock).run(refEq(wanted));}
@Test(expected=ArgumentsAreDifferent.class)public void shouldNotMatchAgain()throws Exception {Child wanted=new Child(1,"foo",999,"bar");verify(mock).run(refEq(wanted));}
@Test(expected=ArgumentsAreDifferent.class)public void shouldNotMatchYetAgain()throws Exception {Child wanted=new Child(1,"XXXXX",2,"bar");verify(mock).run(refEq(wanted));}
@Test(expected=ArgumentsAreDifferent.class)public void shouldNotMatch()throws Exception {Child wanted=new Child(234234,"foo",2,"bar");verify(mock).run(refEq(wanted));}
@Test public void shouldMatchWhenFieldValuesEqualWithOneFieldExcluded()throws Exception {Child wanted=new Child(1,"foo",2,"excluded");verify(mock).run(refEq(wanted,"childFieldTwo"));}
@Test public void shouldMatchWhenFieldValuesEqualWithTwoFieldsExcluded()throws Exception {Child wanted=new Child(234234,"foo",2,"excluded");verify(mock).run(refEq(wanted,"childFieldTwo","parentField"));verify(mock).run(refEq(wanted,"parentField","childFieldTwo"));}
@Test(expected=ArgumentsAreDifferent.class)public void shouldNotMatchWithFieldsExclusion()throws Exception {Child wanted=new Child(234234,"foo",2,"excluded");verify(mock).run(refEq(wanted,"childFieldTwo"));}
@Test public void shouldRemoveMockitoInternalsFromStackTraceWhenRealMethodThrows()throws Throwable {CleanTraceRealMethod realMethod=new CleanTraceRealMethod(new RealMethod(){public Object invoke(Object target,Object[]arguments)throws Throwable {return new Foo().throwSomething();}});try {realMethod.invoke(null,null);fail();}catch(Exception e){assertThat(e,hasMethodInStackTraceAt(0,"throwSomething"));assertThat(e,hasMethodInStackTraceAt(1,"invoke"));assertThat(e,hasMethodInStackTraceAt(2,"shouldRemoveMockitoInternalsFromStackTraceWhenRealMethodThrows"));}}
@Test public void shouldNotThrowCCE(){mock.simpleMethod(new Object());try {verify(mock).simpleMethod(argThat(isStringWithTextFoo()));fail();}catch(ArgumentsAreDifferent e){}}
@Test public void shouldDetectTooLittleActualInvocations()throws Exception {mock.clear();mock.clear();verify(mock,times(2)).clear();try {verify(mock,times(100)).clear();fail();}catch(TooLittleActualInvocations e){assertContains("Wanted 100 times",e.getMessage());assertContains("was 2",e.getMessage());}}
@Test public void shouldDetectTooManyActualInvocations()throws Exception {mock.clear();mock.clear();verify(mock,times(2)).clear();try {verify(mock,times(1)).clear();fail();}catch(TooManyActualInvocations e){assertContains("Wanted 1 time",e.getMessage());assertContains("was 2 times",e.getMessage());}}
@Test public void shouldDetectActualInvocationsCountIsMoreThanZero()throws Exception {verify(mock,times(0)).clear();try {verify(mock,times(15)).clear();fail();}catch(WantedButNotInvoked e){}}
@Test public void shouldDetectActuallyCalledOnce()throws Exception {mock.clear();try {verify(mock,times(0)).clear();fail();}catch(NeverWantedButInvoked e){assertContains("Never wanted here",e.getMessage());}}
@Test public void shouldPassWhenMethodsActuallyNotCalled()throws Exception {verify(mock,times(0)).clear();verify(mock,times(0)).add("yes,I wasn't called");}
@Test public void shouldNotCountInStubbedInvocations()throws Exception {when(mock.add("test")).thenReturn(false);when(mock.add("test")).thenReturn(true);mock.add("test");mock.add("test");verify(mock,times(2)).add("test");}
@Test public void shouldAllowVerifyingInteractionNeverHappened()throws Exception {mock.add("one");verify(mock,never()).add("two");verify(mock,never()).clear();try {verify(mock,never()).add("one");fail();}catch(NeverWantedButInvoked e){}}
@Test public void shouldAllowVerifyingInteractionNeverHappenedInOrder()throws Exception {mock.add("one");mock.add("two");InOrder inOrder=inOrder(mock);inOrder.verify(mock,never()).add("xxx");inOrder.verify(mock).add("one");inOrder.verify(mock,never()).add("one");try {inOrder.verify(mock,never()).add("two");fail();}catch(VerificationInOrderFailure e){}}
@Test public void shouldHaveBridgeMethod()throws Exception {Super s=new Sub();assertEquals("Dummy says: Hello",s.say("Hello"));assertThat(Sub.class,hasBridgeMethod("say"));assertThat(s,hasBridgeMethod("say"));}
@Test public void shouldVerifyCorrectlyWhenBridgeMethodCalled()throws Exception {Sub s=mock(Sub.class);setMockWithDownCast(s);say("Hello");verify(s).say("Hello");}
@Test public void should_not_allow_extra_interface_that_is_the_same_as_the_mocked_type()throws Exception {try {validator.validateExtraInterfaces(IMethods.class,(Collection)asList(IMethods.class));fail();}catch(MockitoException e){assertThat(e.getMessage()).contains("You mocked following type: IMethods");}}
@Test(expected=MockitoException.class)public void should_not_allow_inconsistent_types()throws Exception {validator.validateMockedType(List.class,new ArrayList());}
@Test public void should_allow_only_consistent_types()throws Exception {validator.validateMockedType(ArrayList.class,new ArrayList());}
@Test public void should_validation_be_safe_when_nulls_passed()throws Exception {validator.validateMockedType(null,new ArrayList());validator.validateMockedType(ArrayList.class,null);}
@Test(expected=MockitoException.class)public void should_not_allow_serializable_with_Object_that_dont_implement_Serializable(){class NonSerializableInnerClassThatHaveAHiddenOneArgConstructor {}boolean serializable=true;validator.validateSerializable(NonSerializableInnerClassThatHaveAHiddenOneArgConstructor.class,serializable);}
@Test public void should_allow_serializable_with_interfaces_or_Serializable_objects(){boolean serializable=true;validator.validateSerializable(Observer.class,serializable);validator.validateSerializable(Integer.class,serializable);}
@Test public void tell_handy_return_values_to_return_value_for()throws Exception {final Object expected=new Object();ArgumentCaptor<Object> argumentCaptor=ArgumentCaptor.forClass(Object.class);argumentCaptor.handyReturnValues=will_return(expected);Object returned=argumentCaptor.capture();assertEquals(expected,returned);}
@Ignore("prototyping new feature that allows to avoid eq()matchers when raw args passed")@Test public void shouldAllowMixingRawArgumentsWithMatchers(){mock.varargs("1","2","3");verify(mock).varargs("1",anyString(),"3");verify(mock).varargs(anyBoolean(),false);}
@Test(expected=TooLittleActualInvocations.class)public void shouldLetPassingNullLastActualStackTrace()throws Exception {new Reporter().tooLittleActualInvocations(new org.mockito.internal.reporting.Discrepancy(1,2),new InvocationBuilder().toInvocation(),null);}
@Test(expected=MockitoException.class)public void shouldThrowCorrectExceptionForNullInvocationListener()throws Exception {new Reporter().invocationListenerDoesNotAcceptNullParameters();}
@Test public void shouldFailIfCaptorHasWrongType()throws Exception {try {MockitoAnnotations.initMocks(this);fail();}catch(MockitoException e){assertContains("notACaptorField",e.getMessage());assertContains("wrong type",e.getMessage());}}
@SuppressWarnings("all")@Test public void tryDescriptiveMessagesOnMisuse(){Foo foo=mock(Foo.class);}
@Test(expected=NotAMockException.class)public void shouldScreamWhenWholeMethodPassedToVerify(){verify(mock.booleanReturningMethod());}
@Test(expected=NotAMockException.class)public void shouldScreamWhenWholeMethodPassedToVerifyNoMoreInteractions(){verifyNoMoreInteractions(mock.byteReturningMethod());}
@Test(expected=NotAMockException.class)public void shouldScreamWhenInOrderCreatedWithDodgyMock(){inOrder("not a mock");}
@Test(expected=NullInsteadOfMockException.class)public void shouldScreamWhenInOrderCreatedWithNulls(){inOrder(mock,null);}
@Test(expected=NullInsteadOfMockException.class)public void shouldScreamNullPassedToVerify(){verify(null);}
@Test(expected=NullInsteadOfMockException.class)public void shouldScreamWhenNotMockPassedToVerifyNoMoreInteractions(){verifyNoMoreInteractions(null,"blah");}
@SuppressWarnings("all")@Test(expected=MockitoException.class)public void shouldScreamWhenNullPassedToVerifyNoMoreInteractions(){verifyNoMoreInteractions((Object[])null);}
@Test public void shouldBeSerializable()throws Exception {ByteArrayOutputStream serialized=new ByteArrayOutputStream();new ObjectOutputStream(serialized).writeObject(method);}
@Test public void shouldBeAbleToRetrieveMethodExceptionTypes()throws Exception {assertArrayEquals(toStringMethod.getExceptionTypes(),method.getExceptionTypes());}
@Test public void shouldBeAbleToRetrieveMethodName()throws Exception {assertEquals(toStringMethod.getName(),method.getName());}
@Test public void shouldBeAbleToCheckIsArgVargs()throws Exception {assertEquals(toStringMethod.isVarArgs(),method.isVarArgs());}
@Test public void shouldBeAbleToGetParameterTypes()throws Exception {assertArrayEquals(toStringMethod.getParameterTypes(),method.getParameterTypes());}
@Test public void shouldBeAbleToGetReturnType()throws Exception {assertEquals(toStringMethod.getReturnType(),method.getReturnType());}
@Test public void shouldBeEqualForTwoInstances()throws Exception {assertTrue(new SerializableMethod(toStringMethod).equals(method));}
@Test public void shouldNotBeEqualForSameMethodFromTwoDifferentClasses()throws Exception {Method testBaseToStringMethod=String.class.getMethod("toString",args);assertFalse(new SerializableMethod(testBaseToStringMethod).equals(method));}
@Test public void shouldToStringBeNotVerifiable()throws Exception {InvocationMatcher toString=new InvocationBuilder().method("toString").toInvocationMatcher();try {new VerificationDataImpl(null,toString);fail();}catch(MockitoException e){}}
@Test public void shouldVerify()throws Exception {mock.clear();verify(mock).clear();mock.add("test");verify(mock).add("test");verifyNoMoreInteractions(mock);}
@Test(expected=WantedButNotInvoked.class)public void shouldFailVerification()throws Exception {verify(mock).clear();}
@Test public void shouldFailVerificationOnMethodArgument()throws Exception {mock.clear();mock.add("foo");verify(mock).clear();try {verify(mock).add("bar");fail();}catch(AssertionError expected){}}
@Test public void shouldFailOnWrongMethod()throws Exception {mock.clear();mock.clear();mockTwo.add("add");verify(mock,atLeastOnce()).clear();verify(mockTwo,atLeastOnce()).add("add");try {verify(mockTwo,atLeastOnce()).add("foo");fail();}catch(WantedButNotInvoked e){}}
@Test public void shouldDetectRedundantInvocation()throws Exception {mock.clear();mock.add("foo");mock.add("bar");verify(mock).clear();verify(mock).add("foo");try {verifyNoMoreInteractions(mock);fail();}catch(NoInteractionsWanted e){}}
@Test public void shouldDetectWhenInvokedMoreThanOnce()throws Exception {mock.add("foo");mock.clear();mock.clear();verify(mock).add("foo");try {verify(mock).clear();fail();}catch(TooManyActualInvocations e){}}
@Test public void shouldVerifyStubbedMethods()throws Exception {when(mock.add("test")).thenReturn(Boolean.FALSE);mock.add("test");verify(mock).add("test");}
@Test public void shouldDetectWhenOverloadedMethodCalled()throws Exception {IMethods mockThree=mock(IMethods.class);mockThree.varargs((Object[])new Object[]{});try {verify(mockThree).varargs((String[])new String[]{});fail();}catch(WantedButNotInvoked e){}}
@Test public void shouldVerifyAllInvocationsInOrder(){InOrder inOrder=inOrder(mockOne,mockTwo,mockThree);inOrder.verify(mockOne).simpleMethod(1);inOrder.verify(mockTwo,times(2)).simpleMethod(2);inOrder.verify(mockThree).simpleMethod(3);inOrder.verify(mockTwo).simpleMethod(2);inOrder.verify(mockOne).simpleMethod(4);verifyNoMoreInteractions(mockOne,mockTwo,mockThree);}
@Test public void shouldVerifyInOrderMockTwoAndThree(){InOrder inOrder=inOrder(mockTwo,mockThree);inOrder.verify(mockTwo,times(2)).simpleMethod(2);inOrder.verify(mockThree).simpleMethod(3);inOrder.verify(mockTwo).simpleMethod(2);verifyNoMoreInteractions(mockTwo,mockThree);}
@Test public void shouldVerifyInOrderMockOneAndThree(){InOrder inOrder=inOrder(mockOne,mockThree);inOrder.verify(mockOne).simpleMethod(1);inOrder.verify(mockThree).simpleMethod(3);inOrder.verify(mockOne).simpleMethod(4);verifyNoMoreInteractions(mockOne,mockThree);}
@Test public void shouldVerifyMockOneInOrder(){InOrder inOrder=inOrder(mockOne);inOrder.verify(mockOne).simpleMethod(1);inOrder.verify(mockOne).simpleMethod(4);verifyNoMoreInteractions(mockOne);}
@Test public void shouldFailVerificationForMockOne(){InOrder inOrder=inOrder(mockOne);inOrder.verify(mockOne).simpleMethod(1);try {inOrder.verify(mockOne).differentMethod();fail();}catch(VerificationInOrderFailure e){}}
@Test public void shouldFailVerificationForMockOneBecauseOfWrongOrder(){InOrder inOrder=inOrder(mockOne);inOrder.verify(mockOne).simpleMethod(4);try {inOrder.verify(mockOne).simpleMethod(1);fail();}catch(VerificationInOrderFailure e){}}
@Test public void shouldVerifyMockTwoWhenThreeTimesUsed(){InOrder inOrder=inOrder(mockTwo);inOrder.verify(mockTwo,times(3)).simpleMethod(2);verifyNoMoreInteractions(mockTwo);}
@Test public void shouldVerifyMockTwo(){InOrder inOrder=inOrder(mockTwo);inOrder.verify(mockTwo,atLeastOnce()).simpleMethod(2);verifyNoMoreInteractions(mockTwo);}
@Test public void shouldFailVerificationForMockTwo(){InOrder inOrder=inOrder(mockTwo);try {inOrder.verify(mockTwo).simpleMethod(2);fail();}catch(VerificationInOrderFailure e){}}
@Test public void shouldThrowNoMoreInvocationsForMockTwo(){InOrder inOrder=inOrder(mockTwo);try {inOrder.verify(mockTwo,times(2)).simpleMethod(2);fail();}catch(VerificationInOrderFailure e){}}
@Test public void shouldThrowTooLittleInvocationsForMockTwo(){InOrder inOrder=inOrder(mockTwo);try {inOrder.verify(mockTwo,times(4)).simpleMethod(2);fail();}catch(VerificationInOrderFailure e){}}
@Test public void shouldThrowTooManyInvocationsForMockTwo(){InOrder inOrder=inOrder(mockTwo);try {inOrder.verify(mockTwo,times(2)).simpleMethod(2);fail();}catch(VerificationInOrderFailure e){}}
@Test public void shouldAllowThreeTimesOnMockTwo(){InOrder inOrder=inOrder(mockTwo);inOrder.verify(mockTwo,times(3)).simpleMethod(2);verifyNoMoreInteractions(mockTwo);}
@Test public void shouldVerifyMockTwoCompletely(){InOrder inOrder=inOrder(mockTwo,mockThree);inOrder.verify(mockTwo,times(2)).simpleMethod(2);inOrder.verify(mockThree).simpleMethod(3);inOrder.verify(mockTwo).simpleMethod(2);verifyNoMoreInteractions(mockTwo,mockThree);}
@Test public void shouldAllowTwoTimesOnMockTwo(){InOrder inOrder=inOrder(mockTwo,mockThree);inOrder.verify(mockTwo,times(2)).simpleMethod(2);try {verifyNoMoreInteractions(mockTwo);fail();}catch(NoInteractionsWanted e){}}
@Test public void shouldVerifyUsingMatchers()throws Exception {List list=Mockito.mock(List.class);HashMap map=Mockito.mock(HashMap.class);list.add("test");list.add(1,"test two");map.put("test",100);map.put("test two",200);verify(list).add(anyObject());verify(list).add(anyInt(),eq("test two"));verify(map,times(2)).put(anyObject(),anyObject());verify(map).put(eq("test two"),eq(200));verifyNoMoreInteractions(list,map);}
@Test public void shouldVerifyMultipleMocks()throws Exception {List list=mock(List.class);Map map=mock(Map.class);Set set=mock(Set.class);list.add("one");list.add("one");list.add("two");map.put("one",1);map.put("one",1);verify(list,times(2)).add("one");verify(list,times(1)).add("two");verify(list,times(0)).add("three");verify(map,times(2)).put(anyObject(),anyInt());verifyNoMoreInteractions(list,map);verifyZeroInteractions(set);}
@Test public void shouldValidateExplicitly(){verify(mock);try {Mockito.validateMockitoUsage();fail();}catch(UnfinishedVerificationException e){}}
@Test public void shouldDetectUnfinishedStubbing(){when(mock.simpleMethod());try {Mockito.validateMockitoUsage();fail();}catch(UnfinishedStubbingException e){}}
@Test public void shouldDetectMisplacedArgumentMatcher(){anyObject();try {Mockito.validateMockitoUsage();fail();}catch(InvalidUseOfMatchersException e){}}
@Test public void shouldReadConfigurationClassFromClassPath(){ConfigurationAccess.getConfig().overrideDefaultAnswer(new Answer<Object>(){public Object answer(InvocationOnMock invocation){return "foo";}});IMethods mock=mock(IMethods.class);assertEquals("foo",mock.simpleMethod());}
@Test public void someTest(){}
@Test public void shouldKnowWhenClassHasTests(){assertTrue(new TestMethodsFinder().hasTestMethods(HasTests.class));assertFalse(new TestMethodsFinder().hasTestMethods(DoesNotHaveTests.class));}
@Test public void shouldAllowInlineMockCreation(){when(list.get(0)).thenReturn(mock(Set.class));assertTrue(list.get(0)instanceof Set);}
@Test public void shouldUseCustomAnnotation(){assertEquals("SmartMock should return empty String by default","",smartMock.simpleMethod(1));verify(smartMock).simpleMethod(1);}
@Test public void shouldAllowVerifyingInThreads()throws Exception {for (int i=0;i < 100;i++){performTest();}}
@Test public void can_add_mock_that_have_failing_hashCode_method()throws Exception {new HashCodeAndEqualsSafeSet().add(mock(UnmockableHashCodeAndEquals.class));}
@Test public void mock_with_failing_hashCode_method_can_be_added()throws Exception {new HashCodeAndEqualsSafeSet().add(mock(UnmockableHashCodeAndEquals.class));}
@Test public void mock_with_failing_equals_method_can_be_used()throws Exception {HashCodeAndEqualsSafeSet mocks=new HashCodeAndEqualsSafeSet();UnmockableHashCodeAndEquals mock=mock(UnmockableHashCodeAndEquals.class);mocks.add(mock);assertThat(mocks.contains(mock)).isTrue();assertThat(mocks.contains(mock(UnmockableHashCodeAndEquals.class))).isFalse();}
@Test public void can_remove()throws Exception {HashCodeAndEqualsSafeSet mocks=new HashCodeAndEqualsSafeSet();UnmockableHashCodeAndEquals mock=mock(UnmockableHashCodeAndEquals.class);mocks.add(mock);mocks.remove(mock);assertThat(mocks.isEmpty()).isTrue();}
@Test public void can_add_a_collection()throws Exception {HashCodeAndEqualsSafeSet mocks=HashCodeAndEqualsSafeSet.of(mock(UnmockableHashCodeAndEquals.class),mock(Observer.class));HashCodeAndEqualsSafeSet workingSet=new HashCodeAndEqualsSafeSet();workingSet.addAll(mocks);assertThat(workingSet.containsAll(mocks)).isTrue();}
@Test public void can_retain_a_collection()throws Exception {HashCodeAndEqualsSafeSet mocks=HashCodeAndEqualsSafeSet.of(mock(UnmockableHashCodeAndEquals.class),mock(Observer.class));HashCodeAndEqualsSafeSet workingSet=new HashCodeAndEqualsSafeSet();workingSet.addAll(mocks);workingSet.add(mock(List.class));assertThat(workingSet.retainAll(mocks)).isTrue();assertThat(workingSet.containsAll(mocks)).isTrue();}
@Test public void can_remove_a_collection()throws Exception {HashCodeAndEqualsSafeSet mocks=HashCodeAndEqualsSafeSet.of(mock(UnmockableHashCodeAndEquals.class),mock(Observer.class));HashCodeAndEqualsSafeSet workingSet=new HashCodeAndEqualsSafeSet();workingSet.addAll(mocks);workingSet.add(mock(List.class));assertThat(workingSet.removeAll(mocks)).isTrue();assertThat(workingSet.containsAll(mocks)).isFalse();}
@Test public void can_iterate()throws Exception {HashCodeAndEqualsSafeSet mocks=HashCodeAndEqualsSafeSet.of(mock(UnmockableHashCodeAndEquals.class),mock(Observer.class));LinkedList<Object> accumulator=new LinkedList<Object>();for(Object mock : mocks){accumulator.add(mock);}assertThat(accumulator).isNotEmpty();}
@Test public void toArray_just_work()throws Exception {UnmockableHashCodeAndEquals mock1=mock(UnmockableHashCodeAndEquals.class);HashCodeAndEqualsSafeSet mocks=HashCodeAndEqualsSafeSet.of(mock1);assertThat(mocks.toArray()[0]).isSameAs(mock1);assertThat(mocks.toArray(new UnmockableHashCodeAndEquals[0])[0]).isSameAs(mock1);}
@Test public void should_detect_wrong_number_of_matchers_when_stubbing(){when(mock.threeArgumentMethod(1,"2","3")).thenReturn(null);try {when(mock.threeArgumentMethod(1,eq("2"),"3")).thenReturn(null);fail();}catch(InvalidUseOfMatchersException e){assertThat(e.getMessage()).contains("3 matchers expected").contains("1 recorded");}}
@Test public void should_detect_stupid_use_of_matchers_when_verifying(){mock.oneArg(true);eq("that's the stupid way");eq("of using matchers");try {Mockito.verify(mock).oneArg(true);fail();}catch(InvalidUseOfMatchersException e){assertThat(e.getMessage()).contains("Misplaced argument matcher detected here");e.printStackTrace();}}
@Test public void should_not_scream_on_correct_usage()throws Exception {mock.simpleMethod(AdditionalMatchers.not(eq("asd")));mock.simpleMethod(AdditionalMatchers.or(eq("jkl"),eq("asd")));}
@Test public void should_scream_when_no_matchers_inside_not(){try {mock.simpleMethod(AdditionalMatchers.not("jkl"));fail();}catch(InvalidUseOfMatchersException e){assertThat(e.getMessage()).contains("No matchers found for").containsIgnoringCase("Not(?)");}}
@Test public void should_scream_when_not_enough_matchers_inside_or_AddtionalMatcher(){try {mock.simpleMethod(AdditionalMatchers.or(eq("jkl"),"asd"));fail();}catch(InvalidUseOfMatchersException e){assertThat(e.getMessage()).containsIgnoringCase("inside additional matcher Or(?)").contains("2 sub matchers expected").contains("1 recorded");}}
@Test public void should_scream_when_Matchers_count_dont_match_parameter_count(){try {mock.threeArgumentMethod(1,"asd",eq("asd"));fail();}catch(InvalidUseOfMatchersException e){assertThat(e.getMessage()).contains("3 matchers expected").contains("1 recorded");}}
@Test public void shouldPassIfWantedIsZeroAndMatchingChunkIsEmpty()throws Exception {assertTrue(finderStub.validMatchingChunkToReturn.isEmpty());checker.check(invocations,wanted,0,context);}
@Test public void shouldPassIfChunkMatches()throws Exception {finderStub.validMatchingChunkToReturn.add(wanted.getInvocation());checker.check(invocations,wanted,1,context);}
@Test public void shouldReportTooLittleInvocations()throws Exception {Invocation first=new InvocationBuilder().toInvocation();Invocation second=new InvocationBuilder().toInvocation();finderStub.validMatchingChunkToReturn.addAll(asList(first,second));try {checker.check(invocations,wanted,4,context);fail();}catch(VerificationInOrderFailure e){assertContains("Wanted 4 times",e.getMessage());assertContains("But was 2 times",e.getMessage());}}
@Test public void shouldReportTooManyInvocations()throws Exception {Invocation first=new InvocationBuilder().toInvocation();Invocation second=new InvocationBuilder().toInvocation();finderStub.validMatchingChunkToReturn.addAll(asList(first,second));try {checker.check(invocations,wanted,1,context);fail();}catch(VerificationInOrderFailure e){assertContains("Wanted 1 time",e.getMessage());assertContains("But was 2 times",e.getMessage());}}
@Test public void shouldMarkAsVerifiedInOrder()throws Exception {Invocation invocation=new InvocationBuilder().toInvocation();assertFalse(context.isVerified(invocation));finderStub.validMatchingChunkToReturn.addAll(asList(invocation));checker.check(invocations,wanted,1,context);assertTrue(context.isVerified(invocation));}
@Test public void shouldPrintInvocations(){Invocation verified=new InvocationBuilder().simpleMethod().verified().toInvocation();Invocation unverified=new InvocationBuilder().differentMethod().toInvocation();String out=sp.print((List)asList(verified,unverified));assertContains("1. -> at",out);assertContains("2. [?]-> at",out);}
@Test public void shouldNotPrintInvocationsWhenSingleUnwanted(){Invocation unverified=new InvocationBuilder().differentMethod().toInvocation();String out=sp.print((List)asList(unverified));assertContains("Actually,above is the only interaction with this mock.",out);}
@Test public void mock_declared_fields_shall_be_injected_too()throws Exception {assertNotNull(receiver.oldAntenna);assertNotNull(receiver.satelliteAntenna);assertNotNull(receiver.dvbtAntenna);assertNotNull(receiver.tuner);}
@Test public void unnamed_mocks_should_be_resolved_withe_their_field_names()throws Exception {assertSame(oldAntenna,receiver.oldAntenna);assertSame(satelliteAntenna,receiver.satelliteAntenna);}
@Test public void named_mocks_should_be_resolved_with_their_name()throws Exception {assertSame(antenna,receiver.dvbtAntenna);}
@Test public void inject_mocks_even_in_declared_spy()throws Exception {assertNotNull(spiedReceiver.oldAntenna);assertNotNull(spiedReceiver.tuner);}
@Test public void should_compare_to_be_consistent_with_equals(){Date today=mock(Date.class);Date tomorrow=mock(Date.class);Set<Date> set=new TreeSet<Date>();set.add(today);set.add(tomorrow);assertEquals(2,set.size());}
@Test public void should_compare_to_be_consistent_with_equals_when_comparing_the_same_reference(){Date today=mock(Date.class);Set<Date> set=new TreeSet<Date>();set.add(today);set.add(today);assertEquals(1,set.size());}
@Test public void should_allow_stubbing_and_verifying_compare_to(){Date mock=mock(Date.class);when(mock.compareTo(any(Date.class))).thenReturn(10);mock.compareTo(new Date());assertEquals(10,mock.compareTo(new Date()));verify(mock,atLeastOnce()).compareTo(any(Date.class));}
@Test public void should_reset_not_remove_default_stubbing(){Date mock=mock(Date.class);reset(mock);assertEquals(1,mock.compareTo(new Date()));}
@Test public void should_not_return_to_string_method()throws Exception {Invocation toString=new InvocationBuilder().method("toString").toInvocation();Invocation simpleMethod=new InvocationBuilder().simpleMethod().toInvocation();invocations.add(toString);invocations.add(simpleMethod);assertTrue(invocations.getAll().contains(simpleMethod));assertFalse(invocations.getAll().contains(toString));}
@Test public void shouldStub()throws Exception {given(mock.simpleMethod("foo")).willReturn("bar");assertEquals("bar",mock.simpleMethod("foo"));assertEquals(null,mock.simpleMethod("whatever"));}
@Test public void shouldStubWithThrowable()throws Exception {given(mock.simpleMethod("foo")).willThrow(new RuntimeException());try {assertEquals("foo",mock.simpleMethod("foo"));fail();}catch(RuntimeException e){}}
@Test public void shouldStubWithThrowableClass()throws Exception {given(mock.simpleMethod("foo")).willThrow(RuntimeException.class);try {assertEquals("foo",mock.simpleMethod("foo"));fail();}catch(RuntimeException e){}}
@Test public void shouldStubWithAnswer()throws Exception {given(mock.simpleMethod(anyString())).willAnswer(new Answer<String>(){public String answer(InvocationOnMock invocation)throws Throwable {return (String)invocation.getArguments()[0];}});assertEquals("foo",mock.simpleMethod("foo"));}
@Test public void shouldStubWithWillAnswerAlias()throws Exception {given(mock.simpleMethod(anyString())).will(new Answer<String>(){public String answer(InvocationOnMock invocation)throws Throwable {return (String)invocation.getArguments()[0];}});assertEquals("foo",mock.simpleMethod("foo"));}
@Test public void shouldStubConsecutively()throws Exception {given(mock.simpleMethod(anyString())).willReturn("foo").willReturn("bar");assertEquals("foo",mock.simpleMethod("whatever"));assertEquals("bar",mock.simpleMethod("whatever"));}
@Test public void shouldStubConsecutivelyWithCallRealMethod()throws Exception {MethodsImpl mock=mock(MethodsImpl.class);willReturn("foo").willCallRealMethod().given(mock).simpleMethod();assertEquals("foo",mock.simpleMethod());assertEquals(null,mock.simpleMethod());}
@Test public void shouldStubVoid()throws Exception {willThrow(new RuntimeException()).given(mock).voidMethod();try {mock.voidMethod();fail();}catch(RuntimeException e){}}
@Test public void shouldStubVoidWithExceptionClass()throws Exception {willThrow(RuntimeException.class).given(mock).voidMethod();try {mock.voidMethod();fail();}catch(RuntimeException e){}}
@Test public void shouldStubVoidConsecutively()throws Exception {willDoNothing().willThrow(new RuntimeException()).given(mock).voidMethod();mock.voidMethod();try {mock.voidMethod();fail();}catch(RuntimeException e){}}
@Test public void shouldStubVoidConsecutivelyWithExceptionClass()throws Exception {willDoNothing().willThrow(IllegalArgumentException.class).given(mock).voidMethod();mock.voidMethod();try {mock.voidMethod();fail();}catch(IllegalArgumentException e){}}
@Test public void shouldStubUsingDoReturnStyle()throws Exception {willReturn("foo").given(mock).simpleMethod("bar");assertEquals(null,mock.simpleMethod("boooo"));assertEquals("foo",mock.simpleMethod("bar"));}
@Test public void shouldStubUsingDoAnswerStyle()throws Exception {willAnswer(new Answer<String>(){public String answer(InvocationOnMock invocation)throws Throwable {return (String)invocation.getArguments()[0];}}).given(mock).simpleMethod(anyString());assertEquals("foo",mock.simpleMethod("foo"));}
@Test public void shouldStubByDelegatingToRealMethod()throws Exception {Dog dog=mock(Dog.class);willCallRealMethod().given(dog).bark();assertEquals("woof",dog.bark());}
@Test public void shouldStubByDelegatingToRealMethodUsingTypicalStubbingSyntax()throws Exception {Dog dog=mock(Dog.class);given(dog.bark()).willCallRealMethod();assertEquals("woof",dog.bark());}
@Test public void shouldAllStubbedMockReferenceAccess()throws Exception {Set expectedMock=mock(Set.class);Set returnedMock=given(expectedMock.isEmpty()).willReturn(false).getMock();assertEquals(expectedMock,returnedMock);}
@Test(expected=NotAMockException.class)public void shouldValidateMockWhenVerifying(){then("notMock").should();}
@Test(expected=NotAMockException.class)public void shouldValidateMockWhenVerifyingWithExpectedNumberOfInvocations(){then("notMock").should(times(19));}
@Test(expected=NotAMockException.class)public void shouldValidateMockWhenVerifyingNoMoreInteractions(){then("notMock").should();}
@Test(expected=WantedButNotInvoked.class)public void shouldFailForExpectedBehaviorThatDidNotHappen(){then(mock).should().booleanObjectReturningMethod();}
@Test public void shouldPassForExpectedBehaviorThatHappened(){mock.booleanObjectReturningMethod();then(mock).should().booleanObjectReturningMethod();}
@Test public void shouldPassFluentBddScenario(){Bike bike=new Bike();Person person=mock(Person.class);person.ride(bike);person.ride(bike);then(person).should(times(2)).ride(bike);}
@Test public void shouldNotReportArgumentTypesWhenToStringIsTheSame()throws Exception {Boo boo=mock(Boo.class);boo.withLong(100);try {verify(boo).withLong(eq(100));fail();}catch(ArgumentsAreDifferent e){assertContains("withLong((Integer)100);",e.getMessage());assertContains("withLong((Long)100);",e.getMessage());}}
@Test public void shouldShowTheTypeOfOnlyTheArgumentThatDoesntMatch()throws Exception {Boo boo=mock(Boo.class);boo.withLongAndInt(100,200);try {verify(boo).withLongAndInt(eq(100),eq(200));fail();}catch(ArgumentsAreDifferent e){assertContains("withLongAndInt((Integer)100,200)",e.getMessage());assertContains("withLongAndInt((Long)100,200)",e.getMessage());}}
@Test public void shouldShowTheTypeOfTheMismatchingArgumentWhenOutputDescriptionsForInvocationsAreDifferent()throws Exception {Boo boo=mock(Boo.class);boo.withLongAndInt(100,200);try {verify(boo).withLongAndInt(eq(100),anyInt());fail();}catch(ArgumentsAreDifferent e){assertContains("withLongAndInt((Long)100,200)",e.getMessage());assertContains("withLongAndInt((Integer)100,<any>)",e.getMessage());}}
@Test public void shouldNotShowTypesWhenArgumentValueIsDifferent()throws Exception {Boo boo=mock(Boo.class);boo.withLongAndInt(100,200);try {verify(boo).withLongAndInt(eq(100L),eq(230));fail();}catch(ArgumentsAreDifferent e){assertContains("withLongAndInt(100,200)",e.getMessage());assertContains("withLongAndInt(100,230)",e.getMessage());}}
@Test public void shouldNotShowTypesWhenTypesAreTheSameEvenIfToStringGivesTheSameResult()throws Exception {IMethods mock=mock(IMethods.class);mock.simpleMethod(new Foo(10));try {verify(mock).simpleMethod(new Foo(20));fail();}catch(ArgumentsAreDifferent e){assertContains("simpleMethod(foo)",e.getMessage());}}
@Test public void shouldDoStuff()throws Exception {isMock(hasSpy.spy);}
@Test public void should_allow_multiple_interfaces(){Foo mock=mock(Foo.class,withSettings().extraInterfaces(IFoo.class,IBar.class));assertThat(mock).isInstanceOf(IFoo.class);assertThat(mock).isInstanceOf(IBar.class);}
@Test public void should_scream_when_null_passed_instead_of_an_interface(){try {mock(Foo.class,withSettings().extraInterfaces(IFoo.class,null));fail();}catch(MockitoException e){assertThat(e.getMessage()).contains("extraInterfaces()does not accept null parameters");}}
@Test public void should_scream_when_no_args_passed(){try {mock(Foo.class,withSettings().extraInterfaces());fail();}catch(MockitoException e){assertThat(e.getMessage()).contains("extraInterfaces()requires at least one interface");}}
@Test public void should_scream_when_null_passed_instead_of_an_array(){try {mock(Foo.class,withSettings().extraInterfaces((Class[])null));fail();}catch(MockitoException e){assertThat(e.getMessage()).contains("extraInterfaces()requires at least one interface");}}
@Test public void should_scream_when_non_interface_passed(){try {mock(Foo.class,withSettings().extraInterfaces(Foo.class));fail();}catch(MockitoException e){assertThat(e.getMessage()).contains("Foo which is not an interface");}}
@Test public void should_scream_when_the_same_interfaces_passed(){try {mock(IMethods.class,withSettings().extraInterfaces(IMethods.class));fail();}catch(MockitoException e){assertThat(e.getMessage()).contains("You mocked following type: IMethods");}}
@Test public void should_mock_class_with_interfaces_of_different_class_loader_AND_different_classpaths()throws ClassNotFoundException {Class<?> interface1=inMemoryClassLoader().withClassDefinition("test.Interface1",makeMarkerInterface("test.Interface1")).build().loadClass("test.Interface1");Class<?> interface2=inMemoryClassLoader().withClassDefinition("test.Interface2",makeMarkerInterface("test.Interface2")).build().loadClass("test.Interface2");Object mocked=mock(interface1,withSettings().extraInterfaces(interface2));assertThat(interface2.isInstance(mocked)).describedAs("mock should be assignable from interface2 type").isTrue();}
@Test public void shouldInitMocks()throws Exception {list.clear();map.clear();listTwo.clear();verify(list).clear();verify(map).clear();verify(listTwo).clear();}
@Test public void shouldScreamWhenInitializingMocksForNullClass()throws Exception {try {MockitoAnnotations.initMocks(null);fail();}catch(MockitoException e){assertEquals("testClass cannot be null. For info how to use @Mock annotations see examples in javadoc for MockitoAnnotations class",e.getMessage());}}
@Test public void shouldLookForAnnotatedMocksInSuperClasses()throws Exception {Sub sub=new Sub();MockitoAnnotations.initMocks(sub);assertNotNull(sub.getMock());assertNotNull(sub.getBaseMock());assertNotNull(sub.getSuperBaseMock());}
@Test public void shouldInitMocksWithGivenSettings()throws Exception {assertEquals("i have a name",namedAndReturningMocks.toString());assertNotNull(namedAndReturningMocks.iMethodsReturningMethod());assertEquals("returningDefaults",returningDefaults.toString());assertEquals(0,returningDefaults.intReturningMethod());assertTrue(hasExtraInterfaces instanceof List);assertEquals(0,noExtraConfig.intReturningMethod());}
@Test public void shouldBeEqual(){assertEquals(new Equals(null),new Equals(null));assertEquals(new Equals(new Integer(2)),new Equals(new Integer(2)));assertFalse(new Equals(null).equals(null));assertFalse(new Equals(null).equals("Test"));assertEquals(1,new Equals(null).hashCode());}
@Test public void shouldArraysBeEqual(){assertTrue(new Equals(new int[]{1,2}).matches(new int[]{1,2}));assertFalse(new Equals(new Object[]{"1"}).matches(new Object[]{"1.0"}));}
@Test public void shouldDescribeWithExtraTypeInfo()throws Exception {String descStr=describe(new Equals(100).withExtraTypeInfo());assertEquals("(Integer)100",descStr);}
@Test public void shouldDescribeWithExtraTypeInfoOfLong()throws Exception {String descStr=describe(new Equals(100L).withExtraTypeInfo());assertEquals("(Long)100",descStr);}
@Test public void shouldAppendQuotingForString(){String descStr=describe(new Equals("str"));assertEquals("\"str\"",descStr);}
@Test public void shouldAppendQuotingForChar(){String descStr=describe(new Equals('s'));assertEquals("'s'",descStr);}
@Test public void shouldDescribeUsingToString(){String descStr=describe(new Equals(100));assertEquals("100",descStr);}
@Test public void shouldDescribeNull(){String descStr=describe(new Equals(null));assertEquals("null",descStr);}
@Test public void shouldMatchTypes()throws Exception {ContainsExtraTypeInformation equals=new Equals(10);assertTrue(equals.typeMatches(10));assertFalse(equals.typeMatches(10L));}
@Test public void shouldMatchTypesSafelyWhenActualIsNull()throws Exception {ContainsExtraTypeInformation equals=new Equals(null);assertFalse(equals.typeMatches(10));}
@Test public void shouldMatchTypesSafelyWhenGivenIsNull()throws Exception {ContainsExtraTypeInformation equals=new Equals(10);assertFalse(equals.typeMatches(null));}
@Test public void shouldRemoveVerificationModeEvenWhenInvalidMatchers()throws Throwable {Invocation invocation=new InvocationBuilder().toInvocation();@SuppressWarnings("rawtypes")MockHandlerImpl<?> handler=new MockHandlerImpl(new MockSettingsImpl());handler.mockingProgress.verificationStarted(VerificationModeFactory.atLeastOnce());handler.matchersBinder=new MatchersBinder(){public InvocationMatcher bindMatchers(ArgumentMatcherStorage argumentMatcherStorage,Invocation invocation){throw new InvalidUseOfMatchersException();}};try {handler.handle(invocation);fail();}catch(InvalidUseOfMatchersException e){}assertNull(handler.mockingProgress.pullVerificationMode());}
@Test(expected=MockitoException.class)public void shouldThrowMockitoExceptionWhenInvocationHandlerThrowsAnything()throws Throwable {InvocationListener throwingListener=mock(InvocationListener.class);doThrow(new Throwable()).when(throwingListener).reportInvocation(any(MethodInvocationReport.class));MockHandlerImpl<?> handler=createCorrectlyStubbedHandler(throwingListener);handler.handle(invocation);}
@Test public void should_be_a_citizen_of_hashes()throws Exception {Invocation invocation=new InvocationBuilder().toInvocation();Invocation invocationTwo=new InvocationBuilder().args("blah").toInvocation();Map map=new HashMap();map.put(new InvocationMatcher(invocation),"one");map.put(new InvocationMatcher(invocationTwo),"two");assertEquals(2,map.size());}
@Test public void should_not_equal_if_number_of_arguments_differ()throws Exception {InvocationMatcher withOneArg=new InvocationMatcher(new InvocationBuilder().args("test").toInvocation());InvocationMatcher withTwoArgs=new InvocationMatcher(new InvocationBuilder().args("test",100).toInvocation());assertFalse(withOneArg.equals(null));assertFalse(withOneArg.equals(withTwoArgs));}
@Test public void should_to_string_with_matchers()throws Exception {Matcher m=NotNull.NOT_NULL;InvocationMatcher notNull=new InvocationMatcher(new InvocationBuilder().toInvocation(),asList(m));Matcher mTwo=new Equals('x');InvocationMatcher equals=new InvocationMatcher(new InvocationBuilder().toInvocation(),asList(mTwo));assertContains("simpleMethod(notNull())",notNull.toString());assertContains("simpleMethod('x')",equals.toString());}
@Test public void should_know_if_is_similar_to()throws Exception {Invocation same=new InvocationBuilder().mock(mock).simpleMethod().toInvocation();assertTrue(simpleMethod.hasSimilarMethod(same));Invocation different=new InvocationBuilder().mock(mock).differentMethod().toInvocation();assertFalse(simpleMethod.hasSimilarMethod(different));}
@Test public void should_not_be_similar_to_verified_invocation()throws Exception {Invocation verified=new InvocationBuilder().simpleMethod().verified().toInvocation();assertFalse(simpleMethod.hasSimilarMethod(verified));}
@Test public void should_not_be_similar_if_mocks_are_different()throws Exception {Invocation onDifferentMock=new InvocationBuilder().simpleMethod().mock("different mock").toInvocation();assertFalse(simpleMethod.hasSimilarMethod(onDifferentMock));}
@Test public void should_not_be_similar_if_is_overloaded_but_used_with_the_same_arg()throws Exception {Method method=IMethods.class.getMethod("simpleMethod",String.class);Method overloadedMethod=IMethods.class.getMethod("simpleMethod",Object.class);String sameArg="test";InvocationMatcher invocation=new InvocationBuilder().method(method).arg(sameArg).toInvocationMatcher();Invocation overloadedInvocation=new InvocationBuilder().method(overloadedMethod).arg(sameArg).toInvocation();assertFalse(invocation.hasSimilarMethod(overloadedInvocation));}
@Test public void should_be_similar_if_is_overloaded_but_used_with_different_arg()throws Exception {Method method=IMethods.class.getMethod("simpleMethod",String.class);Method overloadedMethod=IMethods.class.getMethod("simpleMethod",Object.class);InvocationMatcher invocation=new InvocationBuilder().mock(mock).method(method).arg("foo").toInvocationMatcher();Invocation overloadedInvocation=new InvocationBuilder().mock(mock).method(overloadedMethod).arg("bar").toInvocation();assertTrue(invocation.hasSimilarMethod(overloadedInvocation));}
@Test public void should_capture_arguments_from_invocation()throws Exception {Invocation invocation=new InvocationBuilder().args("1",100).toInvocation();CapturingMatcher capturingMatcher=new CapturingMatcher();InvocationMatcher invocationMatcher=new InvocationMatcher(invocation,(List)asList(new Equals("1"),capturingMatcher));invocationMatcher.captureArgumentsFrom(invocation);assertEquals(1,capturingMatcher.getAllValues().size());assertEquals(100,capturingMatcher.getLastValue());}
@Test public void should_match_varargs_using_any_varargs()throws Exception {mock.varargs("1","2");Invocation invocation=getLastInvocation();InvocationMatcher invocationMatcher=new InvocationMatcher(invocation,(List)asList(AnyVararg.ANY_VARARG));boolean match=invocationMatcher.matches(invocation);assertTrue(match);}
@Test public void should_capture_varargs_as_vararg()throws Exception {mock.mixedVarargs(1,"a","b");Invocation invocation=getLastInvocation();CapturingMatcher m=new CapturingMatcher();InvocationMatcher invocationMatcher=new InvocationMatcher(invocation,(List)asList(new Equals(1),new LocalizedMatcher(m)));invocationMatcher.captureArgumentsFrom(invocation);Assertions.assertThat(m.getAllValues()).containsExactly("a","b");}
@Test public void should_capture_arguments_when_args_count_does_NOT_match()throws Exception {mock.varargs();Invocation invocation=getLastInvocation();InvocationMatcher invocationMatcher=new InvocationMatcher(invocation,(List)asList(new LocalizedMatcher(AnyVararg.ANY_VARARG)));invocationMatcher.captureArgumentsFrom(invocation);}
@Test public void should_create_from_invocations()throws Exception {Invocation i=new InvocationBuilder().toInvocation();List<InvocationMatcher> out=InvocationMatcher.createFrom(asList(i));assertEquals(1,out.size());assertEquals(i,out.get(0).getInvocation());}
@Test(expected=ClassNotFoundException.class)public void isolated_class_loader_cannot_load_classes_when_no_given_prefix()throws Exception {ClassLoader cl=isolatedClassLoader().build();cl.loadClass("org.mockito.Mockito");}
@Test public void isolated_class_loader_cannot_load_classes_if_no_code_source_path()throws Exception {ClassLoader cl=isolatedClassLoader().withPrivateCopyOf(CLASS_NAME_USING_INTERFACE).build();try {cl.loadClass(CLASS_NAME_USING_INTERFACE);fail();}catch(ClassNotFoundException e){assertThat(e.getMessage()).contains(CLASS_NAME_USING_INTERFACE);}}
@Test public void isolated_class_loader_cannot_load_classes_not_matching_the_prefix()throws Exception {ClassLoader cl=isolatedClassLoader().withCurrentCodeSourceUrls().withPrivateCopyOf(CLASS_NAME_USING_INTERFACE).build();try {cl.loadClass(CLASS_NAME_USING_INTERFACE);fail();}catch(NoClassDefFoundError e){assertThat(e.getMessage()).contains("org/mockitoutil/ClassLoadersTest$Interface1");}}
@Test public void isolated_class_loader_can_load_all_classes_unless_all_classes_mathch_the_prefixes()throws Exception {ClassLoader cl=isolatedClassLoader().withCurrentCodeSourceUrls().withPrivateCopyOf(CLASS_NAME_USING_INTERFACE).withPrivateCopyOf(INTERFACE_NAME).build();Class<?> aClass=cl.loadClass(CLASS_NAME_USING_INTERFACE);assertThat(aClass).isNotNull();assertThat(aClass.getClassLoader()).isEqualTo(cl);assertThat(aClass.getInterfaces()[0].getClassLoader()).isEqualTo(cl);}
@Test public void isolated_class_loader_has_no_parent()throws Exception {ClassLoader cl=isolatedClassLoader().withCurrentCodeSourceUrls().withPrivateCopyOf(CLASS_NAME_USING_INTERFACE).withPrivateCopyOf(INTERFACE_NAME).build();assertThat(cl.getParent()).isNull();}
@Test public void can_not_load_a_class_not_previously_registered_in_builder()throws Exception {ClassLoader cl=ClassLoaders.inMemoryClassLoader().withClassDefinition("yop.Dude",SimpleClassGenerator.makeMarkerInterface("yop.Dude")).build();try {cl.loadClass("not.Defined");fail();}catch(ClassNotFoundException e){assertThat(e.getMessage()).contains("not.Defined");}}
@Test public void can_load_a_class_in_memory_from_bytes()throws Exception {ClassLoader cl=ClassLoaders.inMemoryClassLoader().withClassDefinition("yop.Dude",SimpleClassGenerator.makeMarkerInterface("yop.Dude")).build();Class<?> aClass=cl.loadClass("yop.Dude");assertThat(aClass).isNotNull();assertThat(aClass.getClassLoader()).isEqualTo(cl);assertThat(aClass.getName()).isEqualTo("yop.Dude");}
@Test public void shouldProduceDecentDescription()throws Exception {assertEquals("<Sentence with strong language>",decamelizeMatcher("SentenceWithStrongLanguage"));assertEquals("<W e i r d o 1>",decamelizeMatcher("WEIRDO1"));assertEquals("<_>",decamelizeMatcher("_"));assertEquals("<Has exactly 3 elements>",decamelizeMatcher("HasExactly3Elements"));assertEquals("<custom argument matcher>",decamelizeMatcher(""));}
@Test public void shouldWorkFineIfNoInvocatins()throws Exception {InOrder inOrder=inOrder(mock);inOrder.verifyNoMoreInteractions();}
@Test public void shouldSayNoInteractionsWanted()throws Exception {mock.simpleMethod();InOrder inOrder=inOrder(mock);try {inOrder.verifyNoMoreInteractions();fail();}catch(VerificationInOrderFailure e){assertContains("No interactions wanted",e.getMessage());}}
@Test public void shouldVerifyNoMoreInteractionsInOrder()throws Exception {mock.simpleMethod();mock.simpleMethod(10);mock.otherMethod();InOrder inOrder=inOrder(mock);inOrder.verify(mock).simpleMethod(10);inOrder.verify(mock).otherMethod();inOrder.verifyNoMoreInteractions();}
@Test public void shouldVerifyNoMoreInteractionsInOrderWithMultipleMocks()throws Exception {mock.simpleMethod();mock2.simpleMethod();mock.otherMethod();InOrder inOrder=inOrder(mock,mock2);inOrder.verify(mock2).simpleMethod();inOrder.verify(mock).otherMethod();inOrder.verifyNoMoreInteractions();}
@Test public void shouldFailToVerifyNoMoreInteractionsInOrder()throws Exception {mock.simpleMethod();mock.simpleMethod(10);mock.otherMethod();InOrder inOrder=inOrder(mock);inOrder.verify(mock).simpleMethod(10);try {inOrder.verifyNoMoreInteractions();fail();}catch(VerificationInOrderFailure e){}}
@Test public void shouldFailToVerifyNoMoreInteractionsInOrderWithMultipleMocks()throws Exception {mock.simpleMethod();mock2.simpleMethod();mock.otherMethod();InOrder inOrder=inOrder(mock,mock2);inOrder.verify(mock2).simpleMethod();try {inOrder.verifyNoMoreInteractions();fail();}catch(VerificationInOrderFailure e){}}
@Test public void shouldValidateState()throws Exception {InOrder inOrder=inOrder(mock);verify(mock);try {inOrder.verifyNoMoreInteractions();fail();}catch(UnfinishedVerificationException e){}}
@Test public void shouldMarkVerifiedInOrder()throws Exception {InOrderImpl impl=new InOrderImpl((List)asList(mock));Invocation i=new InvocationBuilder().toInvocation();assertFalse(impl.isVerified(i));impl.markVerified(i);assertTrue(impl.isVerified(i));}
